var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../lib/telemetry/dist/src/util/system.js
var require_system = __commonJS({
  "../lib/telemetry/dist/src/util/system.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.processMatchingPaths = void 0;
    var processMatchingPaths = (matchingPaths) => {
      const matchPaths = matchingPaths;
      matchPaths.forEach((matchingPath) => {
        matchingPath.patterns = matchingPath.patterns.map((pattern) => new RegExp(`[\\w\\s-./:@!]+${pattern}`, "gi"));
      });
      return matchPaths;
    };
    exports2.processMatchingPaths = processMatchingPaths;
  }
});

// ../lib/telemetry/dist/src/util/cloudDebugger.js
var require_cloudDebugger = __commonJS({
  "../lib/telemetry/dist/src/util/cloudDebugger.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.debug = void 0;
    var fs_1 = __importDefault(require("fs"));
    var os_1 = __importDefault(require("os"));
    var path_1 = __importDefault(require("path"));
    var homedir = os_1.default.homedir();
    var debugFilePath = path_1.default.join(homedir, "theiadebug.txt");
    var debug = (message, active = false) => {
      if (active) {
        fs_1.default.appendFileSync(debugFilePath, `${message}
`, "utf8");
      }
    };
    exports2.debug = debug;
  }
});

// ../lib/common-utils/dist/appStudio.js
var require_appStudio = __commonJS({
  "../lib/common-utils/dist/appStudio.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getAppStudioProxyURL = exports2.getAppStudioBaseURL = exports2.isAppStudio = exports2.ENV = void 0;
    var ENV;
    (function(ENV2) {
      ENV2["PROXY_URL"] = "HTTP_PROXY";
      ENV2["H2O_URL"] = "H2O_URL";
    })(ENV = exports2.ENV || (exports2.ENV = {}));
    function isAppStudio() {
      return !!process.env[ENV.H2O_URL];
    }
    exports2.isAppStudio = isAppStudio;
    function getAppStudioBaseURL() {
      return process.env[ENV.H2O_URL];
    }
    exports2.getAppStudioBaseURL = getAppStudioBaseURL;
    function getAppStudioProxyURL() {
      return process.env[ENV.PROXY_URL];
    }
    exports2.getAppStudioProxyURL = getAppStudioProxyURL;
  }
});

// ../lib/common-utils/dist/file.js
var require_file = __commonJS({
  "../lib/common-utils/dist/file.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toPosixPath = void 0;
    var path_1 = __importDefault(require("path"));
    function toPosixPath(dirPath) {
      return path_1.default.normalize(dirPath).split(/[\\/]/g).join(path_1.default.posix.sep);
    }
    exports2.toPosixPath = toPosixPath;
  }
});

// ../lib/common-utils/dist/promise.js
var require_promise = __commonJS({
  "../lib/common-utils/dist/promise.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.allSettled = void 0;
    function allSettled(promises2) {
      if (!promises2 || promises2.length === 0) {
        return Promise.resolve([]);
      }
      const results = Array(promises2.length);
      let count = 0;
      return new Promise((resolve) => {
        promises2.forEach(async (promise, index) => {
          try {
            const result2 = await Promise.resolve(promise);
            results[index] = { status: "fulfilled", value: result2 };
            count++;
            if (count === promises2.length) {
              resolve(results);
            }
          } catch (err) {
            results[index] = { status: "rejected", reason: err };
            count++;
            if (count === promises2.length) {
              resolve(results);
            }
          }
        });
      });
    }
    exports2.allSettled = allSettled;
  }
});

// ../lib/common-utils/dist/regexp.js
var require_regexp = __commonJS({
  "../lib/common-utils/dist/regexp.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.escapeRegExp = void 0;
    function escapeRegExp(s) {
      return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    exports2.escapeRegExp = escapeRegExp;
  }
});

// ../lib/common-utils/dist/index.js
var require_dist = __commonJS({
  "../lib/common-utils/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getFioriToolsDirectory = exports2.FioriToolsSettings = exports2.getAppStudioProxyURL = exports2.getAppStudioBaseURL = exports2.isAppStudio = void 0;
    var os_1 = require("os");
    var path_1 = __importDefault(require("path"));
    var appStudio_1 = require_appStudio();
    Object.defineProperty(exports2, "isAppStudio", { enumerable: true, get: function() {
      return appStudio_1.isAppStudio;
    } });
    Object.defineProperty(exports2, "getAppStudioBaseURL", { enumerable: true, get: function() {
      return appStudio_1.getAppStudioBaseURL;
    } });
    Object.defineProperty(exports2, "getAppStudioProxyURL", { enumerable: true, get: function() {
      return appStudio_1.getAppStudioProxyURL;
    } });
    __exportStar(require_file(), exports2);
    __exportStar(require_promise(), exports2);
    __exportStar(require_regexp(), exports2);
    var FioriToolsSettings;
    (function(FioriToolsSettings2) {
      FioriToolsSettings2["dir"] = ".fioritools";
    })(FioriToolsSettings = exports2.FioriToolsSettings || (exports2.FioriToolsSettings = {}));
    var getFioriToolsDirectory = () => {
      return path_1.default.join(os_1.homedir(), FioriToolsSettings.dir);
    };
    exports2.getFioriToolsDirectory = getFioriToolsDirectory;
  }
});

// ../lib/telemetry/dist/src/client/model/EventName.js
var require_EventName = __commonJS({
  "../lib/telemetry/dist/src/client/model/EventName.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EventName = void 0;
    var EventName2;
    (function(EventName3) {
      EventName3["Test"] = "test";
      EventName3["TELEMETRY_SETTINGS_INIT_FAILED"] = "TELEMETRY_SETTINGS_INIT_FAILED";
      EventName3["DISABLE_TELEMETRY"] = "DISABLE_TELEMETRY";
      EventName3["GD_GUIDE_ACTION"] = "GUIDE_ACTION";
      EventName3["GD_PANEL_LOAD"] = "PANEL_LOAD";
      EventName3["GD_LAUNCH"] = "LAUNCH_GD";
      EventName3["GD_SIDE_BY_SIDE"] = "GD_SIDE_BY_SIDE";
      EventName3["GD_WIZARD"] = "GD_WIZARD";
      EventName3["GD_DESCMODE"] = "GD_DESCMODE";
      EventName3["PAGEMAP"] = "PAGEMAP";
      EventName3["APP_ACTIONS"] = "ACTIONS";
      EventName3["PAGE_EDITOR"] = "PAGE_EDITOR";
      EventName3["PAGEMAP_STARTUP_TIME"] = "PAGEMAP_STARTUP_TIME";
      EventName3["APPLICATION_PREVIEW"] = "APPLICATION_PREVIEW";
      EventName3["APP_INFO_COMMAND_STARTED"] = "APP_INFO_COMMAND_STARTED";
      EventName3["APP_INFO_LINK_CLICKED"] = "APP_INFO_LINK_CLICKED";
      EventName3["APP_INFO_STARTUP_TIME"] = "APP_INFO_STARTUP_TIME";
      EventName3["SRV_MODELLER_SETTINGS_CHANGED"] = "SRV_MODELER_SETTINGS_CHANGED";
      EventName3["SRV_MODELER_ACTIVATED"] = "SRV_MODELER_ACTIVATED";
      EventName3["SRV_MODELER_PANEL_LOAD"] = "SRV_MODELER_PANEL_LOAD";
      EventName3["SRV_MODELER_BACKEND_LOAD"] = "SRV_MODELER_BACKEND_LOAD";
      EventName3["SRV_MODELER_ODATA_VERSION"] = "SRV_MODELER_ODATA_VERSION";
      EventName3["ANNOTATION_FILE_PANEL_LOAD"] = "ANNOTATION_FILE_PANEL_LOAD";
      EventName3["ANNOTATION_FILE_BACKEND_LOAD"] = "ANNOTATION_FILE_BACKEND_LOAD";
      EventName3["ANNOTATION_LSP_XML_LOAD"] = "ANNOTATION_LSP_XML_LOAD";
      EventName3["ANNOTATION_LSP_USAGE_TERM"] = "ANNOTATION_LSP_USAGE_TERM";
      EventName3["ANNOTATION_LSP_CODE_COMPLETION_TERM"] = "ANNOTATION_LSP_CODE_COMPLETION_TERM";
      EventName3["ANNOTATION_LSP_CODE_COMPLETION"] = "ANNOTATION_LSP_CODE_COMPLETION";
      EventName3["MIGRATION_ACTIVATED"] = "MIGRATION_ACTIVATED";
      EventName3["MIGRATION_BACKEND_LOAD"] = "MIGRATION_BACKEND_LOAD";
      EventName3["MIGRATION_COMPLETED"] = "MIGRATION_COMPLETED";
      EventName3["MIGRATION_SUCCESS"] = "MIGRATION_SUCCESS";
      EventName3["MIGRATION_FAILED"] = "MIGRATION_FAILED";
      EventName3["MIGRATION_SHOW_INFO_PAGE"] = "MIGRATION_SHOW_INFO_PAGE";
      EventName3["DEPLOY_CONFIG"] = "DEPLOY_CONFIG";
      EventName3["DEPLOY"] = "DEPLOY";
      EventName3["DEPLOY_FAIL"] = "DEPLOY_FAIL";
      EventName3["DATA_EDITOR_EVENT"] = "DATA_EDITOR_EVENT";
      EventName3["CPE_EVENT"] = "CONTROL_PROPERTY_EDITOR_EVENT";
      EventName3["SYSTEM_DETAILS_VIEW_EVENT"] = "SYSTEM_DETAILS_VIEW_EVENT";
    })(EventName2 = exports2.EventName || (exports2.EventName = {}));
  }
});

// ../../node_modules/applicationinsights/out/Library/Logging.js
var require_Logging = __commonJS({
  "../../node_modules/applicationinsights/out/Library/Logging.js"(exports2, module2) {
    "use strict";
    var Logging = function() {
      function Logging2() {
      }
      Logging2.info = function(message) {
        var optionalParams = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          optionalParams[_i - 1] = arguments[_i];
        }
        if (Logging2.enableDebug) {
          console.info(Logging2.TAG + message, optionalParams);
        }
      };
      Logging2.warn = function(message) {
        var optionalParams = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          optionalParams[_i - 1] = arguments[_i];
        }
        if (!Logging2.disableWarnings) {
          console.warn(Logging2.TAG + message, optionalParams);
        }
      };
      Logging2.enableDebug = false;
      Logging2.disableWarnings = false;
      Logging2.TAG = "ApplicationInsights:";
      return Logging2;
    }();
    module2.exports = Logging;
  }
});

// ../../node_modules/diagnostic-channel/node_modules/semver/semver.js
var require_semver = __commonJS({
  "../../node_modules/diagnostic-channel/node_modules/semver/semver.js"(exports2, module2) {
    exports2 = module2.exports = SemVer;
    var debug;
    if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
      debug = function() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift("SEMVER");
        console.log.apply(console, args);
      };
    } else {
      debug = function() {
      };
    }
    exports2.SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var re = exports2.re = [];
    var src = exports2.src = [];
    var R = 0;
    var NUMERICIDENTIFIER = R++;
    src[NUMERICIDENTIFIER] = "0|[1-9]\\d*";
    var NUMERICIDENTIFIERLOOSE = R++;
    src[NUMERICIDENTIFIERLOOSE] = "[0-9]+";
    var NONNUMERICIDENTIFIER = R++;
    src[NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
    var MAINVERSION = R++;
    src[MAINVERSION] = "(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")";
    var MAINVERSIONLOOSE = R++;
    src[MAINVERSIONLOOSE] = "(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")";
    var PRERELEASEIDENTIFIER = R++;
    src[PRERELEASEIDENTIFIER] = "(?:" + src[NUMERICIDENTIFIER] + "|" + src[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASEIDENTIFIERLOOSE = R++;
    src[PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[NUMERICIDENTIFIERLOOSE] + "|" + src[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASE = R++;
    src[PRERELEASE] = "(?:-(" + src[PRERELEASEIDENTIFIER] + "(?:\\." + src[PRERELEASEIDENTIFIER] + ")*))";
    var PRERELEASELOOSE = R++;
    src[PRERELEASELOOSE] = "(?:-?(" + src[PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[PRERELEASEIDENTIFIERLOOSE] + ")*))";
    var BUILDIDENTIFIER = R++;
    src[BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
    var BUILD = R++;
    src[BUILD] = "(?:\\+(" + src[BUILDIDENTIFIER] + "(?:\\." + src[BUILDIDENTIFIER] + ")*))";
    var FULL = R++;
    var FULLPLAIN = "v?" + src[MAINVERSION] + src[PRERELEASE] + "?" + src[BUILD] + "?";
    src[FULL] = "^" + FULLPLAIN + "$";
    var LOOSEPLAIN = "[v=\\s]*" + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + "?" + src[BUILD] + "?";
    var LOOSE = R++;
    src[LOOSE] = "^" + LOOSEPLAIN + "$";
    var GTLT = R++;
    src[GTLT] = "((?:<|>)?=?)";
    var XRANGEIDENTIFIERLOOSE = R++;
    src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
    var XRANGEIDENTIFIER = R++;
    src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + "|x|X|\\*";
    var XRANGEPLAIN = R++;
    src[XRANGEPLAIN] = "[v=\\s]*(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:" + src[PRERELEASE] + ")?" + src[BUILD] + "?)?)?";
    var XRANGEPLAINLOOSE = R++;
    src[XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:" + src[PRERELEASELOOSE] + ")?" + src[BUILD] + "?)?)?";
    var XRANGE = R++;
    src[XRANGE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAIN] + "$";
    var XRANGELOOSE = R++;
    src[XRANGELOOSE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAINLOOSE] + "$";
    var COERCE = R++;
    src[COERCE] = "(?:^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
    var LONETILDE = R++;
    src[LONETILDE] = "(?:~>?)";
    var TILDETRIM = R++;
    src[TILDETRIM] = "(\\s*)" + src[LONETILDE] + "\\s+";
    re[TILDETRIM] = new RegExp(src[TILDETRIM], "g");
    var tildeTrimReplace = "$1~";
    var TILDE = R++;
    src[TILDE] = "^" + src[LONETILDE] + src[XRANGEPLAIN] + "$";
    var TILDELOOSE = R++;
    src[TILDELOOSE] = "^" + src[LONETILDE] + src[XRANGEPLAINLOOSE] + "$";
    var LONECARET = R++;
    src[LONECARET] = "(?:\\^)";
    var CARETTRIM = R++;
    src[CARETTRIM] = "(\\s*)" + src[LONECARET] + "\\s+";
    re[CARETTRIM] = new RegExp(src[CARETTRIM], "g");
    var caretTrimReplace = "$1^";
    var CARET = R++;
    src[CARET] = "^" + src[LONECARET] + src[XRANGEPLAIN] + "$";
    var CARETLOOSE = R++;
    src[CARETLOOSE] = "^" + src[LONECARET] + src[XRANGEPLAINLOOSE] + "$";
    var COMPARATORLOOSE = R++;
    src[COMPARATORLOOSE] = "^" + src[GTLT] + "\\s*(" + LOOSEPLAIN + ")$|^$";
    var COMPARATOR = R++;
    src[COMPARATOR] = "^" + src[GTLT] + "\\s*(" + FULLPLAIN + ")$|^$";
    var COMPARATORTRIM = R++;
    src[COMPARATORTRIM] = "(\\s*)" + src[GTLT] + "\\s*(" + LOOSEPLAIN + "|" + src[XRANGEPLAIN] + ")";
    re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], "g");
    var comparatorTrimReplace = "$1$2$3";
    var HYPHENRANGE = R++;
    src[HYPHENRANGE] = "^\\s*(" + src[XRANGEPLAIN] + ")\\s+-\\s+(" + src[XRANGEPLAIN] + ")\\s*$";
    var HYPHENRANGELOOSE = R++;
    src[HYPHENRANGELOOSE] = "^\\s*(" + src[XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[XRANGEPLAINLOOSE] + ")\\s*$";
    var STAR = R++;
    src[STAR] = "(<|>)?=?\\s*\\*";
    for (i = 0; i < R; i++) {
      debug(i, src[i]);
      if (!re[i]) {
        re[i] = new RegExp(src[i]);
      }
    }
    var i;
    exports2.parse = parse2;
    function parse2(version, options2) {
      if (!options2 || typeof options2 !== "object") {
        options2 = {
          loose: !!options2,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      if (version.length > MAX_LENGTH) {
        return null;
      }
      var r = options2.loose ? re[LOOSE] : re[FULL];
      if (!r.test(version)) {
        return null;
      }
      try {
        return new SemVer(version, options2);
      } catch (er) {
        return null;
      }
    }
    exports2.valid = valid;
    function valid(version, options2) {
      var v = parse2(version, options2);
      return v ? v.version : null;
    }
    exports2.clean = clean;
    function clean(version, options2) {
      var s = parse2(version.trim().replace(/^[=v]+/, ""), options2);
      return s ? s.version : null;
    }
    exports2.SemVer = SemVer;
    function SemVer(version, options2) {
      if (!options2 || typeof options2 !== "object") {
        options2 = {
          loose: !!options2,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        if (version.loose === options2.loose) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== "string") {
        throw new TypeError("Invalid Version: " + version);
      }
      if (version.length > MAX_LENGTH) {
        throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
      }
      if (!(this instanceof SemVer)) {
        return new SemVer(version, options2);
      }
      debug("SemVer", version, options2);
      this.options = options2;
      this.loose = !!options2.loose;
      var m = version.trim().match(options2.loose ? re[LOOSE] : re[FULL]);
      if (!m) {
        throw new TypeError("Invalid Version: " + version);
      }
      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map(function(id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    SemVer.prototype.format = function() {
      this.version = this.major + "." + this.minor + "." + this.patch;
      if (this.prerelease.length) {
        this.version += "-" + this.prerelease.join(".");
      }
      return this.version;
    };
    SemVer.prototype.toString = function() {
      return this.version;
    };
    SemVer.prototype.compare = function(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return this.compareMain(other) || this.comparePre(other);
    };
    SemVer.prototype.compareMain = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };
    SemVer.prototype.comparePre = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      var i2 = 0;
      do {
        var a = this.prerelease[i2];
        var b = other.prerelease[i2];
        debug("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.inc = function(release, identifier) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier);
          this.inc("pre", identifier);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier);
          }
          this.inc("pre", identifier);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i2 = this.prerelease.length;
            while (--i2 >= 0) {
              if (typeof this.prerelease[i2] === "number") {
                this.prerelease[i2]++;
                i2 = -2;
              }
            }
            if (i2 === -1) {
              this.prerelease.push(0);
            }
          }
          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }
          break;
        default:
          throw new Error("invalid increment argument: " + release);
      }
      this.format();
      this.raw = this.version;
      return this;
    };
    exports2.inc = inc;
    function inc(version, release, loose, identifier) {
      if (typeof loose === "string") {
        identifier = loose;
        loose = void 0;
      }
      try {
        return new SemVer(version, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }
    exports2.diff = diff;
    function diff(version1, version2) {
      if (eq(version1, version2)) {
        return null;
      } else {
        var v1 = parse2(version1);
        var v2 = parse2(version2);
        var prefix = "";
        if (v1.prerelease.length || v2.prerelease.length) {
          prefix = "pre";
          var defaultResult = "prerelease";
        }
        for (var key in v1) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    }
    exports2.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;
    function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }
    exports2.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }
    exports2.major = major;
    function major(a, loose) {
      return new SemVer(a, loose).major;
    }
    exports2.minor = minor;
    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }
    exports2.patch = patch;
    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }
    exports2.compare = compare;
    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(new SemVer(b, loose));
    }
    exports2.compareLoose = compareLoose;
    function compareLoose(a, b) {
      return compare(a, b, true);
    }
    exports2.rcompare = rcompare;
    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }
    exports2.sort = sort;
    function sort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.compare(a, b, loose);
      });
    }
    exports2.rsort = rsort;
    function rsort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.rcompare(a, b, loose);
      });
    }
    exports2.gt = gt;
    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }
    exports2.lt = lt;
    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }
    exports2.eq = eq;
    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }
    exports2.neq = neq;
    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }
    exports2.gte = gte;
    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }
    exports2.lte = lte;
    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }
    exports2.cmp = cmp;
    function cmp(a, op, b, loose) {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError("Invalid operator: " + op);
      }
    }
    exports2.Comparator = Comparator;
    function Comparator(comp, options2) {
      if (!options2 || typeof options2 !== "object") {
        options2 = {
          loose: !!options2,
          includePrerelease: false
        };
      }
      if (comp instanceof Comparator) {
        if (comp.loose === !!options2.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      if (!(this instanceof Comparator)) {
        return new Comparator(comp, options2);
      }
      debug("comparator", comp, options2);
      this.options = options2;
      this.loose = !!options2.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug("comp", this);
    }
    var ANY = {};
    Comparator.prototype.parse = function(comp) {
      var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
      var m = comp.match(r);
      if (!m) {
        throw new TypeError("Invalid comparator: " + comp);
      }
      this.operator = m[1];
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    };
    Comparator.prototype.toString = function() {
      return this.value;
    };
    Comparator.prototype.test = function(version) {
      debug("Comparator.test", version, this.options.loose);
      if (this.semver === ANY) {
        return true;
      }
      if (typeof version === "string") {
        version = new SemVer(version, this.options);
      }
      return cmp(version, this.operator, this.semver, this.options);
    };
    Comparator.prototype.intersects = function(comp, options2) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options2 || typeof options2 !== "object") {
        options2 = {
          loose: !!options2,
          includePrerelease: false
        };
      }
      var rangeTmp;
      if (this.operator === "") {
        rangeTmp = new Range(comp.value, options2);
        return satisfies(this.value, rangeTmp, options2);
      } else if (comp.operator === "") {
        rangeTmp = new Range(this.value, options2);
        return satisfies(comp.semver, rangeTmp, options2);
      }
      var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options2) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
      var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options2) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };
    exports2.Range = Range;
    function Range(range, options2) {
      if (!options2 || typeof options2 !== "object") {
        options2 = {
          loose: !!options2,
          includePrerelease: false
        };
      }
      if (range instanceof Range) {
        if (range.loose === !!options2.loose && range.includePrerelease === !!options2.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options2);
        }
      }
      if (range instanceof Comparator) {
        return new Range(range.value, options2);
      }
      if (!(this instanceof Range)) {
        return new Range(range, options2);
      }
      this.options = options2;
      this.loose = !!options2.loose;
      this.includePrerelease = !!options2.includePrerelease;
      this.raw = range;
      this.set = range.split(/\s*\|\|\s*/).map(function(range2) {
        return this.parseRange(range2.trim());
      }, this).filter(function(c) {
        return c.length;
      });
      if (!this.set.length) {
        throw new TypeError("Invalid SemVer Range: " + range);
      }
      this.format();
    }
    Range.prototype.format = function() {
      this.range = this.set.map(function(comps) {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    };
    Range.prototype.toString = function() {
      return this.range;
    };
    Range.prototype.parseRange = function(range) {
      var loose = this.options.loose;
      range = range.trim();
      var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug("hyphen replace", range);
      range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range, re[COMPARATORTRIM]);
      range = range.replace(re[TILDETRIM], tildeTrimReplace);
      range = range.replace(re[CARETTRIM], caretTrimReplace);
      range = range.split(/\s+/).join(" ");
      var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
      var set = range.split(" ").map(function(comp) {
        return parseComparator(comp, this.options);
      }, this).join(" ").split(/\s+/);
      if (this.options.loose) {
        set = set.filter(function(comp) {
          return !!comp.match(compRe);
        });
      }
      set = set.map(function(comp) {
        return new Comparator(comp, this.options);
      }, this);
      return set;
    };
    Range.prototype.intersects = function(range, options2) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some(function(thisComparators) {
        return thisComparators.every(function(thisComparator) {
          return range.set.some(function(rangeComparators) {
            return rangeComparators.every(function(rangeComparator) {
              return thisComparator.intersects(rangeComparator, options2);
            });
          });
        });
      });
    };
    exports2.toComparators = toComparators;
    function toComparators(range, options2) {
      return new Range(range, options2).set.map(function(comp) {
        return comp.map(function(c) {
          return c.value;
        }).join(" ").trim().split(" ");
      });
    }
    function parseComparator(comp, options2) {
      debug("comp", comp, options2);
      comp = replaceCarets(comp, options2);
      debug("caret", comp);
      comp = replaceTildes(comp, options2);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options2);
      debug("xrange", comp);
      comp = replaceStars(comp, options2);
      debug("stars", comp);
      return comp;
    }
    function isX(id) {
      return !id || id.toLowerCase() === "x" || id === "*";
    }
    function replaceTildes(comp, options2) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceTilde(comp2, options2);
      }).join(" ");
    }
    function replaceTilde(comp, options2) {
      var r = options2.loose ? re[TILDELOOSE] : re[TILDE];
      return comp.replace(r, function(_45, M, m, p, pr) {
        debug("tilde", comp, _45, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
        }
        debug("tilde return", ret);
        return ret;
      });
    }
    function replaceCarets(comp, options2) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceCaret(comp2, options2);
      }).join(" ");
    }
    function replaceCaret(comp, options2) {
      debug("caret", comp, options2);
      var r = options2.loose ? re[CARETLOOSE] : re[CARET];
      return comp.replace(r, function(_45, M, m, p, pr) {
        debug("caret", comp, _45, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          if (M === "0") {
            ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
          } else {
            ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
          }
        }
        debug("caret return", ret);
        return ret;
      });
    }
    function replaceXRanges(comp, options2) {
      debug("replaceXRanges", comp, options2);
      return comp.split(/\s+/).map(function(comp2) {
        return replaceXRange(comp2, options2);
      }).join(" ");
    }
    function replaceXRange(comp, options2) {
      comp = comp.trim();
      var r = options2.loose ? re[XRANGELOOSE] : re[XRANGE];
      return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          ret = gtlt + M + "." + m + "." + p;
        } else if (xm) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (xp) {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        }
        debug("xRange return", ret);
        return ret;
      });
    }
    function replaceStars(comp, options2) {
      debug("replaceStars", comp, options2);
      return comp.trim().replace(re[STAR], "");
    }
    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = ">=" + fM + ".0.0";
      } else if (isX(fp)) {
        from = ">=" + fM + "." + fm + ".0";
      } else {
        from = ">=" + from;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = "<" + (+tM + 1) + ".0.0";
      } else if (isX(tp)) {
        to = "<" + tM + "." + (+tm + 1) + ".0";
      } else if (tpr) {
        to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
      } else {
        to = "<=" + to;
      }
      return (from + " " + to).trim();
    }
    Range.prototype.test = function(version) {
      if (!version) {
        return false;
      }
      if (typeof version === "string") {
        version = new SemVer(version, this.options);
      }
      for (var i2 = 0; i2 < this.set.length; i2++) {
        if (testSet(this.set[i2], version, this.options)) {
          return true;
        }
      }
      return false;
    };
    function testSet(set, version, options2) {
      for (var i2 = 0; i2 < set.length; i2++) {
        if (!set[i2].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options2.includePrerelease) {
        for (i2 = 0; i2 < set.length; i2++) {
          debug(set[i2].semver);
          if (set[i2].semver === ANY) {
            continue;
          }
          if (set[i2].semver.prerelease.length > 0) {
            var allowed = set[i2].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    }
    exports2.satisfies = satisfies;
    function satisfies(version, range, options2) {
      try {
        range = new Range(range, options2);
      } catch (er) {
        return false;
      }
      return range.test(version);
    }
    exports2.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range, options2) {
      var max = null;
      var maxSV = null;
      try {
        var rangeObj = new Range(range, options2);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options2);
          }
        }
      });
      return max;
    }
    exports2.minSatisfying = minSatisfying;
    function minSatisfying(versions, range, options2) {
      var min = null;
      var minSV = null;
      try {
        var rangeObj = new Range(range, options2);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options2);
          }
        }
      });
      return min;
    }
    exports2.minVersion = minVersion;
    function minVersion(range, loose) {
      range = new Range(range, loose);
      var minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        comparators.forEach(function(comparator) {
          var compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error("Unexpected operation: " + comparator.operator);
          }
        });
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    }
    exports2.validRange = validRange;
    function validRange(range, options2) {
      try {
        return new Range(range, options2).range || "*";
      } catch (er) {
        return null;
      }
    }
    exports2.ltr = ltr;
    function ltr(version, range, options2) {
      return outside(version, range, "<", options2);
    }
    exports2.gtr = gtr;
    function gtr(version, range, options2) {
      return outside(version, range, ">", options2);
    }
    exports2.outside = outside;
    function outside(version, range, hilo, options2) {
      version = new SemVer(version, options2);
      range = new Range(range, options2);
      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options2)) {
        return false;
      }
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        var high = null;
        var low = null;
        comparators.forEach(function(comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options2)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options2)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    }
    exports2.prerelease = prerelease;
    function prerelease(version, options2) {
      var parsed = parse2(version, options2);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }
    exports2.intersects = intersects;
    function intersects(r1, r2, options2) {
      r1 = new Range(r1, options2);
      r2 = new Range(r2, options2);
      return r1.intersects(r2);
    }
    exports2.coerce = coerce;
    function coerce(version) {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      var match = version.match(re[COERCE]);
      if (match == null) {
        return null;
      }
      return parse2(match[1] + "." + (match[2] || "0") + "." + (match[3] || "0"));
    }
  }
});

// ../../node_modules/diagnostic-channel/dist/src/patchRequire.js
var require_patchRequire = __commonJS({
  "../../node_modules/diagnostic-channel/dist/src/patchRequire.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var path = require("path");
    var semver = require_semver();
    var moduleModule = require("module");
    var nativeModules = Object.keys(process.binding("natives"));
    var originalRequire = moduleModule.prototype.require;
    function makePatchingRequire(knownPatches) {
      var patchedModules = {};
      return function patchedRequire(moduleId) {
        var originalModule = originalRequire.apply(this, arguments);
        if (knownPatches[moduleId]) {
          var modulePath = moduleModule._resolveFilename(moduleId, this);
          if (patchedModules.hasOwnProperty(modulePath)) {
            return patchedModules[modulePath];
          }
          var moduleVersion = void 0;
          if (nativeModules.indexOf(moduleId) < 0) {
            try {
              moduleVersion = originalRequire.call(this, path.join(moduleId, "package.json")).version;
            } catch (e) {
              return originalModule;
            }
          } else {
            moduleVersion = process.version.substring(1);
          }
          var prereleaseTagIndex = moduleVersion.indexOf("-");
          if (prereleaseTagIndex >= 0) {
            moduleVersion = moduleVersion.substring(0, prereleaseTagIndex);
          }
          var modifiedModule = originalModule;
          for (var _i = 0, _a2 = knownPatches[moduleId]; _i < _a2.length; _i++) {
            var modulePatcher = _a2[_i];
            if (semver.satisfies(moduleVersion, modulePatcher.versionSpecifier)) {
              modifiedModule = modulePatcher.patch(modifiedModule, modulePath);
            }
          }
          return patchedModules[modulePath] = modifiedModule;
        }
        return originalModule;
      };
    }
    exports2.makePatchingRequire = makePatchingRequire;
  }
});

// ../../node_modules/diagnostic-channel/package.json
var require_package = __commonJS({
  "../../node_modules/diagnostic-channel/package.json"(exports2, module2) {
    module2.exports = {
      name: "diagnostic-channel",
      version: "0.2.0",
      main: "./dist/src/channel.js",
      types: "./dist/src/channel.d.ts",
      scripts: {
        build: "tsc",
        lint: "tslint -c tslint.json -p tsconfig.json",
        clean: "rimraf ./dist",
        test: "mocha ./dist/tests/**/*.js"
      },
      homepage: "https://github.com/Microsoft/node-diagnostic-channel",
      bugs: {
        url: "https://github.com/Microsoft/node-diagnostic-channel/issues"
      },
      repository: {
        type: "git",
        url: "https://github.com/Microsoft/node-diagnostic-channel.git"
      },
      description: "Provides a context-saving pub/sub channel to connect diagnostic event publishers and subscribers",
      dependencies: {
        semver: "^5.3.0"
      },
      devDependencies: {
        "@types/mocha": "^2.2.40",
        "@types/node": "^7.0.12",
        mocha: "^3.2.0",
        rimraf: "^2.6.1",
        tslint: "^5.0.0",
        typescript: "^2.2.1"
      },
      files: [
        "dist/src/**/*.d.ts",
        "dist/src/**/*.js",
        "LICENSE",
        "README.md",
        "package.json"
      ],
      license: "MIT"
    };
  }
});

// ../../node_modules/diagnostic-channel/dist/src/channel.js
var require_channel = __commonJS({
  "../../node_modules/diagnostic-channel/dist/src/channel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var patchRequire_1 = require_patchRequire();
    var patchRequire_2 = require_patchRequire();
    exports2.makePatchingRequire = patchRequire_2.makePatchingRequire;
    var trueFilter = function(publishing) {
      return true;
    };
    var ContextPreservingEventEmitter = function() {
      function ContextPreservingEventEmitter2() {
        this.version = require_package().version;
        this.subscribers = {};
        this.contextPreservationFunction = function(cb) {
          return cb;
        };
        this.knownPatches = {};
        this.currentlyPublishing = false;
      }
      ContextPreservingEventEmitter2.prototype.shouldPublish = function(name) {
        var listeners = this.subscribers[name];
        if (listeners) {
          return listeners.some(function(_a2) {
            var filter = _a2.filter;
            return !filter || filter(false);
          });
        }
        return false;
      };
      ContextPreservingEventEmitter2.prototype.publish = function(name, event) {
        if (this.currentlyPublishing) {
          return;
        }
        var listeners = this.subscribers[name];
        if (listeners) {
          var standardEvent_1 = {
            timestamp: Date.now(),
            data: event
          };
          this.currentlyPublishing = true;
          listeners.forEach(function(_a2) {
            var listener = _a2.listener, filter = _a2.filter;
            try {
              if (filter && filter(true)) {
                listener(standardEvent_1);
              }
            } catch (e) {
            }
          });
          this.currentlyPublishing = false;
        }
      };
      ContextPreservingEventEmitter2.prototype.subscribe = function(name, listener, filter) {
        if (filter === void 0) {
          filter = trueFilter;
        }
        if (!this.subscribers[name]) {
          this.subscribers[name] = [];
        }
        this.subscribers[name].push({ listener, filter });
      };
      ContextPreservingEventEmitter2.prototype.unsubscribe = function(name, listener, filter) {
        if (filter === void 0) {
          filter = trueFilter;
        }
        var listeners = this.subscribers[name];
        if (listeners) {
          for (var index = 0; index < listeners.length; ++index) {
            if (listeners[index].listener === listener && listeners[index].filter === filter) {
              listeners.splice(index, 1);
              return true;
            }
          }
        }
        return false;
      };
      ContextPreservingEventEmitter2.prototype.reset = function() {
        var _this = this;
        this.subscribers = {};
        this.contextPreservationFunction = function(cb) {
          return cb;
        };
        Object.getOwnPropertyNames(this.knownPatches).forEach(function(prop) {
          return delete _this.knownPatches[prop];
        });
      };
      ContextPreservingEventEmitter2.prototype.bindToContext = function(cb) {
        return this.contextPreservationFunction(cb);
      };
      ContextPreservingEventEmitter2.prototype.addContextPreservation = function(preserver) {
        var previousPreservationStack = this.contextPreservationFunction;
        this.contextPreservationFunction = function(cb) {
          return preserver(previousPreservationStack(cb));
        };
      };
      ContextPreservingEventEmitter2.prototype.registerMonkeyPatch = function(packageName, patcher) {
        if (!this.knownPatches[packageName]) {
          this.knownPatches[packageName] = [];
        }
        this.knownPatches[packageName].push(patcher);
      };
      ContextPreservingEventEmitter2.prototype.getPatchesObject = function() {
        return this.knownPatches;
      };
      return ContextPreservingEventEmitter2;
    }();
    if (!global.diagnosticsSource) {
      global.diagnosticsSource = new ContextPreservingEventEmitter();
      moduleModule = require("module");
      moduleModule.prototype.require = patchRequire_1.makePatchingRequire(global.diagnosticsSource.getPatchesObject());
    }
    var moduleModule;
    exports2.channel = global.diagnosticsSource;
  }
});

// ../../node_modules/diagnostic-channel-publishers/dist/src/azure-coretracing.pub.js
var require_azure_coretracing_pub = __commonJS({
  "../../node_modules/diagnostic-channel-publishers/dist/src/azure-coretracing.pub.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var diagnostic_channel_1 = require_channel();
    exports2.AzureMonitorSymbol = "Azure_Monitor_Tracer";
    var azureCoreTracingPatchFunction = function(coreTracing) {
      try {
        var BasicTracer = require("@opentelemetry/tracing").BasicTracer;
        var tracerConfig = diagnostic_channel_1.channel.spanContextPropagator ? { scopeManager: diagnostic_channel_1.channel.spanContextPropagator } : void 0;
        var tracer_1 = new BasicTracer(tracerConfig);
        var startSpanOriginal_1 = tracer_1.startSpan;
        tracer_1.startSpan = function(name, options2) {
          if (!options2 || !options2.parent) {
            var parentOperation = tracer_1.getCurrentSpan();
            if (parentOperation && parentOperation.operation && parentOperation.operation.traceparent) {
              options2 = __assign({}, options2, { parent: {
                traceId: parentOperation.operation.traceparent.traceId,
                spanId: parentOperation.operation.traceparent.spanId
              } });
            }
          }
          var span = startSpanOriginal_1.call(this, name, options2);
          span.addEvent("Application Insights Integration enabled");
          return span;
        };
        tracer_1.addSpanProcessor(new AzureMonitorSpanProcessor());
        tracer_1[exports2.AzureMonitorSymbol] = true;
        coreTracing.setTracer(tracer_1);
      } catch (e) {
      }
      return coreTracing;
    };
    var AzureMonitorSpanProcessor = function() {
      function AzureMonitorSpanProcessor2() {
      }
      AzureMonitorSpanProcessor2.prototype.onStart = function(span) {
      };
      AzureMonitorSpanProcessor2.prototype.onEnd = function(span) {
        diagnostic_channel_1.channel.publish("azure-coretracing", span);
      };
      AzureMonitorSpanProcessor2.prototype.shutdown = function() {
      };
      return AzureMonitorSpanProcessor2;
    }();
    exports2.azureCoreTracing = {
      versionSpecifier: ">= 1.0.0 < 2.0.0",
      patch: azureCoreTracingPatchFunction
    };
    function enable() {
      diagnostic_channel_1.channel.registerMonkeyPatch("@azure/core-tracing", exports2.azureCoreTracing);
    }
    exports2.enable = enable;
  }
});

// ../../node_modules/diagnostic-channel-publishers/dist/src/bunyan.pub.js
var require_bunyan_pub = __commonJS({
  "../../node_modules/diagnostic-channel-publishers/dist/src/bunyan.pub.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var diagnostic_channel_1 = require_channel();
    var bunyanPatchFunction = function(originalBunyan) {
      var originalEmit = originalBunyan.prototype._emit;
      originalBunyan.prototype._emit = function(rec, noemit) {
        var ret = originalEmit.apply(this, arguments);
        if (!noemit) {
          var str = ret;
          if (!str) {
            str = originalEmit.call(this, rec, true);
          }
          diagnostic_channel_1.channel.publish("bunyan", { level: rec.level, result: str });
        }
        return ret;
      };
      return originalBunyan;
    };
    exports2.bunyan = {
      versionSpecifier: ">= 1.0.0 < 2.0.0",
      patch: bunyanPatchFunction
    };
    function enable() {
      diagnostic_channel_1.channel.registerMonkeyPatch("bunyan", exports2.bunyan);
    }
    exports2.enable = enable;
  }
});

// ../../node_modules/diagnostic-channel-publishers/dist/src/console.pub.js
var require_console_pub = __commonJS({
  "../../node_modules/diagnostic-channel-publishers/dist/src/console.pub.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var diagnostic_channel_1 = require_channel();
    var stream_1 = require("stream");
    var consolePatchFunction = function(originalConsole) {
      var aiLoggingOutStream = new stream_1.Writable();
      var aiLoggingErrStream = new stream_1.Writable();
      aiLoggingOutStream.write = function(chunk) {
        if (!chunk) {
          return true;
        }
        var message = chunk.toString();
        diagnostic_channel_1.channel.publish("console", { message });
        return true;
      };
      aiLoggingErrStream.write = function(chunk) {
        if (!chunk) {
          return true;
        }
        var message = chunk.toString();
        diagnostic_channel_1.channel.publish("console", { message, stderr: true });
        return true;
      };
      var aiLoggingConsole = new originalConsole.Console(aiLoggingOutStream, aiLoggingErrStream);
      var consoleMethods = ["log", "info", "warn", "error", "dir", "time", "timeEnd", "trace", "assert"];
      var _loop_1 = function(method2) {
        var originalMethod = originalConsole[method2];
        if (originalMethod) {
          originalConsole[method2] = function() {
            if (aiLoggingConsole[method2]) {
              try {
                aiLoggingConsole[method2].apply(aiLoggingConsole, arguments);
              } catch (e) {
              }
            }
            return originalMethod.apply(originalConsole, arguments);
          };
        }
      };
      for (var _i = 0, consoleMethods_1 = consoleMethods; _i < consoleMethods_1.length; _i++) {
        var method = consoleMethods_1[_i];
        _loop_1(method);
      }
      return originalConsole;
    };
    exports2.console = {
      versionSpecifier: ">= 4.0.0",
      patch: consolePatchFunction
    };
    function enable() {
      diagnostic_channel_1.channel.registerMonkeyPatch("console", exports2.console);
      require("console");
    }
    exports2.enable = enable;
  }
});

// ../../node_modules/diagnostic-channel-publishers/dist/src/mongodb-core.pub.js
var require_mongodb_core_pub = __commonJS({
  "../../node_modules/diagnostic-channel-publishers/dist/src/mongodb-core.pub.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var diagnostic_channel_1 = require_channel();
    var mongodbcorePatchFunction = function(originalMongoCore) {
      var originalConnect = originalMongoCore.Server.prototype.connect;
      originalMongoCore.Server.prototype.connect = function contextPreservingConnect() {
        var ret = originalConnect.apply(this, arguments);
        var originalWrite = this.s.pool.write;
        this.s.pool.write = function contextPreservingWrite() {
          var cbidx = typeof arguments[1] === "function" ? 1 : 2;
          if (typeof arguments[cbidx] === "function") {
            arguments[cbidx] = diagnostic_channel_1.channel.bindToContext(arguments[cbidx]);
          }
          return originalWrite.apply(this, arguments);
        };
        var originalLogout = this.s.pool.logout;
        this.s.pool.logout = function contextPreservingLogout() {
          if (typeof arguments[1] === "function") {
            arguments[1] = diagnostic_channel_1.channel.bindToContext(arguments[1]);
          }
          return originalLogout.apply(this, arguments);
        };
        return ret;
      };
      return originalMongoCore;
    };
    exports2.mongoCore = {
      versionSpecifier: ">= 2.0.0 < 4.0.0",
      patch: mongodbcorePatchFunction
    };
    function enable() {
      diagnostic_channel_1.channel.registerMonkeyPatch("mongodb-core", exports2.mongoCore);
    }
    exports2.enable = enable;
  }
});

// ../../node_modules/diagnostic-channel-publishers/dist/src/mongodb.pub.js
var require_mongodb_pub = __commonJS({
  "../../node_modules/diagnostic-channel-publishers/dist/src/mongodb.pub.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var diagnostic_channel_1 = require_channel();
    var mongodbPatchFunction = function(originalMongo) {
      var listener = originalMongo.instrument({
        operationIdGenerator: {
          next: function() {
            return diagnostic_channel_1.channel.bindToContext(function(cb) {
              return cb();
            });
          }
        }
      });
      var eventMap = {};
      listener.on("started", function(event) {
        if (eventMap[event.requestId]) {
          return;
        }
        eventMap[event.requestId] = __assign({}, event, { time: new Date() });
      });
      listener.on("succeeded", function(event) {
        var startedData = eventMap[event.requestId];
        if (startedData) {
          delete eventMap[event.requestId];
        }
        if (typeof event.operationId === "function") {
          event.operationId(function() {
            return diagnostic_channel_1.channel.publish("mongodb", { startedData, event, succeeded: true });
          });
        } else {
          diagnostic_channel_1.channel.publish("mongodb", { startedData, event, succeeded: true });
        }
      });
      listener.on("failed", function(event) {
        var startedData = eventMap[event.requestId];
        if (startedData) {
          delete eventMap[event.requestId];
        }
        if (typeof event.operationId === "function") {
          event.operationId(function() {
            return diagnostic_channel_1.channel.publish("mongodb", { startedData, event, succeeded: false });
          });
        } else {
          diagnostic_channel_1.channel.publish("mongodb", { startedData, event, succeeded: false });
        }
      });
      return originalMongo;
    };
    var mongodb3PatchFunction = function(originalMongo) {
      var listener = originalMongo.instrument();
      var eventMap = {};
      var contextMap = {};
      listener.on("started", function(event) {
        if (eventMap[event.requestId]) {
          return;
        }
        contextMap[event.requestId] = diagnostic_channel_1.channel.bindToContext(function(cb) {
          return cb();
        });
        eventMap[event.requestId] = __assign({}, event, { time: new Date() });
      });
      listener.on("succeeded", function(event) {
        var startedData = eventMap[event.requestId];
        if (startedData) {
          delete eventMap[event.requestId];
        }
        if (typeof event === "object" && typeof contextMap[event.requestId] === "function") {
          contextMap[event.requestId](function() {
            return diagnostic_channel_1.channel.publish("mongodb", { startedData, event, succeeded: true });
          });
          delete contextMap[event.requestId];
        }
      });
      listener.on("failed", function(event) {
        var startedData = eventMap[event.requestId];
        if (startedData) {
          delete eventMap[event.requestId];
        }
        if (typeof event === "object" && typeof contextMap[event.requestId] === "function") {
          contextMap[event.requestId](function() {
            return diagnostic_channel_1.channel.publish("mongodb", { startedData, event, succeeded: false });
          });
          delete contextMap[event.requestId];
        }
      });
      return originalMongo;
    };
    var mongodbcorePatchFunction = function(originalMongo) {
      var originalConnect = originalMongo.Server.prototype.connect;
      originalMongo.Server.prototype.connect = function contextPreservingConnect() {
        var ret = originalConnect.apply(this, arguments);
        var originalWrite = this.s.coreTopology.s.pool.write;
        this.s.coreTopology.s.pool.write = function contextPreservingWrite() {
          var cbidx = typeof arguments[1] === "function" ? 1 : 2;
          if (typeof arguments[cbidx] === "function") {
            arguments[cbidx] = diagnostic_channel_1.channel.bindToContext(arguments[cbidx]);
          }
          return originalWrite.apply(this, arguments);
        };
        var originalLogout = this.s.coreTopology.s.pool.logout;
        this.s.coreTopology.s.pool.logout = function contextPreservingLogout() {
          if (typeof arguments[1] === "function") {
            arguments[1] = diagnostic_channel_1.channel.bindToContext(arguments[1]);
          }
          return originalLogout.apply(this, arguments);
        };
        return ret;
      };
      return originalMongo;
    };
    var mongodb330PatchFunction = function(originalMongo) {
      mongodbcorePatchFunction(originalMongo);
      var listener = originalMongo.instrument();
      var eventMap = {};
      var contextMap = {};
      listener.on("started", function(event) {
        if (eventMap[event.requestId]) {
          return;
        }
        contextMap[event.requestId] = diagnostic_channel_1.channel.bindToContext(function(cb) {
          return cb();
        });
        eventMap[event.requestId] = event;
      });
      listener.on("succeeded", function(event) {
        var startedData = eventMap[event.requestId];
        if (startedData) {
          delete eventMap[event.requestId];
        }
        if (typeof event === "object" && typeof contextMap[event.requestId] === "function") {
          contextMap[event.requestId](function() {
            return diagnostic_channel_1.channel.publish("mongodb", { startedData, event, succeeded: true });
          });
          delete contextMap[event.requestId];
        }
      });
      listener.on("failed", function(event) {
        var startedData = eventMap[event.requestId];
        if (startedData) {
          delete eventMap[event.requestId];
        }
        if (typeof event === "object" && typeof contextMap[event.requestId] === "function") {
          contextMap[event.requestId](function() {
            return diagnostic_channel_1.channel.publish("mongodb", { startedData, event, succeeded: false });
          });
          delete contextMap[event.requestId];
        }
      });
      return originalMongo;
    };
    exports2.mongo2 = {
      versionSpecifier: ">= 2.0.0 <= 3.0.5",
      patch: mongodbPatchFunction
    };
    exports2.mongo3 = {
      versionSpecifier: "> 3.0.5 < 3.3.0",
      patch: mongodb3PatchFunction
    };
    exports2.mongo330 = {
      versionSpecifier: ">= 3.3.0 < 4.0.0",
      patch: mongodb330PatchFunction
    };
    function enable() {
      diagnostic_channel_1.channel.registerMonkeyPatch("mongodb", exports2.mongo2);
      diagnostic_channel_1.channel.registerMonkeyPatch("mongodb", exports2.mongo3);
      diagnostic_channel_1.channel.registerMonkeyPatch("mongodb", exports2.mongo330);
    }
    exports2.enable = enable;
  }
});

// ../../node_modules/diagnostic-channel-publishers/dist/src/mysql.pub.js
var require_mysql_pub = __commonJS({
  "../../node_modules/diagnostic-channel-publishers/dist/src/mysql.pub.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var diagnostic_channel_1 = require_channel();
    var path = require("path");
    var mysqlPatchFunction = function(originalMysql, originalMysqlPath) {
      var patchObjectFunction = function(obj, name) {
        return function(func, cbWrapper) {
          var originalFunc = obj[func];
          if (originalFunc) {
            obj[func] = function mysqlContextPreserver() {
              var cbidx = arguments.length - 1;
              for (var i = arguments.length - 1; i >= 0; --i) {
                if (typeof arguments[i] === "function") {
                  cbidx = i;
                  break;
                } else if (typeof arguments[i] !== "undefined") {
                  break;
                }
              }
              var cb = arguments[cbidx];
              var resultContainer = { result: null, startTime: null, startDate: null };
              if (typeof cb === "function") {
                if (cbWrapper) {
                  resultContainer.startTime = process.hrtime();
                  resultContainer.startDate = new Date();
                  arguments[cbidx] = diagnostic_channel_1.channel.bindToContext(cbWrapper(resultContainer, cb));
                } else {
                  arguments[cbidx] = diagnostic_channel_1.channel.bindToContext(cb);
                }
              }
              var result2 = originalFunc.apply(this, arguments);
              resultContainer.result = result2;
              return result2;
            };
          }
        };
      };
      var patchClassMemberFunction = function(classObject, name) {
        return patchObjectFunction(classObject.prototype, name + ".prototype");
      };
      var connectionCallbackFunctions = [
        "connect",
        "changeUser",
        "ping",
        "statistics",
        "end"
      ];
      var connectionClass = require(path.dirname(originalMysqlPath) + "/lib/Connection");
      connectionCallbackFunctions.forEach(function(value) {
        return patchClassMemberFunction(connectionClass, "Connection")(value);
      });
      patchObjectFunction(connectionClass, "Connection")("createQuery", function(resultContainer, cb) {
        return function(err) {
          var hrDuration = process.hrtime(resultContainer.startTime);
          var duration = hrDuration[0] * 1e3 + hrDuration[1] / 1e6 | 0;
          diagnostic_channel_1.channel.publish("mysql", { query: resultContainer.result, callbackArgs: arguments, err, duration, time: resultContainer.startDate });
          cb.apply(this, arguments);
        };
      });
      var poolCallbackFunctions = [
        "_enqueueCallback"
      ];
      var poolClass = require(path.dirname(originalMysqlPath) + "/lib/Pool");
      poolCallbackFunctions.forEach(function(value) {
        return patchClassMemberFunction(poolClass, "Pool")(value);
      });
      return originalMysql;
    };
    exports2.mysql = {
      versionSpecifier: ">= 2.0.0 < 3.0.0",
      patch: mysqlPatchFunction
    };
    function enable() {
      diagnostic_channel_1.channel.registerMonkeyPatch("mysql", exports2.mysql);
    }
    exports2.enable = enable;
  }
});

// ../../node_modules/diagnostic-channel-publishers/dist/src/pg-pool.pub.js
var require_pg_pool_pub = __commonJS({
  "../../node_modules/diagnostic-channel-publishers/dist/src/pg-pool.pub.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var diagnostic_channel_1 = require_channel();
    function postgresPool1PatchFunction(originalPgPool) {
      var originalConnect = originalPgPool.prototype.connect;
      originalPgPool.prototype.connect = function connect(callback) {
        if (callback) {
          arguments[0] = diagnostic_channel_1.channel.bindToContext(callback);
        }
        return originalConnect.apply(this, arguments);
      };
      return originalPgPool;
    }
    exports2.postgresPool1 = {
      versionSpecifier: ">= 1.0.0 < 3.0.0",
      patch: postgresPool1PatchFunction
    };
    function enable() {
      diagnostic_channel_1.channel.registerMonkeyPatch("pg-pool", exports2.postgresPool1);
    }
    exports2.enable = enable;
  }
});

// ../../node_modules/diagnostic-channel-publishers/dist/src/pg.pub.js
var require_pg_pub = __commonJS({
  "../../node_modules/diagnostic-channel-publishers/dist/src/pg.pub.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var diagnostic_channel_1 = require_channel();
    var events_1 = require("events");
    function postgres6PatchFunction(originalPg, originalPgPath) {
      var originalClientQuery = originalPg.Client.prototype.query;
      var diagnosticOriginalFunc = "__diagnosticOriginalFunc";
      originalPg.Client.prototype.query = function query(config, values, callback) {
        var data2 = {
          query: {},
          database: {
            host: this.connectionParameters.host,
            port: this.connectionParameters.port
          },
          result: null,
          error: null,
          duration: 0,
          time: new Date()
        };
        var start = process.hrtime();
        var queryResult;
        function patchCallback(cb) {
          if (cb && cb[diagnosticOriginalFunc]) {
            cb = cb[diagnosticOriginalFunc];
          }
          var trackingCallback = diagnostic_channel_1.channel.bindToContext(function(err, res) {
            var end = process.hrtime(start);
            data2.result = res && { rowCount: res.rowCount, command: res.command };
            data2.error = err;
            data2.duration = Math.ceil(end[0] * 1e3 + end[1] / 1e6);
            diagnostic_channel_1.channel.publish("postgres", data2);
            if (err) {
              if (cb) {
                return cb.apply(this, arguments);
              } else if (queryResult && queryResult instanceof events_1.EventEmitter) {
                queryResult.emit("error", err);
              }
            } else if (cb) {
              cb.apply(this, arguments);
            }
          });
          try {
            Object.defineProperty(trackingCallback, diagnosticOriginalFunc, { value: cb });
            return trackingCallback;
          } catch (e) {
            return cb;
          }
        }
        try {
          if (typeof config === "string") {
            if (values instanceof Array) {
              data2.query.preparable = {
                text: config,
                args: values
              };
              callback = patchCallback(callback);
            } else {
              data2.query.text = config;
              if (callback) {
                callback = patchCallback(callback);
              } else {
                values = patchCallback(values);
              }
            }
          } else {
            if (typeof config.name === "string") {
              data2.query.plan = config.name;
            } else if (config.values instanceof Array) {
              data2.query.preparable = {
                text: config.text,
                args: config.values
              };
            } else {
              data2.query.text = config.text;
            }
            if (callback) {
              callback = patchCallback(callback);
            } else if (values) {
              values = patchCallback(values);
            } else {
              config.callback = patchCallback(config.callback);
            }
          }
        } catch (e) {
          return originalClientQuery.apply(this, arguments);
        }
        arguments[0] = config;
        arguments[1] = values;
        arguments[2] = callback;
        arguments.length = arguments.length > 3 ? arguments.length : 3;
        queryResult = originalClientQuery.apply(this, arguments);
        return queryResult;
      };
      return originalPg;
    }
    function postgres7PatchFunction(originalPg, originalPgPath) {
      var originalClientQuery = originalPg.Client.prototype.query;
      var diagnosticOriginalFunc = "__diagnosticOriginalFunc";
      originalPg.Client.prototype.query = function query(config, values, callback) {
        var _this = this;
        var callbackProvided = !!callback;
        var data2 = {
          query: {},
          database: {
            host: this.connectionParameters.host,
            port: this.connectionParameters.port
          },
          result: null,
          error: null,
          duration: 0,
          time: new Date()
        };
        var start = process.hrtime();
        var queryResult;
        function patchCallback(cb) {
          if (cb && cb[diagnosticOriginalFunc]) {
            cb = cb[diagnosticOriginalFunc];
          }
          var trackingCallback = diagnostic_channel_1.channel.bindToContext(function(err, res) {
            var end = process.hrtime(start);
            data2.result = res && { rowCount: res.rowCount, command: res.command };
            data2.error = err;
            data2.duration = Math.ceil(end[0] * 1e3 + end[1] / 1e6);
            diagnostic_channel_1.channel.publish("postgres", data2);
            if (err) {
              if (cb) {
                return cb.apply(this, arguments);
              } else if (queryResult && queryResult instanceof events_1.EventEmitter) {
                queryResult.emit("error", err);
              }
            } else if (cb) {
              cb.apply(this, arguments);
            }
          });
          try {
            Object.defineProperty(trackingCallback, diagnosticOriginalFunc, { value: cb });
            return trackingCallback;
          } catch (e) {
            return cb;
          }
        }
        try {
          if (typeof config === "string") {
            if (values instanceof Array) {
              data2.query.preparable = {
                text: config,
                args: values
              };
              callbackProvided = typeof callback === "function";
              callback = callbackProvided ? patchCallback(callback) : callback;
            } else {
              data2.query.text = config;
              if (callback) {
                callbackProvided = typeof callback === "function";
                callback = callbackProvided ? patchCallback(callback) : callback;
              } else {
                callbackProvided = typeof values === "function";
                values = callbackProvided ? patchCallback(values) : values;
              }
            }
          } else {
            if (typeof config.name === "string") {
              data2.query.plan = config.name;
            } else if (config.values instanceof Array) {
              data2.query.preparable = {
                text: config.text,
                args: config.values
              };
            } else {
              data2.query.text = config.text;
            }
            if (callback) {
              callbackProvided = typeof callback === "function";
              callback = patchCallback(callback);
            } else if (values) {
              callbackProvided = typeof values === "function";
              values = callbackProvided ? patchCallback(values) : values;
            } else {
              callbackProvided = typeof config.callback === "function";
              config.callback = callbackProvided ? patchCallback(config.callback) : config.callback;
            }
          }
        } catch (e) {
          return originalClientQuery.apply(this, arguments);
        }
        arguments[0] = config;
        arguments[1] = values;
        arguments[2] = callback;
        arguments.length = arguments.length > 3 ? arguments.length : 3;
        queryResult = originalClientQuery.apply(this, arguments);
        if (!callbackProvided) {
          return queryResult.then(function(result2) {
            patchCallback()(void 0, result2);
            return new _this._Promise(function(resolve, reject) {
              resolve(result2);
            });
          }).catch(function(error3) {
            patchCallback()(error3, void 0);
            return new _this._Promise(function(resolve, reject) {
              reject(error3);
            });
          });
        }
        return queryResult;
      };
      return originalPg;
    }
    exports2.postgres6 = {
      versionSpecifier: "6.*",
      patch: postgres6PatchFunction
    };
    exports2.postgres7 = {
      versionSpecifier: ">=7.* <=8.*",
      patch: postgres7PatchFunction
    };
    function enable() {
      diagnostic_channel_1.channel.registerMonkeyPatch("pg", exports2.postgres6);
      diagnostic_channel_1.channel.registerMonkeyPatch("pg", exports2.postgres7);
    }
    exports2.enable = enable;
  }
});

// ../../node_modules/diagnostic-channel-publishers/dist/src/redis.pub.js
var require_redis_pub = __commonJS({
  "../../node_modules/diagnostic-channel-publishers/dist/src/redis.pub.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var diagnostic_channel_1 = require_channel();
    var redisPatchFunction = function(originalRedis) {
      var originalSend = originalRedis.RedisClient.prototype.internal_send_command;
      originalRedis.RedisClient.prototype.internal_send_command = function(commandObj) {
        if (commandObj) {
          var cb_1 = commandObj.callback;
          if (!cb_1 || !cb_1.pubsubBound) {
            var address_1 = this.address;
            var startTime_1 = process.hrtime();
            var startDate_1 = new Date();
            commandObj.callback = diagnostic_channel_1.channel.bindToContext(function(err, result2) {
              var hrDuration = process.hrtime(startTime_1);
              var duration = hrDuration[0] * 1e3 + hrDuration[1] / 1e6 | 0;
              diagnostic_channel_1.channel.publish("redis", { duration, address: address_1, commandObj, err, result: result2, time: startDate_1 });
              if (typeof cb_1 === "function") {
                cb_1.apply(this, arguments);
              }
            });
            commandObj.callback.pubsubBound = true;
          }
        }
        return originalSend.call(this, commandObj);
      };
      return originalRedis;
    };
    exports2.redis = {
      versionSpecifier: ">= 2.0.0 < 4.0.0",
      patch: redisPatchFunction
    };
    function enable() {
      diagnostic_channel_1.channel.registerMonkeyPatch("redis", exports2.redis);
    }
    exports2.enable = enable;
  }
});

// ../../node_modules/diagnostic-channel-publishers/dist/src/tedious.pub.js
var require_tedious_pub = __commonJS({
  "../../node_modules/diagnostic-channel-publishers/dist/src/tedious.pub.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var diagnostic_channel_1 = require_channel();
    var tediousPatchFunction = function(originalTedious) {
      var originalMakeRequest = originalTedious.Connection.prototype.makeRequest;
      originalTedious.Connection.prototype.makeRequest = function makeRequest() {
        function getPatchedCallback(origCallback) {
          var start = process.hrtime();
          var data2 = {
            query: {},
            database: {
              host: null,
              port: null
            },
            result: null,
            error: null,
            duration: 0
          };
          return diagnostic_channel_1.channel.bindToContext(function(err, rowCount, rows) {
            var end = process.hrtime(start);
            data2 = __assign({}, data2, { database: {
              host: this.connection.config.server,
              port: this.connection.config.options.port
            }, result: !err && { rowCount, rows }, query: {
              text: this.parametersByName.statement.value
            }, error: err, duration: Math.ceil(end[0] * 1e3 + end[1] / 1e6) });
            diagnostic_channel_1.channel.publish("tedious", data2);
            origCallback.call(this, err, rowCount, rows);
          });
        }
        var request = arguments[0];
        arguments[0].callback = getPatchedCallback(request.callback);
        originalMakeRequest.apply(this, arguments);
      };
      return originalTedious;
    };
    exports2.tedious = {
      versionSpecifier: ">= 6.0.0 < 9.0.0",
      patch: tediousPatchFunction
    };
    function enable() {
      diagnostic_channel_1.channel.registerMonkeyPatch("tedious", exports2.tedious);
    }
    exports2.enable = enable;
  }
});

// ../../node_modules/diagnostic-channel-publishers/dist/src/winston.pub.js
var require_winston_pub = __commonJS({
  "../../node_modules/diagnostic-channel-publishers/dist/src/winston.pub.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (b.hasOwnProperty(p))
            d[p] = b[p];
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __rest = exports2 && exports2.__rest || function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") {
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
          if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
      }
      return t;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var diagnostic_channel_1 = require_channel();
    var winston2PatchFunction = function(originalWinston) {
      var originalLog = originalWinston.Logger.prototype.log;
      var curLevels;
      var loggingFilter = function(level, message, meta) {
        var levelKind;
        if (curLevels === originalWinston.config.npm.levels) {
          levelKind = "npm";
        } else if (curLevels === originalWinston.config.syslog.levels) {
          levelKind = "syslog";
        } else {
          levelKind = "unknown";
        }
        diagnostic_channel_1.channel.publish("winston", { level, message, meta, levelKind });
        return message;
      };
      originalWinston.Logger.prototype.log = function log4() {
        curLevels = this.levels;
        if (!this.filters || this.filters.length === 0) {
          this.filters = [loggingFilter];
        } else if (this.filters[this.filters.length - 1] !== loggingFilter) {
          this.filters = this.filters.filter(function(f) {
            return f !== loggingFilter;
          });
          this.filters.push(loggingFilter);
        }
        return originalLog.apply(this, arguments);
      };
      return originalWinston;
    };
    var winston3PatchFunction = function(originalWinston) {
      var mapLevelToKind = function(winston, level) {
        var levelKind;
        if (winston.config.npm.levels[level] != null) {
          levelKind = "npm";
        } else if (winston.config.syslog.levels[level] != null) {
          levelKind = "syslog";
        } else {
          levelKind = "unknown";
        }
        return levelKind;
      };
      var AppInsightsTransport = function(_super) {
        __extends2(AppInsightsTransport2, _super);
        function AppInsightsTransport2(winston, opts) {
          var _this = _super.call(this, opts) || this;
          _this.winston = winston;
          return _this;
        }
        AppInsightsTransport2.prototype.log = function(info, callback) {
          var message = info.message, level = info.level, meta = info.meta, splat = __rest(info, ["message", "level", "meta"]);
          level = typeof Symbol["for"] === "function" ? info[Symbol["for"]("level")] : level;
          message = info instanceof Error ? info : message;
          var levelKind = mapLevelToKind(this.winston, level);
          meta = meta || {};
          for (var key in splat) {
            if (splat.hasOwnProperty(key)) {
              meta[key] = splat[key];
            }
          }
          diagnostic_channel_1.channel.publish("winston", { message, level, levelKind, meta });
          callback();
        };
        return AppInsightsTransport2;
      }(originalWinston.Transport);
      function patchedConfigure() {
        var levels = arguments[0].levels || originalWinston.config.npm.levels;
        var lastLevel;
        for (var level in levels) {
          if (levels.hasOwnProperty(level)) {
            lastLevel = lastLevel === void 0 || levels[level] > levels[lastLevel] ? level : lastLevel;
          }
        }
        this.add(new AppInsightsTransport(originalWinston, { level: lastLevel }));
      }
      var origCreate = originalWinston.createLogger;
      originalWinston.createLogger = function patchedCreate() {
        var levels = arguments[0].levels || originalWinston.config.npm.levels;
        var lastLevel;
        for (var level in levels) {
          if (levels.hasOwnProperty(level)) {
            lastLevel = lastLevel === void 0 || levels[level] > levels[lastLevel] ? level : lastLevel;
          }
        }
        var result2 = origCreate.apply(this, arguments);
        result2.add(new AppInsightsTransport(originalWinston, { level: lastLevel }));
        var origConfigure = result2.configure;
        result2.configure = function() {
          origConfigure.apply(this, arguments);
          patchedConfigure.apply(this, arguments);
        };
        return result2;
      };
      var origRootConfigure = originalWinston.createLogger;
      originalWinston.configure = function() {
        origRootConfigure.apply(this, arguments);
        patchedConfigure.apply(this, arguments);
      };
      originalWinston.add(new AppInsightsTransport(originalWinston));
      return originalWinston;
    };
    exports2.winston3 = {
      versionSpecifier: "3.x",
      patch: winston3PatchFunction
    };
    exports2.winston2 = {
      versionSpecifier: "2.x",
      patch: winston2PatchFunction
    };
    function enable() {
      diagnostic_channel_1.channel.registerMonkeyPatch("winston", exports2.winston2);
      diagnostic_channel_1.channel.registerMonkeyPatch("winston", exports2.winston3);
    }
    exports2.enable = enable;
  }
});

// ../../node_modules/diagnostic-channel-publishers/dist/src/index.js
var require_src = __commonJS({
  "../../node_modules/diagnostic-channel-publishers/dist/src/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var azuresdk = require_azure_coretracing_pub();
    exports2.azuresdk = azuresdk;
    var bunyan = require_bunyan_pub();
    exports2.bunyan = bunyan;
    var consolePub = require_console_pub();
    exports2.console = consolePub;
    var mongodbCore = require_mongodb_core_pub();
    exports2.mongodbCore = mongodbCore;
    var mongodb = require_mongodb_pub();
    exports2.mongodb = mongodb;
    var mysql = require_mysql_pub();
    exports2.mysql = mysql;
    var pgPool = require_pg_pool_pub();
    exports2.pgPool = pgPool;
    var pg = require_pg_pub();
    exports2.pg = pg;
    var redis = require_redis_pub();
    exports2.redis = redis;
    var tedious = require_tedious_pub();
    exports2.tedious = tedious;
    var winston = require_winston_pub();
    exports2.winston = winston;
    function enable() {
      bunyan.enable();
      consolePub.enable();
      mongodbCore.enable();
      mongodb.enable();
      mysql.enable();
      pg.enable();
      pgPool.enable();
      redis.enable();
      winston.enable();
      azuresdk.enable();
      tedious.enable();
    }
    exports2.enable = enable;
  }
});

// ../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/initialization.js
var require_initialization = __commonJS({
  "../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/initialization.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IsInitialized = !process.env["APPLICATION_INSIGHTS_NO_DIAGNOSTIC_CHANNEL"];
    if (exports2.IsInitialized) {
      publishers = require_src();
      individualOptOuts = process.env["APPLICATION_INSIGHTS_NO_PATCH_MODULES"] || "";
      unpatchedModules = individualOptOuts.split(",");
      modules = {
        bunyan: publishers.bunyan,
        console: publishers.console,
        mongodb: publishers.mongodb,
        mongodbCore: publishers.mongodbCore,
        mysql: publishers.mysql,
        redis: publishers.redis,
        pg: publishers.pg,
        pgPool: publishers.pgPool,
        winston: publishers.winston
      };
      for (mod in modules) {
        if (unpatchedModules.indexOf(mod) === -1) {
          modules[mod].enable();
        }
      }
    }
    var publishers;
    var individualOptOuts;
    var unpatchedModules;
    var modules;
    var mod;
    function registerContextPreservation(cb) {
      if (!exports2.IsInitialized) {
        return;
      }
      require_channel().channel.addContextPreservation(cb);
    }
    exports2.registerContextPreservation = registerContextPreservation;
  }
});

// ../../node_modules/cls-hooked/node_modules/semver/semver.js
var require_semver2 = __commonJS({
  "../../node_modules/cls-hooked/node_modules/semver/semver.js"(exports2, module2) {
    exports2 = module2.exports = SemVer;
    var debug;
    if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
      debug = function() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift("SEMVER");
        console.log.apply(console, args);
      };
    } else {
      debug = function() {
      };
    }
    exports2.SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var re = exports2.re = [];
    var src = exports2.src = [];
    var R = 0;
    var NUMERICIDENTIFIER = R++;
    src[NUMERICIDENTIFIER] = "0|[1-9]\\d*";
    var NUMERICIDENTIFIERLOOSE = R++;
    src[NUMERICIDENTIFIERLOOSE] = "[0-9]+";
    var NONNUMERICIDENTIFIER = R++;
    src[NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
    var MAINVERSION = R++;
    src[MAINVERSION] = "(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")";
    var MAINVERSIONLOOSE = R++;
    src[MAINVERSIONLOOSE] = "(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")";
    var PRERELEASEIDENTIFIER = R++;
    src[PRERELEASEIDENTIFIER] = "(?:" + src[NUMERICIDENTIFIER] + "|" + src[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASEIDENTIFIERLOOSE = R++;
    src[PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[NUMERICIDENTIFIERLOOSE] + "|" + src[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASE = R++;
    src[PRERELEASE] = "(?:-(" + src[PRERELEASEIDENTIFIER] + "(?:\\." + src[PRERELEASEIDENTIFIER] + ")*))";
    var PRERELEASELOOSE = R++;
    src[PRERELEASELOOSE] = "(?:-?(" + src[PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[PRERELEASEIDENTIFIERLOOSE] + ")*))";
    var BUILDIDENTIFIER = R++;
    src[BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
    var BUILD = R++;
    src[BUILD] = "(?:\\+(" + src[BUILDIDENTIFIER] + "(?:\\." + src[BUILDIDENTIFIER] + ")*))";
    var FULL = R++;
    var FULLPLAIN = "v?" + src[MAINVERSION] + src[PRERELEASE] + "?" + src[BUILD] + "?";
    src[FULL] = "^" + FULLPLAIN + "$";
    var LOOSEPLAIN = "[v=\\s]*" + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + "?" + src[BUILD] + "?";
    var LOOSE = R++;
    src[LOOSE] = "^" + LOOSEPLAIN + "$";
    var GTLT = R++;
    src[GTLT] = "((?:<|>)?=?)";
    var XRANGEIDENTIFIERLOOSE = R++;
    src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
    var XRANGEIDENTIFIER = R++;
    src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + "|x|X|\\*";
    var XRANGEPLAIN = R++;
    src[XRANGEPLAIN] = "[v=\\s]*(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:" + src[PRERELEASE] + ")?" + src[BUILD] + "?)?)?";
    var XRANGEPLAINLOOSE = R++;
    src[XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:" + src[PRERELEASELOOSE] + ")?" + src[BUILD] + "?)?)?";
    var XRANGE = R++;
    src[XRANGE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAIN] + "$";
    var XRANGELOOSE = R++;
    src[XRANGELOOSE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAINLOOSE] + "$";
    var COERCE = R++;
    src[COERCE] = "(?:^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
    var LONETILDE = R++;
    src[LONETILDE] = "(?:~>?)";
    var TILDETRIM = R++;
    src[TILDETRIM] = "(\\s*)" + src[LONETILDE] + "\\s+";
    re[TILDETRIM] = new RegExp(src[TILDETRIM], "g");
    var tildeTrimReplace = "$1~";
    var TILDE = R++;
    src[TILDE] = "^" + src[LONETILDE] + src[XRANGEPLAIN] + "$";
    var TILDELOOSE = R++;
    src[TILDELOOSE] = "^" + src[LONETILDE] + src[XRANGEPLAINLOOSE] + "$";
    var LONECARET = R++;
    src[LONECARET] = "(?:\\^)";
    var CARETTRIM = R++;
    src[CARETTRIM] = "(\\s*)" + src[LONECARET] + "\\s+";
    re[CARETTRIM] = new RegExp(src[CARETTRIM], "g");
    var caretTrimReplace = "$1^";
    var CARET = R++;
    src[CARET] = "^" + src[LONECARET] + src[XRANGEPLAIN] + "$";
    var CARETLOOSE = R++;
    src[CARETLOOSE] = "^" + src[LONECARET] + src[XRANGEPLAINLOOSE] + "$";
    var COMPARATORLOOSE = R++;
    src[COMPARATORLOOSE] = "^" + src[GTLT] + "\\s*(" + LOOSEPLAIN + ")$|^$";
    var COMPARATOR = R++;
    src[COMPARATOR] = "^" + src[GTLT] + "\\s*(" + FULLPLAIN + ")$|^$";
    var COMPARATORTRIM = R++;
    src[COMPARATORTRIM] = "(\\s*)" + src[GTLT] + "\\s*(" + LOOSEPLAIN + "|" + src[XRANGEPLAIN] + ")";
    re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], "g");
    var comparatorTrimReplace = "$1$2$3";
    var HYPHENRANGE = R++;
    src[HYPHENRANGE] = "^\\s*(" + src[XRANGEPLAIN] + ")\\s+-\\s+(" + src[XRANGEPLAIN] + ")\\s*$";
    var HYPHENRANGELOOSE = R++;
    src[HYPHENRANGELOOSE] = "^\\s*(" + src[XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[XRANGEPLAINLOOSE] + ")\\s*$";
    var STAR = R++;
    src[STAR] = "(<|>)?=?\\s*\\*";
    for (i = 0; i < R; i++) {
      debug(i, src[i]);
      if (!re[i]) {
        re[i] = new RegExp(src[i]);
      }
    }
    var i;
    exports2.parse = parse2;
    function parse2(version, options2) {
      if (!options2 || typeof options2 !== "object") {
        options2 = {
          loose: !!options2,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      if (version.length > MAX_LENGTH) {
        return null;
      }
      var r = options2.loose ? re[LOOSE] : re[FULL];
      if (!r.test(version)) {
        return null;
      }
      try {
        return new SemVer(version, options2);
      } catch (er) {
        return null;
      }
    }
    exports2.valid = valid;
    function valid(version, options2) {
      var v = parse2(version, options2);
      return v ? v.version : null;
    }
    exports2.clean = clean;
    function clean(version, options2) {
      var s = parse2(version.trim().replace(/^[=v]+/, ""), options2);
      return s ? s.version : null;
    }
    exports2.SemVer = SemVer;
    function SemVer(version, options2) {
      if (!options2 || typeof options2 !== "object") {
        options2 = {
          loose: !!options2,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        if (version.loose === options2.loose) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== "string") {
        throw new TypeError("Invalid Version: " + version);
      }
      if (version.length > MAX_LENGTH) {
        throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
      }
      if (!(this instanceof SemVer)) {
        return new SemVer(version, options2);
      }
      debug("SemVer", version, options2);
      this.options = options2;
      this.loose = !!options2.loose;
      var m = version.trim().match(options2.loose ? re[LOOSE] : re[FULL]);
      if (!m) {
        throw new TypeError("Invalid Version: " + version);
      }
      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map(function(id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    SemVer.prototype.format = function() {
      this.version = this.major + "." + this.minor + "." + this.patch;
      if (this.prerelease.length) {
        this.version += "-" + this.prerelease.join(".");
      }
      return this.version;
    };
    SemVer.prototype.toString = function() {
      return this.version;
    };
    SemVer.prototype.compare = function(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return this.compareMain(other) || this.comparePre(other);
    };
    SemVer.prototype.compareMain = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };
    SemVer.prototype.comparePre = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      var i2 = 0;
      do {
        var a = this.prerelease[i2];
        var b = other.prerelease[i2];
        debug("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.inc = function(release, identifier) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier);
          this.inc("pre", identifier);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier);
          }
          this.inc("pre", identifier);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i2 = this.prerelease.length;
            while (--i2 >= 0) {
              if (typeof this.prerelease[i2] === "number") {
                this.prerelease[i2]++;
                i2 = -2;
              }
            }
            if (i2 === -1) {
              this.prerelease.push(0);
            }
          }
          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }
          break;
        default:
          throw new Error("invalid increment argument: " + release);
      }
      this.format();
      this.raw = this.version;
      return this;
    };
    exports2.inc = inc;
    function inc(version, release, loose, identifier) {
      if (typeof loose === "string") {
        identifier = loose;
        loose = void 0;
      }
      try {
        return new SemVer(version, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }
    exports2.diff = diff;
    function diff(version1, version2) {
      if (eq(version1, version2)) {
        return null;
      } else {
        var v1 = parse2(version1);
        var v2 = parse2(version2);
        var prefix = "";
        if (v1.prerelease.length || v2.prerelease.length) {
          prefix = "pre";
          var defaultResult = "prerelease";
        }
        for (var key in v1) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    }
    exports2.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;
    function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }
    exports2.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }
    exports2.major = major;
    function major(a, loose) {
      return new SemVer(a, loose).major;
    }
    exports2.minor = minor;
    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }
    exports2.patch = patch;
    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }
    exports2.compare = compare;
    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(new SemVer(b, loose));
    }
    exports2.compareLoose = compareLoose;
    function compareLoose(a, b) {
      return compare(a, b, true);
    }
    exports2.rcompare = rcompare;
    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }
    exports2.sort = sort;
    function sort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.compare(a, b, loose);
      });
    }
    exports2.rsort = rsort;
    function rsort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.rcompare(a, b, loose);
      });
    }
    exports2.gt = gt;
    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }
    exports2.lt = lt;
    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }
    exports2.eq = eq;
    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }
    exports2.neq = neq;
    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }
    exports2.gte = gte;
    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }
    exports2.lte = lte;
    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }
    exports2.cmp = cmp;
    function cmp(a, op, b, loose) {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError("Invalid operator: " + op);
      }
    }
    exports2.Comparator = Comparator;
    function Comparator(comp, options2) {
      if (!options2 || typeof options2 !== "object") {
        options2 = {
          loose: !!options2,
          includePrerelease: false
        };
      }
      if (comp instanceof Comparator) {
        if (comp.loose === !!options2.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      if (!(this instanceof Comparator)) {
        return new Comparator(comp, options2);
      }
      debug("comparator", comp, options2);
      this.options = options2;
      this.loose = !!options2.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug("comp", this);
    }
    var ANY = {};
    Comparator.prototype.parse = function(comp) {
      var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
      var m = comp.match(r);
      if (!m) {
        throw new TypeError("Invalid comparator: " + comp);
      }
      this.operator = m[1];
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    };
    Comparator.prototype.toString = function() {
      return this.value;
    };
    Comparator.prototype.test = function(version) {
      debug("Comparator.test", version, this.options.loose);
      if (this.semver === ANY) {
        return true;
      }
      if (typeof version === "string") {
        version = new SemVer(version, this.options);
      }
      return cmp(version, this.operator, this.semver, this.options);
    };
    Comparator.prototype.intersects = function(comp, options2) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options2 || typeof options2 !== "object") {
        options2 = {
          loose: !!options2,
          includePrerelease: false
        };
      }
      var rangeTmp;
      if (this.operator === "") {
        rangeTmp = new Range(comp.value, options2);
        return satisfies(this.value, rangeTmp, options2);
      } else if (comp.operator === "") {
        rangeTmp = new Range(this.value, options2);
        return satisfies(comp.semver, rangeTmp, options2);
      }
      var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options2) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
      var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options2) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };
    exports2.Range = Range;
    function Range(range, options2) {
      if (!options2 || typeof options2 !== "object") {
        options2 = {
          loose: !!options2,
          includePrerelease: false
        };
      }
      if (range instanceof Range) {
        if (range.loose === !!options2.loose && range.includePrerelease === !!options2.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options2);
        }
      }
      if (range instanceof Comparator) {
        return new Range(range.value, options2);
      }
      if (!(this instanceof Range)) {
        return new Range(range, options2);
      }
      this.options = options2;
      this.loose = !!options2.loose;
      this.includePrerelease = !!options2.includePrerelease;
      this.raw = range;
      this.set = range.split(/\s*\|\|\s*/).map(function(range2) {
        return this.parseRange(range2.trim());
      }, this).filter(function(c) {
        return c.length;
      });
      if (!this.set.length) {
        throw new TypeError("Invalid SemVer Range: " + range);
      }
      this.format();
    }
    Range.prototype.format = function() {
      this.range = this.set.map(function(comps) {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    };
    Range.prototype.toString = function() {
      return this.range;
    };
    Range.prototype.parseRange = function(range) {
      var loose = this.options.loose;
      range = range.trim();
      var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug("hyphen replace", range);
      range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range, re[COMPARATORTRIM]);
      range = range.replace(re[TILDETRIM], tildeTrimReplace);
      range = range.replace(re[CARETTRIM], caretTrimReplace);
      range = range.split(/\s+/).join(" ");
      var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
      var set = range.split(" ").map(function(comp) {
        return parseComparator(comp, this.options);
      }, this).join(" ").split(/\s+/);
      if (this.options.loose) {
        set = set.filter(function(comp) {
          return !!comp.match(compRe);
        });
      }
      set = set.map(function(comp) {
        return new Comparator(comp, this.options);
      }, this);
      return set;
    };
    Range.prototype.intersects = function(range, options2) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some(function(thisComparators) {
        return thisComparators.every(function(thisComparator) {
          return range.set.some(function(rangeComparators) {
            return rangeComparators.every(function(rangeComparator) {
              return thisComparator.intersects(rangeComparator, options2);
            });
          });
        });
      });
    };
    exports2.toComparators = toComparators;
    function toComparators(range, options2) {
      return new Range(range, options2).set.map(function(comp) {
        return comp.map(function(c) {
          return c.value;
        }).join(" ").trim().split(" ");
      });
    }
    function parseComparator(comp, options2) {
      debug("comp", comp, options2);
      comp = replaceCarets(comp, options2);
      debug("caret", comp);
      comp = replaceTildes(comp, options2);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options2);
      debug("xrange", comp);
      comp = replaceStars(comp, options2);
      debug("stars", comp);
      return comp;
    }
    function isX(id) {
      return !id || id.toLowerCase() === "x" || id === "*";
    }
    function replaceTildes(comp, options2) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceTilde(comp2, options2);
      }).join(" ");
    }
    function replaceTilde(comp, options2) {
      var r = options2.loose ? re[TILDELOOSE] : re[TILDE];
      return comp.replace(r, function(_45, M, m, p, pr) {
        debug("tilde", comp, _45, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
        }
        debug("tilde return", ret);
        return ret;
      });
    }
    function replaceCarets(comp, options2) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceCaret(comp2, options2);
      }).join(" ");
    }
    function replaceCaret(comp, options2) {
      debug("caret", comp, options2);
      var r = options2.loose ? re[CARETLOOSE] : re[CARET];
      return comp.replace(r, function(_45, M, m, p, pr) {
        debug("caret", comp, _45, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          if (M === "0") {
            ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
          } else {
            ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
          }
        }
        debug("caret return", ret);
        return ret;
      });
    }
    function replaceXRanges(comp, options2) {
      debug("replaceXRanges", comp, options2);
      return comp.split(/\s+/).map(function(comp2) {
        return replaceXRange(comp2, options2);
      }).join(" ");
    }
    function replaceXRange(comp, options2) {
      comp = comp.trim();
      var r = options2.loose ? re[XRANGELOOSE] : re[XRANGE];
      return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          ret = gtlt + M + "." + m + "." + p;
        } else if (xm) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (xp) {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        }
        debug("xRange return", ret);
        return ret;
      });
    }
    function replaceStars(comp, options2) {
      debug("replaceStars", comp, options2);
      return comp.trim().replace(re[STAR], "");
    }
    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = ">=" + fM + ".0.0";
      } else if (isX(fp)) {
        from = ">=" + fM + "." + fm + ".0";
      } else {
        from = ">=" + from;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = "<" + (+tM + 1) + ".0.0";
      } else if (isX(tp)) {
        to = "<" + tM + "." + (+tm + 1) + ".0";
      } else if (tpr) {
        to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
      } else {
        to = "<=" + to;
      }
      return (from + " " + to).trim();
    }
    Range.prototype.test = function(version) {
      if (!version) {
        return false;
      }
      if (typeof version === "string") {
        version = new SemVer(version, this.options);
      }
      for (var i2 = 0; i2 < this.set.length; i2++) {
        if (testSet(this.set[i2], version, this.options)) {
          return true;
        }
      }
      return false;
    };
    function testSet(set, version, options2) {
      for (var i2 = 0; i2 < set.length; i2++) {
        if (!set[i2].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options2.includePrerelease) {
        for (i2 = 0; i2 < set.length; i2++) {
          debug(set[i2].semver);
          if (set[i2].semver === ANY) {
            continue;
          }
          if (set[i2].semver.prerelease.length > 0) {
            var allowed = set[i2].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    }
    exports2.satisfies = satisfies;
    function satisfies(version, range, options2) {
      try {
        range = new Range(range, options2);
      } catch (er) {
        return false;
      }
      return range.test(version);
    }
    exports2.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range, options2) {
      var max = null;
      var maxSV = null;
      try {
        var rangeObj = new Range(range, options2);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options2);
          }
        }
      });
      return max;
    }
    exports2.minSatisfying = minSatisfying;
    function minSatisfying(versions, range, options2) {
      var min = null;
      var minSV = null;
      try {
        var rangeObj = new Range(range, options2);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options2);
          }
        }
      });
      return min;
    }
    exports2.minVersion = minVersion;
    function minVersion(range, loose) {
      range = new Range(range, loose);
      var minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        comparators.forEach(function(comparator) {
          var compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error("Unexpected operation: " + comparator.operator);
          }
        });
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    }
    exports2.validRange = validRange;
    function validRange(range, options2) {
      try {
        return new Range(range, options2).range || "*";
      } catch (er) {
        return null;
      }
    }
    exports2.ltr = ltr;
    function ltr(version, range, options2) {
      return outside(version, range, "<", options2);
    }
    exports2.gtr = gtr;
    function gtr(version, range, options2) {
      return outside(version, range, ">", options2);
    }
    exports2.outside = outside;
    function outside(version, range, hilo, options2) {
      version = new SemVer(version, options2);
      range = new Range(range, options2);
      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options2)) {
        return false;
      }
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        var high = null;
        var low = null;
        comparators.forEach(function(comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options2)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options2)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    }
    exports2.prerelease = prerelease;
    function prerelease(version, options2) {
      var parsed = parse2(version, options2);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }
    exports2.intersects = intersects;
    function intersects(r1, r2, options2) {
      r1 = new Range(r1, options2);
      r2 = new Range(r2, options2);
      return r1.intersects(r2);
    }
    exports2.coerce = coerce;
    function coerce(version) {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      var match = version.match(re[COERCE]);
      if (match == null) {
        return null;
      }
      return parse2(match[1] + "." + (match[2] || "0") + "." + (match[3] || "0"));
    }
  }
});

// ../../node_modules/shimmer/index.js
var require_shimmer = __commonJS({
  "../../node_modules/shimmer/index.js"(exports2, module2) {
    "use strict";
    function isFunction(funktion) {
      return typeof funktion === "function";
    }
    var logger = console.error.bind(console);
    function defineProperty(obj, name, value) {
      var enumerable = !!obj[name] && obj.propertyIsEnumerable(name);
      Object.defineProperty(obj, name, {
        configurable: true,
        enumerable,
        writable: true,
        value
      });
    }
    function shimmer(options2) {
      if (options2 && options2.logger) {
        if (!isFunction(options2.logger))
          logger("new logger isn't a function, not replacing");
        else
          logger = options2.logger;
      }
    }
    function wrap(nodule, name, wrapper) {
      if (!nodule || !nodule[name]) {
        logger("no original function " + name + " to wrap");
        return;
      }
      if (!wrapper) {
        logger("no wrapper function");
        logger(new Error().stack);
        return;
      }
      if (!isFunction(nodule[name]) || !isFunction(wrapper)) {
        logger("original object and wrapper must be functions");
        return;
      }
      var original = nodule[name];
      var wrapped = wrapper(original, name);
      defineProperty(wrapped, "__original", original);
      defineProperty(wrapped, "__unwrap", function() {
        if (nodule[name] === wrapped)
          defineProperty(nodule, name, original);
      });
      defineProperty(wrapped, "__wrapped", true);
      defineProperty(nodule, name, wrapped);
      return wrapped;
    }
    function massWrap(nodules, names, wrapper) {
      if (!nodules) {
        logger("must provide one or more modules to patch");
        logger(new Error().stack);
        return;
      } else if (!Array.isArray(nodules)) {
        nodules = [nodules];
      }
      if (!(names && Array.isArray(names))) {
        logger("must provide one or more functions to wrap on modules");
        return;
      }
      nodules.forEach(function(nodule) {
        names.forEach(function(name) {
          wrap(nodule, name, wrapper);
        });
      });
    }
    function unwrap(nodule, name) {
      if (!nodule || !nodule[name]) {
        logger("no function to unwrap.");
        logger(new Error().stack);
        return;
      }
      if (!nodule[name].__unwrap) {
        logger("no original to unwrap to -- has " + name + " already been unwrapped?");
      } else {
        return nodule[name].__unwrap();
      }
    }
    function massUnwrap(nodules, names) {
      if (!nodules) {
        logger("must provide one or more modules to patch");
        logger(new Error().stack);
        return;
      } else if (!Array.isArray(nodules)) {
        nodules = [nodules];
      }
      if (!(names && Array.isArray(names))) {
        logger("must provide one or more functions to unwrap on modules");
        return;
      }
      nodules.forEach(function(nodule) {
        names.forEach(function(name) {
          unwrap(nodule, name);
        });
      });
    }
    shimmer.wrap = wrap;
    shimmer.massWrap = massWrap;
    shimmer.unwrap = unwrap;
    shimmer.massUnwrap = massUnwrap;
    module2.exports = shimmer;
  }
});

// ../../node_modules/emitter-listener/listener.js
var require_listener = __commonJS({
  "../../node_modules/emitter-listener/listener.js"(exports2, module2) {
    "use strict";
    var shimmer = require_shimmer();
    var wrap = shimmer.wrap;
    var unwrap = shimmer.unwrap;
    var SYMBOL = "wrap@before";
    function defineProperty(obj, name, value) {
      var enumerable = !!obj[name] && obj.propertyIsEnumerable(name);
      Object.defineProperty(obj, name, {
        configurable: true,
        enumerable,
        writable: true,
        value
      });
    }
    function _process(self2, listeners) {
      var l = listeners.length;
      for (var p = 0; p < l; p++) {
        var listener = listeners[p];
        var before = self2[SYMBOL];
        if (typeof before === "function") {
          before(listener);
        } else if (Array.isArray(before)) {
          var length = before.length;
          for (var i = 0; i < length; i++)
            before[i](listener);
        }
      }
    }
    function _listeners(self2, event) {
      var listeners;
      listeners = self2._events && self2._events[event];
      if (!Array.isArray(listeners)) {
        if (listeners) {
          listeners = [listeners];
        } else {
          listeners = [];
        }
      }
      return listeners;
    }
    function _findAndProcess(self2, event, before) {
      var after = _listeners(self2, event);
      var unprocessed = after.filter(function(fn) {
        return before.indexOf(fn) === -1;
      });
      if (unprocessed.length > 0)
        _process(self2, unprocessed);
    }
    function _wrap(unwrapped, visit) {
      if (!unwrapped)
        return;
      var wrapped = unwrapped;
      if (typeof unwrapped === "function") {
        wrapped = visit(unwrapped);
      } else if (Array.isArray(unwrapped)) {
        wrapped = [];
        for (var i = 0; i < unwrapped.length; i++) {
          wrapped[i] = visit(unwrapped[i]);
        }
      }
      return wrapped;
    }
    module2.exports = function wrapEmitter(emitter, onAddListener, onEmit) {
      if (!emitter || !emitter.on || !emitter.addListener || !emitter.removeListener || !emitter.emit) {
        throw new Error("can only wrap real EEs");
      }
      if (!onAddListener)
        throw new Error("must have function to run on listener addition");
      if (!onEmit)
        throw new Error("must have function to wrap listeners when emitting");
      function adding(on) {
        return function added(event, listener) {
          var existing = _listeners(this, event).slice();
          try {
            var returned = on.call(this, event, listener);
            _findAndProcess(this, event, existing);
            return returned;
          } finally {
            if (!this.on.__wrapped)
              wrap(this, "on", adding);
            if (!this.addListener.__wrapped)
              wrap(this, "addListener", adding);
          }
        };
      }
      function emitting(emit) {
        return function emitted(event) {
          if (!this._events || !this._events[event])
            return emit.apply(this, arguments);
          var unwrapped = this._events[event];
          function remover(removeListener) {
            return function removed() {
              this._events[event] = unwrapped;
              try {
                return removeListener.apply(this, arguments);
              } finally {
                unwrapped = this._events[event];
                this._events[event] = _wrap(unwrapped, onEmit);
              }
            };
          }
          wrap(this, "removeListener", remover);
          try {
            this._events[event] = _wrap(unwrapped, onEmit);
            return emit.apply(this, arguments);
          } finally {
            unwrap(this, "removeListener");
            this._events[event] = unwrapped;
          }
        };
      }
      if (!emitter[SYMBOL]) {
        defineProperty(emitter, SYMBOL, onAddListener);
      } else if (typeof emitter[SYMBOL] === "function") {
        defineProperty(emitter, SYMBOL, [emitter[SYMBOL], onAddListener]);
      } else if (Array.isArray(emitter[SYMBOL])) {
        emitter[SYMBOL].push(onAddListener);
      }
      if (!emitter.__wrapped) {
        wrap(emitter, "addListener", adding);
        wrap(emitter, "on", adding);
        wrap(emitter, "emit", emitting);
        defineProperty(emitter, "__unwrap", function() {
          unwrap(emitter, "addListener");
          unwrap(emitter, "on");
          unwrap(emitter, "emit");
          delete emitter[SYMBOL];
          delete emitter.__wrapped;
        });
        defineProperty(emitter, "__wrapped", true);
      }
    };
  }
});

// ../../node_modules/cls-hooked/context.js
var require_context = __commonJS({
  "../../node_modules/cls-hooked/context.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var assert = require("assert");
    var wrapEmitter = require_listener();
    var async_hooks = require("async_hooks");
    var CONTEXTS_SYMBOL = "cls@contexts";
    var ERROR_SYMBOL = "error@context";
    var DEBUG_CLS_HOOKED = process.env.DEBUG_CLS_HOOKED;
    var currentUid = -1;
    module2.exports = {
      getNamespace,
      createNamespace,
      destroyNamespace,
      reset,
      ERROR_SYMBOL
    };
    function Namespace(name) {
      this.name = name;
      this.active = null;
      this._set = [];
      this.id = null;
      this._contexts = /* @__PURE__ */ new Map();
      this._indent = 0;
    }
    Namespace.prototype.set = function set(key, value) {
      if (!this.active) {
        throw new Error("No context available. ns.run() or ns.bind() must be called first.");
      }
      this.active[key] = value;
      if (DEBUG_CLS_HOOKED) {
        const indentStr = " ".repeat(this._indent < 0 ? 0 : this._indent);
        debug2(indentStr + "CONTEXT-SET KEY:" + key + "=" + value + " in ns:" + this.name + " currentUid:" + currentUid + " active:" + util.inspect(this.active, { showHidden: true, depth: 2, colors: true }));
      }
      return value;
    };
    Namespace.prototype.get = function get3(key) {
      if (!this.active) {
        if (DEBUG_CLS_HOOKED) {
          const asyncHooksCurrentId = async_hooks.currentId();
          const triggerId = async_hooks.triggerAsyncId();
          const indentStr = " ".repeat(this._indent < 0 ? 0 : this._indent);
          debug2(`${indentStr}CONTEXT-GETTING KEY NO ACTIVE NS: (${this.name}) ${key}=undefined currentUid:${currentUid} asyncHooksCurrentId:${asyncHooksCurrentId} triggerId:${triggerId} len:${this._set.length}`);
        }
        return void 0;
      }
      if (DEBUG_CLS_HOOKED) {
        const asyncHooksCurrentId = async_hooks.executionAsyncId();
        const triggerId = async_hooks.triggerAsyncId();
        const indentStr = " ".repeat(this._indent < 0 ? 0 : this._indent);
        debug2(indentStr + "CONTEXT-GETTING KEY:" + key + "=" + this.active[key] + " (" + this.name + ") currentUid:" + currentUid + " active:" + util.inspect(this.active, { showHidden: true, depth: 2, colors: true }));
        debug2(`${indentStr}CONTEXT-GETTING KEY: (${this.name}) ${key}=${this.active[key]} currentUid:${currentUid} asyncHooksCurrentId:${asyncHooksCurrentId} triggerId:${triggerId} len:${this._set.length} active:${util.inspect(this.active)}`);
      }
      return this.active[key];
    };
    Namespace.prototype.createContext = function createContext() {
      let context = Object.create(this.active ? this.active : Object.prototype);
      context._ns_name = this.name;
      context.id = currentUid;
      if (DEBUG_CLS_HOOKED) {
        const asyncHooksCurrentId = async_hooks.executionAsyncId();
        const triggerId = async_hooks.triggerAsyncId();
        const indentStr = " ".repeat(this._indent < 0 ? 0 : this._indent);
        debug2(`${indentStr}CONTEXT-CREATED Context: (${this.name}) currentUid:${currentUid} asyncHooksCurrentId:${asyncHooksCurrentId} triggerId:${triggerId} len:${this._set.length} context:${util.inspect(context, { showHidden: true, depth: 2, colors: true })}`);
      }
      return context;
    };
    Namespace.prototype.run = function run(fn) {
      let context = this.createContext();
      this.enter(context);
      try {
        if (DEBUG_CLS_HOOKED) {
          const triggerId = async_hooks.triggerAsyncId();
          const asyncHooksCurrentId = async_hooks.executionAsyncId();
          const indentStr = " ".repeat(this._indent < 0 ? 0 : this._indent);
          debug2(`${indentStr}CONTEXT-RUN BEGIN: (${this.name}) currentUid:${currentUid} triggerId:${triggerId} asyncHooksCurrentId:${asyncHooksCurrentId} len:${this._set.length} context:${util.inspect(context)}`);
        }
        fn(context);
        return context;
      } catch (exception) {
        if (exception) {
          exception[ERROR_SYMBOL] = context;
        }
        throw exception;
      } finally {
        if (DEBUG_CLS_HOOKED) {
          const triggerId = async_hooks.triggerAsyncId();
          const asyncHooksCurrentId = async_hooks.executionAsyncId();
          const indentStr = " ".repeat(this._indent < 0 ? 0 : this._indent);
          debug2(`${indentStr}CONTEXT-RUN END: (${this.name}) currentUid:${currentUid} triggerId:${triggerId} asyncHooksCurrentId:${asyncHooksCurrentId} len:${this._set.length} ${util.inspect(context)}`);
        }
        this.exit(context);
      }
    };
    Namespace.prototype.runAndReturn = function runAndReturn(fn) {
      let value;
      this.run(function(context) {
        value = fn(context);
      });
      return value;
    };
    Namespace.prototype.runPromise = function runPromise(fn) {
      let context = this.createContext();
      this.enter(context);
      let promise = fn(context);
      if (!promise || !promise.then || !promise.catch) {
        throw new Error("fn must return a promise.");
      }
      if (DEBUG_CLS_HOOKED) {
        debug2("CONTEXT-runPromise BEFORE: (" + this.name + ") currentUid:" + currentUid + " len:" + this._set.length + " " + util.inspect(context));
      }
      return promise.then((result2) => {
        if (DEBUG_CLS_HOOKED) {
          debug2("CONTEXT-runPromise AFTER then: (" + this.name + ") currentUid:" + currentUid + " len:" + this._set.length + " " + util.inspect(context));
        }
        this.exit(context);
        return result2;
      }).catch((err) => {
        err[ERROR_SYMBOL] = context;
        if (DEBUG_CLS_HOOKED) {
          debug2("CONTEXT-runPromise AFTER catch: (" + this.name + ") currentUid:" + currentUid + " len:" + this._set.length + " " + util.inspect(context));
        }
        this.exit(context);
        throw err;
      });
    };
    Namespace.prototype.bind = function bindFactory(fn, context) {
      if (!context) {
        if (!this.active) {
          context = this.createContext();
        } else {
          context = this.active;
        }
      }
      let self2 = this;
      return function clsBind() {
        self2.enter(context);
        try {
          return fn.apply(this, arguments);
        } catch (exception) {
          if (exception) {
            exception[ERROR_SYMBOL] = context;
          }
          throw exception;
        } finally {
          self2.exit(context);
        }
      };
    };
    Namespace.prototype.enter = function enter(context) {
      assert.ok(context, "context must be provided for entering");
      if (DEBUG_CLS_HOOKED) {
        const asyncHooksCurrentId = async_hooks.executionAsyncId();
        const triggerId = async_hooks.triggerAsyncId();
        const indentStr = " ".repeat(this._indent < 0 ? 0 : this._indent);
        debug2(`${indentStr}CONTEXT-ENTER: (${this.name}) currentUid:${currentUid} triggerId:${triggerId} asyncHooksCurrentId:${asyncHooksCurrentId} len:${this._set.length} ${util.inspect(context)}`);
      }
      this._set.push(this.active);
      this.active = context;
    };
    Namespace.prototype.exit = function exit(context) {
      assert.ok(context, "context must be provided for exiting");
      if (DEBUG_CLS_HOOKED) {
        const asyncHooksCurrentId = async_hooks.executionAsyncId();
        const triggerId = async_hooks.triggerAsyncId();
        const indentStr = " ".repeat(this._indent < 0 ? 0 : this._indent);
        debug2(`${indentStr}CONTEXT-EXIT: (${this.name}) currentUid:${currentUid} triggerId:${triggerId} asyncHooksCurrentId:${asyncHooksCurrentId} len:${this._set.length} ${util.inspect(context)}`);
      }
      if (this.active === context) {
        assert.ok(this._set.length, "can't remove top context");
        this.active = this._set.pop();
        return;
      }
      let index = this._set.lastIndexOf(context);
      if (index < 0) {
        if (DEBUG_CLS_HOOKED) {
          debug2("??ERROR?? context exiting but not entered - ignoring: " + util.inspect(context));
        }
        assert.ok(index >= 0, "context not currently entered; can't exit. \n" + util.inspect(this) + "\n" + util.inspect(context));
      } else {
        assert.ok(index, "can't remove top context");
        this._set.splice(index, 1);
      }
    };
    Namespace.prototype.bindEmitter = function bindEmitter(emitter) {
      assert.ok(emitter.on && emitter.addListener && emitter.emit, "can only bind real EEs");
      let namespace = this;
      let thisSymbol = "context@" + this.name;
      function attach(listener) {
        if (!listener) {
          return;
        }
        if (!listener[CONTEXTS_SYMBOL]) {
          listener[CONTEXTS_SYMBOL] = /* @__PURE__ */ Object.create(null);
        }
        listener[CONTEXTS_SYMBOL][thisSymbol] = {
          namespace,
          context: namespace.active
        };
      }
      function bind(unwrapped) {
        if (!(unwrapped && unwrapped[CONTEXTS_SYMBOL])) {
          return unwrapped;
        }
        let wrapped = unwrapped;
        let unwrappedContexts = unwrapped[CONTEXTS_SYMBOL];
        Object.keys(unwrappedContexts).forEach(function(name) {
          let thunk = unwrappedContexts[name];
          wrapped = thunk.namespace.bind(wrapped, thunk.context);
        });
        return wrapped;
      }
      wrapEmitter(emitter, attach, bind);
    };
    Namespace.prototype.fromException = function fromException(exception) {
      return exception[ERROR_SYMBOL];
    };
    function getNamespace(name) {
      return process.namespaces[name];
    }
    function createNamespace(name) {
      assert.ok(name, "namespace must be given a name.");
      if (DEBUG_CLS_HOOKED) {
        debug2(`NS-CREATING NAMESPACE (${name})`);
      }
      let namespace = new Namespace(name);
      namespace.id = currentUid;
      const hook = async_hooks.createHook({
        init(asyncId, type, triggerId, resource) {
          currentUid = async_hooks.executionAsyncId();
          if (namespace.active) {
            namespace._contexts.set(asyncId, namespace.active);
            if (DEBUG_CLS_HOOKED) {
              const indentStr = " ".repeat(namespace._indent < 0 ? 0 : namespace._indent);
              debug2(`${indentStr}INIT [${type}] (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, { showHidden: true, depth: 2, colors: true })} resource:${resource}`);
            }
          } else if (currentUid === 0) {
            const triggerId2 = async_hooks.triggerAsyncId();
            const triggerIdContext = namespace._contexts.get(triggerId2);
            if (triggerIdContext) {
              namespace._contexts.set(asyncId, triggerIdContext);
              if (DEBUG_CLS_HOOKED) {
                const indentStr = " ".repeat(namespace._indent < 0 ? 0 : namespace._indent);
                debug2(`${indentStr}INIT USING CONTEXT FROM TRIGGERID [${type}] (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId2} active:${util.inspect(namespace.active, { showHidden: true, depth: 2, colors: true })} resource:${resource}`);
              }
            } else if (DEBUG_CLS_HOOKED) {
              const indentStr = " ".repeat(namespace._indent < 0 ? 0 : namespace._indent);
              debug2(`${indentStr}INIT MISSING CONTEXT [${type}] (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId2} active:${util.inspect(namespace.active, { showHidden: true, depth: 2, colors: true })} resource:${resource}`);
            }
          }
          if (DEBUG_CLS_HOOKED && type === "PROMISE") {
            debug2(util.inspect(resource, { showHidden: true }));
            const parentId = resource.parentId;
            const indentStr = " ".repeat(namespace._indent < 0 ? 0 : namespace._indent);
            debug2(`${indentStr}INIT RESOURCE-PROMISE [${type}] (${name}) parentId:${parentId} asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, { showHidden: true, depth: 2, colors: true })} resource:${resource}`);
          }
        },
        before(asyncId) {
          currentUid = async_hooks.executionAsyncId();
          let context;
          context = namespace._contexts.get(asyncId) || namespace._contexts.get(currentUid);
          if (context) {
            if (DEBUG_CLS_HOOKED) {
              const triggerId = async_hooks.triggerAsyncId();
              const indentStr = " ".repeat(namespace._indent < 0 ? 0 : namespace._indent);
              debug2(`${indentStr}BEFORE (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, { showHidden: true, depth: 2, colors: true })} context:${util.inspect(context)}`);
              namespace._indent += 2;
            }
            namespace.enter(context);
          } else if (DEBUG_CLS_HOOKED) {
            const triggerId = async_hooks.triggerAsyncId();
            const indentStr = " ".repeat(namespace._indent < 0 ? 0 : namespace._indent);
            debug2(`${indentStr}BEFORE MISSING CONTEXT (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, { showHidden: true, depth: 2, colors: true })} namespace._contexts:${util.inspect(namespace._contexts, { showHidden: true, depth: 2, colors: true })}`);
            namespace._indent += 2;
          }
        },
        after(asyncId) {
          currentUid = async_hooks.executionAsyncId();
          let context;
          context = namespace._contexts.get(asyncId) || namespace._contexts.get(currentUid);
          if (context) {
            if (DEBUG_CLS_HOOKED) {
              const triggerId = async_hooks.triggerAsyncId();
              namespace._indent -= 2;
              const indentStr = " ".repeat(namespace._indent < 0 ? 0 : namespace._indent);
              debug2(`${indentStr}AFTER (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, { showHidden: true, depth: 2, colors: true })} context:${util.inspect(context)}`);
            }
            namespace.exit(context);
          } else if (DEBUG_CLS_HOOKED) {
            const triggerId = async_hooks.triggerAsyncId();
            namespace._indent -= 2;
            const indentStr = " ".repeat(namespace._indent < 0 ? 0 : namespace._indent);
            debug2(`${indentStr}AFTER MISSING CONTEXT (${name}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, { showHidden: true, depth: 2, colors: true })} context:${util.inspect(context)}`);
          }
        },
        destroy(asyncId) {
          currentUid = async_hooks.executionAsyncId();
          if (DEBUG_CLS_HOOKED) {
            const triggerId = async_hooks.triggerAsyncId();
            const indentStr = " ".repeat(namespace._indent < 0 ? 0 : namespace._indent);
            debug2(`${indentStr}DESTROY (${name}) currentUid:${currentUid} asyncId:${asyncId} triggerId:${triggerId} active:${util.inspect(namespace.active, { showHidden: true, depth: 2, colors: true })} context:${util.inspect(namespace._contexts.get(currentUid))}`);
          }
          namespace._contexts.delete(asyncId);
        }
      });
      hook.enable();
      process.namespaces[name] = namespace;
      return namespace;
    }
    function destroyNamespace(name) {
      let namespace = getNamespace(name);
      assert.ok(namespace, `can't delete nonexistent namespace! "` + name + '"');
      assert.ok(namespace.id, "don't assign to process.namespaces directly! " + util.inspect(namespace));
      process.namespaces[name] = null;
    }
    function reset() {
      if (process.namespaces) {
        Object.keys(process.namespaces).forEach(function(name) {
          destroyNamespace(name);
        });
      }
      process.namespaces = /* @__PURE__ */ Object.create(null);
    }
    process.namespaces = {};
    function debug2(...args) {
      if (DEBUG_CLS_HOOKED) {
        process._rawDebug(`${util.format(...args)}`);
      }
    }
  }
});

// ../../node_modules/async-hook-jl/patches/next-tick.js
var require_next_tick = __commonJS({
  "../../node_modules/async-hook-jl/patches/next-tick.js"(exports2, module2) {
    "use strict";
    function NextTickWrap() {
    }
    module2.exports = function patch() {
      const hooks = this._hooks;
      const state = this._state;
      const oldNextTick = process.nextTick;
      process.nextTick = function() {
        if (!state.enabled)
          return oldNextTick.apply(process, arguments);
        const args = new Array(arguments.length);
        for (let i = 0; i < arguments.length; i++) {
          args[i] = arguments[i];
        }
        const callback = args[0];
        if (typeof callback !== "function") {
          throw new TypeError("callback is not a function");
        }
        const handle3 = new NextTickWrap();
        const uid = --state.counter;
        hooks.init.call(handle3, uid, 0, null, null);
        args[0] = function() {
          hooks.pre.call(handle3, uid);
          let didThrow = true;
          try {
            callback.apply(this, arguments);
            didThrow = false;
          } finally {
            if (didThrow && process.listenerCount("uncaughtException") > 0) {
              process.once("uncaughtException", function() {
                hooks.post.call(handle3, uid, true);
                hooks.destroy.call(null, uid);
              });
            }
          }
          hooks.post.call(handle3, uid, false);
          hooks.destroy.call(null, uid);
        };
        return oldNextTick.apply(process, args);
      };
    };
  }
});

// ../../node_modules/async-hook-jl/patches/promise.js
var require_promise2 = __commonJS({
  "../../node_modules/async-hook-jl/patches/promise.js"(exports2, module2) {
    "use strict";
    function PromiseWrap() {
    }
    module2.exports = function patchPromise() {
      const hooks = this._hooks;
      const state = this._state;
      const Promise2 = global.Promise;
      const oldThen = Promise2.prototype.then;
      Promise2.prototype.then = wrappedThen;
      function makeWrappedHandler(fn, handle3, uid, isOnFulfilled) {
        if ("function" !== typeof fn) {
          return isOnFulfilled ? makeUnhandledResolutionHandler(uid) : makeUnhandledRejectionHandler(uid);
        }
        return function wrappedHandler() {
          hooks.pre.call(handle3, uid);
          try {
            return fn.apply(this, arguments);
          } finally {
            hooks.post.call(handle3, uid, false);
            hooks.destroy.call(null, uid);
          }
        };
      }
      function makeUnhandledResolutionHandler(uid) {
        return function unhandledResolutionHandler(val) {
          hooks.destroy.call(null, uid);
          return val;
        };
      }
      function makeUnhandledRejectionHandler(uid) {
        return function unhandledRejectedHandler(val) {
          hooks.destroy.call(null, uid);
          throw val;
        };
      }
      function wrappedThen(onFulfilled, onRejected) {
        if (!state.enabled)
          return oldThen.call(this, onFulfilled, onRejected);
        const handle3 = new PromiseWrap();
        const uid = --state.counter;
        hooks.init.call(handle3, uid, 0, null, null);
        return oldThen.call(this, makeWrappedHandler(onFulfilled, handle3, uid, true), makeWrappedHandler(onRejected, handle3, uid, false));
      }
    };
  }
});

// ../../node_modules/async-hook-jl/patches/timers.js
var require_timers = __commonJS({
  "../../node_modules/async-hook-jl/patches/timers.js"(exports2, module2) {
    "use strict";
    var timers = require("timers");
    function TimeoutWrap() {
    }
    function IntervalWrap() {
    }
    function ImmediateWrap() {
    }
    var timeoutMap = /* @__PURE__ */ new Map();
    var intervalMap = /* @__PURE__ */ new Map();
    var ImmediateMap = /* @__PURE__ */ new Map();
    var activeCallback = null;
    var clearedInCallback = false;
    module2.exports = function patch() {
      patchTimer(this._hooks, this._state, "setTimeout", "clearTimeout", TimeoutWrap, timeoutMap, true);
      patchTimer(this._hooks, this._state, "setInterval", "clearInterval", IntervalWrap, intervalMap, false);
      patchTimer(this._hooks, this._state, "setImmediate", "clearImmediate", ImmediateWrap, ImmediateMap, true);
      global.setTimeout = timers.setTimeout;
      global.setInterval = timers.setInterval;
      global.setImmediate = timers.setImmediate;
      global.clearTimeout = timers.clearTimeout;
      global.clearInterval = timers.clearInterval;
      global.clearImmediate = timers.clearImmediate;
    };
    function patchTimer(hooks, state, setFn, clearFn, Handle, timerMap, singleCall) {
      const oldSetFn = timers[setFn];
      const oldClearFn = timers[clearFn];
      timers[setFn] = function() {
        if (!state.enabled)
          return oldSetFn.apply(timers, arguments);
        const args = new Array(arguments.length);
        for (let i = 0; i < arguments.length; i++) {
          args[i] = arguments[i];
        }
        const callback = args[0];
        if (typeof callback !== "function") {
          throw new TypeError('"callback" argument must be a function');
        }
        const handle3 = new Handle();
        const uid = --state.counter;
        let timerId = void 0;
        hooks.init.call(handle3, uid, 0, null, null);
        args[0] = function() {
          activeCallback = timerId;
          hooks.pre.call(handle3, uid);
          let didThrow = true;
          try {
            callback.apply(this, arguments);
            didThrow = false;
          } finally {
            if (didThrow && process.listenerCount("uncaughtException") > 0) {
              process.once("uncaughtException", function() {
                hooks.post.call(handle3, uid, true);
                timerMap.delete(timerId);
                hooks.destroy.call(null, uid);
              });
            }
          }
          hooks.post.call(handle3, uid, false);
          activeCallback = null;
          if (singleCall || clearedInCallback) {
            clearedInCallback = false;
            timerMap.delete(timerId);
            hooks.destroy.call(null, uid);
          }
        };
        timerId = oldSetFn.apply(timers, args);
        timerMap.set(timerId, uid);
        return timerId;
      };
      timers[clearFn] = function(timerId) {
        if (activeCallback === timerId && timerId !== null) {
          clearedInCallback = true;
        } else if (timerMap.has(timerId)) {
          const uid = timerMap.get(timerId);
          timerMap.delete(timerId);
          hooks.destroy.call(null, uid);
        }
        oldClearFn.apply(timers, arguments);
      };
    }
  }
});

// ../../node_modules/async-hook-jl/package.json
var require_package2 = __commonJS({
  "../../node_modules/async-hook-jl/package.json"(exports2, module2) {
    module2.exports = {
      name: "async-hook-jl",
      description: "Inspect the life of handle objects in node",
      version: "1.7.6",
      author: "Andreas Madsen <amwebdk@gmail.com>",
      main: "./index.js",
      scripts: {
        test: "node ./test/runner.js && eslint ."
      },
      repository: {
        type: "git",
        url: "git://github.com/jeff-lewis/async-hook-jl.git"
      },
      keywords: [
        "async",
        "async hooks",
        "inspect",
        "async wrap"
      ],
      license: "MIT",
      dependencies: {
        "stack-chain": "^1.3.7"
      },
      devDependencies: {
        async: "1.5.x",
        "cli-color": "1.1.x",
        eslint: "^3.4.0",
        endpoint: "0.4.x"
      },
      engines: {
        node: "^4.7 || >=6.9 || >=7.3"
      }
    };
  }
});

// ../../node_modules/async-hook-jl/async-hook.js
var require_async_hook = __commonJS({
  "../../node_modules/async-hook-jl/async-hook.js"(exports2, module2) {
    "use strict";
    var asyncWrap = process.binding("async_wrap");
    var TIMERWRAP = asyncWrap.Providers.TIMERWRAP;
    var patchs = {
      "nextTick": require_next_tick(),
      "promise": require_promise2(),
      "timers": require_timers()
    };
    var ignoreUIDs = /* @__PURE__ */ new Set();
    function State() {
      this.enabled = false;
      this.counter = 0;
    }
    function Hooks() {
      const initFns = this.initFns = [];
      const preFns = this.preFns = [];
      const postFns = this.postFns = [];
      const destroyFns = this.destroyFns = [];
      this.init = function(uid, provider, parentUid, parentHandle) {
        if (provider === TIMERWRAP) {
          ignoreUIDs.add(uid);
          return;
        }
        for (const hook of initFns) {
          hook(uid, this, provider, parentUid, parentHandle);
        }
      };
      this.pre = function(uid) {
        if (ignoreUIDs.has(uid))
          return;
        for (const hook of preFns) {
          hook(uid, this);
        }
      };
      this.post = function(uid, didThrow) {
        if (ignoreUIDs.has(uid))
          return;
        for (const hook of postFns) {
          hook(uid, this, didThrow);
        }
      };
      this.destroy = function(uid) {
        if (ignoreUIDs.has(uid)) {
          ignoreUIDs.delete(uid);
          return;
        }
        for (const hook of destroyFns) {
          hook(uid);
        }
      };
    }
    Hooks.prototype.add = function(hooks) {
      if (hooks.init)
        this.initFns.push(hooks.init);
      if (hooks.pre)
        this.preFns.push(hooks.pre);
      if (hooks.post)
        this.postFns.push(hooks.post);
      if (hooks.destroy)
        this.destroyFns.push(hooks.destroy);
    };
    function removeElement(array, item) {
      const index = array.indexOf(item);
      if (index === -1)
        return;
      array.splice(index, 1);
    }
    Hooks.prototype.remove = function(hooks) {
      if (hooks.init)
        removeElement(this.initFns, hooks.init);
      if (hooks.pre)
        removeElement(this.preFns, hooks.pre);
      if (hooks.post)
        removeElement(this.postFns, hooks.post);
      if (hooks.destroy)
        removeElement(this.destroyFns, hooks.destroy);
    };
    function AsyncHook() {
      this._state = new State();
      this._hooks = new Hooks();
      this.version = require_package2().version;
      this.providers = asyncWrap.Providers;
      for (const key of Object.keys(patchs)) {
        patchs[key].call(this);
      }
      if (process.env.hasOwnProperty("NODE_ASYNC_HOOK_WARNING")) {
        console.warn("warning: you are using async-hook-jl which is unstable.");
      }
      asyncWrap.setupHooks({
        init: this._hooks.init,
        pre: this._hooks.pre,
        post: this._hooks.post,
        destroy: this._hooks.destroy
      });
    }
    module2.exports = AsyncHook;
    AsyncHook.prototype.addHooks = function(hooks) {
      this._hooks.add(hooks);
    };
    AsyncHook.prototype.removeHooks = function(hooks) {
      this._hooks.remove(hooks);
    };
    AsyncHook.prototype.enable = function() {
      this._state.enabled = true;
      asyncWrap.enable();
    };
    AsyncHook.prototype.disable = function() {
      this._state.enabled = false;
      asyncWrap.disable();
    };
  }
});

// ../../node_modules/stack-chain/package.json
var require_package3 = __commonJS({
  "../../node_modules/stack-chain/package.json"(exports2, module2) {
    module2.exports = {
      name: "stack-chain",
      description: "API for combining call site modifiers",
      version: "1.3.7",
      author: "Andreas Madsen <amwebdk@gmail.com>",
      scripts: {
        test: "tap ./test/simple"
      },
      repository: {
        type: "git",
        url: "git://github.com/AndreasMadsen/stack-chain.git"
      },
      keywords: [
        "stack",
        "chain",
        "trace",
        "call site",
        "concat",
        "format"
      ],
      devDependencies: {
        tap: "2.x.x",
        "uglify-js": "2.5.x"
      },
      license: "MIT"
    };
  }
});

// ../../node_modules/stack-chain/format.js
var require_format = __commonJS({
  "../../node_modules/stack-chain/format.js"(exports2, module2) {
    function FormatErrorString(error3) {
      try {
        return Error.prototype.toString.call(error3);
      } catch (e) {
        try {
          return "<error: " + e + ">";
        } catch (ee) {
          return "<error>";
        }
      }
    }
    module2.exports = function FormatStackTrace(error3, frames) {
      var lines = [];
      lines.push(FormatErrorString(error3));
      for (var i = 0; i < frames.length; i++) {
        var frame = frames[i];
        var line;
        try {
          line = frame.toString();
        } catch (e) {
          try {
            line = "<error: " + e + ">";
          } catch (ee) {
            line = "<error>";
          }
        }
        lines.push("    at " + line);
      }
      return lines.join("\n");
    };
  }
});

// ../../node_modules/stack-chain/stack-chain.js
var require_stack_chain = __commonJS({
  "../../node_modules/stack-chain/stack-chain.js"(exports2, module2) {
    var defaultFormater = require_format();
    function stackChain() {
      this.extend = new TraceModifier();
      this.filter = new TraceModifier();
      this.format = new StackFormater();
      this.version = require_package3().version;
    }
    var SHORTCIRCUIT_CALLSITE = false;
    stackChain.prototype.callSite = function collectCallSites(options2) {
      if (!options2)
        options2 = {};
      SHORTCIRCUIT_CALLSITE = true;
      var obj = {};
      Error.captureStackTrace(obj, collectCallSites);
      var callSites = obj.stack;
      SHORTCIRCUIT_CALLSITE = false;
      callSites = callSites.slice(options2.slice || 0);
      if (options2.extend)
        callSites = this.extend._modify(obj, callSites);
      if (options2.filter)
        callSites = this.filter._modify(obj, callSites);
      return callSites;
    };
    var chain = new stackChain();
    function TraceModifier() {
      this._modifiers = [];
    }
    TraceModifier.prototype._modify = function(error3, frames) {
      for (var i = 0, l = this._modifiers.length; i < l; i++) {
        frames = this._modifiers[i](error3, frames);
      }
      return frames;
    };
    TraceModifier.prototype.attach = function(modifier) {
      this._modifiers.push(modifier);
    };
    TraceModifier.prototype.deattach = function(modifier) {
      var index = this._modifiers.indexOf(modifier);
      if (index === -1)
        return false;
      this._modifiers.splice(index, 1);
      return true;
    };
    function StackFormater() {
      this._formater = defaultFormater;
      this._previous = void 0;
    }
    StackFormater.prototype.replace = function(formater) {
      if (formater) {
        this._formater = formater;
      } else {
        this.restore();
      }
    };
    StackFormater.prototype.restore = function() {
      this._formater = defaultFormater;
      this._previous = void 0;
    };
    StackFormater.prototype._backup = function() {
      this._previous = this._formater;
    };
    StackFormater.prototype._roolback = function() {
      if (this._previous === defaultFormater) {
        this.replace(void 0);
      } else {
        this.replace(this._previous);
      }
      this._previous = void 0;
    };
    if (Error.prepareStackTrace) {
      chain.format.replace(Error.prepareStackTrace);
    }
    var SHORTCIRCUIT_FORMATER = false;
    function prepareStackTrace(error3, originalFrames) {
      if (SHORTCIRCUIT_CALLSITE)
        return originalFrames;
      if (SHORTCIRCUIT_FORMATER)
        return defaultFormater(error3, originalFrames);
      var frames = originalFrames.concat();
      frames = chain.extend._modify(error3, frames);
      frames = chain.filter._modify(error3, frames);
      frames = frames.slice(0, Error.stackTraceLimit);
      if (Object.isExtensible(error3) && Object.getOwnPropertyDescriptor(error3, "callSite") === void 0) {
        error3.callSite = {
          original: originalFrames,
          mutated: frames
        };
      }
      SHORTCIRCUIT_FORMATER = true;
      var format2 = chain.format._formater(error3, frames);
      SHORTCIRCUIT_FORMATER = false;
      return format2;
    }
    Object.defineProperty(Error, "prepareStackTrace", {
      "get": function() {
        return prepareStackTrace;
      },
      "set": function(formater) {
        if (formater === prepareStackTrace) {
          chain.format._roolback();
        } else {
          chain.format._backup();
          chain.format.replace(formater);
        }
      }
    });
    function callSiteGetter() {
      this.stack;
      return this.callSite;
    }
    Object.defineProperty(Error.prototype, "callSite", {
      "get": callSiteGetter,
      "set": function(frames) {
        Object.defineProperty(this, "callSite", {
          value: frames,
          writable: true,
          configurable: true
        });
      },
      configurable: true
    });
    module2.exports = chain;
  }
});

// ../../node_modules/stack-chain/index.js
var require_stack_chain2 = __commonJS({
  "../../node_modules/stack-chain/index.js"(exports2, module2) {
    if (global._stackChain) {
      if (global._stackChain.version === require_package3().version) {
        module2.exports = global._stackChain;
      } else {
        throw new Error("Conflicting version of stack-chain found");
      }
    } else {
      module2.exports = global._stackChain = require_stack_chain();
    }
  }
});

// ../../node_modules/async-hook-jl/index.js
var require_async_hook_jl = __commonJS({
  "../../node_modules/async-hook-jl/index.js"(exports2, module2) {
    "use strict";
    var AsyncHook = require_async_hook();
    if (global._asyncHook) {
      if (global._asyncHook.version === require_package2().version) {
        module2.exports = global._asyncHook;
      } else {
        throw new Error("Conflicting version of async-hook-jl found");
      }
    } else {
      const stackChain = require_stack_chain2();
      stackChain.filter.attach(function(error3, frames) {
        return frames.filter(function(callSite) {
          const filename = callSite.getFileName();
          return !(filename && filename.slice(0, __dirname.length) === __dirname);
        });
      });
      module2.exports = global._asyncHook = new AsyncHook();
    }
  }
});

// ../../node_modules/cls-hooked/context-legacy.js
var require_context_legacy = __commonJS({
  "../../node_modules/cls-hooked/context-legacy.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var assert = require("assert");
    var wrapEmitter = require_listener();
    var asyncHook = require_async_hook_jl();
    var CONTEXTS_SYMBOL = "cls@contexts";
    var ERROR_SYMBOL = "error@context";
    var invertedProviders = [];
    for (let key in asyncHook.providers) {
      invertedProviders[asyncHook.providers[key]] = key;
    }
    var DEBUG_CLS_HOOKED = process.env.DEBUG_CLS_HOOKED;
    var currentUid = -1;
    module2.exports = {
      getNamespace,
      createNamespace,
      destroyNamespace,
      reset,
      ERROR_SYMBOL
    };
    function Namespace(name) {
      this.name = name;
      this.active = null;
      this._set = [];
      this.id = null;
      this._contexts = /* @__PURE__ */ new Map();
    }
    Namespace.prototype.set = function set(key, value) {
      if (!this.active) {
        throw new Error("No context available. ns.run() or ns.bind() must be called first.");
      }
      if (DEBUG_CLS_HOOKED) {
        debug2("    SETTING KEY:" + key + "=" + value + " in ns:" + this.name + " uid:" + currentUid + " active:" + util.inspect(this.active, true));
      }
      this.active[key] = value;
      return value;
    };
    Namespace.prototype.get = function get3(key) {
      if (!this.active) {
        if (DEBUG_CLS_HOOKED) {
          debug2("    GETTING KEY:" + key + "=undefined " + this.name + " uid:" + currentUid + " active:" + util.inspect(this.active, true));
        }
        return void 0;
      }
      if (DEBUG_CLS_HOOKED) {
        debug2("    GETTING KEY:" + key + "=" + this.active[key] + " " + this.name + " uid:" + currentUid + " active:" + util.inspect(this.active, true));
      }
      return this.active[key];
    };
    Namespace.prototype.createContext = function createContext() {
      if (DEBUG_CLS_HOOKED) {
        debug2("   CREATING Context: " + this.name + " uid:" + currentUid + " len:" + this._set.length + "  active:" + util.inspect(this.active, true, 2, true));
      }
      let context = Object.create(this.active ? this.active : Object.prototype);
      context._ns_name = this.name;
      context.id = currentUid;
      if (DEBUG_CLS_HOOKED) {
        debug2("   CREATED Context: " + this.name + " uid:" + currentUid + " len:" + this._set.length + "  context:" + util.inspect(context, true, 2, true));
      }
      return context;
    };
    Namespace.prototype.run = function run(fn) {
      let context = this.createContext();
      this.enter(context);
      try {
        if (DEBUG_CLS_HOOKED) {
          debug2(" BEFORE RUN: " + this.name + " uid:" + currentUid + " len:" + this._set.length + " " + util.inspect(context));
        }
        fn(context);
        return context;
      } catch (exception) {
        if (exception) {
          exception[ERROR_SYMBOL] = context;
        }
        throw exception;
      } finally {
        if (DEBUG_CLS_HOOKED) {
          debug2(" AFTER RUN: " + this.name + " uid:" + currentUid + " len:" + this._set.length + " " + util.inspect(context));
        }
        this.exit(context);
      }
    };
    Namespace.prototype.runAndReturn = function runAndReturn(fn) {
      var value;
      this.run(function(context) {
        value = fn(context);
      });
      return value;
    };
    Namespace.prototype.runPromise = function runPromise(fn) {
      let context = this.createContext();
      this.enter(context);
      let promise = fn(context);
      if (!promise || !promise.then || !promise.catch) {
        throw new Error("fn must return a promise.");
      }
      if (DEBUG_CLS_HOOKED) {
        debug2(" BEFORE runPromise: " + this.name + " uid:" + currentUid + " len:" + this._set.length + " " + util.inspect(context));
      }
      return promise.then((result2) => {
        if (DEBUG_CLS_HOOKED) {
          debug2(" AFTER runPromise: " + this.name + " uid:" + currentUid + " len:" + this._set.length + " " + util.inspect(context));
        }
        this.exit(context);
        return result2;
      }).catch((err) => {
        err[ERROR_SYMBOL] = context;
        if (DEBUG_CLS_HOOKED) {
          debug2(" AFTER runPromise: " + this.name + " uid:" + currentUid + " len:" + this._set.length + " " + util.inspect(context));
        }
        this.exit(context);
        throw err;
      });
    };
    Namespace.prototype.bind = function bindFactory(fn, context) {
      if (!context) {
        if (!this.active) {
          context = this.createContext();
        } else {
          context = this.active;
        }
      }
      let self2 = this;
      return function clsBind() {
        self2.enter(context);
        try {
          return fn.apply(this, arguments);
        } catch (exception) {
          if (exception) {
            exception[ERROR_SYMBOL] = context;
          }
          throw exception;
        } finally {
          self2.exit(context);
        }
      };
    };
    Namespace.prototype.enter = function enter(context) {
      assert.ok(context, "context must be provided for entering");
      if (DEBUG_CLS_HOOKED) {
        debug2("  ENTER " + this.name + " uid:" + currentUid + " len:" + this._set.length + " context: " + util.inspect(context));
      }
      this._set.push(this.active);
      this.active = context;
    };
    Namespace.prototype.exit = function exit(context) {
      assert.ok(context, "context must be provided for exiting");
      if (DEBUG_CLS_HOOKED) {
        debug2("  EXIT " + this.name + " uid:" + currentUid + " len:" + this._set.length + " context: " + util.inspect(context));
      }
      if (this.active === context) {
        assert.ok(this._set.length, "can't remove top context");
        this.active = this._set.pop();
        return;
      }
      let index = this._set.lastIndexOf(context);
      if (index < 0) {
        if (DEBUG_CLS_HOOKED) {
          debug2("??ERROR?? context exiting but not entered - ignoring: " + util.inspect(context));
        }
        assert.ok(index >= 0, "context not currently entered; can't exit. \n" + util.inspect(this) + "\n" + util.inspect(context));
      } else {
        assert.ok(index, "can't remove top context");
        this._set.splice(index, 1);
      }
    };
    Namespace.prototype.bindEmitter = function bindEmitter(emitter) {
      assert.ok(emitter.on && emitter.addListener && emitter.emit, "can only bind real EEs");
      let namespace = this;
      let thisSymbol = "context@" + this.name;
      function attach(listener) {
        if (!listener) {
          return;
        }
        if (!listener[CONTEXTS_SYMBOL]) {
          listener[CONTEXTS_SYMBOL] = /* @__PURE__ */ Object.create(null);
        }
        listener[CONTEXTS_SYMBOL][thisSymbol] = {
          namespace,
          context: namespace.active
        };
      }
      function bind(unwrapped) {
        if (!(unwrapped && unwrapped[CONTEXTS_SYMBOL])) {
          return unwrapped;
        }
        let wrapped = unwrapped;
        let unwrappedContexts = unwrapped[CONTEXTS_SYMBOL];
        Object.keys(unwrappedContexts).forEach(function(name) {
          let thunk = unwrappedContexts[name];
          wrapped = thunk.namespace.bind(wrapped, thunk.context);
        });
        return wrapped;
      }
      wrapEmitter(emitter, attach, bind);
    };
    Namespace.prototype.fromException = function fromException(exception) {
      return exception[ERROR_SYMBOL];
    };
    function getNamespace(name) {
      return process.namespaces[name];
    }
    function createNamespace(name) {
      assert.ok(name, "namespace must be given a name.");
      if (DEBUG_CLS_HOOKED) {
        debug2("CREATING NAMESPACE " + name);
      }
      let namespace = new Namespace(name);
      namespace.id = currentUid;
      asyncHook.addHooks({
        init(uid, handle3, provider, parentUid, parentHandle) {
          currentUid = uid;
          if (parentUid) {
            namespace._contexts.set(uid, namespace._contexts.get(parentUid));
            if (DEBUG_CLS_HOOKED) {
              debug2("PARENTID: " + name + " uid:" + uid + " parent:" + parentUid + " provider:" + provider);
            }
          } else {
            namespace._contexts.set(currentUid, namespace.active);
          }
          if (DEBUG_CLS_HOOKED) {
            debug2("INIT " + name + " uid:" + uid + " parent:" + parentUid + " provider:" + invertedProviders[provider] + " active:" + util.inspect(namespace.active, true));
          }
        },
        pre(uid, handle3) {
          currentUid = uid;
          let context = namespace._contexts.get(uid);
          if (context) {
            if (DEBUG_CLS_HOOKED) {
              debug2(" PRE " + name + " uid:" + uid + " handle:" + getFunctionName(handle3) + " context:" + util.inspect(context));
            }
            namespace.enter(context);
          } else {
            if (DEBUG_CLS_HOOKED) {
              debug2(" PRE MISSING CONTEXT " + name + " uid:" + uid + " handle:" + getFunctionName(handle3));
            }
          }
        },
        post(uid, handle3) {
          currentUid = uid;
          let context = namespace._contexts.get(uid);
          if (context) {
            if (DEBUG_CLS_HOOKED) {
              debug2(" POST " + name + " uid:" + uid + " handle:" + getFunctionName(handle3) + " context:" + util.inspect(context));
            }
            namespace.exit(context);
          } else {
            if (DEBUG_CLS_HOOKED) {
              debug2(" POST MISSING CONTEXT " + name + " uid:" + uid + " handle:" + getFunctionName(handle3));
            }
          }
        },
        destroy(uid) {
          currentUid = uid;
          if (DEBUG_CLS_HOOKED) {
            debug2("DESTROY " + name + " uid:" + uid + " context:" + util.inspect(namespace._contexts.get(currentUid)) + " active:" + util.inspect(namespace.active, true));
          }
          namespace._contexts.delete(uid);
        }
      });
      process.namespaces[name] = namespace;
      return namespace;
    }
    function destroyNamespace(name) {
      let namespace = getNamespace(name);
      assert.ok(namespace, `can't delete nonexistent namespace! "` + name + '"');
      assert.ok(namespace.id, "don't assign to process.namespaces directly! " + util.inspect(namespace));
      process.namespaces[name] = null;
    }
    function reset() {
      if (process.namespaces) {
        Object.keys(process.namespaces).forEach(function(name) {
          destroyNamespace(name);
        });
      }
      process.namespaces = /* @__PURE__ */ Object.create(null);
    }
    process.namespaces = {};
    if (asyncHook._state && !asyncHook._state.enabled) {
      asyncHook.enable();
    }
    function debug2(msg) {
      if (process.env.DEBUG) {
        process._rawDebug(msg);
      }
    }
    function getFunctionName(fn) {
      if (!fn) {
        return fn;
      }
      if (typeof fn === "function") {
        if (fn.name) {
          return fn.name;
        }
        return (fn.toString().trim().match(/^function\s*([^\s(]+)/) || [])[1];
      } else if (fn.constructor && fn.constructor.name) {
        return fn.constructor.name;
      }
    }
    if (DEBUG_CLS_HOOKED) {
      stackChain = require_stack_chain2();
      for (modifier in stackChain.filter._modifiers) {
        stackChain.filter.deattach(modifier);
      }
    }
    var stackChain;
    var modifier;
  }
});

// ../../node_modules/cls-hooked/index.js
var require_cls_hooked = __commonJS({
  "../../node_modules/cls-hooked/index.js"(exports2, module2) {
    "use strict";
    var semver = require_semver2();
    if (process && semver.gte(process.versions.node, "8.0.0")) {
      module2.exports = require_context();
    } else {
      module2.exports = require_context_legacy();
    }
  }
});

// ../../node_modules/async-listener/node_modules/semver/semver.js
var require_semver3 = __commonJS({
  "../../node_modules/async-listener/node_modules/semver/semver.js"(exports2, module2) {
    exports2 = module2.exports = SemVer;
    var debug;
    if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
      debug = function() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift("SEMVER");
        console.log.apply(console, args);
      };
    } else {
      debug = function() {
      };
    }
    exports2.SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var re = exports2.re = [];
    var src = exports2.src = [];
    var R = 0;
    var NUMERICIDENTIFIER = R++;
    src[NUMERICIDENTIFIER] = "0|[1-9]\\d*";
    var NUMERICIDENTIFIERLOOSE = R++;
    src[NUMERICIDENTIFIERLOOSE] = "[0-9]+";
    var NONNUMERICIDENTIFIER = R++;
    src[NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
    var MAINVERSION = R++;
    src[MAINVERSION] = "(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")";
    var MAINVERSIONLOOSE = R++;
    src[MAINVERSIONLOOSE] = "(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")";
    var PRERELEASEIDENTIFIER = R++;
    src[PRERELEASEIDENTIFIER] = "(?:" + src[NUMERICIDENTIFIER] + "|" + src[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASEIDENTIFIERLOOSE = R++;
    src[PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[NUMERICIDENTIFIERLOOSE] + "|" + src[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASE = R++;
    src[PRERELEASE] = "(?:-(" + src[PRERELEASEIDENTIFIER] + "(?:\\." + src[PRERELEASEIDENTIFIER] + ")*))";
    var PRERELEASELOOSE = R++;
    src[PRERELEASELOOSE] = "(?:-?(" + src[PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[PRERELEASEIDENTIFIERLOOSE] + ")*))";
    var BUILDIDENTIFIER = R++;
    src[BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
    var BUILD = R++;
    src[BUILD] = "(?:\\+(" + src[BUILDIDENTIFIER] + "(?:\\." + src[BUILDIDENTIFIER] + ")*))";
    var FULL = R++;
    var FULLPLAIN = "v?" + src[MAINVERSION] + src[PRERELEASE] + "?" + src[BUILD] + "?";
    src[FULL] = "^" + FULLPLAIN + "$";
    var LOOSEPLAIN = "[v=\\s]*" + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + "?" + src[BUILD] + "?";
    var LOOSE = R++;
    src[LOOSE] = "^" + LOOSEPLAIN + "$";
    var GTLT = R++;
    src[GTLT] = "((?:<|>)?=?)";
    var XRANGEIDENTIFIERLOOSE = R++;
    src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
    var XRANGEIDENTIFIER = R++;
    src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + "|x|X|\\*";
    var XRANGEPLAIN = R++;
    src[XRANGEPLAIN] = "[v=\\s]*(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:" + src[PRERELEASE] + ")?" + src[BUILD] + "?)?)?";
    var XRANGEPLAINLOOSE = R++;
    src[XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:" + src[PRERELEASELOOSE] + ")?" + src[BUILD] + "?)?)?";
    var XRANGE = R++;
    src[XRANGE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAIN] + "$";
    var XRANGELOOSE = R++;
    src[XRANGELOOSE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAINLOOSE] + "$";
    var COERCE = R++;
    src[COERCE] = "(?:^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
    var LONETILDE = R++;
    src[LONETILDE] = "(?:~>?)";
    var TILDETRIM = R++;
    src[TILDETRIM] = "(\\s*)" + src[LONETILDE] + "\\s+";
    re[TILDETRIM] = new RegExp(src[TILDETRIM], "g");
    var tildeTrimReplace = "$1~";
    var TILDE = R++;
    src[TILDE] = "^" + src[LONETILDE] + src[XRANGEPLAIN] + "$";
    var TILDELOOSE = R++;
    src[TILDELOOSE] = "^" + src[LONETILDE] + src[XRANGEPLAINLOOSE] + "$";
    var LONECARET = R++;
    src[LONECARET] = "(?:\\^)";
    var CARETTRIM = R++;
    src[CARETTRIM] = "(\\s*)" + src[LONECARET] + "\\s+";
    re[CARETTRIM] = new RegExp(src[CARETTRIM], "g");
    var caretTrimReplace = "$1^";
    var CARET = R++;
    src[CARET] = "^" + src[LONECARET] + src[XRANGEPLAIN] + "$";
    var CARETLOOSE = R++;
    src[CARETLOOSE] = "^" + src[LONECARET] + src[XRANGEPLAINLOOSE] + "$";
    var COMPARATORLOOSE = R++;
    src[COMPARATORLOOSE] = "^" + src[GTLT] + "\\s*(" + LOOSEPLAIN + ")$|^$";
    var COMPARATOR = R++;
    src[COMPARATOR] = "^" + src[GTLT] + "\\s*(" + FULLPLAIN + ")$|^$";
    var COMPARATORTRIM = R++;
    src[COMPARATORTRIM] = "(\\s*)" + src[GTLT] + "\\s*(" + LOOSEPLAIN + "|" + src[XRANGEPLAIN] + ")";
    re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], "g");
    var comparatorTrimReplace = "$1$2$3";
    var HYPHENRANGE = R++;
    src[HYPHENRANGE] = "^\\s*(" + src[XRANGEPLAIN] + ")\\s+-\\s+(" + src[XRANGEPLAIN] + ")\\s*$";
    var HYPHENRANGELOOSE = R++;
    src[HYPHENRANGELOOSE] = "^\\s*(" + src[XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[XRANGEPLAINLOOSE] + ")\\s*$";
    var STAR = R++;
    src[STAR] = "(<|>)?=?\\s*\\*";
    for (i = 0; i < R; i++) {
      debug(i, src[i]);
      if (!re[i]) {
        re[i] = new RegExp(src[i]);
      }
    }
    var i;
    exports2.parse = parse2;
    function parse2(version, options2) {
      if (!options2 || typeof options2 !== "object") {
        options2 = {
          loose: !!options2,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      if (version.length > MAX_LENGTH) {
        return null;
      }
      var r = options2.loose ? re[LOOSE] : re[FULL];
      if (!r.test(version)) {
        return null;
      }
      try {
        return new SemVer(version, options2);
      } catch (er) {
        return null;
      }
    }
    exports2.valid = valid;
    function valid(version, options2) {
      var v = parse2(version, options2);
      return v ? v.version : null;
    }
    exports2.clean = clean;
    function clean(version, options2) {
      var s = parse2(version.trim().replace(/^[=v]+/, ""), options2);
      return s ? s.version : null;
    }
    exports2.SemVer = SemVer;
    function SemVer(version, options2) {
      if (!options2 || typeof options2 !== "object") {
        options2 = {
          loose: !!options2,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        if (version.loose === options2.loose) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== "string") {
        throw new TypeError("Invalid Version: " + version);
      }
      if (version.length > MAX_LENGTH) {
        throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
      }
      if (!(this instanceof SemVer)) {
        return new SemVer(version, options2);
      }
      debug("SemVer", version, options2);
      this.options = options2;
      this.loose = !!options2.loose;
      var m = version.trim().match(options2.loose ? re[LOOSE] : re[FULL]);
      if (!m) {
        throw new TypeError("Invalid Version: " + version);
      }
      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map(function(id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    SemVer.prototype.format = function() {
      this.version = this.major + "." + this.minor + "." + this.patch;
      if (this.prerelease.length) {
        this.version += "-" + this.prerelease.join(".");
      }
      return this.version;
    };
    SemVer.prototype.toString = function() {
      return this.version;
    };
    SemVer.prototype.compare = function(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return this.compareMain(other) || this.comparePre(other);
    };
    SemVer.prototype.compareMain = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };
    SemVer.prototype.comparePre = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      var i2 = 0;
      do {
        var a = this.prerelease[i2];
        var b = other.prerelease[i2];
        debug("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.inc = function(release, identifier) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier);
          this.inc("pre", identifier);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier);
          }
          this.inc("pre", identifier);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i2 = this.prerelease.length;
            while (--i2 >= 0) {
              if (typeof this.prerelease[i2] === "number") {
                this.prerelease[i2]++;
                i2 = -2;
              }
            }
            if (i2 === -1) {
              this.prerelease.push(0);
            }
          }
          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }
          break;
        default:
          throw new Error("invalid increment argument: " + release);
      }
      this.format();
      this.raw = this.version;
      return this;
    };
    exports2.inc = inc;
    function inc(version, release, loose, identifier) {
      if (typeof loose === "string") {
        identifier = loose;
        loose = void 0;
      }
      try {
        return new SemVer(version, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }
    exports2.diff = diff;
    function diff(version1, version2) {
      if (eq(version1, version2)) {
        return null;
      } else {
        var v1 = parse2(version1);
        var v2 = parse2(version2);
        var prefix = "";
        if (v1.prerelease.length || v2.prerelease.length) {
          prefix = "pre";
          var defaultResult = "prerelease";
        }
        for (var key in v1) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    }
    exports2.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;
    function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }
    exports2.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }
    exports2.major = major;
    function major(a, loose) {
      return new SemVer(a, loose).major;
    }
    exports2.minor = minor;
    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }
    exports2.patch = patch;
    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }
    exports2.compare = compare;
    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(new SemVer(b, loose));
    }
    exports2.compareLoose = compareLoose;
    function compareLoose(a, b) {
      return compare(a, b, true);
    }
    exports2.rcompare = rcompare;
    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }
    exports2.sort = sort;
    function sort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.compare(a, b, loose);
      });
    }
    exports2.rsort = rsort;
    function rsort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.rcompare(a, b, loose);
      });
    }
    exports2.gt = gt;
    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }
    exports2.lt = lt;
    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }
    exports2.eq = eq;
    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }
    exports2.neq = neq;
    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }
    exports2.gte = gte;
    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }
    exports2.lte = lte;
    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }
    exports2.cmp = cmp;
    function cmp(a, op, b, loose) {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError("Invalid operator: " + op);
      }
    }
    exports2.Comparator = Comparator;
    function Comparator(comp, options2) {
      if (!options2 || typeof options2 !== "object") {
        options2 = {
          loose: !!options2,
          includePrerelease: false
        };
      }
      if (comp instanceof Comparator) {
        if (comp.loose === !!options2.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      if (!(this instanceof Comparator)) {
        return new Comparator(comp, options2);
      }
      debug("comparator", comp, options2);
      this.options = options2;
      this.loose = !!options2.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug("comp", this);
    }
    var ANY = {};
    Comparator.prototype.parse = function(comp) {
      var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
      var m = comp.match(r);
      if (!m) {
        throw new TypeError("Invalid comparator: " + comp);
      }
      this.operator = m[1];
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    };
    Comparator.prototype.toString = function() {
      return this.value;
    };
    Comparator.prototype.test = function(version) {
      debug("Comparator.test", version, this.options.loose);
      if (this.semver === ANY) {
        return true;
      }
      if (typeof version === "string") {
        version = new SemVer(version, this.options);
      }
      return cmp(version, this.operator, this.semver, this.options);
    };
    Comparator.prototype.intersects = function(comp, options2) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options2 || typeof options2 !== "object") {
        options2 = {
          loose: !!options2,
          includePrerelease: false
        };
      }
      var rangeTmp;
      if (this.operator === "") {
        rangeTmp = new Range(comp.value, options2);
        return satisfies(this.value, rangeTmp, options2);
      } else if (comp.operator === "") {
        rangeTmp = new Range(this.value, options2);
        return satisfies(comp.semver, rangeTmp, options2);
      }
      var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options2) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
      var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options2) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };
    exports2.Range = Range;
    function Range(range, options2) {
      if (!options2 || typeof options2 !== "object") {
        options2 = {
          loose: !!options2,
          includePrerelease: false
        };
      }
      if (range instanceof Range) {
        if (range.loose === !!options2.loose && range.includePrerelease === !!options2.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options2);
        }
      }
      if (range instanceof Comparator) {
        return new Range(range.value, options2);
      }
      if (!(this instanceof Range)) {
        return new Range(range, options2);
      }
      this.options = options2;
      this.loose = !!options2.loose;
      this.includePrerelease = !!options2.includePrerelease;
      this.raw = range;
      this.set = range.split(/\s*\|\|\s*/).map(function(range2) {
        return this.parseRange(range2.trim());
      }, this).filter(function(c) {
        return c.length;
      });
      if (!this.set.length) {
        throw new TypeError("Invalid SemVer Range: " + range);
      }
      this.format();
    }
    Range.prototype.format = function() {
      this.range = this.set.map(function(comps) {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    };
    Range.prototype.toString = function() {
      return this.range;
    };
    Range.prototype.parseRange = function(range) {
      var loose = this.options.loose;
      range = range.trim();
      var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug("hyphen replace", range);
      range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range, re[COMPARATORTRIM]);
      range = range.replace(re[TILDETRIM], tildeTrimReplace);
      range = range.replace(re[CARETTRIM], caretTrimReplace);
      range = range.split(/\s+/).join(" ");
      var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
      var set = range.split(" ").map(function(comp) {
        return parseComparator(comp, this.options);
      }, this).join(" ").split(/\s+/);
      if (this.options.loose) {
        set = set.filter(function(comp) {
          return !!comp.match(compRe);
        });
      }
      set = set.map(function(comp) {
        return new Comparator(comp, this.options);
      }, this);
      return set;
    };
    Range.prototype.intersects = function(range, options2) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some(function(thisComparators) {
        return thisComparators.every(function(thisComparator) {
          return range.set.some(function(rangeComparators) {
            return rangeComparators.every(function(rangeComparator) {
              return thisComparator.intersects(rangeComparator, options2);
            });
          });
        });
      });
    };
    exports2.toComparators = toComparators;
    function toComparators(range, options2) {
      return new Range(range, options2).set.map(function(comp) {
        return comp.map(function(c) {
          return c.value;
        }).join(" ").trim().split(" ");
      });
    }
    function parseComparator(comp, options2) {
      debug("comp", comp, options2);
      comp = replaceCarets(comp, options2);
      debug("caret", comp);
      comp = replaceTildes(comp, options2);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options2);
      debug("xrange", comp);
      comp = replaceStars(comp, options2);
      debug("stars", comp);
      return comp;
    }
    function isX(id) {
      return !id || id.toLowerCase() === "x" || id === "*";
    }
    function replaceTildes(comp, options2) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceTilde(comp2, options2);
      }).join(" ");
    }
    function replaceTilde(comp, options2) {
      var r = options2.loose ? re[TILDELOOSE] : re[TILDE];
      return comp.replace(r, function(_45, M, m, p, pr) {
        debug("tilde", comp, _45, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
        }
        debug("tilde return", ret);
        return ret;
      });
    }
    function replaceCarets(comp, options2) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceCaret(comp2, options2);
      }).join(" ");
    }
    function replaceCaret(comp, options2) {
      debug("caret", comp, options2);
      var r = options2.loose ? re[CARETLOOSE] : re[CARET];
      return comp.replace(r, function(_45, M, m, p, pr) {
        debug("caret", comp, _45, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          if (M === "0") {
            ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
          } else {
            ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
          }
        }
        debug("caret return", ret);
        return ret;
      });
    }
    function replaceXRanges(comp, options2) {
      debug("replaceXRanges", comp, options2);
      return comp.split(/\s+/).map(function(comp2) {
        return replaceXRange(comp2, options2);
      }).join(" ");
    }
    function replaceXRange(comp, options2) {
      comp = comp.trim();
      var r = options2.loose ? re[XRANGELOOSE] : re[XRANGE];
      return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          ret = gtlt + M + "." + m + "." + p;
        } else if (xm) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (xp) {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        }
        debug("xRange return", ret);
        return ret;
      });
    }
    function replaceStars(comp, options2) {
      debug("replaceStars", comp, options2);
      return comp.trim().replace(re[STAR], "");
    }
    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = ">=" + fM + ".0.0";
      } else if (isX(fp)) {
        from = ">=" + fM + "." + fm + ".0";
      } else {
        from = ">=" + from;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = "<" + (+tM + 1) + ".0.0";
      } else if (isX(tp)) {
        to = "<" + tM + "." + (+tm + 1) + ".0";
      } else if (tpr) {
        to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
      } else {
        to = "<=" + to;
      }
      return (from + " " + to).trim();
    }
    Range.prototype.test = function(version) {
      if (!version) {
        return false;
      }
      if (typeof version === "string") {
        version = new SemVer(version, this.options);
      }
      for (var i2 = 0; i2 < this.set.length; i2++) {
        if (testSet(this.set[i2], version, this.options)) {
          return true;
        }
      }
      return false;
    };
    function testSet(set, version, options2) {
      for (var i2 = 0; i2 < set.length; i2++) {
        if (!set[i2].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options2.includePrerelease) {
        for (i2 = 0; i2 < set.length; i2++) {
          debug(set[i2].semver);
          if (set[i2].semver === ANY) {
            continue;
          }
          if (set[i2].semver.prerelease.length > 0) {
            var allowed = set[i2].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    }
    exports2.satisfies = satisfies;
    function satisfies(version, range, options2) {
      try {
        range = new Range(range, options2);
      } catch (er) {
        return false;
      }
      return range.test(version);
    }
    exports2.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range, options2) {
      var max = null;
      var maxSV = null;
      try {
        var rangeObj = new Range(range, options2);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options2);
          }
        }
      });
      return max;
    }
    exports2.minSatisfying = minSatisfying;
    function minSatisfying(versions, range, options2) {
      var min = null;
      var minSV = null;
      try {
        var rangeObj = new Range(range, options2);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options2);
          }
        }
      });
      return min;
    }
    exports2.minVersion = minVersion;
    function minVersion(range, loose) {
      range = new Range(range, loose);
      var minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        comparators.forEach(function(comparator) {
          var compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error("Unexpected operation: " + comparator.operator);
          }
        });
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    }
    exports2.validRange = validRange;
    function validRange(range, options2) {
      try {
        return new Range(range, options2).range || "*";
      } catch (er) {
        return null;
      }
    }
    exports2.ltr = ltr;
    function ltr(version, range, options2) {
      return outside(version, range, "<", options2);
    }
    exports2.gtr = gtr;
    function gtr(version, range, options2) {
      return outside(version, range, ">", options2);
    }
    exports2.outside = outside;
    function outside(version, range, hilo, options2) {
      version = new SemVer(version, options2);
      range = new Range(range, options2);
      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options2)) {
        return false;
      }
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        var high = null;
        var low = null;
        comparators.forEach(function(comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options2)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options2)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    }
    exports2.prerelease = prerelease;
    function prerelease(version, options2) {
      var parsed = parse2(version, options2);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }
    exports2.intersects = intersects;
    function intersects(r1, r2, options2) {
      r1 = new Range(r1, options2);
      r2 = new Range(r2, options2);
      return r1.intersects(r2);
    }
    exports2.coerce = coerce;
    function coerce(version) {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      var match = version.match(re[COERCE]);
      if (match == null) {
        return null;
      }
      return parse2(match[1] + "." + (match[2] || "0") + "." + (match[3] || "0"));
    }
  }
});

// ../../node_modules/async-listener/glue.js
var require_glue = __commonJS({
  "../../node_modules/async-listener/glue.js"(exports2, module2) {
    var wrap = require_shimmer().wrap;
    var HAS_CREATE_AL = 1 << 0;
    var HAS_BEFORE_AL = 1 << 1;
    var HAS_AFTER_AL = 1 << 2;
    var HAS_ERROR_AL = 1 << 3;
    var listeners = [];
    var uid = 0;
    var inAsyncTick = false;
    var listenerStack = [];
    var asyncCatcher;
    var asyncWrap;
    function union(dest, added) {
      var destLength = dest.length;
      var addedLength = added.length;
      var returned = [];
      if (destLength === 0 && addedLength === 0)
        return returned;
      for (var j = 0; j < destLength; j++)
        returned[j] = dest[j];
      if (addedLength === 0)
        return returned;
      for (var i = 0; i < addedLength; i++) {
        var missing = true;
        for (j = 0; j < destLength; j++) {
          if (dest[j].uid === added[i].uid) {
            missing = false;
            break;
          }
        }
        if (missing)
          returned.push(added[i]);
      }
      return returned;
    }
    if (process._fatalException) {
      inErrorTick = false;
      asyncCatcher = function asyncCatcher2(er) {
        var length = listeners.length;
        if (inErrorTick || length === 0)
          return false;
        var handled = false;
        inErrorTick = true;
        for (var i = 0; i < length; ++i) {
          var listener = listeners[i];
          if ((listener.flags & HAS_ERROR_AL) === 0)
            continue;
          var value = errorValues && errorValues[listener.uid];
          handled = listener.error(value, er) || handled;
        }
        inErrorTick = false;
        if (listenerStack.length > 0)
          listeners = listenerStack.pop();
        errorValues = void 0;
        return handled && !inAsyncTick;
      };
      asyncWrap = function asyncWrap2(original, list, length) {
        var values = [];
        inAsyncTick = true;
        for (var i = 0; i < length; ++i) {
          var listener = list[i];
          values[listener.uid] = listener.data;
          if ((listener.flags & HAS_CREATE_AL) === 0)
            continue;
          var value = listener.create(listener.data);
          if (value !== void 0)
            values[listener.uid] = value;
        }
        inAsyncTick = false;
        return function() {
          errorValues = values;
          listenerStack.push(listeners);
          listeners = union(list, listeners);
          inAsyncTick = true;
          for (var i2 = 0; i2 < length; ++i2) {
            if ((list[i2].flags & HAS_BEFORE_AL) > 0) {
              list[i2].before(this, values[list[i2].uid]);
            }
          }
          inAsyncTick = false;
          var returned = original.apply(this, arguments);
          inAsyncTick = true;
          for (i2 = 0; i2 < length; ++i2) {
            if ((list[i2].flags & HAS_AFTER_AL) > 0) {
              list[i2].after(this, values[list[i2].uid]);
            }
          }
          inAsyncTick = false;
          listeners = listenerStack.pop();
          errorValues = void 0;
          return returned;
        };
      };
      wrap(process, "_fatalException", function(_fatalException) {
        return function _asyncFatalException(er) {
          return asyncCatcher(er) || _fatalException(er);
        };
      });
    } else {
      errorThrew = false;
      asyncCatcher = function uncaughtCatcher(er) {
        if (errorThrew)
          throw er;
        var handled = false;
        var length = listeners.length;
        for (var i = 0; i < length; ++i) {
          var listener = listeners[i];
          if ((listener.flags & HAS_ERROR_AL) === 0)
            continue;
          handled = listener.error(null, er) || handled;
        }
        if (!handled && inAsyncTick)
          throw er;
      };
      asyncWrap = function asyncWrap2(original, list, length) {
        var values = [];
        inAsyncTick = true;
        for (var i = 0; i < length; ++i) {
          var listener = list[i];
          values[listener.uid] = listener.data;
          if ((listener.flags & HAS_CREATE_AL) === 0)
            continue;
          var value = listener.create(listener.data);
          if (value !== void 0)
            values[listener.uid] = value;
        }
        inAsyncTick = false;
        return function() {
          var threw = false;
          var handled = false;
          listenerStack.push(listeners);
          listeners = union(list, listeners);
          inAsyncTick = true;
          for (var i2 = 0; i2 < length; ++i2) {
            if ((list[i2].flags & HAS_BEFORE_AL) > 0) {
              list[i2].before(this, values[list[i2].uid]);
            }
          }
          inAsyncTick = false;
          var returned;
          try {
            returned = original.apply(this, arguments);
          } catch (er) {
            threw = true;
            for (var i2 = 0; i2 < length; ++i2) {
              if ((listeners[i2].flags & HAS_ERROR_AL) == 0)
                continue;
              try {
                handled = listeners[i2].error(values[list[i2].uid], er) || handled;
              } catch (x) {
                errorThrew = true;
                throw x;
              }
            }
            if (!handled) {
              process.removeListener("uncaughtException", asyncCatcher);
              process._originalNextTick(function() {
                process.addListener("uncaughtException", asyncCatcher);
              });
              throw er;
            }
          } finally {
            if (!threw || handled) {
              inAsyncTick = true;
              for (i2 = 0; i2 < length; ++i2) {
                if ((list[i2].flags & HAS_AFTER_AL) > 0) {
                  list[i2].after(this, values[list[i2].uid]);
                }
              }
              inAsyncTick = false;
            }
            listeners = listenerStack.pop();
          }
          return returned;
        };
      };
      process.addListener("uncaughtException", asyncCatcher);
    }
    var inErrorTick;
    var errorValues;
    var errorThrew;
    function simpleWrap(original, list, length) {
      inAsyncTick = true;
      for (var i = 0; i < length; ++i) {
        var listener = list[i];
        if (listener.create)
          listener.create(listener.data);
      }
      inAsyncTick = false;
      return function() {
        listenerStack.push(listeners);
        listeners = union(list, listeners);
        var returned = original.apply(this, arguments);
        listeners = listenerStack.pop();
        return returned;
      };
    }
    function wrapCallback(original) {
      var length = listeners.length;
      if (length === 0)
        return original;
      var list = listeners.slice();
      for (var i = 0; i < length; ++i) {
        if (list[i].flags > 0)
          return asyncWrap(original, list, length);
      }
      return simpleWrap(original, list, length);
    }
    function AsyncListener(callbacks, data2) {
      if (typeof callbacks.create === "function") {
        this.create = callbacks.create;
        this.flags |= HAS_CREATE_AL;
      }
      if (typeof callbacks.before === "function") {
        this.before = callbacks.before;
        this.flags |= HAS_BEFORE_AL;
      }
      if (typeof callbacks.after === "function") {
        this.after = callbacks.after;
        this.flags |= HAS_AFTER_AL;
      }
      if (typeof callbacks.error === "function") {
        this.error = callbacks.error;
        this.flags |= HAS_ERROR_AL;
      }
      this.uid = ++uid;
      this.data = data2 === void 0 ? null : data2;
    }
    AsyncListener.prototype.create = void 0;
    AsyncListener.prototype.before = void 0;
    AsyncListener.prototype.after = void 0;
    AsyncListener.prototype.error = void 0;
    AsyncListener.prototype.data = void 0;
    AsyncListener.prototype.uid = 0;
    AsyncListener.prototype.flags = 0;
    function createAsyncListener(callbacks, data2) {
      if (typeof callbacks !== "object" || !callbacks) {
        throw new TypeError("callbacks argument must be an object");
      }
      if (callbacks instanceof AsyncListener) {
        return callbacks;
      } else {
        return new AsyncListener(callbacks, data2);
      }
    }
    function addAsyncListener(callbacks, data2) {
      var listener;
      if (!(callbacks instanceof AsyncListener)) {
        listener = createAsyncListener(callbacks, data2);
      } else {
        listener = callbacks;
      }
      var registered = false;
      for (var i = 0; i < listeners.length; i++) {
        if (listener === listeners[i]) {
          registered = true;
          break;
        }
      }
      if (!registered)
        listeners.push(listener);
      return listener;
    }
    function removeAsyncListener(listener) {
      for (var i = 0; i < listeners.length; i++) {
        if (listener === listeners[i]) {
          listeners.splice(i, 1);
          break;
        }
      }
    }
    process.createAsyncListener = createAsyncListener;
    process.addAsyncListener = addAsyncListener;
    process.removeAsyncListener = removeAsyncListener;
    module2.exports = wrapCallback;
  }
});

// ../../node_modules/async-listener/es6-wrapped-promise.js
var require_es6_wrapped_promise = __commonJS({
  "../../node_modules/async-listener/es6-wrapped-promise.js"(exports2, module2) {
    "use strict";
    module2.exports = (Promise2, ensureAslWrapper) => {
      return class WrappedPromise extends Promise2 {
        constructor(executor) {
          var context, args;
          super(wrappedExecutor);
          var promise = this;
          try {
            executor.apply(context, args);
          } catch (err) {
            args[1](err);
          }
          return promise;
          function wrappedExecutor(resolve, reject) {
            context = this;
            args = [wrappedResolve, wrappedReject];
            function wrappedResolve(val) {
              ensureAslWrapper(promise, false);
              return resolve(val);
            }
            function wrappedReject(val) {
              ensureAslWrapper(promise, false);
              return reject(val);
            }
          }
        }
      };
    };
  }
});

// ../../node_modules/async-listener/index.js
var require_async_listener = __commonJS({
  "../../node_modules/async-listener/index.js"() {
    "use strict";
    if (process.addAsyncListener)
      throw new Error("Don't require polyfill unless needed");
    var shimmer = require_shimmer();
    var semver = require_semver3();
    var wrap = shimmer.wrap;
    var massWrap = shimmer.massWrap;
    var wrapCallback = require_glue();
    var util = require("util");
    var v6plus = semver.gte(process.version, "6.0.0");
    var v7plus = semver.gte(process.version, "7.0.0");
    var v8plus = semver.gte(process.version, "8.0.0");
    var v11plus = semver.gte(process.version, "11.0.0");
    var net = require("net");
    if (v7plus && !net._normalizeArgs) {
      net._normalizeArgs = function(args) {
        if (args.length === 0) {
          return [{}, null];
        }
        var arg0 = args[0];
        var options2 = {};
        if (typeof arg0 === "object" && arg0 !== null) {
          options2 = arg0;
        } else if (isPipeName(arg0)) {
          options2.path = arg0;
        } else {
          options2.port = arg0;
          if (args.length > 1 && typeof args[1] === "string") {
            options2.host = args[1];
          }
        }
        var cb = args[args.length - 1];
        if (typeof cb !== "function")
          return [options2, null];
        else
          return [options2, cb];
      };
    } else if (!v7plus && !net._normalizeConnectArgs) {
      net._normalizeConnectArgs = function(args) {
        var options2 = {};
        function toNumber2(x) {
          return (x = Number(x)) >= 0 ? x : false;
        }
        if (typeof args[0] === "object" && args[0] !== null) {
          options2 = args[0];
        } else if (typeof args[0] === "string" && toNumber2(args[0]) === false) {
          options2.path = args[0];
        } else {
          options2.port = args[0];
          if (typeof args[1] === "string") {
            options2.host = args[1];
          }
        }
        var cb = args[args.length - 1];
        return typeof cb === "function" ? [options2, cb] : [options2];
      };
    }
    if ("_setUpListenHandle" in net.Server.prototype) {
      wrap(net.Server.prototype, "_setUpListenHandle", wrapSetUpListenHandle);
    } else {
      wrap(net.Server.prototype, "_listen2", wrapSetUpListenHandle);
    }
    function wrapSetUpListenHandle(original) {
      return function() {
        this.on("connection", function(socket) {
          if (socket._handle) {
            socket._handle.onread = wrapCallback(socket._handle.onread);
          }
        });
        try {
          return original.apply(this, arguments);
        } finally {
          if (this._handle && this._handle.onconnection) {
            this._handle.onconnection = wrapCallback(this._handle.onconnection);
          }
        }
      };
    }
    function patchOnRead(ctx) {
      if (ctx && ctx._handle) {
        var handle3 = ctx._handle;
        if (!handle3._originalOnread) {
          handle3._originalOnread = handle3.onread;
        }
        handle3.onread = wrapCallback(handle3._originalOnread);
      }
    }
    wrap(net.Socket.prototype, "connect", function(original) {
      return function() {
        var args;
        if (v8plus && Array.isArray(arguments[0]) && Object.getOwnPropertySymbols(arguments[0]).length > 0) {
          args = arguments[0];
        } else {
          args = v7plus ? net._normalizeArgs(arguments) : net._normalizeConnectArgs(arguments);
        }
        if (args[1])
          args[1] = wrapCallback(args[1]);
        var result2 = original.apply(this, args);
        patchOnRead(this);
        return result2;
      };
    });
    var http = require("http");
    wrap(http.Agent.prototype, "addRequest", function(original) {
      return function(req) {
        var onSocket = req.onSocket;
        req.onSocket = wrapCallback(function(socket) {
          patchOnRead(socket);
          return onSocket.apply(this, arguments);
        });
        return original.apply(this, arguments);
      };
    });
    var childProcess = require("child_process");
    function wrapChildProcess(child) {
      if (Array.isArray(child.stdio)) {
        child.stdio.forEach(function(socket) {
          if (socket && socket._handle) {
            socket._handle.onread = wrapCallback(socket._handle.onread);
            wrap(socket._handle, "close", activatorFirst);
          }
        });
      }
      if (child._handle) {
        child._handle.onexit = wrapCallback(child._handle.onexit);
      }
    }
    if (childProcess.ChildProcess) {
      wrap(childProcess.ChildProcess.prototype, "spawn", function(original) {
        return function() {
          var result2 = original.apply(this, arguments);
          wrapChildProcess(this);
          return result2;
        };
      });
    } else {
      massWrap(childProcess, [
        "execFile",
        "fork",
        "spawn"
      ], function(original) {
        return function() {
          var result2 = original.apply(this, arguments);
          wrapChildProcess(result2);
          return result2;
        };
      });
    }
    if (!process._fatalException) {
      process._originalNextTick = process.nextTick;
    }
    var processors = [];
    if (process._nextDomainTick)
      processors.push("_nextDomainTick");
    if (process._tickDomainCallback)
      processors.push("_tickDomainCallback");
    massWrap(process, processors, activator);
    wrap(process, "nextTick", activatorFirst);
    var asynchronizers = [
      "setTimeout",
      "setInterval"
    ];
    if (global.setImmediate)
      asynchronizers.push("setImmediate");
    var timers = require("timers");
    var patchGlobalTimers = global.setTimeout === timers.setTimeout;
    massWrap(timers, asynchronizers, activatorFirst);
    if (patchGlobalTimers) {
      massWrap(global, asynchronizers, activatorFirst);
    }
    var dns = require("dns");
    massWrap(dns, [
      "lookup",
      "resolve",
      "resolve4",
      "resolve6",
      "resolveCname",
      "resolveMx",
      "resolveNs",
      "resolveTxt",
      "resolveSrv",
      "reverse"
    ], activator);
    if (dns.resolveNaptr)
      wrap(dns, "resolveNaptr", activator);
    var fs2 = require("fs");
    massWrap(fs2, [
      "watch",
      "rename",
      "truncate",
      "chown",
      "fchown",
      "chmod",
      "fchmod",
      "stat",
      "lstat",
      "fstat",
      "link",
      "symlink",
      "readlink",
      "realpath",
      "unlink",
      "rmdir",
      "mkdir",
      "readdir",
      "close",
      "open",
      "utimes",
      "futimes",
      "fsync",
      "write",
      "read",
      "readFile",
      "writeFile",
      "appendFile",
      "watchFile",
      "unwatchFile",
      "exists"
    ], activator);
    if (fs2.lchown)
      wrap(fs2, "lchown", activator);
    if (fs2.lchmod)
      wrap(fs2, "lchmod", activator);
    if (fs2.ftruncate)
      wrap(fs2, "ftruncate", activator);
    var zlib;
    try {
      zlib = require("zlib");
    } catch (err) {
    }
    if (zlib && zlib.Deflate && zlib.Deflate.prototype) {
      proto = Object.getPrototypeOf(zlib.Deflate.prototype);
      if (proto._transform) {
        wrap(proto, "_transform", activator);
      } else if (proto.write && proto.flush && proto.end) {
        massWrap(proto, [
          "write",
          "flush",
          "end"
        ], activator);
      }
    }
    var proto;
    var crypto2;
    try {
      crypto2 = require("crypto");
    } catch (err) {
    }
    if (crypto2) {
      toWrap = [
        "pbkdf2",
        "randomBytes"
      ];
      if (!v11plus) {
        toWrap.push("pseudoRandomBytes");
      }
      massWrap(crypto2, toWrap, activator);
    }
    var toWrap;
    var instrumentPromise = !!global.Promise && Promise.toString() === "function Promise() { [native code] }" && Promise.toString.toString() === "function toString() { [native code] }";
    if (instrumentPromise) {
      promiseListener = process.addAsyncListener({
        create: function create() {
          instrumentPromise = false;
        }
      });
      global.Promise.resolve(true).then(function notSync() {
        instrumentPromise = false;
      });
      process.removeAsyncListener(promiseListener);
    }
    var promiseListener;
    if (instrumentPromise) {
      wrapPromise();
    }
    function wrapPromise() {
      var Promise2 = global.Promise;
      function wrappedPromise(executor) {
        if (!(this instanceof wrappedPromise)) {
          return Promise2(executor);
        }
        if (typeof executor !== "function") {
          return new Promise2(executor);
        }
        var context, args;
        var promise = new Promise2(wrappedExecutor);
        promise.__proto__ = wrappedPromise.prototype;
        try {
          executor.apply(context, args);
        } catch (err) {
          args[1](err);
        }
        return promise;
        function wrappedExecutor(resolve, reject) {
          context = this;
          args = [wrappedResolve, wrappedReject];
          function wrappedResolve(val) {
            ensureAslWrapper(promise, false);
            return resolve(val);
          }
          function wrappedReject(val) {
            ensureAslWrapper(promise, false);
            return reject(val);
          }
        }
      }
      util.inherits(wrappedPromise, Promise2);
      wrap(Promise2.prototype, "then", wrapThen);
      if (Promise2.prototype.chain) {
        wrap(Promise2.prototype, "chain", wrapThen);
      }
      if (v6plus) {
        global.Promise = require_es6_wrapped_promise()(Promise2, ensureAslWrapper);
      } else {
        var PromiseFunctions = [
          "all",
          "race",
          "reject",
          "resolve",
          "accept",
          "defer"
        ];
        PromiseFunctions.forEach(function(key) {
          if (typeof Promise2[key] === "function") {
            wrappedPromise[key] = Promise2[key];
          }
        });
        global.Promise = wrappedPromise;
      }
      function ensureAslWrapper(promise, overwrite) {
        if (!promise.__asl_wrapper || overwrite) {
          promise.__asl_wrapper = wrapCallback(propagateAslWrapper);
        }
      }
      function propagateAslWrapper(ctx, fn, result2, next) {
        var nextResult;
        try {
          nextResult = fn.call(ctx, result2);
          return { returnVal: nextResult, error: false };
        } catch (err) {
          return { errorVal: err, error: true };
        } finally {
          if (nextResult instanceof Promise2) {
            next.__asl_wrapper = function proxyWrapper() {
              var aslWrapper = nextResult.__asl_wrapper || propagateAslWrapper;
              return aslWrapper.apply(this, arguments);
            };
          } else {
            ensureAslWrapper(next, true);
          }
        }
      }
      function wrapThen(original) {
        return function wrappedThen() {
          var promise = this;
          var next = original.apply(promise, Array.prototype.map.call(arguments, bind));
          next.__asl_wrapper = function proxyWrapper(ctx, fn, val, last) {
            if (promise.__asl_wrapper) {
              promise.__asl_wrapper(ctx, function() {
              }, null, next);
              return next.__asl_wrapper(ctx, fn, val, last);
            }
            return propagateAslWrapper(ctx, fn, val, last);
          };
          return next;
          function bind(fn) {
            if (typeof fn !== "function")
              return fn;
            return wrapCallback(function(val) {
              var result2 = (promise.__asl_wrapper || propagateAslWrapper)(this, fn, val, next);
              if (result2.error) {
                throw result2.errorVal;
              } else {
                return result2.returnVal;
              }
            });
          }
        };
      }
    }
    function activator(fn) {
      var fallback = function() {
        var args;
        var cbIdx = arguments.length - 1;
        if (typeof arguments[cbIdx] === "function") {
          args = Array(arguments.length);
          for (var i = 0; i < arguments.length - 1; i++) {
            args[i] = arguments[i];
          }
          args[cbIdx] = wrapCallback(arguments[cbIdx]);
        }
        return fn.apply(this, args || arguments);
      };
      switch (fn.length) {
        case 1:
          return function(cb) {
            if (arguments.length !== 1)
              return fallback.apply(this, arguments);
            if (typeof cb === "function")
              cb = wrapCallback(cb);
            return fn.call(this, cb);
          };
        case 2:
          return function(a, cb) {
            if (arguments.length !== 2)
              return fallback.apply(this, arguments);
            if (typeof cb === "function")
              cb = wrapCallback(cb);
            return fn.call(this, a, cb);
          };
        case 3:
          return function(a, b, cb) {
            if (arguments.length !== 3)
              return fallback.apply(this, arguments);
            if (typeof cb === "function")
              cb = wrapCallback(cb);
            return fn.call(this, a, b, cb);
          };
        case 4:
          return function(a, b, c, cb) {
            if (arguments.length !== 4)
              return fallback.apply(this, arguments);
            if (typeof cb === "function")
              cb = wrapCallback(cb);
            return fn.call(this, a, b, c, cb);
          };
        case 5:
          return function(a, b, c, d, cb) {
            if (arguments.length !== 5)
              return fallback.apply(this, arguments);
            if (typeof cb === "function")
              cb = wrapCallback(cb);
            return fn.call(this, a, b, c, d, cb);
          };
        case 6:
          return function(a, b, c, d, e, cb) {
            if (arguments.length !== 6)
              return fallback.apply(this, arguments);
            if (typeof cb === "function")
              cb = wrapCallback(cb);
            return fn.call(this, a, b, c, d, e, cb);
          };
        default:
          return fallback;
      }
    }
    function activatorFirst(fn) {
      var fallback = function() {
        var args;
        if (typeof arguments[0] === "function") {
          args = Array(arguments.length);
          args[0] = wrapCallback(arguments[0]);
          for (var i = 1; i < arguments.length; i++) {
            args[i] = arguments[i];
          }
        }
        return fn.apply(this, args || arguments);
      };
      switch (fn.length) {
        case 1:
          return function(cb) {
            if (arguments.length !== 1)
              return fallback.apply(this, arguments);
            if (typeof cb === "function")
              cb = wrapCallback(cb);
            return fn.call(this, cb);
          };
        case 2:
          return function(cb, a) {
            if (arguments.length !== 2)
              return fallback.apply(this, arguments);
            if (typeof cb === "function")
              cb = wrapCallback(cb);
            return fn.call(this, cb, a);
          };
        case 3:
          return function(cb, a, b) {
            if (arguments.length !== 3)
              return fallback.apply(this, arguments);
            if (typeof cb === "function")
              cb = wrapCallback(cb);
            return fn.call(this, cb, a, b);
          };
        case 4:
          return function(cb, a, b, c) {
            if (arguments.length !== 4)
              return fallback.apply(this, arguments);
            if (typeof cb === "function")
              cb = wrapCallback(cb);
            return fn.call(this, cb, a, b, c);
          };
        case 5:
          return function(cb, a, b, c, d) {
            if (arguments.length !== 5)
              return fallback.apply(this, arguments);
            if (typeof cb === "function")
              cb = wrapCallback(cb);
            return fn.call(this, cb, a, b, c, d);
          };
        case 6:
          return function(cb, a, b, c, d, e) {
            if (arguments.length !== 6)
              return fallback.apply(this, arguments);
            if (typeof cb === "function")
              cb = wrapCallback(cb);
            return fn.call(this, cb, a, b, c, d, e);
          };
        default:
          return fallback;
      }
    }
    function toNumber(x) {
      return (x = Number(x)) >= 0 ? x : false;
    }
    function isPipeName(s) {
      return typeof s === "string" && toNumber(s) === false;
    }
  }
});

// ../../node_modules/continuation-local-storage/context.js
var require_context2 = __commonJS({
  "../../node_modules/continuation-local-storage/context.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var wrapEmitter = require_listener();
    var CONTEXTS_SYMBOL = "cls@contexts";
    var ERROR_SYMBOL = "error@context";
    if (!process.addAsyncListener)
      require_async_listener();
    function Namespace(name) {
      this.name = name;
      this.active = null;
      this._set = [];
      this.id = null;
    }
    Namespace.prototype.set = function(key, value) {
      if (!this.active) {
        throw new Error("No context available. ns.run() or ns.bind() must be called first.");
      }
      this.active[key] = value;
      return value;
    };
    Namespace.prototype.get = function(key) {
      if (!this.active)
        return void 0;
      return this.active[key];
    };
    Namespace.prototype.createContext = function() {
      return Object.create(this.active);
    };
    Namespace.prototype.run = function(fn) {
      var context = this.createContext();
      this.enter(context);
      try {
        fn(context);
        return context;
      } catch (exception) {
        if (exception) {
          exception[ERROR_SYMBOL] = context;
        }
        throw exception;
      } finally {
        this.exit(context);
      }
    };
    Namespace.prototype.runAndReturn = function(fn) {
      var value;
      this.run(function(context) {
        value = fn(context);
      });
      return value;
    };
    Namespace.prototype.bind = function(fn, context) {
      if (!context) {
        if (!this.active) {
          context = this.createContext();
        } else {
          context = this.active;
        }
      }
      var self2 = this;
      return function() {
        self2.enter(context);
        try {
          return fn.apply(this, arguments);
        } catch (exception) {
          if (exception) {
            exception[ERROR_SYMBOL] = context;
          }
          throw exception;
        } finally {
          self2.exit(context);
        }
      };
    };
    Namespace.prototype.enter = function(context) {
      assert.ok(context, "context must be provided for entering");
      this._set.push(this.active);
      this.active = context;
    };
    Namespace.prototype.exit = function(context) {
      assert.ok(context, "context must be provided for exiting");
      if (this.active === context) {
        assert.ok(this._set.length, "can't remove top context");
        this.active = this._set.pop();
        return;
      }
      var index = this._set.lastIndexOf(context);
      assert.ok(index >= 0, "context not currently entered; can't exit");
      assert.ok(index, "can't remove top context");
      this._set.splice(index, 1);
    };
    Namespace.prototype.bindEmitter = function(emitter) {
      assert.ok(emitter.on && emitter.addListener && emitter.emit, "can only bind real EEs");
      var namespace = this;
      var thisSymbol = "context@" + this.name;
      function attach(listener) {
        if (!listener)
          return;
        if (!listener[CONTEXTS_SYMBOL])
          listener[CONTEXTS_SYMBOL] = /* @__PURE__ */ Object.create(null);
        listener[CONTEXTS_SYMBOL][thisSymbol] = {
          namespace,
          context: namespace.active
        };
      }
      function bind(unwrapped) {
        if (!(unwrapped && unwrapped[CONTEXTS_SYMBOL]))
          return unwrapped;
        var wrapped = unwrapped;
        var contexts = unwrapped[CONTEXTS_SYMBOL];
        Object.keys(contexts).forEach(function(name) {
          var thunk = contexts[name];
          wrapped = thunk.namespace.bind(wrapped, thunk.context);
        });
        return wrapped;
      }
      wrapEmitter(emitter, attach, bind);
    };
    Namespace.prototype.fromException = function(exception) {
      return exception[ERROR_SYMBOL];
    };
    function get3(name) {
      return process.namespaces[name];
    }
    function create(name) {
      assert.ok(name, "namespace must be given a name!");
      var namespace = new Namespace(name);
      namespace.id = process.addAsyncListener({
        create: function() {
          return namespace.active;
        },
        before: function(context, storage) {
          if (storage)
            namespace.enter(storage);
        },
        after: function(context, storage) {
          if (storage)
            namespace.exit(storage);
        },
        error: function(storage) {
          if (storage)
            namespace.exit(storage);
        }
      });
      process.namespaces[name] = namespace;
      return namespace;
    }
    function destroy(name) {
      var namespace = get3(name);
      assert.ok(namespace, "can't delete nonexistent namespace!");
      assert.ok(namespace.id, "don't assign to process.namespaces directly!");
      process.removeAsyncListener(namespace.id);
      process.namespaces[name] = null;
    }
    function reset() {
      if (process.namespaces) {
        Object.keys(process.namespaces).forEach(function(name) {
          destroy(name);
        });
      }
      process.namespaces = /* @__PURE__ */ Object.create(null);
    }
    if (!process.namespaces)
      reset();
    module2.exports = {
      getNamespace: get3,
      createNamespace: create,
      destroyNamespace: destroy,
      reset
    };
  }
});

// ../../node_modules/applicationinsights/out/AutoCollection/CorrelationContextManager.js
var require_CorrelationContextManager = __commonJS({
  "../../node_modules/applicationinsights/out/AutoCollection/CorrelationContextManager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Logging = require_Logging();
    var DiagChannel = require_initialization();
    var CorrelationContextManager = function() {
      function CorrelationContextManager2() {
      }
      CorrelationContextManager2.getCurrentContext = function() {
        if (!CorrelationContextManager2.enabled) {
          return null;
        }
        var context = CorrelationContextManager2.session.get(CorrelationContextManager2.CONTEXT_NAME);
        if (context === void 0) {
          return null;
        }
        return context;
      };
      CorrelationContextManager2.generateContextObject = function(operationId, parentId, operationName, correlationContextHeader, traceparent, tracestate) {
        parentId = parentId || operationId;
        if (this.enabled) {
          return {
            operation: {
              name: operationName,
              id: operationId,
              parentId,
              traceparent,
              tracestate
            },
            customProperties: new CustomPropertiesImpl(correlationContextHeader)
          };
        }
        return null;
      };
      CorrelationContextManager2.runWithContext = function(context, fn) {
        if (CorrelationContextManager2.enabled) {
          return CorrelationContextManager2.session.bind(fn, (_a2 = {}, _a2[CorrelationContextManager2.CONTEXT_NAME] = context, _a2))();
        } else {
          return fn();
        }
        var _a2;
      };
      CorrelationContextManager2.wrapEmitter = function(emitter) {
        if (CorrelationContextManager2.enabled) {
          CorrelationContextManager2.session.bindEmitter(emitter);
        }
      };
      CorrelationContextManager2.wrapCallback = function(fn) {
        if (CorrelationContextManager2.enabled) {
          return CorrelationContextManager2.session.bind(fn);
        }
        return fn;
      };
      CorrelationContextManager2.enable = function(forceClsHooked) {
        if (this.enabled) {
          return;
        }
        if (!this.isNodeVersionCompatible()) {
          this.enabled = false;
          return;
        }
        if (!CorrelationContextManager2.hasEverEnabled) {
          this.forceClsHooked = forceClsHooked;
          this.hasEverEnabled = true;
          if (typeof this.cls === "undefined") {
            if (CorrelationContextManager2.forceClsHooked === true || CorrelationContextManager2.forceClsHooked === void 0 && CorrelationContextManager2.shouldUseClsHooked()) {
              this.cls = require_cls_hooked();
            } else {
              this.cls = require_context2();
            }
          }
          CorrelationContextManager2.session = this.cls.createNamespace("AI-CLS-Session");
          DiagChannel.registerContextPreservation(function(cb) {
            return CorrelationContextManager2.session.bind(cb);
          });
        }
        this.enabled = true;
      };
      CorrelationContextManager2.disable = function() {
        this.enabled = false;
      };
      CorrelationContextManager2.reset = function() {
        if (CorrelationContextManager2.hasEverEnabled) {
          CorrelationContextManager2.session = null;
          CorrelationContextManager2.session = this.cls.createNamespace("AI-CLS-Session");
        }
      };
      CorrelationContextManager2.isNodeVersionCompatible = function() {
        var nodeVer = process.versions.node.split(".");
        return parseInt(nodeVer[0]) > 3 || parseInt(nodeVer[0]) > 2 && parseInt(nodeVer[1]) > 2;
      };
      CorrelationContextManager2.shouldUseClsHooked = function() {
        var nodeVer = process.versions.node.split(".");
        return parseInt(nodeVer[0]) > 8 || parseInt(nodeVer[0]) >= 8 && parseInt(nodeVer[1]) >= 2;
      };
      CorrelationContextManager2.canUseClsHooked = function() {
        var nodeVer = process.versions.node.split(".");
        var greater800 = parseInt(nodeVer[0]) > 8 || parseInt(nodeVer[0]) >= 8 && parseInt(nodeVer[1]) >= 0;
        var less820 = parseInt(nodeVer[0]) < 8 || parseInt(nodeVer[0]) <= 8 && parseInt(nodeVer[1]) < 2;
        var greater470 = parseInt(nodeVer[0]) > 4 || parseInt(nodeVer[0]) >= 4 && parseInt(nodeVer[1]) >= 7;
        return !(greater800 && less820) && greater470;
      };
      CorrelationContextManager2.enabled = false;
      CorrelationContextManager2.hasEverEnabled = false;
      CorrelationContextManager2.forceClsHooked = void 0;
      CorrelationContextManager2.CONTEXT_NAME = "ApplicationInsights-Context";
      return CorrelationContextManager2;
    }();
    exports2.CorrelationContextManager = CorrelationContextManager;
    var CustomPropertiesImpl = function() {
      function CustomPropertiesImpl2(header) {
        this.props = [];
        this.addHeaderData(header);
      }
      CustomPropertiesImpl2.prototype.addHeaderData = function(header) {
        var keyvals = header ? header.split(", ") : [];
        this.props = keyvals.map(function(keyval) {
          var parts = keyval.split("=");
          return { key: parts[0], value: parts[1] };
        }).concat(this.props);
      };
      CustomPropertiesImpl2.prototype.serializeToHeader = function() {
        return this.props.map(function(keyval) {
          return keyval.key + "=" + keyval.value;
        }).join(", ");
      };
      CustomPropertiesImpl2.prototype.getProperty = function(prop) {
        for (var i = 0; i < this.props.length; ++i) {
          var keyval = this.props[i];
          if (keyval.key === prop) {
            return keyval.value;
          }
        }
        return;
      };
      CustomPropertiesImpl2.prototype.setProperty = function(prop, val) {
        if (CustomPropertiesImpl2.bannedCharacters.test(prop) || CustomPropertiesImpl2.bannedCharacters.test(val)) {
          Logging.warn("Correlation context property keys and values must not contain ',' or '='. setProperty was called with key: " + prop + " and value: " + val);
          return;
        }
        for (var i = 0; i < this.props.length; ++i) {
          var keyval = this.props[i];
          if (keyval.key === prop) {
            keyval.value = val;
            return;
          }
        }
        this.props.push({ key: prop, value: val });
      };
      CustomPropertiesImpl2.bannedCharacters = /[,=]/;
      return CustomPropertiesImpl2;
    }();
  }
});

// ../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/Domain.js
var require_Domain = __commonJS({
  "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/Domain.js"(exports2, module2) {
    "use strict";
    var Domain = function() {
      function Domain2() {
      }
      return Domain2;
    }();
    module2.exports = Domain;
  }
});

// ../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/AvailabilityData.js
var require_AvailabilityData = __commonJS({
  "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/AvailabilityData.js"(exports2, module2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (b.hasOwnProperty(p))
            d[p] = b[p];
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var Domain = require_Domain();
    var AvailabilityData = function(_super) {
      __extends2(AvailabilityData2, _super);
      function AvailabilityData2() {
        var _this = _super.call(this) || this;
        _this.ver = 2;
        _this.properties = {};
        _this.measurements = {};
        return _this;
      }
      return AvailabilityData2;
    }(Domain);
    module2.exports = AvailabilityData;
  }
});

// ../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/Base.js
var require_Base = __commonJS({
  "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/Base.js"(exports2, module2) {
    "use strict";
    var Base = function() {
      function Base2() {
      }
      return Base2;
    }();
    module2.exports = Base;
  }
});

// ../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/ContextTagKeys.js
var require_ContextTagKeys = __commonJS({
  "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/ContextTagKeys.js"(exports2, module2) {
    "use strict";
    var ContextTagKeys = function() {
      function ContextTagKeys2() {
        this.applicationVersion = "ai.application.ver";
        this.deviceId = "ai.device.id";
        this.deviceLocale = "ai.device.locale";
        this.deviceModel = "ai.device.model";
        this.deviceOEMName = "ai.device.oemName";
        this.deviceOSVersion = "ai.device.osVersion";
        this.deviceType = "ai.device.type";
        this.locationIp = "ai.location.ip";
        this.operationId = "ai.operation.id";
        this.operationName = "ai.operation.name";
        this.operationParentId = "ai.operation.parentId";
        this.operationSyntheticSource = "ai.operation.syntheticSource";
        this.operationCorrelationVector = "ai.operation.correlationVector";
        this.sessionId = "ai.session.id";
        this.sessionIsFirst = "ai.session.isFirst";
        this.userAccountId = "ai.user.accountId";
        this.userId = "ai.user.id";
        this.userAuthUserId = "ai.user.authUserId";
        this.cloudRole = "ai.cloud.role";
        this.cloudRoleInstance = "ai.cloud.roleInstance";
        this.internalSdkVersion = "ai.internal.sdkVersion";
        this.internalAgentVersion = "ai.internal.agentVersion";
        this.internalNodeName = "ai.internal.nodeName";
      }
      return ContextTagKeys2;
    }();
    module2.exports = ContextTagKeys;
  }
});

// ../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/Data.js
var require_Data = __commonJS({
  "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/Data.js"(exports2, module2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (b.hasOwnProperty(p))
            d[p] = b[p];
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var Base = require_Base();
    var Data = function(_super) {
      __extends2(Data2, _super);
      function Data2() {
        return _super.call(this) || this;
      }
      return Data2;
    }(Base);
    module2.exports = Data;
  }
});

// ../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/DataPointType.js
var require_DataPointType = __commonJS({
  "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/DataPointType.js"(exports2, module2) {
    "use strict";
    var DataPointType;
    (function(DataPointType2) {
      DataPointType2[DataPointType2["Measurement"] = 0] = "Measurement";
      DataPointType2[DataPointType2["Aggregation"] = 1] = "Aggregation";
    })(DataPointType || (DataPointType = {}));
    module2.exports = DataPointType;
  }
});

// ../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/DataPoint.js
var require_DataPoint = __commonJS({
  "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/DataPoint.js"(exports2, module2) {
    "use strict";
    var DataPointType = require_DataPointType();
    var DataPoint = function() {
      function DataPoint2() {
        this.kind = DataPointType.Measurement;
      }
      return DataPoint2;
    }();
    module2.exports = DataPoint;
  }
});

// ../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/Envelope.js
var require_Envelope = __commonJS({
  "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/Envelope.js"(exports2, module2) {
    "use strict";
    var Envelope = function() {
      function Envelope2() {
        this.ver = 1;
        this.sampleRate = 100;
        this.tags = {};
      }
      return Envelope2;
    }();
    module2.exports = Envelope;
  }
});

// ../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/EventData.js
var require_EventData = __commonJS({
  "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/EventData.js"(exports2, module2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (b.hasOwnProperty(p))
            d[p] = b[p];
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var Domain = require_Domain();
    var EventData = function(_super) {
      __extends2(EventData2, _super);
      function EventData2() {
        var _this = _super.call(this) || this;
        _this.ver = 2;
        _this.properties = {};
        _this.measurements = {};
        return _this;
      }
      return EventData2;
    }(Domain);
    module2.exports = EventData;
  }
});

// ../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/ExceptionData.js
var require_ExceptionData = __commonJS({
  "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/ExceptionData.js"(exports2, module2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (b.hasOwnProperty(p))
            d[p] = b[p];
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var Domain = require_Domain();
    var ExceptionData = function(_super) {
      __extends2(ExceptionData2, _super);
      function ExceptionData2() {
        var _this = _super.call(this) || this;
        _this.ver = 2;
        _this.exceptions = [];
        _this.properties = {};
        _this.measurements = {};
        return _this;
      }
      return ExceptionData2;
    }(Domain);
    module2.exports = ExceptionData;
  }
});

// ../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/ExceptionDetails.js
var require_ExceptionDetails = __commonJS({
  "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/ExceptionDetails.js"(exports2, module2) {
    "use strict";
    var ExceptionDetails = function() {
      function ExceptionDetails2() {
        this.hasFullStack = true;
        this.parsedStack = [];
      }
      return ExceptionDetails2;
    }();
    module2.exports = ExceptionDetails;
  }
});

// ../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/MessageData.js
var require_MessageData = __commonJS({
  "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/MessageData.js"(exports2, module2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (b.hasOwnProperty(p))
            d[p] = b[p];
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var Domain = require_Domain();
    var MessageData = function(_super) {
      __extends2(MessageData2, _super);
      function MessageData2() {
        var _this = _super.call(this) || this;
        _this.ver = 2;
        _this.properties = {};
        return _this;
      }
      return MessageData2;
    }(Domain);
    module2.exports = MessageData;
  }
});

// ../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/MetricData.js
var require_MetricData = __commonJS({
  "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/MetricData.js"(exports2, module2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (b.hasOwnProperty(p))
            d[p] = b[p];
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var Domain = require_Domain();
    var MetricData = function(_super) {
      __extends2(MetricData2, _super);
      function MetricData2() {
        var _this = _super.call(this) || this;
        _this.ver = 2;
        _this.metrics = [];
        _this.properties = {};
        return _this;
      }
      return MetricData2;
    }(Domain);
    module2.exports = MetricData;
  }
});

// ../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/PageViewData.js
var require_PageViewData = __commonJS({
  "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/PageViewData.js"(exports2, module2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (b.hasOwnProperty(p))
            d[p] = b[p];
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var EventData = require_EventData();
    var PageViewData = function(_super) {
      __extends2(PageViewData2, _super);
      function PageViewData2() {
        var _this = _super.call(this) || this;
        _this.ver = 2;
        _this.properties = {};
        _this.measurements = {};
        return _this;
      }
      return PageViewData2;
    }(EventData);
    module2.exports = PageViewData;
  }
});

// ../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/RemoteDependencyData.js
var require_RemoteDependencyData = __commonJS({
  "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/RemoteDependencyData.js"(exports2, module2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (b.hasOwnProperty(p))
            d[p] = b[p];
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var Domain = require_Domain();
    var RemoteDependencyData = function(_super) {
      __extends2(RemoteDependencyData2, _super);
      function RemoteDependencyData2() {
        var _this = _super.call(this) || this;
        _this.ver = 2;
        _this.success = true;
        _this.properties = {};
        _this.measurements = {};
        return _this;
      }
      return RemoteDependencyData2;
    }(Domain);
    module2.exports = RemoteDependencyData;
  }
});

// ../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/RequestData.js
var require_RequestData = __commonJS({
  "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/RequestData.js"(exports2, module2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (b.hasOwnProperty(p))
            d[p] = b[p];
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var Domain = require_Domain();
    var RequestData = function(_super) {
      __extends2(RequestData2, _super);
      function RequestData2() {
        var _this = _super.call(this) || this;
        _this.ver = 2;
        _this.properties = {};
        _this.measurements = {};
        return _this;
      }
      return RequestData2;
    }(Domain);
    module2.exports = RequestData;
  }
});

// ../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/SeverityLevel.js
var require_SeverityLevel = __commonJS({
  "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/SeverityLevel.js"(exports2, module2) {
    "use strict";
    var SeverityLevel;
    (function(SeverityLevel2) {
      SeverityLevel2[SeverityLevel2["Verbose"] = 0] = "Verbose";
      SeverityLevel2[SeverityLevel2["Information"] = 1] = "Information";
      SeverityLevel2[SeverityLevel2["Warning"] = 2] = "Warning";
      SeverityLevel2[SeverityLevel2["Error"] = 3] = "Error";
      SeverityLevel2[SeverityLevel2["Critical"] = 4] = "Critical";
    })(SeverityLevel || (SeverityLevel = {}));
    module2.exports = SeverityLevel;
  }
});

// ../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/StackFrame.js
var require_StackFrame = __commonJS({
  "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/StackFrame.js"(exports2, module2) {
    "use strict";
    var StackFrame = function() {
      function StackFrame2() {
      }
      return StackFrame2;
    }();
    module2.exports = StackFrame;
  }
});

// ../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/index.js
var require_Generated = __commonJS({
  "../../node_modules/applicationinsights/out/Declarations/Contracts/Generated/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AvailabilityData = require_AvailabilityData();
    exports2.Base = require_Base();
    exports2.ContextTagKeys = require_ContextTagKeys();
    exports2.Data = require_Data();
    exports2.DataPoint = require_DataPoint();
    exports2.DataPointType = require_DataPointType();
    exports2.Domain = require_Domain();
    exports2.Envelope = require_Envelope();
    exports2.EventData = require_EventData();
    exports2.ExceptionData = require_ExceptionData();
    exports2.ExceptionDetails = require_ExceptionDetails();
    exports2.MessageData = require_MessageData();
    exports2.MetricData = require_MetricData();
    exports2.PageViewData = require_PageViewData();
    exports2.RemoteDependencyData = require_RemoteDependencyData();
    exports2.RequestData = require_RequestData();
    exports2.SeverityLevel = require_SeverityLevel();
    exports2.StackFrame = require_StackFrame();
  }
});

// ../../node_modules/applicationinsights/out/Declarations/Contracts/Constants.js
var require_Constants = __commonJS({
  "../../node_modules/applicationinsights/out/Declarations/Contracts/Constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Generated_1 = require_Generated();
    var RemoteDependencyDataConstants = function() {
      function RemoteDependencyDataConstants2() {
      }
      RemoteDependencyDataConstants2.TYPE_HTTP = "Http";
      RemoteDependencyDataConstants2.TYPE_AI = "Http (tracked component)";
      return RemoteDependencyDataConstants2;
    }();
    exports2.RemoteDependencyDataConstants = RemoteDependencyDataConstants;
    function domainSupportsProperties(domain) {
      return "properties" in domain || domain instanceof Generated_1.EventData || domain instanceof Generated_1.ExceptionData || domain instanceof Generated_1.MessageData || domain instanceof Generated_1.MetricData || domain instanceof Generated_1.PageViewData || domain instanceof Generated_1.RemoteDependencyData || domain instanceof Generated_1.RequestData;
    }
    exports2.domainSupportsProperties = domainSupportsProperties;
  }
});

// ../../node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/TelemetryType.js
var require_TelemetryType = __commonJS({
  "../../node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/TelemetryType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function telemetryTypeToBaseType(type) {
      switch (type) {
        case TelemetryType.Event:
          return "EventData";
        case TelemetryType.Exception:
          return "ExceptionData";
        case TelemetryType.Trace:
          return "MessageData";
        case TelemetryType.Metric:
          return "MetricData";
        case TelemetryType.Request:
          return "RequestData";
        case TelemetryType.Dependency:
          return "RemoteDependencyData";
      }
      return void 0;
    }
    exports2.telemetryTypeToBaseType = telemetryTypeToBaseType;
    function baseTypeToTelemetryType(baseType) {
      switch (baseType) {
        case "EventData":
          return TelemetryType.Event;
        case "ExceptionData":
          return TelemetryType.Exception;
        case "MessageData":
          return TelemetryType.Trace;
        case "MetricData":
          return TelemetryType.Metric;
        case "RequestData":
          return TelemetryType.Request;
        case "RemoteDependencyData":
          return TelemetryType.Dependency;
      }
      return void 0;
    }
    exports2.baseTypeToTelemetryType = baseTypeToTelemetryType;
    exports2.TelemetryTypeString = {
      Event: "EventData",
      Exception: "ExceptionData",
      Trace: "MessageData",
      Metric: "MetricData",
      Request: "RequestData",
      Dependency: "RemoteDependencyData"
    };
    var TelemetryType;
    (function(TelemetryType2) {
      TelemetryType2[TelemetryType2["Event"] = 0] = "Event";
      TelemetryType2[TelemetryType2["Exception"] = 1] = "Exception";
      TelemetryType2[TelemetryType2["Trace"] = 2] = "Trace";
      TelemetryType2[TelemetryType2["Metric"] = 3] = "Metric";
      TelemetryType2[TelemetryType2["Request"] = 4] = "Request";
      TelemetryType2[TelemetryType2["Dependency"] = 5] = "Dependency";
    })(TelemetryType = exports2.TelemetryType || (exports2.TelemetryType = {}));
  }
});

// ../../node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/index.js
var require_TelemetryTypes = __commonJS({
  "../../node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/index.js"(exports2) {
    "use strict";
    function __export2(m) {
      for (var p in m)
        if (!exports2.hasOwnProperty(p))
          exports2[p] = m[p];
    }
    Object.defineProperty(exports2, "__esModule", { value: true });
    __export2(require_TelemetryType());
  }
});

// ../../node_modules/applicationinsights/out/Declarations/Contracts/index.js
var require_Contracts = __commonJS({
  "../../node_modules/applicationinsights/out/Declarations/Contracts/index.js"(exports2) {
    "use strict";
    function __export2(m) {
      for (var p in m)
        if (!exports2.hasOwnProperty(p))
          exports2[p] = m[p];
    }
    Object.defineProperty(exports2, "__esModule", { value: true });
    __export2(require_Constants());
    __export2(require_Generated());
    __export2(require_TelemetryTypes());
  }
});

// ../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/console.sub.js
var require_console_sub = __commonJS({
  "../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/console.sub.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Contracts_1 = require_Contracts();
    var diagnostic_channel_1 = require_channel();
    var clients = [];
    var subscriber = function(event) {
      clients.forEach(function(client) {
        var message = event.data.message;
        if (message.lastIndexOf("\n") == message.length - 1) {
          message = message.substring(0, message.length - 1);
        }
        client.trackTrace({ message, severity: event.data.stderr ? Contracts_1.SeverityLevel.Warning : Contracts_1.SeverityLevel.Information });
      });
    };
    function enable(enabled, client) {
      if (enabled) {
        if (clients.length === 0) {
          diagnostic_channel_1.channel.subscribe("console", subscriber);
        }
        ;
        clients.push(client);
      } else {
        clients = clients.filter(function(c) {
          return c != client;
        });
        if (clients.length === 0) {
          diagnostic_channel_1.channel.unsubscribe("console", subscriber);
        }
      }
    }
    exports2.enable = enable;
  }
});

// ../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/bunyan.sub.js
var require_bunyan_sub = __commonJS({
  "../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/bunyan.sub.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Contracts_1 = require_Contracts();
    var diagnostic_channel_1 = require_channel();
    var clients = [];
    var bunyanToAILevelMap = {
      10: Contracts_1.SeverityLevel.Verbose,
      20: Contracts_1.SeverityLevel.Verbose,
      30: Contracts_1.SeverityLevel.Information,
      40: Contracts_1.SeverityLevel.Warning,
      50: Contracts_1.SeverityLevel.Error,
      60: Contracts_1.SeverityLevel.Critical
    };
    var subscriber = function(event) {
      clients.forEach(function(client) {
        var AIlevel = bunyanToAILevelMap[event.data.level];
        client.trackTrace({ message: event.data.result, severity: AIlevel });
      });
    };
    function enable(enabled, client) {
      if (enabled) {
        if (clients.length === 0) {
          diagnostic_channel_1.channel.subscribe("bunyan", subscriber);
        }
        ;
        clients.push(client);
      } else {
        clients = clients.filter(function(c) {
          return c != client;
        });
        if (clients.length === 0) {
          diagnostic_channel_1.channel.unsubscribe("bunyan", subscriber);
        }
      }
    }
    exports2.enable = enable;
  }
});

// ../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/winston.sub.js
var require_winston_sub = __commonJS({
  "../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/winston.sub.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Contracts_1 = require_Contracts();
    var diagnostic_channel_1 = require_channel();
    var clients = [];
    var winstonToAILevelMap = {
      syslog: function(og) {
        var map = {
          emerg: Contracts_1.SeverityLevel.Critical,
          alert: Contracts_1.SeverityLevel.Critical,
          crit: Contracts_1.SeverityLevel.Critical,
          error: Contracts_1.SeverityLevel.Error,
          warning: Contracts_1.SeverityLevel.Warning,
          notice: Contracts_1.SeverityLevel.Information,
          info: Contracts_1.SeverityLevel.Information,
          debug: Contracts_1.SeverityLevel.Verbose
        };
        return map[og] === void 0 ? Contracts_1.SeverityLevel.Information : map[og];
      },
      npm: function(og) {
        var map = {
          error: Contracts_1.SeverityLevel.Error,
          warn: Contracts_1.SeverityLevel.Warning,
          info: Contracts_1.SeverityLevel.Information,
          verbose: Contracts_1.SeverityLevel.Verbose,
          debug: Contracts_1.SeverityLevel.Verbose,
          silly: Contracts_1.SeverityLevel.Verbose
        };
        return map[og] === void 0 ? Contracts_1.SeverityLevel.Information : map[og];
      },
      unknown: function(og) {
        return Contracts_1.SeverityLevel.Information;
      }
    };
    var subscriber = function(event) {
      clients.forEach(function(client) {
        var AIlevel = winstonToAILevelMap[event.data.levelKind](event.data.level);
        client.trackTrace({
          message: event.data.message,
          severity: AIlevel,
          properties: event.data.meta
        });
      });
    };
    function enable(enabled, client) {
      if (enabled) {
        if (clients.length === 0) {
          diagnostic_channel_1.channel.subscribe("winston", subscriber);
        }
        ;
        clients.push(client);
      } else {
        clients = clients.filter(function(c) {
          return c != client;
        });
        if (clients.length === 0) {
          diagnostic_channel_1.channel.unsubscribe("winston", subscriber);
        }
      }
    }
    exports2.enable = enable;
  }
});

// ../../node_modules/applicationinsights/out/AutoCollection/Console.js
var require_Console = __commonJS({
  "../../node_modules/applicationinsights/out/AutoCollection/Console.js"(exports2, module2) {
    "use strict";
    var DiagChannel = require_initialization();
    var AutoCollectConsole = function() {
      function AutoCollectConsole2(client) {
        if (!!AutoCollectConsole2.INSTANCE) {
          throw new Error("Console logging adapter tracking should be configured from the applicationInsights object");
        }
        this._client = client;
        AutoCollectConsole2.INSTANCE = this;
      }
      AutoCollectConsole2.prototype.enable = function(isEnabled, collectConsoleLog) {
        if (DiagChannel.IsInitialized) {
          require_console_sub().enable(isEnabled && collectConsoleLog, this._client);
          require_bunyan_sub().enable(isEnabled, this._client);
          require_winston_sub().enable(isEnabled, this._client);
        }
      };
      AutoCollectConsole2.prototype.isInitialized = function() {
        return this._isInitialized;
      };
      AutoCollectConsole2.prototype.dispose = function() {
        AutoCollectConsole2.INSTANCE = null;
        this.enable(false, false);
      };
      AutoCollectConsole2._methodNames = ["debug", "info", "log", "warn", "error"];
      return AutoCollectConsole2;
    }();
    module2.exports = AutoCollectConsole;
  }
});

// ../../node_modules/applicationinsights/out/AutoCollection/Exceptions.js
var require_Exceptions = __commonJS({
  "../../node_modules/applicationinsights/out/AutoCollection/Exceptions.js"(exports2, module2) {
    "use strict";
    var AutoCollectExceptions = function() {
      function AutoCollectExceptions2(client) {
        if (!!AutoCollectExceptions2.INSTANCE) {
          throw new Error("Exception tracking should be configured from the applicationInsights object");
        }
        AutoCollectExceptions2.INSTANCE = this;
        this._client = client;
      }
      Object.defineProperty(AutoCollectExceptions2, "UNCAUGHT_EXCEPTION_HANDLER_NAME", {
        get: function() {
          return "uncaughtException";
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(AutoCollectExceptions2, "UNHANDLED_REJECTION_HANDLER_NAME", {
        get: function() {
          return "unhandledRejection";
        },
        enumerable: true,
        configurable: true
      });
      AutoCollectExceptions2.prototype.isInitialized = function() {
        return this._isInitialized;
      };
      AutoCollectExceptions2.prototype.enable = function(isEnabled) {
        var _this = this;
        if (isEnabled) {
          this._isInitialized = true;
          var self2 = this;
          if (!this._exceptionListenerHandle) {
            var handle3 = function(reThrow, error3) {
              _this._client.trackException({ exception: error3 });
              _this._client.flush({ isAppCrashing: true });
              if (reThrow) {
                var THIS_IS_APPLICATION_INSIGHTS_RETHROWING_YOUR_EXCEPTION = error3;
                throw THIS_IS_APPLICATION_INSIGHTS_RETHROWING_YOUR_EXCEPTION;
              }
            };
            this._exceptionListenerHandle = handle3.bind(this, true);
            this._rejectionListenerHandle = handle3.bind(this, false);
            process.on(AutoCollectExceptions2.UNCAUGHT_EXCEPTION_HANDLER_NAME, this._exceptionListenerHandle);
            process.on(AutoCollectExceptions2.UNHANDLED_REJECTION_HANDLER_NAME, this._rejectionListenerHandle);
          }
        } else {
          if (this._exceptionListenerHandle) {
            process.removeListener(AutoCollectExceptions2.UNCAUGHT_EXCEPTION_HANDLER_NAME, this._exceptionListenerHandle);
            process.removeListener(AutoCollectExceptions2.UNHANDLED_REJECTION_HANDLER_NAME, this._rejectionListenerHandle);
            this._exceptionListenerHandle = void 0;
            this._rejectionListenerHandle = void 0;
            delete this._exceptionListenerHandle;
            delete this._rejectionListenerHandle;
          }
        }
      };
      AutoCollectExceptions2.prototype.dispose = function() {
        AutoCollectExceptions2.INSTANCE = null;
        this.enable(false);
        this._isInitialized = false;
      };
      AutoCollectExceptions2.INSTANCE = null;
      return AutoCollectExceptions2;
    }();
    module2.exports = AutoCollectExceptions;
  }
});

// ../../node_modules/applicationinsights/out/Declarations/Constants.js
var require_Constants2 = __commonJS({
  "../../node_modules/applicationinsights/out/Declarations/Constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var QuickPulseCounter;
    (function(QuickPulseCounter2) {
      QuickPulseCounter2["COMMITTED_BYTES"] = "\\Memory\\Committed Bytes";
      QuickPulseCounter2["PROCESSOR_TIME"] = "\\Processor(_Total)\\% Processor Time";
      QuickPulseCounter2["REQUEST_RATE"] = "\\ApplicationInsights\\Requests/Sec";
      QuickPulseCounter2["REQUEST_FAILURE_RATE"] = "\\ApplicationInsights\\Requests Failed/Sec";
      QuickPulseCounter2["REQUEST_DURATION"] = "\\ApplicationInsights\\Request Duration";
      QuickPulseCounter2["DEPENDENCY_RATE"] = "\\ApplicationInsights\\Dependency Calls/Sec";
      QuickPulseCounter2["DEPENDENCY_FAILURE_RATE"] = "\\ApplicationInsights\\Dependency Calls Failed/Sec";
      QuickPulseCounter2["DEPENDENCY_DURATION"] = "\\ApplicationInsights\\Dependency Call Duration";
      QuickPulseCounter2["EXCEPTION_RATE"] = "\\ApplicationInsights\\Exceptions/Sec";
    })(QuickPulseCounter = exports2.QuickPulseCounter || (exports2.QuickPulseCounter = {}));
    var PerformanceCounter;
    (function(PerformanceCounter2) {
      PerformanceCounter2["PRIVATE_BYTES"] = "\\Process(??APP_WIN32_PROC??)\\Private Bytes";
      PerformanceCounter2["AVAILABLE_BYTES"] = "\\Memory\\Available Bytes";
      PerformanceCounter2["PROCESSOR_TIME"] = "\\Processor(_Total)\\% Processor Time";
      PerformanceCounter2["PROCESS_TIME"] = "\\Process(??APP_WIN32_PROC??)\\% Processor Time";
      PerformanceCounter2["REQUEST_RATE"] = "\\ASP.NET Applications(??APP_W3SVC_PROC??)\\Requests/Sec";
      PerformanceCounter2["REQUEST_DURATION"] = "\\ASP.NET Applications(??APP_W3SVC_PROC??)\\Request Execution Time";
    })(PerformanceCounter = exports2.PerformanceCounter || (exports2.PerformanceCounter = {}));
    exports2.PerformanceToQuickPulseCounter = (_a2 = {}, _a2[PerformanceCounter.PROCESSOR_TIME] = QuickPulseCounter.PROCESSOR_TIME, _a2[PerformanceCounter.REQUEST_RATE] = QuickPulseCounter.REQUEST_RATE, _a2[PerformanceCounter.REQUEST_DURATION] = QuickPulseCounter.REQUEST_DURATION, _a2[QuickPulseCounter.COMMITTED_BYTES] = QuickPulseCounter.COMMITTED_BYTES, _a2[QuickPulseCounter.REQUEST_FAILURE_RATE] = QuickPulseCounter.REQUEST_FAILURE_RATE, _a2[QuickPulseCounter.DEPENDENCY_RATE] = QuickPulseCounter.DEPENDENCY_RATE, _a2[QuickPulseCounter.DEPENDENCY_FAILURE_RATE] = QuickPulseCounter.DEPENDENCY_FAILURE_RATE, _a2[QuickPulseCounter.DEPENDENCY_DURATION] = QuickPulseCounter.DEPENDENCY_DURATION, _a2[QuickPulseCounter.EXCEPTION_RATE] = QuickPulseCounter.EXCEPTION_RATE, _a2);
    exports2.QuickPulseDocumentType = {
      Event: "Event",
      Exception: "Exception",
      Trace: "Trace",
      Metric: "Metric",
      Request: "Request",
      Dependency: "RemoteDependency"
    };
    exports2.QuickPulseType = {
      Event: "EventTelemetryDocument",
      Exception: "ExceptionTelemetryDocument",
      Trace: "TraceTelemetryDocument",
      Metric: "MetricTelemetryDocument",
      Request: "RequestTelemetryDocument",
      Dependency: "DependencyTelemetryDocument"
    };
    exports2.TelemetryTypeStringToQuickPulseType = {
      EventData: exports2.QuickPulseType.Event,
      ExceptionData: exports2.QuickPulseType.Exception,
      MessageData: exports2.QuickPulseType.Trace,
      MetricData: exports2.QuickPulseType.Metric,
      RequestData: exports2.QuickPulseType.Request,
      RemoteDependencyData: exports2.QuickPulseType.Dependency
    };
    exports2.TelemetryTypeStringToQuickPulseDocumentType = {
      EventData: exports2.QuickPulseDocumentType.Event,
      ExceptionData: exports2.QuickPulseDocumentType.Exception,
      MessageData: exports2.QuickPulseDocumentType.Trace,
      MetricData: exports2.QuickPulseDocumentType.Metric,
      RequestData: exports2.QuickPulseDocumentType.Request,
      RemoteDependencyData: exports2.QuickPulseDocumentType.Dependency
    };
    var _a2;
  }
});

// ../../node_modules/applicationinsights/out/AutoCollection/Performance.js
var require_Performance = __commonJS({
  "../../node_modules/applicationinsights/out/AutoCollection/Performance.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var Logging = require_Logging();
    var Constants = require_Constants2();
    var AutoCollectPerformance = function() {
      function AutoCollectPerformance2(client, collectionInterval, enableLiveMetricsCounters) {
        if (collectionInterval === void 0) {
          collectionInterval = 6e4;
        }
        if (enableLiveMetricsCounters === void 0) {
          enableLiveMetricsCounters = false;
        }
        if (!AutoCollectPerformance2.INSTANCE) {
          AutoCollectPerformance2.INSTANCE = this;
        }
        this._isInitialized = false;
        this._client = client;
        this._collectionInterval = collectionInterval;
        this._enableLiveMetricsCounters = enableLiveMetricsCounters;
      }
      AutoCollectPerformance2.prototype.enable = function(isEnabled, collectionInterval) {
        var _this = this;
        this._isEnabled = isEnabled;
        if (this._isEnabled && !this._isInitialized) {
          this._isInitialized = true;
        }
        if (isEnabled) {
          if (!this._handle) {
            this._lastCpus = os.cpus();
            this._lastRequests = {
              totalRequestCount: AutoCollectPerformance2._totalRequestCount,
              totalFailedRequestCount: AutoCollectPerformance2._totalFailedRequestCount,
              time: +new Date()
            };
            this._lastDependencies = {
              totalDependencyCount: AutoCollectPerformance2._totalDependencyCount,
              totalFailedDependencyCount: AutoCollectPerformance2._totalFailedDependencyCount,
              time: +new Date()
            };
            this._lastExceptions = {
              totalExceptionCount: AutoCollectPerformance2._totalExceptionCount,
              time: +new Date()
            };
            if (typeof process.cpuUsage === "function") {
              this._lastAppCpuUsage = process.cpuUsage();
            }
            this._lastHrtime = process.hrtime();
            this._collectionInterval = collectionInterval || this._collectionInterval;
            this._handle = setInterval(function() {
              return _this.trackPerformance();
            }, this._collectionInterval);
            this._handle.unref();
          }
        } else {
          if (this._handle) {
            clearInterval(this._handle);
            this._handle = void 0;
          }
        }
      };
      AutoCollectPerformance2.countRequest = function(request, response) {
        var _this = this;
        if (!AutoCollectPerformance2.isEnabled()) {
          return;
        }
        var start = +new Date();
        if (!request || !response) {
          Logging.warn("AutoCollectPerformance.countRequest was called with invalid parameters: ", !!request, !!response);
          return;
        }
        if (typeof response.once === "function") {
          response.once("finish", function() {
            var end = +new Date();
            AutoCollectPerformance2._intervalRequestExecutionTime += _this._lastRequestExecutionTime = end - start;
            AutoCollectPerformance2._totalRequestCount++;
            if (response.statusCode >= 400) {
              AutoCollectPerformance2._totalFailedRequestCount++;
            }
          });
        }
      };
      AutoCollectPerformance2.countException = function() {
        AutoCollectPerformance2._totalExceptionCount++;
      };
      AutoCollectPerformance2.countDependency = function(duration, success) {
        var durationMs;
        if (!AutoCollectPerformance2.isEnabled()) {
          return;
        }
        if (typeof duration === "string") {
          durationMs = +new Date("1970-01-01T" + duration + "Z");
        } else if (typeof duration === "number") {
          durationMs = duration;
        } else {
          return;
        }
        AutoCollectPerformance2._intervalDependencyExecutionTime += durationMs;
        if (success === false) {
          AutoCollectPerformance2._totalFailedDependencyCount++;
        }
        AutoCollectPerformance2._totalDependencyCount++;
      };
      AutoCollectPerformance2.prototype.isInitialized = function() {
        return this._isInitialized;
      };
      AutoCollectPerformance2.isEnabled = function() {
        return AutoCollectPerformance2.INSTANCE && AutoCollectPerformance2.INSTANCE._isEnabled;
      };
      AutoCollectPerformance2.prototype.trackPerformance = function() {
        this._trackCpu();
        this._trackMemory();
        this._trackNetwork();
        this._trackDependencyRate();
        this._trackExceptionRate();
      };
      AutoCollectPerformance2.prototype._trackCpu = function() {
        var cpus = os.cpus();
        if (cpus && cpus.length && this._lastCpus && cpus.length === this._lastCpus.length) {
          var totalUser = 0;
          var totalSys = 0;
          var totalNice = 0;
          var totalIdle = 0;
          var totalIrq = 0;
          for (var i = 0; !!cpus && i < cpus.length; i++) {
            var cpu = cpus[i];
            var lastCpu = this._lastCpus[i];
            var name = "% cpu(" + i + ") ";
            var model = cpu.model;
            var speed = cpu.speed;
            var times = cpu.times;
            var lastTimes = lastCpu.times;
            var user = times.user - lastTimes.user || 0;
            totalUser += user;
            var sys = times.sys - lastTimes.sys || 0;
            totalSys += sys;
            var nice = times.nice - lastTimes.nice || 0;
            totalNice += nice;
            var idle = times.idle - lastTimes.idle || 0;
            totalIdle += idle;
            var irq = times.irq - lastTimes.irq || 0;
            totalIrq += irq;
          }
          var appCpuPercent = void 0;
          if (typeof process.cpuUsage === "function") {
            var appCpuUsage = process.cpuUsage();
            var hrtime = process.hrtime();
            var totalApp = appCpuUsage.user - this._lastAppCpuUsage.user + (appCpuUsage.system - this._lastAppCpuUsage.system) || 0;
            if (typeof this._lastHrtime !== "undefined" && this._lastHrtime.length === 2) {
              var elapsedTime = (hrtime[0] - this._lastHrtime[0]) * 1e6 + (hrtime[1] - this._lastHrtime[1]) / 1e3 || 0;
              appCpuPercent = 100 * totalApp / (elapsedTime * cpus.length);
            }
            this._lastAppCpuUsage = appCpuUsage;
            this._lastHrtime = hrtime;
          }
          var combinedTotal = totalUser + totalSys + totalNice + totalIdle + totalIrq || 1;
          this._client.trackMetric({ name: Constants.PerformanceCounter.PROCESSOR_TIME, value: (combinedTotal - totalIdle) / combinedTotal * 100 });
          this._client.trackMetric({ name: Constants.PerformanceCounter.PROCESS_TIME, value: appCpuPercent || totalUser / combinedTotal * 100 });
        }
        this._lastCpus = cpus;
      };
      AutoCollectPerformance2.prototype._trackMemory = function() {
        var freeMem = os.freemem();
        var usedMem = process.memoryUsage().rss;
        var committedMemory = os.totalmem() - freeMem;
        this._client.trackMetric({ name: Constants.PerformanceCounter.PRIVATE_BYTES, value: usedMem });
        this._client.trackMetric({ name: Constants.PerformanceCounter.AVAILABLE_BYTES, value: freeMem });
        if (this._enableLiveMetricsCounters) {
          this._client.trackMetric({ name: Constants.QuickPulseCounter.COMMITTED_BYTES, value: committedMemory });
        }
      };
      AutoCollectPerformance2.prototype._trackNetwork = function() {
        var lastRequests = this._lastRequests;
        var requests = {
          totalRequestCount: AutoCollectPerformance2._totalRequestCount,
          totalFailedRequestCount: AutoCollectPerformance2._totalFailedRequestCount,
          time: +new Date()
        };
        var intervalRequests = requests.totalRequestCount - lastRequests.totalRequestCount || 0;
        var intervalFailedRequests = requests.totalFailedRequestCount - lastRequests.totalFailedRequestCount || 0;
        var elapsedMs = requests.time - lastRequests.time;
        var elapsedSeconds = elapsedMs / 1e3;
        var averageRequestExecutionTime = AutoCollectPerformance2._intervalRequestExecutionTime / intervalRequests || 0;
        AutoCollectPerformance2._intervalRequestExecutionTime = 0;
        if (elapsedMs > 0) {
          var requestsPerSec = intervalRequests / elapsedSeconds;
          var failedRequestsPerSec = intervalFailedRequests / elapsedSeconds;
          this._client.trackMetric({ name: Constants.PerformanceCounter.REQUEST_RATE, value: requestsPerSec });
          if (!this._enableLiveMetricsCounters || intervalRequests > 0) {
            this._client.trackMetric({ name: Constants.PerformanceCounter.REQUEST_DURATION, value: averageRequestExecutionTime });
          }
          if (this._enableLiveMetricsCounters) {
            this._client.trackMetric({ name: Constants.QuickPulseCounter.REQUEST_FAILURE_RATE, value: failedRequestsPerSec });
          }
        }
        this._lastRequests = requests;
      };
      AutoCollectPerformance2.prototype._trackDependencyRate = function() {
        if (this._enableLiveMetricsCounters) {
          var lastDependencies = this._lastDependencies;
          var dependencies = {
            totalDependencyCount: AutoCollectPerformance2._totalDependencyCount,
            totalFailedDependencyCount: AutoCollectPerformance2._totalFailedDependencyCount,
            time: +new Date()
          };
          var intervalDependencies = dependencies.totalDependencyCount - lastDependencies.totalDependencyCount || 0;
          var intervalFailedDependencies = dependencies.totalFailedDependencyCount - lastDependencies.totalFailedDependencyCount || 0;
          var elapsedMs = dependencies.time - lastDependencies.time;
          var elapsedSeconds = elapsedMs / 1e3;
          var averageDependencyExecutionTime = AutoCollectPerformance2._intervalDependencyExecutionTime / intervalDependencies || 0;
          AutoCollectPerformance2._intervalDependencyExecutionTime = 0;
          if (elapsedMs > 0) {
            var dependenciesPerSec = intervalDependencies / elapsedSeconds;
            var failedDependenciesPerSec = intervalFailedDependencies / elapsedSeconds;
            this._client.trackMetric({ name: Constants.QuickPulseCounter.DEPENDENCY_RATE, value: dependenciesPerSec });
            this._client.trackMetric({ name: Constants.QuickPulseCounter.DEPENDENCY_FAILURE_RATE, value: failedDependenciesPerSec });
            if (!this._enableLiveMetricsCounters || intervalDependencies > 0) {
              this._client.trackMetric({ name: Constants.QuickPulseCounter.DEPENDENCY_DURATION, value: averageDependencyExecutionTime });
            }
          }
          this._lastDependencies = dependencies;
        }
      };
      AutoCollectPerformance2.prototype._trackExceptionRate = function() {
        if (this._enableLiveMetricsCounters) {
          var lastExceptions = this._lastExceptions;
          var exceptions = {
            totalExceptionCount: AutoCollectPerformance2._totalExceptionCount,
            time: +new Date()
          };
          var intervalExceptions = exceptions.totalExceptionCount - lastExceptions.totalExceptionCount || 0;
          var elapsedMs = exceptions.time - lastExceptions.time;
          var elapsedSeconds = elapsedMs / 1e3;
          if (elapsedMs > 0) {
            var exceptionsPerSec = intervalExceptions / elapsedSeconds;
            this._client.trackMetric({ name: Constants.QuickPulseCounter.EXCEPTION_RATE, value: exceptionsPerSec });
          }
          this._lastExceptions = exceptions;
        }
      };
      AutoCollectPerformance2.prototype.dispose = function() {
        AutoCollectPerformance2.INSTANCE = null;
        this.enable(false);
        this._isInitialized = false;
      };
      AutoCollectPerformance2._totalRequestCount = 0;
      AutoCollectPerformance2._totalFailedRequestCount = 0;
      AutoCollectPerformance2._lastRequestExecutionTime = 0;
      AutoCollectPerformance2._totalDependencyCount = 0;
      AutoCollectPerformance2._totalFailedDependencyCount = 0;
      AutoCollectPerformance2._lastDependencyExecutionTime = 0;
      AutoCollectPerformance2._totalExceptionCount = 0;
      AutoCollectPerformance2._intervalDependencyExecutionTime = 0;
      AutoCollectPerformance2._intervalRequestExecutionTime = 0;
      return AutoCollectPerformance2;
    }();
    module2.exports = AutoCollectPerformance;
  }
});

// ../../node_modules/applicationinsights/out/Library/RequestResponseHeaders.js
var require_RequestResponseHeaders = __commonJS({
  "../../node_modules/applicationinsights/out/Library/RequestResponseHeaders.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      requestContextHeader: "request-context",
      requestContextSourceKey: "appId",
      requestContextTargetKey: "appId",
      requestIdHeader: "request-id",
      parentIdHeader: "x-ms-request-id",
      rootIdHeader: "x-ms-request-root-id",
      correlationContextHeader: "correlation-context",
      traceparentHeader: "traceparent",
      traceStateHeader: "tracestate"
    };
  }
});

// ../../node_modules/applicationinsights/out/Library/Util.js
var require_Util = __commonJS({
  "../../node_modules/applicationinsights/out/Library/Util.js"(exports2, module2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    var http = require("http");
    var https = require("https");
    var url = require("url");
    var constants = require("constants");
    var Logging = require_Logging();
    var RequestResponseHeaders = require_RequestResponseHeaders();
    var Util = function() {
      function Util2() {
      }
      Util2.getCookie = function(name, cookie) {
        var value = "";
        if (name && name.length && typeof cookie === "string") {
          var cookieName = name + "=";
          var cookies = cookie.split(";");
          for (var i = 0; i < cookies.length; i++) {
            var cookie = cookies[i];
            cookie = Util2.trim(cookie);
            if (cookie && cookie.indexOf(cookieName) === 0) {
              value = cookie.substring(cookieName.length, cookies[i].length);
              break;
            }
          }
        }
        return value;
      };
      Util2.trim = function(str) {
        if (typeof str === "string") {
          return str.replace(/^\s+|\s+$/g, "");
        } else {
          return "";
        }
      };
      Util2.int32ArrayToBase64 = function(array) {
        var toChar = function(v, i) {
          return String.fromCharCode(v >> i & 255);
        };
        var int32AsString = function(v) {
          return toChar(v, 24) + toChar(v, 16) + toChar(v, 8) + toChar(v, 0);
        };
        var x = array.map(int32AsString).join("");
        var b = Buffer.from ? Buffer.from(x, "binary") : new Buffer(x, "binary");
        var s = b.toString("base64");
        return s.substr(0, s.indexOf("="));
      };
      Util2.random32 = function() {
        return 4294967296 * Math.random() | 0;
      };
      Util2.randomu32 = function() {
        return Util2.random32() + 2147483648;
      };
      Util2.w3cTraceId = function() {
        var hexValues = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
        var oct = "", tmp;
        for (var a = 0; a < 4; a++) {
          tmp = Util2.random32();
          oct += hexValues[tmp & 15] + hexValues[tmp >> 4 & 15] + hexValues[tmp >> 8 & 15] + hexValues[tmp >> 12 & 15] + hexValues[tmp >> 16 & 15] + hexValues[tmp >> 20 & 15] + hexValues[tmp >> 24 & 15] + hexValues[tmp >> 28 & 15];
        }
        var clockSequenceHi = hexValues[8 + Math.random() * 4 | 0];
        return oct.substr(0, 8) + oct.substr(9, 4) + "4" + oct.substr(13, 3) + clockSequenceHi + oct.substr(16, 3) + oct.substr(19, 12);
      };
      Util2.isValidW3CId = function(id) {
        return id.length === 32 && id !== "00000000000000000000000000000000";
      };
      Util2.isArray = function(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      };
      Util2.isError = function(obj) {
        return obj instanceof Error;
      };
      Util2.isPrimitive = function(input) {
        var propType = typeof input;
        return propType === "string" || propType === "number" || propType === "boolean";
      };
      Util2.isDate = function(obj) {
        return Object.prototype.toString.call(obj) === "[object Date]";
      };
      Util2.msToTimeSpan = function(totalms) {
        if (isNaN(totalms) || totalms < 0) {
          totalms = 0;
        }
        var sec = (totalms / 1e3 % 60).toFixed(7).replace(/0{0,4}$/, "");
        var min = "" + Math.floor(totalms / (1e3 * 60)) % 60;
        var hour = "" + Math.floor(totalms / (1e3 * 60 * 60)) % 24;
        var days = Math.floor(totalms / (1e3 * 60 * 60 * 24));
        sec = sec.indexOf(".") < 2 ? "0" + sec : sec;
        min = min.length < 2 ? "0" + min : min;
        hour = hour.length < 2 ? "0" + hour : hour;
        var daysText = days > 0 ? days + "." : "";
        return daysText + hour + ":" + min + ":" + sec;
      };
      Util2.extractError = function(err) {
        var looseError = err;
        return {
          message: err.message,
          code: looseError.code || looseError.id || ""
        };
      };
      Util2.extractObject = function(origProperty) {
        if (origProperty instanceof Error) {
          return Util2.extractError(origProperty);
        }
        if (typeof origProperty.toJSON === "function") {
          return origProperty.toJSON();
        }
        return origProperty;
      };
      Util2.validateStringMap = function(obj) {
        if (typeof obj !== "object") {
          Logging.info("Invalid properties dropped from payload");
          return;
        }
        var map = {};
        for (var field in obj) {
          var property = "";
          var origProperty = obj[field];
          var propType = typeof origProperty;
          if (Util2.isPrimitive(origProperty)) {
            property = origProperty.toString();
          } else if (origProperty === null || propType === "undefined") {
            property = "";
          } else if (propType === "function") {
            Logging.info("key: " + field + " was function; will not serialize");
            continue;
          } else {
            var stringTarget = Util2.isArray(origProperty) ? origProperty : Util2.extractObject(origProperty);
            try {
              if (Util2.isPrimitive(stringTarget)) {
                property = stringTarget;
              } else {
                property = JSON.stringify(stringTarget);
              }
            } catch (e) {
              property = origProperty.constructor.name.toString() + " (Error: " + e.message + ")";
              Logging.info("key: " + field + ", could not be serialized");
            }
          }
          map[field] = property.substring(0, Util2.MAX_PROPERTY_LENGTH);
        }
        return map;
      };
      Util2.canIncludeCorrelationHeader = function(client, requestUrl) {
        var excludedDomains = client && client.config && client.config.correlationHeaderExcludedDomains;
        if (!excludedDomains || excludedDomains.length == 0 || !requestUrl) {
          return true;
        }
        for (var i = 0; i < excludedDomains.length; i++) {
          var regex = new RegExp(excludedDomains[i].replace(/\./g, ".").replace(/\*/g, ".*"));
          if (regex.test(url.parse(requestUrl).hostname)) {
            return false;
          }
        }
        return true;
      };
      Util2.getCorrelationContextTarget = function(response, key) {
        var contextHeaders = response.headers && response.headers[RequestResponseHeaders.requestContextHeader];
        if (contextHeaders) {
          var keyValues = contextHeaders.split(",");
          for (var i = 0; i < keyValues.length; ++i) {
            var keyValue = keyValues[i].split("=");
            if (keyValue.length == 2 && keyValue[0] == key) {
              return keyValue[1];
            }
          }
        }
      };
      Util2.makeRequest = function(config, requestUrl, requestOptions, requestCallback) {
        if (requestUrl && requestUrl.indexOf("//") === 0) {
          requestUrl = "https:" + requestUrl;
        }
        var requestUrlParsed = url.parse(requestUrl);
        var options2 = __assign({}, requestOptions, { host: requestUrlParsed.hostname, port: requestUrlParsed.port, path: requestUrlParsed.pathname });
        var proxyUrl = void 0;
        if (requestUrlParsed.protocol === "https:") {
          proxyUrl = config.proxyHttpsUrl || void 0;
        }
        if (requestUrlParsed.protocol === "http:") {
          proxyUrl = config.proxyHttpUrl || void 0;
        }
        if (proxyUrl) {
          if (proxyUrl.indexOf("//") === 0) {
            proxyUrl = "http:" + proxyUrl;
          }
          var proxyUrlParsed = url.parse(proxyUrl);
          if (proxyUrlParsed.protocol === "https:") {
            Logging.info("Proxies that use HTTPS are not supported");
            proxyUrl = void 0;
          } else {
            options2 = __assign({}, options2, { host: proxyUrlParsed.hostname, port: proxyUrlParsed.port || "80", path: requestUrl, headers: __assign({}, options2.headers, { Host: requestUrlParsed.hostname }) });
          }
        }
        var isHttps = requestUrlParsed.protocol === "https:" && !proxyUrl;
        if (isHttps && config.httpsAgent !== void 0) {
          options2.agent = config.httpsAgent;
        } else if (!isHttps && config.httpAgent !== void 0) {
          options2.agent = config.httpAgent;
        } else if (isHttps) {
          options2.agent = Util2.tlsRestrictedAgent;
        }
        if (isHttps) {
          return https.request(options2, requestCallback);
        } else {
          return http.request(options2, requestCallback);
        }
      };
      ;
      Util2.safeIncludeCorrelationHeader = function(client, request, correlationHeader) {
        var header;
        if (typeof correlationHeader === "string") {
          header = correlationHeader;
        } else if (correlationHeader instanceof Array) {
          header = correlationHeader.join(",");
        } else if (correlationHeader && typeof correlationHeader.toString === "function") {
          try {
            header = correlationHeader.toString();
          } catch (err) {
            Logging.warn("Outgoing request-context header could not be read. Correlation of requests may be lost.", err, correlationHeader);
          }
        }
        if (header) {
          Util2.addCorrelationIdHeaderFromString(client, request, header);
        } else {
          request.setHeader(RequestResponseHeaders.requestContextHeader, RequestResponseHeaders.requestContextSourceKey + "=" + client.config.correlationId);
        }
      };
      Util2.addCorrelationIdHeaderFromString = function(client, response, correlationHeader) {
        var components = correlationHeader.split(",");
        var key = RequestResponseHeaders.requestContextSourceKey + "=";
        var found = components.some(function(value) {
          return value.substring(0, key.length) === key;
        });
        if (!found) {
          response.setHeader(RequestResponseHeaders.requestContextHeader, correlationHeader + "," + RequestResponseHeaders.requestContextSourceKey + "=" + client.config.correlationId);
        }
      };
      Util2.MAX_PROPERTY_LENGTH = 8192;
      Util2.tlsRestrictedAgent = new https.Agent({
        secureOptions: constants.SSL_OP_NO_SSLv2 | constants.SSL_OP_NO_SSLv3 | constants.SSL_OP_NO_TLSv1 | constants.SSL_OP_NO_TLSv1_1
      });
      return Util2;
    }();
    module2.exports = Util;
  }
});

// ../../node_modules/applicationinsights/out/AutoCollection/RequestParser.js
var require_RequestParser = __commonJS({
  "../../node_modules/applicationinsights/out/AutoCollection/RequestParser.js"(exports2, module2) {
    "use strict";
    var RequestParser = function() {
      function RequestParser2() {
      }
      RequestParser2.prototype.getUrl = function() {
        return this.url;
      };
      RequestParser2.prototype.RequestParser = function() {
        this.startTime = +new Date();
      };
      RequestParser2.prototype._setStatus = function(status, error3) {
        var endTime = +new Date();
        this.duration = endTime - this.startTime;
        this.statusCode = status;
        var properties = this.properties || {};
        if (error3) {
          if (typeof error3 === "string") {
            properties["error"] = error3;
          } else if (error3 instanceof Error) {
            properties["error"] = error3.message;
          } else if (typeof error3 === "object") {
            for (var key in error3) {
              properties[key] = error3[key] && error3[key].toString && error3[key].toString();
            }
          }
        }
        this.properties = properties;
      };
      RequestParser2.prototype._isSuccess = function() {
        return 0 < this.statusCode && this.statusCode < 400;
      };
      return RequestParser2;
    }();
    module2.exports = RequestParser;
  }
});

// ../../node_modules/applicationinsights/out/Library/CorrelationIdManager.js
var require_CorrelationIdManager = __commonJS({
  "../../node_modules/applicationinsights/out/Library/CorrelationIdManager.js"(exports2, module2) {
    "use strict";
    var Util = require_Util();
    var Logging = require_Logging();
    var CorrelationIdManager = function() {
      function CorrelationIdManager2() {
      }
      CorrelationIdManager2.queryCorrelationId = function(config, callback) {
        var appIdUrlString = config.profileQueryEndpoint + "/api/profiles/" + config.instrumentationKey + "/appId";
        if (CorrelationIdManager2.completedLookups.hasOwnProperty(appIdUrlString)) {
          callback(CorrelationIdManager2.completedLookups[appIdUrlString]);
          return;
        } else if (CorrelationIdManager2.pendingLookups[appIdUrlString]) {
          CorrelationIdManager2.pendingLookups[appIdUrlString].push(callback);
          return;
        }
        CorrelationIdManager2.pendingLookups[appIdUrlString] = [callback];
        var fetchAppId = function() {
          if (!CorrelationIdManager2.pendingLookups[appIdUrlString]) {
            return;
          }
          var requestOptions = {
            method: "GET",
            disableAppInsightsAutoCollection: true
          };
          Logging.info(CorrelationIdManager2.TAG, requestOptions);
          var req = Util.makeRequest(config, appIdUrlString, requestOptions, function(res) {
            if (res.statusCode === 200) {
              var appId_1 = "";
              res.setEncoding("utf-8");
              res.on("data", function(data2) {
                appId_1 += data2;
              });
              res.on("end", function() {
                Logging.info(CorrelationIdManager2.TAG, appId_1);
                var result2 = CorrelationIdManager2.correlationIdPrefix + appId_1;
                CorrelationIdManager2.completedLookups[appIdUrlString] = result2;
                if (CorrelationIdManager2.pendingLookups[appIdUrlString]) {
                  CorrelationIdManager2.pendingLookups[appIdUrlString].forEach(function(cb) {
                    return cb(result2);
                  });
                }
                delete CorrelationIdManager2.pendingLookups[appIdUrlString];
              });
            } else if (res.statusCode >= 400 && res.statusCode < 500) {
              CorrelationIdManager2.completedLookups[appIdUrlString] = void 0;
              delete CorrelationIdManager2.pendingLookups[appIdUrlString];
            } else {
              setTimeout(fetchAppId, config.correlationIdRetryIntervalMs);
            }
          });
          if (req) {
            req.on("error", function(error3) {
              Logging.warn(CorrelationIdManager2.TAG, error3);
            });
            req.end();
          }
        };
        setTimeout(fetchAppId, 0);
      };
      CorrelationIdManager2.cancelCorrelationIdQuery = function(config, callback) {
        var appIdUrlString = config.profileQueryEndpoint + "/api/profiles/" + config.instrumentationKey + "/appId";
        var pendingLookups = CorrelationIdManager2.pendingLookups[appIdUrlString];
        if (pendingLookups) {
          CorrelationIdManager2.pendingLookups[appIdUrlString] = pendingLookups.filter(function(cb) {
            return cb != callback;
          });
          if (CorrelationIdManager2.pendingLookups[appIdUrlString].length == 0) {
            delete CorrelationIdManager2.pendingLookups[appIdUrlString];
          }
        }
      };
      CorrelationIdManager2.generateRequestId = function(parentId) {
        if (parentId) {
          parentId = parentId[0] == "|" ? parentId : "|" + parentId;
          if (parentId[parentId.length - 1] !== ".") {
            parentId += ".";
          }
          var suffix = (CorrelationIdManager2.currentRootId++).toString(16);
          return CorrelationIdManager2.appendSuffix(parentId, suffix, "_");
        } else {
          return CorrelationIdManager2.generateRootId();
        }
      };
      CorrelationIdManager2.getRootId = function(id) {
        var endIndex = id.indexOf(".");
        if (endIndex < 0) {
          endIndex = id.length;
        }
        var startIndex = id[0] === "|" ? 1 : 0;
        return id.substring(startIndex, endIndex);
      };
      CorrelationIdManager2.generateRootId = function() {
        return "|" + Util.w3cTraceId() + ".";
      };
      CorrelationIdManager2.appendSuffix = function(parentId, suffix, delimiter) {
        if (parentId.length + suffix.length < CorrelationIdManager2.requestIdMaxLength) {
          return parentId + suffix + delimiter;
        }
        var trimPosition = CorrelationIdManager2.requestIdMaxLength - 9;
        if (parentId.length > trimPosition) {
          for (; trimPosition > 1; --trimPosition) {
            var c = parentId[trimPosition - 1];
            if (c === "." || c === "_") {
              break;
            }
          }
        }
        if (trimPosition <= 1) {
          return CorrelationIdManager2.generateRootId();
        }
        suffix = Util.randomu32().toString(16);
        while (suffix.length < 8) {
          suffix = "0" + suffix;
        }
        return parentId.substring(0, trimPosition) + suffix + "#";
      };
      CorrelationIdManager2.TAG = "CorrelationIdManager";
      CorrelationIdManager2.correlationIdPrefix = "cid-v1:";
      CorrelationIdManager2.w3cEnabled = false;
      CorrelationIdManager2.pendingLookups = {};
      CorrelationIdManager2.completedLookups = {};
      CorrelationIdManager2.requestIdMaxLength = 1024;
      CorrelationIdManager2.currentRootId = Util.randomu32();
      return CorrelationIdManager2;
    }();
    module2.exports = CorrelationIdManager;
  }
});

// ../../node_modules/applicationinsights/out/AutoCollection/HttpDependencyParser.js
var require_HttpDependencyParser = __commonJS({
  "../../node_modules/applicationinsights/out/AutoCollection/HttpDependencyParser.js"(exports2, module2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (b.hasOwnProperty(p))
            d[p] = b[p];
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var url = require("url");
    var Contracts = require_Contracts();
    var Util = require_Util();
    var RequestResponseHeaders = require_RequestResponseHeaders();
    var RequestParser = require_RequestParser();
    var CorrelationIdManager = require_CorrelationIdManager();
    var HttpDependencyParser = function(_super) {
      __extends2(HttpDependencyParser2, _super);
      function HttpDependencyParser2(requestOptions, request) {
        var _this = _super.call(this) || this;
        if (request && request.method && requestOptions) {
          _this.method = request.method;
          _this.url = HttpDependencyParser2._getUrlFromRequestOptions(requestOptions, request);
          _this.startTime = +new Date();
        }
        return _this;
      }
      HttpDependencyParser2.prototype.onError = function(error3) {
        this._setStatus(void 0, error3);
      };
      HttpDependencyParser2.prototype.onResponse = function(response) {
        this._setStatus(response.statusCode, void 0);
        this.correlationId = Util.getCorrelationContextTarget(response, RequestResponseHeaders.requestContextTargetKey);
      };
      HttpDependencyParser2.prototype.getDependencyTelemetry = function(baseTelemetry, dependencyId) {
        var urlObject = url.parse(this.url);
        urlObject.search = void 0;
        urlObject.hash = void 0;
        var dependencyName = this.method.toUpperCase() + " " + urlObject.pathname;
        var remoteDependencyType = Contracts.RemoteDependencyDataConstants.TYPE_HTTP;
        var remoteDependencyTarget = urlObject.hostname;
        if (this.correlationId) {
          remoteDependencyType = Contracts.RemoteDependencyDataConstants.TYPE_AI;
          if (this.correlationId !== CorrelationIdManager.correlationIdPrefix) {
            remoteDependencyTarget = urlObject.hostname + " | " + this.correlationId;
          }
        } else {
          remoteDependencyType = Contracts.RemoteDependencyDataConstants.TYPE_HTTP;
        }
        var dependencyTelemetry = {
          id: dependencyId,
          name: dependencyName,
          data: this.url,
          duration: this.duration,
          success: this._isSuccess(),
          resultCode: this.statusCode ? this.statusCode.toString() : null,
          properties: this.properties || {},
          dependencyTypeName: remoteDependencyType,
          target: remoteDependencyTarget
        };
        if (baseTelemetry) {
          for (var key in baseTelemetry) {
            if (!dependencyTelemetry[key]) {
              dependencyTelemetry[key] = baseTelemetry[key];
            }
          }
          if (baseTelemetry.properties) {
            for (var key in baseTelemetry.properties) {
              dependencyTelemetry.properties[key] = baseTelemetry.properties[key];
            }
          }
        }
        return dependencyTelemetry;
      };
      HttpDependencyParser2._getUrlFromRequestOptions = function(options2, request) {
        if (typeof options2 === "string") {
          options2 = url.parse(options2);
        } else {
          var originalOptions_1 = options2;
          options2 = {};
          if (originalOptions_1) {
            Object.keys(originalOptions_1).forEach(function(key) {
              options2[key] = originalOptions_1[key];
            });
          }
        }
        if (options2.path) {
          var parsedQuery = url.parse(options2.path);
          options2.pathname = parsedQuery.pathname;
          options2.search = parsedQuery.search;
        }
        if (options2.host && options2.port) {
          var parsedHost = url.parse("http://" + options2.host);
          if (!parsedHost.port && options2.port) {
            options2.hostname = options2.host;
            delete options2.host;
          }
        }
        options2.protocol = options2.protocol || request.agent && request.agent.protocol || void 0;
        options2.hostname = options2.hostname || "localhost";
        return url.format(options2);
      };
      return HttpDependencyParser2;
    }(RequestParser);
    module2.exports = HttpDependencyParser;
  }
});

// ../../node_modules/applicationinsights/out/Library/Traceparent.js
var require_Traceparent = __commonJS({
  "../../node_modules/applicationinsights/out/Library/Traceparent.js"(exports2, module2) {
    "use strict";
    var Util = require_Util();
    var CorrelationIdManager = require_CorrelationIdManager();
    var Traceparent = function() {
      function Traceparent2(traceparent, parentId) {
        this.traceFlag = Traceparent2.DEFAULT_TRACE_FLAG;
        this.version = Traceparent2.DEFAULT_VERSION;
        if (traceparent && typeof traceparent === "string") {
          if (traceparent.split(",").length > 1) {
            this.traceId = Util.w3cTraceId();
            this.spanId = Util.w3cTraceId().substr(0, 16);
          } else {
            var traceparentArr = traceparent.trim().split("-");
            var len = traceparentArr.length;
            if (len >= 4) {
              this.version = traceparentArr[0];
              this.traceId = traceparentArr[1];
              this.spanId = traceparentArr[2];
              this.traceFlag = traceparentArr[3];
            } else {
              this.traceId = Util.w3cTraceId();
              this.spanId = Util.w3cTraceId().substr(0, 16);
            }
            if (!this.version.match(/^[0-9a-f]{2}$/g)) {
              this.version = Traceparent2.DEFAULT_VERSION;
              this.traceId = Util.w3cTraceId();
            }
            if (this.version === "00" && len !== 4) {
              this.traceId = Util.w3cTraceId();
              this.spanId = Util.w3cTraceId().substr(0, 16);
            }
            if (this.version === "ff") {
              this.version = Traceparent2.DEFAULT_VERSION;
              this.traceId = Util.w3cTraceId();
              this.spanId = Util.w3cTraceId().substr(0, 16);
            }
            if (!this.version.match(/^0[0-9a-f]$/g)) {
              this.version = Traceparent2.DEFAULT_VERSION;
            }
            if (!this.traceFlag.match(/^[0-9a-f]{2}$/g)) {
              this.traceFlag = Traceparent2.DEFAULT_VERSION;
              this.traceId = Util.w3cTraceId();
            }
            if (!Traceparent2.isValidTraceId(this.traceId)) {
              this.traceId = Util.w3cTraceId();
            }
            if (!Traceparent2.isValidSpanId(this.spanId)) {
              this.spanId = Util.w3cTraceId().substr(0, 16);
              this.traceId = Util.w3cTraceId();
            }
            this.parentId = this.getBackCompatRequestId();
          }
        } else if (parentId) {
          this.parentId = parentId.slice();
          var operationId = CorrelationIdManager.getRootId(parentId);
          if (!Traceparent2.isValidTraceId(operationId)) {
            this.legacyRootId = operationId;
            operationId = Util.w3cTraceId();
          }
          if (parentId.indexOf("|") !== -1) {
            parentId = parentId.substring(1 + parentId.substring(0, parentId.length - 1).lastIndexOf("."), parentId.length - 1);
          }
          this.traceId = operationId;
          this.spanId = parentId;
        } else {
          this.traceId = Util.w3cTraceId();
          this.spanId = Util.w3cTraceId().substr(0, 16);
        }
      }
      Traceparent2.isValidTraceId = function(id) {
        return id.match(/^[0-9a-f]{32}$/) && id !== "00000000000000000000000000000000";
      };
      Traceparent2.isValidSpanId = function(id) {
        return id.match(/^[0-9a-f]{16}$/) && id !== "0000000000000000";
      };
      Traceparent2.prototype.getBackCompatRequestId = function() {
        return "|" + this.traceId + "." + this.spanId + ".";
      };
      Traceparent2.prototype.toString = function() {
        return this.version + "-" + this.traceId + "-" + this.spanId + "-" + this.traceFlag;
      };
      Traceparent2.prototype.updateSpanId = function() {
        this.spanId = Util.w3cTraceId().substr(0, 16);
      };
      Traceparent2.DEFAULT_TRACE_FLAG = "00";
      Traceparent2.DEFAULT_VERSION = "00";
      return Traceparent2;
    }();
    module2.exports = Traceparent;
  }
});

// ../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/mongodb.sub.js
var require_mongodb_sub = __commonJS({
  "../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/mongodb.sub.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var diagnostic_channel_1 = require_channel();
    var clients = [];
    exports2.subscriber = function(event) {
      clients.forEach(function(client) {
        var dbName = event.data.startedData && event.data.startedData.databaseName || "Unknown database";
        client.trackDependency({
          target: dbName,
          data: event.data.event.commandName,
          name: event.data.event.commandName,
          duration: event.data.event.duration,
          success: event.data.succeeded,
          resultCode: event.data.succeeded ? "0" : "1",
          dependencyTypeName: "mongodb"
        });
      });
    };
    function enable(enabled, client) {
      if (enabled) {
        if (clients.length === 0) {
          diagnostic_channel_1.channel.subscribe("mongodb", exports2.subscriber);
        }
        ;
        clients.push(client);
      } else {
        clients = clients.filter(function(c) {
          return c != client;
        });
        if (clients.length === 0) {
          diagnostic_channel_1.channel.unsubscribe("mongodb", exports2.subscriber);
        }
      }
    }
    exports2.enable = enable;
  }
});

// ../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/mysql.sub.js
var require_mysql_sub = __commonJS({
  "../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/mysql.sub.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var diagnostic_channel_1 = require_channel();
    var clients = [];
    exports2.subscriber = function(event) {
      clients.forEach(function(client) {
        var queryObj = event.data.query || {};
        var sqlString = queryObj.sql || "Unknown query";
        var success = !event.data.err;
        var connection = queryObj._connection || {};
        var connectionConfig = connection.config || {};
        var dbName = connectionConfig.socketPath ? connectionConfig.socketPath : (connectionConfig.host || "localhost") + ":" + connectionConfig.port;
        client.trackDependency({
          target: dbName,
          data: sqlString,
          name: sqlString,
          duration: event.data.duration,
          success,
          resultCode: success ? "0" : "1",
          dependencyTypeName: "mysql"
        });
      });
    };
    function enable(enabled, client) {
      if (enabled) {
        if (clients.length === 0) {
          diagnostic_channel_1.channel.subscribe("mysql", exports2.subscriber);
        }
        ;
        clients.push(client);
      } else {
        clients = clients.filter(function(c) {
          return c != client;
        });
        if (clients.length === 0) {
          diagnostic_channel_1.channel.unsubscribe("mysql", exports2.subscriber);
        }
      }
    }
    exports2.enable = enable;
  }
});

// ../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/redis.sub.js
var require_redis_sub = __commonJS({
  "../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/redis.sub.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var diagnostic_channel_1 = require_channel();
    var clients = [];
    exports2.subscriber = function(event) {
      clients.forEach(function(client) {
        if (event.data.commandObj.command === "info") {
          return;
        }
        client.trackDependency({
          target: event.data.address,
          name: event.data.commandObj.command,
          data: event.data.commandObj.command,
          duration: event.data.duration,
          success: !event.data.err,
          resultCode: event.data.err ? "1" : "0",
          dependencyTypeName: "redis"
        });
      });
    };
    function enable(enabled, client) {
      if (enabled) {
        if (clients.length === 0) {
          diagnostic_channel_1.channel.subscribe("redis", exports2.subscriber);
        }
        ;
        clients.push(client);
      } else {
        clients = clients.filter(function(c) {
          return c != client;
        });
        if (clients.length === 0) {
          diagnostic_channel_1.channel.unsubscribe("redis", exports2.subscriber);
        }
      }
    }
    exports2.enable = enable;
  }
});

// ../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/postgres.sub.js
var require_postgres_sub = __commonJS({
  "../../node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/postgres.sub.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var diagnostic_channel_1 = require_channel();
    var clients = [];
    exports2.subscriber = function(event) {
      clients.forEach(function(client) {
        var q = event.data.query;
        var sql = q.preparable && q.preparable.text || q.plan || q.text || "unknown query";
        var success = !event.data.error;
        var conn = event.data.database.host + ":" + event.data.database.port;
        client.trackDependency({
          target: conn,
          data: sql,
          name: sql,
          duration: event.data.duration,
          success,
          resultCode: success ? "0" : "1",
          dependencyTypeName: "postgres"
        });
      });
    };
    function enable(enabled, client) {
      if (enabled) {
        if (clients.length === 0) {
          diagnostic_channel_1.channel.subscribe("postgres", exports2.subscriber);
        }
        ;
        clients.push(client);
      } else {
        clients = clients.filter(function(c) {
          return c != client;
        });
        if (clients.length === 0) {
          diagnostic_channel_1.channel.unsubscribe("postgres", exports2.subscriber);
        }
      }
    }
    exports2.enable = enable;
  }
});

// ../../node_modules/applicationinsights/out/AutoCollection/HttpDependencies.js
var require_HttpDependencies = __commonJS({
  "../../node_modules/applicationinsights/out/AutoCollection/HttpDependencies.js"(exports2, module2) {
    "use strict";
    var http = require("http");
    var https = require("https");
    var Logging = require_Logging();
    var Util = require_Util();
    var RequestResponseHeaders = require_RequestResponseHeaders();
    var HttpDependencyParser = require_HttpDependencyParser();
    var CorrelationContextManager_1 = require_CorrelationContextManager();
    var CorrelationIdManager = require_CorrelationIdManager();
    var Traceparent = require_Traceparent();
    var DiagChannel = require_initialization();
    var AutoCollectHttpDependencies = function() {
      function AutoCollectHttpDependencies2(client) {
        if (!!AutoCollectHttpDependencies2.INSTANCE) {
          throw new Error("Client request tracking should be configured from the applicationInsights object");
        }
        AutoCollectHttpDependencies2.INSTANCE = this;
        this._client = client;
      }
      AutoCollectHttpDependencies2.prototype.enable = function(isEnabled) {
        this._isEnabled = isEnabled;
        if (this._isEnabled && !this._isInitialized) {
          this._initialize();
        }
        if (DiagChannel.IsInitialized) {
          require_mongodb_sub().enable(isEnabled, this._client);
          require_mysql_sub().enable(isEnabled, this._client);
          require_redis_sub().enable(isEnabled, this._client);
          require_postgres_sub().enable(isEnabled, this._client);
        }
      };
      AutoCollectHttpDependencies2.prototype.isInitialized = function() {
        return this._isInitialized;
      };
      AutoCollectHttpDependencies2.prototype._initialize = function() {
        var _this = this;
        this._isInitialized = true;
        var originalGet = http.get;
        var originalRequest = http.request;
        var originalHttpsRequest = https.request;
        var clientRequestPatch = function(request, options2) {
          var shouldCollect = !options2[AutoCollectHttpDependencies2.disableCollectionRequestOption] && !request[AutoCollectHttpDependencies2.alreadyAutoCollectedFlag];
          request[AutoCollectHttpDependencies2.alreadyAutoCollectedFlag] = true;
          if (request && options2 && shouldCollect) {
            CorrelationContextManager_1.CorrelationContextManager.wrapEmitter(request);
            AutoCollectHttpDependencies2.trackRequest(_this._client, { options: options2, request });
          }
        };
        http.request = function(options2) {
          var requestArgs = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            requestArgs[_i - 1] = arguments[_i];
          }
          var request = originalRequest.call.apply(originalRequest, [http, options2].concat(requestArgs));
          clientRequestPatch(request, options2);
          return request;
        };
        https.request = function(options2) {
          var requestArgs = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            requestArgs[_i - 1] = arguments[_i];
          }
          var request = originalHttpsRequest.call.apply(originalHttpsRequest, [https, options2].concat(requestArgs));
          clientRequestPatch(request, options2);
          return request;
        };
        http.get = function(options2) {
          var requestArgs = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            requestArgs[_i - 1] = arguments[_i];
          }
          var request = (_a2 = http.request).call.apply(_a2, [http, options2].concat(requestArgs));
          request.end();
          return request;
          var _a2;
        };
        https.get = function(options2) {
          var requestArgs = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            requestArgs[_i - 1] = arguments[_i];
          }
          var request = (_a2 = https.request).call.apply(_a2, [https, options2].concat(requestArgs));
          request.end();
          return request;
          var _a2;
        };
      };
      AutoCollectHttpDependencies2.trackRequest = function(client, telemetry) {
        if (!telemetry.options || !telemetry.request || !client) {
          Logging.info("AutoCollectHttpDependencies.trackRequest was called with invalid parameters: ", !telemetry.options, !telemetry.request, !client);
          return;
        }
        var requestParser = new HttpDependencyParser(telemetry.options, telemetry.request);
        var currentContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();
        var uniqueRequestId;
        var uniqueTraceparent;
        if (currentContext && currentContext.operation && currentContext.operation.traceparent && Traceparent.isValidTraceId(currentContext.operation.traceparent.traceId)) {
          currentContext.operation.traceparent.updateSpanId();
          uniqueRequestId = currentContext.operation.traceparent.getBackCompatRequestId();
        } else if (CorrelationIdManager.w3cEnabled) {
          var traceparent = new Traceparent();
          uniqueTraceparent = traceparent.toString();
          uniqueRequestId = traceparent.getBackCompatRequestId();
        } else {
          uniqueRequestId = currentContext && currentContext.operation && currentContext.operation.parentId + AutoCollectHttpDependencies2.requestNumber++ + ".";
        }
        if (Util.canIncludeCorrelationHeader(client, requestParser.getUrl()) && telemetry.request.getHeader && telemetry.request.setHeader) {
          if (client.config && client.config.correlationId) {
            var correlationHeader = telemetry.request.getHeader(RequestResponseHeaders.requestContextHeader);
            try {
              Util.safeIncludeCorrelationHeader(client, telemetry.request, correlationHeader);
            } catch (err) {
              Logging.warn("Request-Context header could not be set. Correlation of requests may be lost", err);
            }
            if (currentContext && currentContext.operation) {
              try {
                telemetry.request.setHeader(RequestResponseHeaders.requestIdHeader, uniqueRequestId);
                telemetry.request.setHeader(RequestResponseHeaders.parentIdHeader, currentContext.operation.id);
                telemetry.request.setHeader(RequestResponseHeaders.rootIdHeader, uniqueRequestId);
                if (uniqueTraceparent || currentContext.operation.traceparent) {
                  telemetry.request.setHeader(RequestResponseHeaders.traceparentHeader, uniqueTraceparent || currentContext.operation.traceparent.toString());
                } else if (CorrelationIdManager.w3cEnabled) {
                  var traceparent = new Traceparent().toString();
                  telemetry.request.setHeader(RequestResponseHeaders.traceparentHeader, traceparent);
                }
                if (currentContext.operation.tracestate) {
                  var tracestate = currentContext.operation.tracestate.toString();
                  if (tracestate) {
                    telemetry.request.setHeader(RequestResponseHeaders.traceStateHeader, tracestate);
                  }
                }
                var correlationContextHeader = currentContext.customProperties.serializeToHeader();
                if (correlationContextHeader) {
                  telemetry.request.setHeader(RequestResponseHeaders.correlationContextHeader, correlationContextHeader);
                }
              } catch (err) {
                Logging.warn("Correlation headers could not be set. Correlation of requests may be lost.", err);
              }
            }
          }
        }
        if (telemetry.request.on) {
          telemetry.request.on("response", function(response) {
            requestParser.onResponse(response);
            var dependencyTelemetry = requestParser.getDependencyTelemetry(telemetry, uniqueRequestId);
            dependencyTelemetry.contextObjects = dependencyTelemetry.contextObjects || {};
            dependencyTelemetry.contextObjects["http.RequestOptions"] = telemetry.options;
            dependencyTelemetry.contextObjects["http.ClientRequest"] = telemetry.request;
            dependencyTelemetry.contextObjects["http.ClientResponse"] = response;
            client.trackDependency(dependencyTelemetry);
          });
          telemetry.request.on("error", function(e) {
            requestParser.onError(e);
            var dependencyTelemetry = requestParser.getDependencyTelemetry(telemetry, uniqueRequestId);
            dependencyTelemetry.contextObjects = dependencyTelemetry.contextObjects || {};
            dependencyTelemetry.contextObjects["http.RequestOptions"] = telemetry.options;
            dependencyTelemetry.contextObjects["http.ClientRequest"] = telemetry.request;
            dependencyTelemetry.contextObjects["Error"] = e;
            client.trackDependency(dependencyTelemetry);
          });
        }
      };
      AutoCollectHttpDependencies2.prototype.dispose = function() {
        AutoCollectHttpDependencies2.INSTANCE = null;
        this.enable(false);
        this._isInitialized = false;
      };
      AutoCollectHttpDependencies2.disableCollectionRequestOption = "disableAppInsightsAutoCollection";
      AutoCollectHttpDependencies2.requestNumber = 1;
      AutoCollectHttpDependencies2.alreadyAutoCollectedFlag = "_appInsightsAutoCollected";
      return AutoCollectHttpDependencies2;
    }();
    module2.exports = AutoCollectHttpDependencies;
  }
});

// ../../node_modules/applicationinsights/out/Library/Tracestate.js
var require_Tracestate = __commonJS({
  "../../node_modules/applicationinsights/out/Library/Tracestate.js"(exports2, module2) {
    "use strict";
    var Tracestate = function() {
      function Tracestate2(id) {
        this.fieldmap = [];
        if (!id) {
          return;
        }
        this.fieldmap = this.parseHeader(id);
      }
      Tracestate2.prototype.toString = function() {
        var fieldarr = this.fieldmap;
        if (!fieldarr || fieldarr.length == 0) {
          return null;
        }
        return fieldarr.join(", ");
      };
      Tracestate2.validateKeyChars = function(key) {
        var keyParts = key.split("@");
        if (keyParts.length == 2) {
          var tenant = keyParts[0].trim();
          var vendor = keyParts[1].trim();
          var tenantValid = Boolean(tenant.match(/^[\ ]?[a-z0-9\*\-\_/]{1,241}$/));
          var vendorValid = Boolean(vendor.match(/^[\ ]?[a-z0-9\*\-\_/]{1,14}$/));
          return tenantValid && vendorValid;
        } else if (keyParts.length == 1) {
          return Boolean(key.match(/^[\ ]?[a-z0-9\*\-\_/]{1,256}$/));
        }
        return false;
      };
      Tracestate2.prototype.parseHeader = function(id) {
        var res = [];
        var keydeduper = {};
        var parts = id.split(",");
        if (parts.length > 32)
          return null;
        for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {
          var rawPart = parts_1[_i];
          var part = rawPart.trim();
          if (part.length === 0) {
            continue;
          }
          var pair = part.split("=");
          if (pair.length !== 2) {
            return null;
          }
          if (!Tracestate2.validateKeyChars(pair[0])) {
            return null;
          }
          if (keydeduper[pair[0]]) {
            return null;
          } else {
            keydeduper[pair[0]] = true;
          }
          res.push(part);
        }
        return res;
      };
      Tracestate2.strict = true;
      return Tracestate2;
    }();
    module2.exports = Tracestate;
  }
});

// ../../node_modules/applicationinsights/out/AutoCollection/HttpRequestParser.js
var require_HttpRequestParser = __commonJS({
  "../../node_modules/applicationinsights/out/AutoCollection/HttpRequestParser.js"(exports2, module2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (b.hasOwnProperty(p))
            d[p] = b[p];
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var url = require("url");
    var Contracts = require_Contracts();
    var Util = require_Util();
    var RequestResponseHeaders = require_RequestResponseHeaders();
    var RequestParser = require_RequestParser();
    var CorrelationIdManager = require_CorrelationIdManager();
    var Tracestate = require_Tracestate();
    var Traceparent = require_Traceparent();
    var HttpRequestParser = function(_super) {
      __extends2(HttpRequestParser2, _super);
      function HttpRequestParser2(request, requestId) {
        var _this = _super.call(this) || this;
        if (request) {
          _this.method = request.method;
          _this.url = _this._getAbsoluteUrl(request);
          _this.startTime = +new Date();
          _this.socketRemoteAddress = request.socket && request.socket.remoteAddress;
          _this.parseHeaders(request, requestId);
          if (request.connection) {
            _this.connectionRemoteAddress = request.connection.remoteAddress;
            _this.legacySocketRemoteAddress = request.connection["socket"] && request.connection["socket"].remoteAddress;
          }
        }
        return _this;
      }
      HttpRequestParser2.prototype.onError = function(error3, ellapsedMilliseconds) {
        this._setStatus(void 0, error3);
        if (ellapsedMilliseconds) {
          this.duration = ellapsedMilliseconds;
        }
      };
      HttpRequestParser2.prototype.onResponse = function(response, ellapsedMilliseconds) {
        this._setStatus(response.statusCode, void 0);
        if (ellapsedMilliseconds) {
          this.duration = ellapsedMilliseconds;
        }
      };
      HttpRequestParser2.prototype.getRequestTelemetry = function(baseTelemetry) {
        var requestTelemetry = {
          id: this.requestId,
          name: this.method + " " + url.parse(this.url).pathname,
          url: this.url,
          source: this.sourceCorrelationId,
          duration: this.duration,
          resultCode: this.statusCode ? this.statusCode.toString() : null,
          success: this._isSuccess(),
          properties: this.properties
        };
        if (baseTelemetry) {
          for (var key in baseTelemetry) {
            if (!requestTelemetry[key]) {
              requestTelemetry[key] = baseTelemetry[key];
            }
          }
          if (baseTelemetry.properties) {
            for (var key in baseTelemetry.properties) {
              requestTelemetry.properties[key] = baseTelemetry.properties[key];
            }
          }
        }
        return requestTelemetry;
      };
      HttpRequestParser2.prototype.getRequestTags = function(tags) {
        var newTags = {};
        for (var key in tags) {
          newTags[key] = tags[key];
        }
        newTags[HttpRequestParser2.keys.locationIp] = tags[HttpRequestParser2.keys.locationIp] || this._getIp();
        newTags[HttpRequestParser2.keys.sessionId] = tags[HttpRequestParser2.keys.sessionId] || this._getId("ai_session");
        newTags[HttpRequestParser2.keys.userId] = tags[HttpRequestParser2.keys.userId] || this._getId("ai_user");
        newTags[HttpRequestParser2.keys.userAuthUserId] = tags[HttpRequestParser2.keys.userAuthUserId] || this._getId("ai_authUser");
        newTags[HttpRequestParser2.keys.operationName] = this.getOperationName(tags);
        newTags[HttpRequestParser2.keys.operationParentId] = this.getOperationParentId(tags);
        newTags[HttpRequestParser2.keys.operationId] = this.getOperationId(tags);
        return newTags;
      };
      HttpRequestParser2.prototype.getOperationId = function(tags) {
        return tags[HttpRequestParser2.keys.operationId] || this.operationId;
      };
      HttpRequestParser2.prototype.getOperationParentId = function(tags) {
        return tags[HttpRequestParser2.keys.operationParentId] || this.parentId || this.getOperationId(tags);
      };
      HttpRequestParser2.prototype.getOperationName = function(tags) {
        return tags[HttpRequestParser2.keys.operationName] || this.method + " " + url.parse(this.url).pathname;
      };
      HttpRequestParser2.prototype.getRequestId = function() {
        return this.requestId;
      };
      HttpRequestParser2.prototype.getCorrelationContextHeader = function() {
        return this.correlationContextHeader;
      };
      HttpRequestParser2.prototype.getTraceparent = function() {
        return this.traceparent;
      };
      HttpRequestParser2.prototype.getTracestate = function() {
        return this.tracestate;
      };
      HttpRequestParser2.prototype.getLegacyRootId = function() {
        return this.legacyRootId;
      };
      HttpRequestParser2.prototype._getAbsoluteUrl = function(request) {
        if (!request.headers) {
          return request.url;
        }
        var encrypted = request.connection ? request.connection.encrypted : null;
        var requestUrl = url.parse(request.url);
        var pathName = requestUrl.pathname;
        var search = requestUrl.search;
        var absoluteUrl = url.format({
          protocol: encrypted ? "https" : "http",
          host: request.headers.host,
          pathname: pathName,
          search
        });
        return absoluteUrl;
      };
      HttpRequestParser2.prototype._getIp = function() {
        var ipMatch = /[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/;
        var check = function(str) {
          var results = ipMatch.exec(str);
          if (results) {
            return results[0];
          }
        };
        var ip = check(this.rawHeaders["x-forwarded-for"]) || check(this.rawHeaders["x-client-ip"]) || check(this.rawHeaders["x-real-ip"]) || check(this.connectionRemoteAddress) || check(this.socketRemoteAddress) || check(this.legacySocketRemoteAddress);
        if (!ip && this.connectionRemoteAddress && this.connectionRemoteAddress.substr && this.connectionRemoteAddress.substr(0, 2) === "::") {
          ip = "127.0.0.1";
        }
        return ip;
      };
      HttpRequestParser2.prototype._getId = function(name) {
        var cookie = this.rawHeaders && this.rawHeaders["cookie"] && typeof this.rawHeaders["cookie"] === "string" && this.rawHeaders["cookie"] || "";
        var value = HttpRequestParser2.parseId(Util.getCookie(name, cookie));
        return value;
      };
      HttpRequestParser2.prototype.setBackCompatFromThisTraceContext = function() {
        this.operationId = this.traceparent.traceId;
        if (this.traceparent.legacyRootId) {
          this.legacyRootId = this.traceparent.legacyRootId;
        }
        this.parentId = this.traceparent.parentId;
        this.traceparent.updateSpanId();
        this.requestId = this.traceparent.getBackCompatRequestId();
      };
      HttpRequestParser2.prototype.parseHeaders = function(request, requestId) {
        this.rawHeaders = request.headers || request.rawHeaders;
        this.userAgent = request.headers && request.headers["user-agent"];
        this.sourceCorrelationId = Util.getCorrelationContextTarget(request, RequestResponseHeaders.requestContextSourceKey);
        if (request.headers) {
          var tracestateHeader = request.headers[RequestResponseHeaders.traceStateHeader];
          var traceparentHeader = request.headers[RequestResponseHeaders.traceparentHeader];
          var requestIdHeader = request.headers[RequestResponseHeaders.requestIdHeader];
          var legacy_parentId = request.headers[RequestResponseHeaders.parentIdHeader];
          var legacy_rootId = request.headers[RequestResponseHeaders.rootIdHeader];
          this.correlationContextHeader = request.headers[RequestResponseHeaders.correlationContextHeader];
          if (CorrelationIdManager.w3cEnabled && (traceparentHeader || tracestateHeader)) {
            this.traceparent = new Traceparent(traceparentHeader);
            this.tracestate = traceparentHeader && tracestateHeader && new Tracestate(tracestateHeader);
            this.setBackCompatFromThisTraceContext();
          } else if (requestIdHeader) {
            if (CorrelationIdManager.w3cEnabled) {
              this.traceparent = new Traceparent(null, requestIdHeader);
              this.setBackCompatFromThisTraceContext();
            } else {
              this.parentId = requestIdHeader;
              this.requestId = CorrelationIdManager.generateRequestId(this.parentId);
              this.operationId = CorrelationIdManager.getRootId(this.requestId);
            }
          } else {
            if (CorrelationIdManager.w3cEnabled) {
              this.traceparent = new Traceparent();
              this.traceparent.parentId = legacy_parentId;
              this.traceparent.legacyRootId = legacy_rootId || legacy_parentId;
              this.setBackCompatFromThisTraceContext();
            } else {
              this.parentId = legacy_parentId;
              this.requestId = CorrelationIdManager.generateRequestId(legacy_rootId || this.parentId);
              this.correlationContextHeader = null;
              this.operationId = CorrelationIdManager.getRootId(this.requestId);
            }
          }
          if (requestId) {
            this.requestId = requestId;
            this.operationId = CorrelationIdManager.getRootId(this.requestId);
          }
        }
      };
      HttpRequestParser2.parseId = function(cookieValue) {
        var cookieParts = cookieValue.split("|");
        if (cookieParts.length > 0) {
          return cookieParts[0];
        }
        return "";
      };
      HttpRequestParser2.keys = new Contracts.ContextTagKeys();
      return HttpRequestParser2;
    }(RequestParser);
    module2.exports = HttpRequestParser;
  }
});

// ../../node_modules/applicationinsights/out/AutoCollection/HttpRequests.js
var require_HttpRequests = __commonJS({
  "../../node_modules/applicationinsights/out/AutoCollection/HttpRequests.js"(exports2, module2) {
    "use strict";
    var http = require("http");
    var https = require("https");
    var Logging = require_Logging();
    var Util = require_Util();
    var RequestResponseHeaders = require_RequestResponseHeaders();
    var HttpRequestParser = require_HttpRequestParser();
    var CorrelationContextManager_1 = require_CorrelationContextManager();
    var AutoCollectPerformance = require_Performance();
    var AutoCollectHttpRequests = function() {
      function AutoCollectHttpRequests2(client) {
        if (!!AutoCollectHttpRequests2.INSTANCE) {
          throw new Error("Server request tracking should be configured from the applicationInsights object");
        }
        AutoCollectHttpRequests2.INSTANCE = this;
        this._client = client;
      }
      AutoCollectHttpRequests2.prototype.enable = function(isEnabled) {
        this._isEnabled = isEnabled;
        if ((this._isAutoCorrelating || this._isEnabled || AutoCollectPerformance.isEnabled()) && !this._isInitialized) {
          this.useAutoCorrelation(this._isAutoCorrelating);
          this._initialize();
        }
      };
      AutoCollectHttpRequests2.prototype.useAutoCorrelation = function(isEnabled, forceClsHooked) {
        if (isEnabled && !this._isAutoCorrelating) {
          CorrelationContextManager_1.CorrelationContextManager.enable(forceClsHooked);
        } else if (!isEnabled && this._isAutoCorrelating) {
          CorrelationContextManager_1.CorrelationContextManager.disable();
        }
        this._isAutoCorrelating = isEnabled;
      };
      AutoCollectHttpRequests2.prototype.isInitialized = function() {
        return this._isInitialized;
      };
      AutoCollectHttpRequests2.prototype.isAutoCorrelating = function() {
        return this._isAutoCorrelating;
      };
      AutoCollectHttpRequests2.prototype._generateCorrelationContext = function(requestParser) {
        if (!this._isAutoCorrelating) {
          return;
        }
        return CorrelationContextManager_1.CorrelationContextManager.generateContextObject(requestParser.getOperationId(this._client.context.tags), requestParser.getRequestId(), requestParser.getOperationName(this._client.context.tags), requestParser.getCorrelationContextHeader(), requestParser.getTraceparent(), requestParser.getTracestate());
      };
      AutoCollectHttpRequests2.prototype._initialize = function() {
        var _this = this;
        this._isInitialized = true;
        var wrapOnRequestHandler = function(onRequest) {
          if (!onRequest) {
            return void 0;
          }
          if (typeof onRequest !== "function") {
            throw new Error("onRequest handler must be a function");
          }
          return function(request, response) {
            CorrelationContextManager_1.CorrelationContextManager.wrapEmitter(request);
            CorrelationContextManager_1.CorrelationContextManager.wrapEmitter(response);
            var shouldCollect = request && !request[AutoCollectHttpRequests2.alreadyAutoCollectedFlag];
            if (request && shouldCollect) {
              var requestParser_1 = new HttpRequestParser(request);
              var correlationContext = _this._generateCorrelationContext(requestParser_1);
              CorrelationContextManager_1.CorrelationContextManager.runWithContext(correlationContext, function() {
                if (_this._isEnabled) {
                  request[AutoCollectHttpRequests2.alreadyAutoCollectedFlag] = true;
                  AutoCollectHttpRequests2.trackRequest(_this._client, { request, response }, requestParser_1);
                }
                AutoCollectPerformance.countRequest(request, response);
                if (typeof onRequest === "function") {
                  onRequest(request, response);
                }
              });
            } else {
              if (typeof onRequest === "function") {
                onRequest(request, response);
              }
            }
          };
        };
        var wrapServerEventHandler = function(server) {
          var originalAddListener = server.addListener.bind(server);
          server.addListener = function(eventType, eventHandler) {
            switch (eventType) {
              case "request":
              case "checkContinue":
                return originalAddListener(eventType, wrapOnRequestHandler(eventHandler));
              default:
                return originalAddListener(eventType, eventHandler);
            }
          };
          server.on = server.addListener;
        };
        var originalHttpServer = http.createServer;
        http.createServer = function(onRequest) {
          var server = originalHttpServer(wrapOnRequestHandler(onRequest));
          wrapServerEventHandler(server);
          return server;
        };
        var originalHttpsServer = https.createServer;
        https.createServer = function(options2, onRequest) {
          var server = originalHttpsServer(options2, wrapOnRequestHandler(onRequest));
          wrapServerEventHandler(server);
          return server;
        };
      };
      AutoCollectHttpRequests2.trackRequestSync = function(client, telemetry) {
        if (!telemetry.request || !telemetry.response || !client) {
          Logging.info("AutoCollectHttpRequests.trackRequestSync was called with invalid parameters: ", !telemetry.request, !telemetry.response, !client);
          return;
        }
        AutoCollectHttpRequests2.addResponseCorrelationIdHeader(client, telemetry.response);
        var correlationContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();
        var requestParser = new HttpRequestParser(telemetry.request, correlationContext && correlationContext.operation.parentId);
        if (correlationContext) {
          correlationContext.operation.id = requestParser.getOperationId(client.context.tags) || correlationContext.operation.id;
          correlationContext.operation.name = requestParser.getOperationName(client.context.tags) || correlationContext.operation.name;
          correlationContext.operation.parentId = requestParser.getRequestId() || correlationContext.operation.parentId;
          correlationContext.customProperties.addHeaderData(requestParser.getCorrelationContextHeader());
        }
        AutoCollectHttpRequests2.endRequest(client, requestParser, telemetry, telemetry.duration, telemetry.error);
      };
      AutoCollectHttpRequests2.trackRequest = function(client, telemetry, _requestParser) {
        if (!telemetry.request || !telemetry.response || !client) {
          Logging.info("AutoCollectHttpRequests.trackRequest was called with invalid parameters: ", !telemetry.request, !telemetry.response, !client);
          return;
        }
        var correlationContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();
        var requestParser = _requestParser || new HttpRequestParser(telemetry.request, correlationContext && correlationContext.operation.parentId);
        if (Util.canIncludeCorrelationHeader(client, requestParser.getUrl())) {
          AutoCollectHttpRequests2.addResponseCorrelationIdHeader(client, telemetry.response);
        }
        if (correlationContext && !_requestParser) {
          correlationContext.operation.id = requestParser.getOperationId(client.context.tags) || correlationContext.operation.id;
          correlationContext.operation.name = requestParser.getOperationName(client.context.tags) || correlationContext.operation.name;
          correlationContext.operation.parentId = requestParser.getOperationParentId(client.context.tags) || correlationContext.operation.parentId;
          correlationContext.customProperties.addHeaderData(requestParser.getCorrelationContextHeader());
        }
        if (telemetry.response.once) {
          telemetry.response.once("finish", function() {
            AutoCollectHttpRequests2.endRequest(client, requestParser, telemetry, null, null);
          });
        }
        if (telemetry.request.on) {
          telemetry.request.on("error", function(error3) {
            AutoCollectHttpRequests2.endRequest(client, requestParser, telemetry, null, error3);
          });
        }
      };
      AutoCollectHttpRequests2.addResponseCorrelationIdHeader = function(client, response) {
        if (client.config && client.config.correlationId && response.getHeader && response.setHeader && !response.headersSent) {
          var correlationHeader = response.getHeader(RequestResponseHeaders.requestContextHeader);
          Util.safeIncludeCorrelationHeader(client, response, correlationHeader);
        }
      };
      AutoCollectHttpRequests2.endRequest = function(client, requestParser, telemetry, ellapsedMilliseconds, error3) {
        if (error3) {
          requestParser.onError(error3, ellapsedMilliseconds);
        } else {
          requestParser.onResponse(telemetry.response, ellapsedMilliseconds);
        }
        var requestTelemetry = requestParser.getRequestTelemetry(telemetry);
        requestTelemetry.tagOverrides = requestParser.getRequestTags(client.context.tags);
        if (telemetry.tagOverrides) {
          for (var key in telemetry.tagOverrides) {
            requestTelemetry.tagOverrides[key] = telemetry.tagOverrides[key];
          }
        }
        var legacyRootId = requestParser.getLegacyRootId();
        if (legacyRootId) {
          requestTelemetry.properties["ai_legacyRootId"] = legacyRootId;
        }
        requestTelemetry.contextObjects = requestTelemetry.contextObjects || {};
        requestTelemetry.contextObjects["http.ServerRequest"] = telemetry.request;
        requestTelemetry.contextObjects["http.ServerResponse"] = telemetry.response;
        client.trackRequest(requestTelemetry);
      };
      AutoCollectHttpRequests2.prototype.dispose = function() {
        AutoCollectHttpRequests2.INSTANCE = null;
        this.enable(false);
        this._isInitialized = false;
        CorrelationContextManager_1.CorrelationContextManager.disable();
        this._isAutoCorrelating = false;
      };
      AutoCollectHttpRequests2.alreadyAutoCollectedFlag = "_appInsightsAutoCollected";
      return AutoCollectHttpRequests2;
    }();
    module2.exports = AutoCollectHttpRequests;
  }
});

// ../../node_modules/applicationinsights/out/Library/Config.js
var require_Config = __commonJS({
  "../../node_modules/applicationinsights/out/Library/Config.js"(exports2, module2) {
    "use strict";
    var CorrelationIdManager = require_CorrelationIdManager();
    var Config = function() {
      function Config2(instrumentationKey) {
        var _this = this;
        this.endpointBase = "https://dc.services.visualstudio.com";
        this.instrumentationKey = instrumentationKey || Config2._getInstrumentationKey();
        this.endpointUrl = this.endpointBase + "/v2/track";
        this.maxBatchSize = 250;
        this.maxBatchIntervalMs = 15e3;
        this.disableAppInsights = false;
        this.samplingPercentage = 100;
        this.correlationIdRetryIntervalMs = 30 * 1e3;
        this.correlationHeaderExcludedDomains = [
          "*.core.windows.net",
          "*.core.chinacloudapi.cn",
          "*.core.cloudapi.de",
          "*.core.usgovcloudapi.net"
        ];
        this.setCorrelationId = function(correlationId) {
          return _this.correlationId = correlationId;
        };
        this.profileQueryEndpoint = process.env[Config2.ENV_profileQueryEndpoint] || this.endpointBase;
        this.proxyHttpUrl = process.env[Config2.ENV_http_proxy] || void 0;
        this.proxyHttpsUrl = process.env[Config2.ENV_https_proxy] || void 0;
        this.httpAgent = void 0;
        this.httpsAgent = void 0;
        this._quickPulseHost = process.env[Config2.ENV_quickPulseHost] || "rt.services.visualstudio.com";
      }
      Object.defineProperty(Config2.prototype, "profileQueryEndpoint", {
        get: function() {
          return this._profileQueryEndpoint;
        },
        set: function(endpoint) {
          CorrelationIdManager.cancelCorrelationIdQuery(this, this.setCorrelationId);
          this._profileQueryEndpoint = endpoint;
          this.correlationId = CorrelationIdManager.correlationIdPrefix;
          CorrelationIdManager.queryCorrelationId(this, this.setCorrelationId);
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(Config2.prototype, "quickPulseHost", {
        get: function() {
          return this._quickPulseHost;
        },
        set: function(host) {
          this._quickPulseHost = host;
        },
        enumerable: true,
        configurable: true
      });
      Config2._getInstrumentationKey = function() {
        var iKey = process.env[Config2.ENV_iKey] || process.env[Config2.ENV_azurePrefix + Config2.ENV_iKey] || process.env[Config2.legacy_ENV_iKey] || process.env[Config2.ENV_azurePrefix + Config2.legacy_ENV_iKey];
        if (!iKey || iKey == "") {
          throw new Error("Instrumentation key not found, pass the key in the config to this method or set the key in the environment variable APPINSIGHTS_INSTRUMENTATIONKEY before starting the server");
        }
        return iKey;
      };
      Config2.ENV_azurePrefix = "APPSETTING_";
      Config2.ENV_iKey = "APPINSIGHTS_INSTRUMENTATIONKEY";
      Config2.legacy_ENV_iKey = "APPINSIGHTS_INSTRUMENTATION_KEY";
      Config2.ENV_profileQueryEndpoint = "APPINSIGHTS_PROFILE_QUERY_ENDPOINT";
      Config2.ENV_quickPulseHost = "APPINSIGHTS_QUICKPULSE_HOST";
      Config2.ENV_nativeMetricsDisablers = "APPLICATION_INSIGHTS_DISABLE_EXTENDED_METRIC";
      Config2.ENV_nativeMetricsDisableAll = "APPLICATION_INSIGHTS_DISABLE_ALL_EXTENDED_METRICS";
      Config2.ENV_http_proxy = "http_proxy";
      Config2.ENV_https_proxy = "https_proxy";
      return Config2;
    }();
    module2.exports = Config;
  }
});

// ../../node_modules/applicationinsights/out/Library/QuickPulseEnvelopeFactory.js
var require_QuickPulseEnvelopeFactory = __commonJS({
  "../../node_modules/applicationinsights/out/Library/QuickPulseEnvelopeFactory.js"(exports2, module2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    var os = require("os");
    var Contracts = require_Contracts();
    var Constants = require_Constants2();
    var Util = require_Util();
    var Logging = require_Logging();
    var StreamId = Util.w3cTraceId();
    var QuickPulseEnvelopeFactory = function() {
      function QuickPulseEnvelopeFactory2() {
      }
      QuickPulseEnvelopeFactory2.createQuickPulseEnvelope = function(metrics, documents, config, context) {
        var machineName = os && typeof os.hostname === "function" && os.hostname() || "Unknown";
        var instance = context.tags && context.keys && context.keys.cloudRoleInstance && context.tags[context.keys.cloudRoleInstance] || machineName;
        var envelope = {
          Documents: documents.length > 0 ? documents : null,
          InstrumentationKey: config.instrumentationKey || "",
          Metrics: metrics.length > 0 ? metrics : null,
          InvariantVersion: 1,
          Timestamp: "/Date(" + Date.now() + ")/",
          Version: context.tags[context.keys.internalSdkVersion],
          StreamId,
          MachineName: machineName,
          Instance: instance
        };
        return envelope;
      };
      QuickPulseEnvelopeFactory2.createQuickPulseMetric = function(telemetry) {
        var data2;
        data2 = {
          Name: telemetry.name,
          Value: telemetry.value,
          Weight: telemetry.count || 1
        };
        return data2;
      };
      QuickPulseEnvelopeFactory2.telemetryEnvelopeToQuickPulseDocument = function(envelope) {
        switch (envelope.data.baseType) {
          case Contracts.TelemetryTypeString.Event:
            return QuickPulseEnvelopeFactory2.createQuickPulseEventDocument(envelope);
          case Contracts.TelemetryTypeString.Exception:
            return QuickPulseEnvelopeFactory2.createQuickPulseExceptionDocument(envelope);
          case Contracts.TelemetryTypeString.Trace:
            return QuickPulseEnvelopeFactory2.createQuickPulseTraceDocument(envelope);
          case Contracts.TelemetryTypeString.Dependency:
            return QuickPulseEnvelopeFactory2.createQuickPulseDependencyDocument(envelope);
          case Contracts.TelemetryTypeString.Request:
            return QuickPulseEnvelopeFactory2.createQuickPulseRequestDocument(envelope);
        }
        return null;
      };
      QuickPulseEnvelopeFactory2.createQuickPulseEventDocument = function(envelope) {
        var document2 = QuickPulseEnvelopeFactory2.createQuickPulseDocument(envelope);
        var name = envelope.data.baseData.name;
        var eventDocument = __assign({}, document2, { Name: name });
        return eventDocument;
      };
      QuickPulseEnvelopeFactory2.createQuickPulseTraceDocument = function(envelope) {
        var document2 = QuickPulseEnvelopeFactory2.createQuickPulseDocument(envelope);
        var severityLevel = envelope.data.baseData.severityLevel || 0;
        var traceDocument = __assign({}, document2, { Message: envelope.data.baseData.message, SeverityLevel: Contracts.SeverityLevel[severityLevel] });
        return traceDocument;
      };
      QuickPulseEnvelopeFactory2.createQuickPulseExceptionDocument = function(envelope) {
        var document2 = QuickPulseEnvelopeFactory2.createQuickPulseDocument(envelope);
        var exceptionDetails = envelope.data.baseData.exceptions;
        var exception = "";
        var exceptionMessage = "";
        var exceptionType = "";
        if (exceptionDetails && exceptionDetails.length > 0) {
          if (exceptionDetails[0].parsedStack && exceptionDetails[0].parsedStack.length > 0) {
            exceptionDetails[0].parsedStack.forEach(function(err) {
              exception += err.assembly + "\n";
            });
          } else if (exceptionDetails[0].stack && exceptionDetails[0].stack.length > 0) {
            exception = exceptionDetails[0].stack;
          }
          exceptionMessage = exceptionDetails[0].message;
          exceptionType = exceptionDetails[0].typeName;
        }
        var exceptionDocument = __assign({}, document2, { Exception: exception, ExceptionMessage: exceptionMessage, ExceptionType: exceptionType });
        return exceptionDocument;
      };
      QuickPulseEnvelopeFactory2.createQuickPulseRequestDocument = function(envelope) {
        var document2 = QuickPulseEnvelopeFactory2.createQuickPulseDocument(envelope);
        var baseData = envelope.data.baseData;
        var requestDocument = __assign({}, document2, {
          Name: baseData.name,
          Success: baseData.success,
          Duration: baseData.duration,
          ResponseCode: baseData.responseCode,
          OperationName: baseData.name
        });
        return requestDocument;
      };
      QuickPulseEnvelopeFactory2.createQuickPulseDependencyDocument = function(envelope) {
        var document2 = QuickPulseEnvelopeFactory2.createQuickPulseDocument(envelope);
        var baseData = envelope.data.baseData;
        var dependencyDocument = __assign({}, document2, { Name: baseData.name, Target: baseData.target, Success: baseData.success, Duration: baseData.duration, ResultCode: baseData.resultCode, CommandName: baseData.data, OperationName: document2.OperationId, DependencyTypeName: baseData.type });
        return dependencyDocument;
      };
      QuickPulseEnvelopeFactory2.createQuickPulseDocument = function(envelope) {
        var documentType;
        var __type;
        var operationId, properties;
        if (envelope.data.baseType) {
          __type = Constants.TelemetryTypeStringToQuickPulseType[envelope.data.baseType];
          documentType = Constants.TelemetryTypeStringToQuickPulseDocumentType[envelope.data.baseType];
        } else {
          Logging.warn("Document type invalid; not sending live metric document", envelope.data.baseType);
        }
        operationId = envelope.tags[QuickPulseEnvelopeFactory2.keys.operationId];
        properties = QuickPulseEnvelopeFactory2.aggregateProperties(envelope);
        var document2 = {
          DocumentType: documentType,
          __type,
          OperationId: operationId,
          Version: "1.0",
          Properties: properties
        };
        return document2;
      };
      QuickPulseEnvelopeFactory2.aggregateProperties = function(envelope) {
        var properties = [];
        var meas = envelope.data.baseData.measurements || {};
        for (var key in meas) {
          if (meas.hasOwnProperty(key)) {
            var value = meas[key];
            var property = { key, value };
            properties.push(property);
          }
        }
        var props = envelope.data.baseData.properties || {};
        for (var key in props) {
          if (props.hasOwnProperty(key)) {
            var value = props[key];
            var property = { key, value };
            properties.push(property);
          }
        }
        return properties;
      };
      QuickPulseEnvelopeFactory2.keys = new Contracts.ContextTagKeys();
      return QuickPulseEnvelopeFactory2;
    }();
    module2.exports = QuickPulseEnvelopeFactory;
  }
});

// ../../node_modules/applicationinsights/out/Library/QuickPulseSender.js
var require_QuickPulseSender = __commonJS({
  "../../node_modules/applicationinsights/out/Library/QuickPulseSender.js"(exports2, module2) {
    "use strict";
    var https = require("https");
    var AutoCollectHttpDependencies = require_HttpDependencies();
    var Logging = require_Logging();
    var QuickPulseConfig = {
      method: "POST",
      time: "x-ms-qps-transmission-time",
      subscribed: "x-ms-qps-subscribed"
    };
    var QuickPulseSender = function() {
      function QuickPulseSender2(config) {
        this._config = config;
        this._consecutiveErrors = 0;
      }
      QuickPulseSender2.prototype.ping = function(envelope, done) {
        this._submitData(envelope, done, "ping");
      };
      QuickPulseSender2.prototype.post = function(envelope, done) {
        this._submitData([envelope], done, "post");
      };
      QuickPulseSender2.prototype._submitData = function(envelope, done, postOrPing) {
        var _this = this;
        var payload = JSON.stringify(envelope);
        var options2 = (_a2 = {}, _a2[AutoCollectHttpDependencies.disableCollectionRequestOption] = true, _a2.host = this._config.quickPulseHost, _a2.method = QuickPulseConfig.method, _a2.path = "/QuickPulseService.svc/" + postOrPing + "?ikey=" + this._config.instrumentationKey, _a2.headers = (_b = {
          "Expect": "100-continue"
        }, _b[QuickPulseConfig.time] = 1e4 * Date.now(), _b["Content-Type"] = "application/json", _b["Content-Length"] = Buffer.byteLength(payload), _b), _a2);
        var req = https.request(options2, function(res) {
          var shouldPOSTData = res.headers[QuickPulseConfig.subscribed] === "true";
          _this._consecutiveErrors = 0;
          done(shouldPOSTData, res);
        });
        req.on("error", function(error3) {
          _this._consecutiveErrors++;
          var notice = "Transient error connecting to the Live Metrics endpoint. This packet will not appear in your Live Metrics Stream. Error:";
          if (_this._consecutiveErrors % QuickPulseSender2.MAX_QPS_FAILURES_BEFORE_WARN === 0) {
            notice = "Live Metrics endpoint could not be reached " + _this._consecutiveErrors + " consecutive times. Most recent error:";
            Logging.warn(QuickPulseSender2.TAG, notice, error3);
          } else {
            Logging.info(QuickPulseSender2.TAG, notice, error3);
          }
          done();
        });
        req.write(payload);
        req.end();
        var _a2, _b;
      };
      QuickPulseSender2.TAG = "QuickPulseSender";
      QuickPulseSender2.MAX_QPS_FAILURES_BEFORE_WARN = 25;
      return QuickPulseSender2;
    }();
    module2.exports = QuickPulseSender;
  }
});

// ../../node_modules/applicationinsights/out/Library/Context.js
var require_Context = __commonJS({
  "../../node_modules/applicationinsights/out/Library/Context.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var fs2 = require("fs");
    var path = require("path");
    var Contracts = require_Contracts();
    var Logging = require_Logging();
    var Context = function() {
      function Context2(packageJsonPath) {
        this.keys = new Contracts.ContextTagKeys();
        this.tags = {};
        this._loadApplicationContext();
        this._loadDeviceContext();
        this._loadInternalContext();
      }
      Context2.prototype._loadApplicationContext = function(packageJsonPath) {
        packageJsonPath = packageJsonPath || path.resolve(__dirname, "../../../../package.json");
        if (!Context2.appVersion[packageJsonPath]) {
          Context2.appVersion[packageJsonPath] = "unknown";
          try {
            var packageJson = JSON.parse(fs2.readFileSync(packageJsonPath, "utf8"));
            if (packageJson && typeof packageJson.version === "string") {
              Context2.appVersion[packageJsonPath] = packageJson.version;
            }
          } catch (exception) {
            Logging.info("unable to read app version: ", exception);
          }
        }
        this.tags[this.keys.applicationVersion] = Context2.appVersion[packageJsonPath];
      };
      Context2.prototype._loadDeviceContext = function() {
        this.tags[this.keys.deviceId] = "";
        this.tags[this.keys.cloudRoleInstance] = os && os.hostname();
        this.tags[this.keys.deviceOSVersion] = os && os.type() + " " + os.release();
        this.tags[this.keys.cloudRole] = Context2.DefaultRoleName;
        this.tags["ai.device.osArchitecture"] = os && os.arch();
        this.tags["ai.device.osPlatform"] = os && os.platform();
      };
      Context2.prototype._loadInternalContext = function() {
        var packageJsonPath = path.resolve(__dirname, "../../package.json");
        if (!Context2.sdkVersion) {
          Context2.sdkVersion = "unknown";
          try {
            var packageJson = JSON.parse(fs2.readFileSync(packageJsonPath, "utf8"));
            if (packageJson && typeof packageJson.version === "string") {
              Context2.sdkVersion = packageJson.version;
            }
          } catch (exception) {
            Logging.info("unable to read app version: ", exception);
          }
        }
        this.tags[this.keys.internalSdkVersion] = "node:" + Context2.sdkVersion;
      };
      Context2.DefaultRoleName = "Web";
      Context2.appVersion = {};
      Context2.sdkVersion = null;
      return Context2;
    }();
    module2.exports = Context;
  }
});

// ../../node_modules/applicationinsights/out/Library/QuickPulseStateManager.js
var require_QuickPulseStateManager = __commonJS({
  "../../node_modules/applicationinsights/out/Library/QuickPulseStateManager.js"(exports2, module2) {
    "use strict";
    var Logging = require_Logging();
    var Config = require_Config();
    var QuickPulseEnvelopeFactory = require_QuickPulseEnvelopeFactory();
    var QuickPulseSender = require_QuickPulseSender();
    var Constants = require_Constants2();
    var Context = require_Context();
    var QuickPulseStateManager = function() {
      function QuickPulseStateManager2(iKey, context) {
        this._isCollectingData = false;
        this._lastSuccessTime = Date.now();
        this._lastSendSucceeded = true;
        this._metrics = {};
        this._documents = [];
        this._collectors = [];
        this.config = new Config(iKey);
        this.context = context || new Context();
        this._sender = new QuickPulseSender(this.config);
        this._isEnabled = false;
      }
      QuickPulseStateManager2.prototype.addCollector = function(collector) {
        this._collectors.push(collector);
      };
      QuickPulseStateManager2.prototype.trackMetric = function(telemetry) {
        this._addMetric(telemetry);
      };
      QuickPulseStateManager2.prototype.addDocument = function(envelope) {
        var document2 = QuickPulseEnvelopeFactory.telemetryEnvelopeToQuickPulseDocument(envelope);
        if (document2) {
          this._documents.push(document2);
        }
      };
      QuickPulseStateManager2.prototype.enable = function(isEnabled) {
        if (isEnabled && !this._isEnabled) {
          this._isEnabled = true;
          this._goQuickPulse();
        } else if (!isEnabled && this._isEnabled) {
          this._isEnabled = false;
          clearTimeout(this._handle);
          this._handle = void 0;
        }
      };
      QuickPulseStateManager2.prototype.enableCollectors = function(enable) {
        this._collectors.forEach(function(collector) {
          collector.enable(enable);
        });
      };
      QuickPulseStateManager2.prototype._addMetric = function(telemetry) {
        var value = telemetry.value;
        var count = telemetry.count || 1;
        var name = Constants.PerformanceToQuickPulseCounter[telemetry.name];
        if (name) {
          if (this._metrics[name]) {
            this._metrics[name].Value = (this._metrics[name].Value * this._metrics[name].Weight + value * count) / (this._metrics[name].Weight + count);
            this._metrics[name].Weight += count;
          } else {
            this._metrics[name] = QuickPulseEnvelopeFactory.createQuickPulseMetric(telemetry);
            this._metrics[name].Name = name;
            this._metrics[name].Weight = 1;
          }
        }
      };
      QuickPulseStateManager2.prototype._resetQuickPulseBuffer = function() {
        delete this._metrics;
        this._metrics = {};
        this._documents.length = 0;
      };
      QuickPulseStateManager2.prototype._goQuickPulse = function() {
        var _this = this;
        var metrics = Object.keys(this._metrics).map(function(k) {
          return _this._metrics[k];
        });
        var envelope = QuickPulseEnvelopeFactory.createQuickPulseEnvelope(metrics, this._documents.slice(), this.config, this.context);
        this._resetQuickPulseBuffer();
        if (this._isCollectingData) {
          this._post(envelope);
        } else {
          this._ping(envelope);
        }
        var currentTimeout = this._isCollectingData ? QuickPulseStateManager2.POST_INTERVAL : QuickPulseStateManager2.PING_INTERVAL;
        if (this._isCollectingData && Date.now() - this._lastSuccessTime >= QuickPulseStateManager2.MAX_POST_WAIT_TIME && !this._lastSendSucceeded) {
          this._isCollectingData = false;
          currentTimeout = QuickPulseStateManager2.FALLBACK_INTERVAL;
        } else if (!this._isCollectingData && Date.now() - this._lastSuccessTime >= QuickPulseStateManager2.MAX_PING_WAIT_TIME && !this._lastSendSucceeded) {
          currentTimeout = QuickPulseStateManager2.FALLBACK_INTERVAL;
        }
        this._lastSendSucceeded = null;
        this._handle = setTimeout(this._goQuickPulse.bind(this), currentTimeout);
        this._handle.unref();
      };
      QuickPulseStateManager2.prototype._ping = function(envelope) {
        this._sender.ping(envelope, this._quickPulseDone.bind(this));
      };
      QuickPulseStateManager2.prototype._post = function(envelope) {
        this._sender.post(envelope, this._quickPulseDone.bind(this));
      };
      QuickPulseStateManager2.prototype._quickPulseDone = function(shouldPOST, res) {
        if (shouldPOST != void 0) {
          if (this._isCollectingData !== shouldPOST) {
            Logging.info("Live Metrics sending data", shouldPOST);
            this.enableCollectors(shouldPOST);
          }
          this._isCollectingData = shouldPOST;
          if (res && res.statusCode < 300 && res.statusCode >= 200) {
            this._lastSuccessTime = Date.now();
            this._lastSendSucceeded = true;
          } else {
            this._lastSendSucceeded = false;
          }
        } else {
          this._lastSendSucceeded = false;
        }
      };
      QuickPulseStateManager2.MAX_POST_WAIT_TIME = 2e4;
      QuickPulseStateManager2.MAX_PING_WAIT_TIME = 6e4;
      QuickPulseStateManager2.FALLBACK_INTERVAL = 6e4;
      QuickPulseStateManager2.PING_INTERVAL = 5e3;
      QuickPulseStateManager2.POST_INTERVAL = 1e3;
      return QuickPulseStateManager2;
    }();
    module2.exports = QuickPulseStateManager;
  }
});

// ../../node_modules/applicationinsights/out/AutoCollection/NativePerformance.js
var require_NativePerformance = __commonJS({
  "../../node_modules/applicationinsights/out/AutoCollection/NativePerformance.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Config = require_Config();
    var Context = require_Context();
    var Logging = require_Logging();
    var AutoCollectNativePerformance = function() {
      function AutoCollectNativePerformance2(client) {
        this._disabledMetrics = {};
        if (AutoCollectNativePerformance2.INSTANCE) {
          AutoCollectNativePerformance2.INSTANCE.dispose();
        }
        AutoCollectNativePerformance2.INSTANCE = this;
        this._client = client;
      }
      AutoCollectNativePerformance2.isNodeVersionCompatible = function() {
        var nodeVer = process.versions.node.split(".");
        return parseInt(nodeVer[0]) >= 6;
      };
      AutoCollectNativePerformance2.prototype.enable = function(isEnabled, disabledMetrics, collectionInterval) {
        var _this = this;
        if (disabledMetrics === void 0) {
          disabledMetrics = {};
        }
        if (collectionInterval === void 0) {
          collectionInterval = 6e4;
        }
        if (!AutoCollectNativePerformance2.isNodeVersionCompatible()) {
          return;
        }
        if (AutoCollectNativePerformance2._metricsAvailable == void 0 && isEnabled && !this._isInitialized) {
          try {
            var NativeMetricsEmitters = require("applicationinsights-native-metrics");
            AutoCollectNativePerformance2._emitter = new NativeMetricsEmitters();
            AutoCollectNativePerformance2._metricsAvailable = true;
            Logging.info("Native metrics module successfully loaded!");
          } catch (err) {
            AutoCollectNativePerformance2._metricsAvailable = false;
            return;
          }
        }
        this._isEnabled = isEnabled;
        this._disabledMetrics = disabledMetrics;
        if (this._isEnabled && !this._isInitialized) {
          this._isInitialized = true;
        }
        if (this._isEnabled && AutoCollectNativePerformance2._emitter) {
          AutoCollectNativePerformance2._emitter.enable(true, collectionInterval);
          this._handle = setInterval(function() {
            return _this._trackNativeMetrics();
          }, collectionInterval);
          this._handle.unref();
        } else if (AutoCollectNativePerformance2._emitter) {
          AutoCollectNativePerformance2._emitter.enable(false);
          if (this._handle) {
            clearInterval(this._handle);
            this._handle = void 0;
          }
        }
      };
      AutoCollectNativePerformance2.prototype.dispose = function() {
        this.enable(false);
      };
      AutoCollectNativePerformance2.parseEnabled = function(collectExtendedMetrics) {
        var disableAll = process.env[Config.ENV_nativeMetricsDisableAll];
        var individualOptOuts = process.env[Config.ENV_nativeMetricsDisablers];
        if (disableAll) {
          return { isEnabled: false, disabledMetrics: {} };
        }
        if (individualOptOuts) {
          var optOutsArr = individualOptOuts.split(",");
          var disabledMetrics = {};
          if (optOutsArr.length > 0) {
            for (var _i = 0, optOutsArr_1 = optOutsArr; _i < optOutsArr_1.length; _i++) {
              var opt = optOutsArr_1[_i];
              disabledMetrics[opt] = true;
            }
          }
          if (typeof collectExtendedMetrics === "object") {
            return { isEnabled: true, disabledMetrics: __assign({}, collectExtendedMetrics, disabledMetrics) };
          }
          return { isEnabled: collectExtendedMetrics, disabledMetrics };
        }
        if (typeof collectExtendedMetrics === "boolean") {
          return { isEnabled: collectExtendedMetrics, disabledMetrics: {} };
        } else {
          return { isEnabled: true, disabledMetrics: collectExtendedMetrics };
        }
      };
      AutoCollectNativePerformance2.prototype._trackNativeMetrics = function() {
        var shouldSendAll = true;
        if (typeof this._isEnabled !== "object") {
          shouldSendAll = this._isEnabled;
        }
        if (shouldSendAll) {
          this._trackGarbageCollection();
          this._trackEventLoop();
          this._trackHeapUsage();
        }
      };
      AutoCollectNativePerformance2.prototype._trackGarbageCollection = function() {
        if (this._disabledMetrics.gc) {
          return;
        }
        var gcData = AutoCollectNativePerformance2._emitter.getGCData();
        for (var gc in gcData) {
          var metrics = gcData[gc].metrics;
          var name_1 = gc + " Garbage Collection Duration";
          var stdDev = Math.sqrt(metrics.sumSquares / metrics.count - Math.pow(metrics.total / metrics.count, 2)) || 0;
          this._client.trackMetric({
            name: name_1,
            value: metrics.total,
            count: metrics.count,
            max: metrics.max,
            min: metrics.min,
            stdDev,
            tagOverrides: (_a2 = {}, _a2[this._client.context.keys.internalSdkVersion] = "node-nativeperf:" + Context.sdkVersion, _a2)
          });
        }
        var _a2;
      };
      AutoCollectNativePerformance2.prototype._trackEventLoop = function() {
        if (this._disabledMetrics.loop) {
          return;
        }
        var loopData = AutoCollectNativePerformance2._emitter.getLoopData();
        var metrics = loopData.loopUsage;
        if (metrics.count == 0) {
          return;
        }
        var name = "Event Loop CPU Time";
        var stdDev = Math.sqrt(metrics.sumSquares / metrics.count - Math.pow(metrics.total / metrics.count, 2)) || 0;
        this._client.trackMetric({
          name,
          value: metrics.total,
          count: metrics.count,
          min: metrics.min,
          max: metrics.max,
          stdDev,
          tagOverrides: (_a2 = {}, _a2[this._client.context.keys.internalSdkVersion] = "node-nativeperf:" + Context.sdkVersion, _a2)
        });
        var _a2;
      };
      AutoCollectNativePerformance2.prototype._trackHeapUsage = function() {
        if (this._disabledMetrics.heap) {
          return;
        }
        var memoryUsage = process.memoryUsage();
        var heapUsed = memoryUsage.heapUsed, heapTotal = memoryUsage.heapTotal, rss = memoryUsage.rss;
        this._client.trackMetric({
          name: "Memory Usage (Heap)",
          value: heapUsed,
          count: 1,
          tagOverrides: (_a2 = {}, _a2[this._client.context.keys.internalSdkVersion] = "node-nativeperf:" + Context.sdkVersion, _a2)
        });
        this._client.trackMetric({
          name: "Memory Total (Heap)",
          value: heapTotal,
          count: 1,
          tagOverrides: (_b = {}, _b[this._client.context.keys.internalSdkVersion] = "node-nativeperf:" + Context.sdkVersion, _b)
        });
        this._client.trackMetric({
          name: "Memory Usage (Non-Heap)",
          value: rss - heapTotal,
          count: 1,
          tagOverrides: (_c = {}, _c[this._client.context.keys.internalSdkVersion] = "node-nativeperf:" + Context.sdkVersion, _c)
        });
        var _a2, _b, _c;
      };
      return AutoCollectNativePerformance2;
    }();
    exports2.AutoCollectNativePerformance = AutoCollectNativePerformance;
  }
});

// ../../node_modules/applicationinsights/out/Library/Channel.js
var require_Channel = __commonJS({
  "../../node_modules/applicationinsights/out/Library/Channel.js"(exports2, module2) {
    "use strict";
    var Logging = require_Logging();
    var Channel = function() {
      function Channel2(isDisabled, getBatchSize, getBatchIntervalMs, sender) {
        this._buffer = [];
        this._lastSend = 0;
        this._isDisabled = isDisabled;
        this._getBatchSize = getBatchSize;
        this._getBatchIntervalMs = getBatchIntervalMs;
        this._sender = sender;
      }
      Channel2.prototype.setUseDiskRetryCaching = function(value, resendInterval, maxBytesOnDisk) {
        this._sender.setDiskRetryMode(value, resendInterval, maxBytesOnDisk);
      };
      Channel2.prototype.send = function(envelope) {
        var _this = this;
        if (this._isDisabled()) {
          return;
        }
        if (!envelope) {
          Logging.warn("Cannot send null/undefined telemetry");
          return;
        }
        var payload = this._stringify(envelope);
        if (typeof payload !== "string") {
          return;
        }
        this._buffer.push(payload);
        if (this._buffer.length >= this._getBatchSize()) {
          this.triggerSend(false);
          return;
        }
        if (!this._timeoutHandle && this._buffer.length > 0) {
          this._timeoutHandle = setTimeout(function() {
            _this._timeoutHandle = null;
            _this.triggerSend(false);
          }, this._getBatchIntervalMs());
        }
      };
      Channel2.prototype.triggerSend = function(isNodeCrashing, callback) {
        var bufferIsEmpty = this._buffer.length < 1;
        if (!bufferIsEmpty) {
          var batch = this._buffer.join("\n");
          if (isNodeCrashing) {
            this._sender.saveOnCrash(batch);
            if (typeof callback === "function") {
              callback("data saved on crash");
            }
          } else {
            this._sender.send(Buffer.from ? Buffer.from(batch) : new Buffer(batch), callback);
          }
        }
        this._lastSend = +new Date();
        this._buffer.length = 0;
        clearTimeout(this._timeoutHandle);
        this._timeoutHandle = null;
        if (bufferIsEmpty && typeof callback === "function") {
          callback("no data to send");
        }
      };
      Channel2.prototype._stringify = function(envelope) {
        try {
          return JSON.stringify(envelope);
        } catch (error3) {
          Logging.warn("Failed to serialize payload", error3, envelope);
        }
      };
      return Channel2;
    }();
    module2.exports = Channel;
  }
});

// ../../node_modules/applicationinsights/out/TelemetryProcessors/SamplingTelemetryProcessor.js
var require_SamplingTelemetryProcessor = __commonJS({
  "../../node_modules/applicationinsights/out/TelemetryProcessors/SamplingTelemetryProcessor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Contracts = require_Contracts();
    function samplingTelemetryProcessor(envelope, contextObjects) {
      var samplingPercentage = envelope.sampleRate;
      var isSampledIn = false;
      if (samplingPercentage === null || samplingPercentage === void 0 || samplingPercentage >= 100) {
        return true;
      } else if (envelope.data && Contracts.TelemetryType.Metric === Contracts.baseTypeToTelemetryType(envelope.data.baseType)) {
        return true;
      } else if (contextObjects.correlationContext && contextObjects.correlationContext.operation) {
        isSampledIn = getSamplingHashCode(contextObjects.correlationContext.operation.id) < samplingPercentage;
      } else {
        isSampledIn = Math.random() * 100 < samplingPercentage;
      }
      return isSampledIn;
    }
    exports2.samplingTelemetryProcessor = samplingTelemetryProcessor;
    function getSamplingHashCode(input) {
      var csharpMin = -2147483648;
      var csharpMax = 2147483647;
      var hash = 5381;
      if (!input) {
        return 0;
      }
      while (input.length < 8) {
        input = input + input;
      }
      for (var i = 0; i < input.length; i++) {
        hash = ((hash << 5) + hash | 0) + input.charCodeAt(i) | 0;
      }
      hash = hash <= csharpMin ? csharpMax : Math.abs(hash);
      return hash / csharpMax * 100;
    }
    exports2.getSamplingHashCode = getSamplingHashCode;
  }
});

// ../../node_modules/applicationinsights/out/TelemetryProcessors/QuickPulseTelemetryProcessor.js
var require_QuickPulseTelemetryProcessor = __commonJS({
  "../../node_modules/applicationinsights/out/TelemetryProcessors/QuickPulseTelemetryProcessor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var AutoCollectPerformance = require_Performance();
    function quickPulseTelemetryProcessor(envelope, client) {
      if (client) {
        client.addDocument(envelope);
        switch (envelope.data.baseType) {
          case "ExceptionData":
            AutoCollectPerformance.countException();
            break;
          case "RequestData":
            break;
          case "RemoteDependencyData":
            var baseData = envelope.data.baseData;
            AutoCollectPerformance.countDependency(baseData.duration, baseData.success);
            break;
        }
      }
      return true;
    }
    exports2.quickPulseTelemetryProcessor = quickPulseTelemetryProcessor;
  }
});

// ../../node_modules/applicationinsights/out/TelemetryProcessors/index.js
var require_TelemetryProcessors = __commonJS({
  "../../node_modules/applicationinsights/out/TelemetryProcessors/index.js"(exports2) {
    "use strict";
    function __export2(m) {
      for (var p in m)
        if (!exports2.hasOwnProperty(p))
          exports2[p] = m[p];
    }
    Object.defineProperty(exports2, "__esModule", { value: true });
    __export2(require_SamplingTelemetryProcessor());
    __export2(require_QuickPulseTelemetryProcessor());
  }
});

// ../../node_modules/applicationinsights/out/Library/Sender.js
var require_Sender = __commonJS({
  "../../node_modules/applicationinsights/out/Library/Sender.js"(exports2, module2) {
    "use strict";
    var fs2 = require("fs");
    var os = require("os");
    var path = require("path");
    var zlib = require("zlib");
    var child_process = require("child_process");
    var Logging = require_Logging();
    var AutoCollectHttpDependencies = require_HttpDependencies();
    var Util = require_Util();
    var Sender = function() {
      function Sender2(config, onSuccess, onError) {
        this._config = config;
        this._onSuccess = onSuccess;
        this._onError = onError;
        this._enableDiskRetryMode = false;
        this._resendInterval = Sender2.WAIT_BETWEEN_RESEND;
        this._maxBytesOnDisk = Sender2.MAX_BYTES_ON_DISK;
        this._numConsecutiveFailures = 0;
        if (!Sender2.OS_PROVIDES_FILE_PROTECTION) {
          if (Sender2.USE_ICACLS) {
            try {
              Sender2.OS_PROVIDES_FILE_PROTECTION = fs2.existsSync(Sender2.ICACLS_PATH);
            } catch (e) {
            }
            if (!Sender2.OS_PROVIDES_FILE_PROTECTION) {
              Logging.warn(Sender2.TAG, "Could not find ICACLS in expected location! This is necessary to use disk retry mode on Windows.");
            }
          } else {
            Sender2.OS_PROVIDES_FILE_PROTECTION = true;
          }
        }
      }
      Sender2.prototype.setDiskRetryMode = function(value, resendInterval, maxBytesOnDisk) {
        this._enableDiskRetryMode = Sender2.OS_PROVIDES_FILE_PROTECTION && value;
        if (typeof resendInterval === "number" && resendInterval >= 0) {
          this._resendInterval = Math.floor(resendInterval);
        }
        if (typeof maxBytesOnDisk === "number" && maxBytesOnDisk >= 0) {
          this._maxBytesOnDisk = Math.floor(maxBytesOnDisk);
        }
        if (value && !Sender2.OS_PROVIDES_FILE_PROTECTION) {
          this._enableDiskRetryMode = false;
          Logging.warn(Sender2.TAG, "Ignoring request to enable disk retry mode. Sufficient file protection capabilities were not detected.");
        }
      };
      Sender2.prototype.send = function(payload, callback) {
        var _this = this;
        var endpointUrl = this._config.endpointUrl;
        var options2 = {
          method: "POST",
          withCredentials: false,
          headers: {
            "Content-Type": "application/x-json-stream"
          }
        };
        zlib.gzip(payload, function(err, buffer) {
          var dataToSend = buffer;
          if (err) {
            Logging.warn(err);
            dataToSend = payload;
            options2.headers["Content-Length"] = payload.length.toString();
          } else {
            options2.headers["Content-Encoding"] = "gzip";
            options2.headers["Content-Length"] = buffer.length;
          }
          Logging.info(Sender2.TAG, options2);
          options2[AutoCollectHttpDependencies.disableCollectionRequestOption] = true;
          var requestCallback = function(res) {
            res.setEncoding("utf-8");
            var responseString = "";
            res.on("data", function(data2) {
              responseString += data2;
            });
            res.on("end", function() {
              _this._numConsecutiveFailures = 0;
              Logging.info(Sender2.TAG, responseString);
              if (typeof _this._onSuccess === "function") {
                _this._onSuccess(responseString);
              }
              if (typeof callback === "function") {
                callback(responseString);
              }
              if (_this._enableDiskRetryMode) {
                if (res.statusCode === 200) {
                  setTimeout(function() {
                    return _this._sendFirstFileOnDisk();
                  }, _this._resendInterval).unref();
                } else if (res.statusCode === 408 || res.statusCode === 429 || res.statusCode === 439 || res.statusCode === 500 || res.statusCode === 503) {
                  _this._storeToDisk(payload);
                }
              }
            });
          };
          var req = Util.makeRequest(_this._config, endpointUrl, options2, requestCallback);
          req.on("error", function(error3) {
            _this._numConsecutiveFailures++;
            if (!_this._enableDiskRetryMode || _this._numConsecutiveFailures > 0 && _this._numConsecutiveFailures % Sender2.MAX_CONNECTION_FAILURES_BEFORE_WARN === 0) {
              var notice = "Ingestion endpoint could not be reached. This batch of telemetry items has been lost. Use Disk Retry Caching to enable resending of failed telemetry. Error:";
              if (_this._enableDiskRetryMode) {
                notice = "Ingestion endpoint could not be reached " + _this._numConsecutiveFailures + " consecutive times. There may be resulting telemetry loss. Most recent error:";
              }
              Logging.warn(Sender2.TAG, notice, error3);
            } else {
              var notice = "Transient failure to reach ingestion endpoint. This batch of telemetry items will be retried. Error:";
              Logging.info(Sender2.TAG, notice, error3);
            }
            _this._onErrorHelper(error3);
            if (typeof callback === "function") {
              var errorMessage = "error sending telemetry";
              if (error3 && typeof error3.toString === "function") {
                errorMessage = error3.toString();
              }
              callback(errorMessage);
            }
            if (_this._enableDiskRetryMode) {
              _this._storeToDisk(payload);
            }
          });
          req.write(dataToSend);
          req.end();
        });
      };
      Sender2.prototype.saveOnCrash = function(payload) {
        if (this._enableDiskRetryMode) {
          this._storeToDiskSync(payload);
        }
      };
      Sender2.prototype._runICACLS = function(args, callback) {
        var aclProc = child_process.spawn(Sender2.ICACLS_PATH, args, { windowsHide: true });
        aclProc.on("error", function(e) {
          return callback(e);
        });
        aclProc.on("close", function(code, signal) {
          return callback(code === 0 ? null : new Error("Setting ACL restrictions did not succeed (ICACLS returned code " + code + ")"));
        });
      };
      Sender2.prototype._runICACLSSync = function(args) {
        if (child_process.spawnSync) {
          var aclProc = child_process.spawnSync(Sender2.ICACLS_PATH, args, { windowsHide: true });
          if (aclProc.error) {
            throw aclProc.error;
          } else if (aclProc.status !== 0) {
            throw new Error("Setting ACL restrictions did not succeed (ICACLS returned code " + aclProc.status + ")");
          }
        } else {
          throw new Error("Could not synchronously call ICACLS under current version of Node.js");
        }
      };
      Sender2.prototype._getACLIdentity = function(callback) {
        if (Sender2.ACL_IDENTITY) {
          return callback(null, Sender2.ACL_IDENTITY);
        }
        var psProc = child_process.spawn(Sender2.POWERSHELL_PATH, ["-Command", "[System.Security.Principal.WindowsIdentity]::GetCurrent().Name"], {
          windowsHide: true,
          stdio: ["ignore", "pipe", "pipe"]
        });
        var data2 = "";
        psProc.stdout.on("data", function(d) {
          return data2 += d;
        });
        psProc.on("error", function(e) {
          return callback(e, null);
        });
        psProc.on("close", function(code, signal) {
          Sender2.ACL_IDENTITY = data2 && data2.trim();
          return callback(code === 0 ? null : new Error("Getting ACL identity did not succeed (PS returned code " + code + ")"), Sender2.ACL_IDENTITY);
        });
      };
      Sender2.prototype._getACLIdentitySync = function() {
        if (Sender2.ACL_IDENTITY) {
          return Sender2.ACL_IDENTITY;
        }
        if (child_process.spawnSync) {
          var psProc = child_process.spawnSync(Sender2.POWERSHELL_PATH, ["-Command", "[System.Security.Principal.WindowsIdentity]::GetCurrent().Name"], {
            windowsHide: true,
            stdio: ["ignore", "pipe", "pipe"]
          });
          if (psProc.error) {
            throw psProc.error;
          } else if (psProc.status !== 0) {
            throw new Error("Getting ACL identity did not succeed (PS returned code " + psProc.status + ")");
          }
          Sender2.ACL_IDENTITY = psProc.stdout && psProc.stdout.toString().trim();
          return Sender2.ACL_IDENTITY;
        } else {
          throw new Error("Could not synchronously get ACL identity under current version of Node.js");
        }
      };
      Sender2.prototype._getACLArguments = function(directory, identity) {
        return [
          directory,
          "/grant",
          "*S-1-5-32-544:(OI)(CI)F",
          "/grant",
          identity + ":(OI)(CI)F",
          "/inheritance:r"
        ];
      };
      Sender2.prototype._applyACLRules = function(directory, callback) {
        var _this = this;
        if (!Sender2.USE_ICACLS) {
          return callback(null);
        }
        if (Sender2.ACLED_DIRECTORIES[directory] === void 0) {
          Sender2.ACLED_DIRECTORIES[directory] = false;
          this._getACLIdentity(function(err, identity) {
            if (err) {
              Sender2.ACLED_DIRECTORIES[directory] = false;
              return callback(err);
            } else {
              _this._runICACLS(_this._getACLArguments(directory, identity), function(err2) {
                Sender2.ACLED_DIRECTORIES[directory] = !err2;
                return callback(err2);
              });
            }
          });
        } else {
          return callback(Sender2.ACLED_DIRECTORIES[directory] ? null : new Error("Setting ACL restrictions did not succeed (cached result)"));
        }
      };
      Sender2.prototype._applyACLRulesSync = function(directory) {
        if (Sender2.USE_ICACLS) {
          if (Sender2.ACLED_DIRECTORIES[directory] === void 0) {
            this._runICACLSSync(this._getACLArguments(directory, this._getACLIdentitySync()));
            Sender2.ACLED_DIRECTORIES[directory] = true;
            return;
          } else if (!Sender2.ACLED_DIRECTORIES[directory]) {
            throw new Error("Setting ACL restrictions did not succeed (cached result)");
          }
        }
      };
      Sender2.prototype._confirmDirExists = function(directory, callback) {
        var _this = this;
        fs2.lstat(directory, function(err, stats) {
          if (err && err.code === "ENOENT") {
            fs2.mkdir(directory, function(err2) {
              if (err2 && err2.code !== "EEXIST") {
                callback(err2);
              } else {
                _this._applyACLRules(directory, callback);
              }
            });
          } else if (!err && stats.isDirectory()) {
            _this._applyACLRules(directory, callback);
          } else {
            callback(err || new Error("Path existed but was not a directory"));
          }
        });
      };
      Sender2.prototype._getShallowDirectorySize = function(directory, callback) {
        fs2.readdir(directory, function(err, files) {
          if (err) {
            return callback(err, -1);
          }
          var error3 = null;
          var totalSize = 0;
          var count = 0;
          if (files.length === 0) {
            callback(null, 0);
            return;
          }
          for (var i = 0; i < files.length; i++) {
            fs2.stat(path.join(directory, files[i]), function(err2, fileStats) {
              count++;
              if (err2) {
                error3 = err2;
              } else {
                if (fileStats.isFile()) {
                  totalSize += fileStats.size;
                }
              }
              if (count === files.length) {
                if (error3) {
                  callback(error3, -1);
                } else {
                  callback(error3, totalSize);
                }
              }
            });
          }
        });
      };
      Sender2.prototype._getShallowDirectorySizeSync = function(directory) {
        var files = fs2.readdirSync(directory);
        var totalSize = 0;
        for (var i = 0; i < files.length; i++) {
          totalSize += fs2.statSync(path.join(directory, files[i])).size;
        }
        return totalSize;
      };
      Sender2.prototype._storeToDisk = function(payload) {
        var _this = this;
        var directory = path.join(os.tmpdir(), Sender2.TEMPDIR_PREFIX + this._config.instrumentationKey);
        Logging.info(Sender2.TAG, "Checking existance of data storage directory: " + directory);
        this._confirmDirExists(directory, function(error3) {
          if (error3) {
            Logging.warn(Sender2.TAG, "Error while checking/creating directory: " + (error3 && error3.message));
            _this._onErrorHelper(error3);
            return;
          }
          _this._getShallowDirectorySize(directory, function(err, size) {
            if (err || size < 0) {
              Logging.warn(Sender2.TAG, "Error while checking directory size: " + (err && err.message));
              _this._onErrorHelper(err);
              return;
            } else if (size > _this._maxBytesOnDisk) {
              Logging.warn(Sender2.TAG, "Not saving data due to max size limit being met. Directory size in bytes is: " + size);
              return;
            }
            var fileName = new Date().getTime() + ".ai.json";
            var fileFullPath = path.join(directory, fileName);
            Logging.info(Sender2.TAG, "saving data to disk at: " + fileFullPath);
            fs2.writeFile(fileFullPath, payload, { mode: 384 }, function(error4) {
              return _this._onErrorHelper(error4);
            });
          });
        });
      };
      Sender2.prototype._storeToDiskSync = function(payload) {
        var directory = path.join(os.tmpdir(), Sender2.TEMPDIR_PREFIX + this._config.instrumentationKey);
        try {
          Logging.info(Sender2.TAG, "Checking existance of data storage directory: " + directory);
          if (!fs2.existsSync(directory)) {
            fs2.mkdirSync(directory);
          }
          this._applyACLRulesSync(directory);
          var dirSize = this._getShallowDirectorySizeSync(directory);
          if (dirSize > this._maxBytesOnDisk) {
            Logging.info(Sender2.TAG, "Not saving data due to max size limit being met. Directory size in bytes is: " + dirSize);
            return;
          }
          var fileName = new Date().getTime() + ".ai.json";
          var fileFullPath = path.join(directory, fileName);
          Logging.info(Sender2.TAG, "saving data before crash to disk at: " + fileFullPath);
          fs2.writeFileSync(fileFullPath, payload, { mode: 384 });
        } catch (error3) {
          Logging.warn(Sender2.TAG, "Error while saving data to disk: " + (error3 && error3.message));
          this._onErrorHelper(error3);
        }
      };
      Sender2.prototype._sendFirstFileOnDisk = function() {
        var _this = this;
        var tempDir = path.join(os.tmpdir(), Sender2.TEMPDIR_PREFIX + this._config.instrumentationKey);
        fs2.exists(tempDir, function(exists) {
          if (exists) {
            fs2.readdir(tempDir, function(error3, files) {
              if (!error3) {
                files = files.filter(function(f) {
                  return path.basename(f).indexOf(".ai.json") > -1;
                });
                if (files.length > 0) {
                  var firstFile = files[0];
                  var filePath = path.join(tempDir, firstFile);
                  fs2.readFile(filePath, function(error4, payload) {
                    if (!error4) {
                      fs2.unlink(filePath, function(error5) {
                        if (!error5) {
                          _this.send(payload);
                        } else {
                          _this._onErrorHelper(error5);
                        }
                      });
                    } else {
                      _this._onErrorHelper(error4);
                    }
                  });
                }
              } else {
                _this._onErrorHelper(error3);
              }
            });
          }
        });
      };
      Sender2.prototype._onErrorHelper = function(error3) {
        if (typeof this._onError === "function") {
          this._onError(error3);
        }
      };
      Sender2.TAG = "Sender";
      Sender2.ICACLS_PATH = process.env.systemdrive + "/windows/system32/icacls.exe";
      Sender2.POWERSHELL_PATH = process.env.systemdrive + "/windows/system32/windowspowershell/v1.0/powershell.exe";
      Sender2.ACLED_DIRECTORIES = {};
      Sender2.ACL_IDENTITY = null;
      Sender2.WAIT_BETWEEN_RESEND = 60 * 1e3;
      Sender2.MAX_BYTES_ON_DISK = 50 * 1e3 * 1e3;
      Sender2.MAX_CONNECTION_FAILURES_BEFORE_WARN = 5;
      Sender2.TEMPDIR_PREFIX = "appInsights-node";
      Sender2.OS_PROVIDES_FILE_PROTECTION = false;
      Sender2.USE_ICACLS = os.type() === "Windows_NT";
      return Sender2;
    }();
    module2.exports = Sender;
  }
});

// ../../node_modules/applicationinsights/out/Library/EnvelopeFactory.js
var require_EnvelopeFactory = __commonJS({
  "../../node_modules/applicationinsights/out/Library/EnvelopeFactory.js"(exports2, module2) {
    "use strict";
    var Contracts = require_Contracts();
    var Util = require_Util();
    var CorrelationContextManager_1 = require_CorrelationContextManager();
    var EnvelopeFactory = function() {
      function EnvelopeFactory2() {
      }
      EnvelopeFactory2.createEnvelope = function(telemetry, telemetryType, commonProperties, context, config) {
        var data2 = null;
        switch (telemetryType) {
          case Contracts.TelemetryType.Trace:
            data2 = EnvelopeFactory2.createTraceData(telemetry);
            break;
          case Contracts.TelemetryType.Dependency:
            data2 = EnvelopeFactory2.createDependencyData(telemetry);
            break;
          case Contracts.TelemetryType.Event:
            data2 = EnvelopeFactory2.createEventData(telemetry);
            break;
          case Contracts.TelemetryType.Exception:
            data2 = EnvelopeFactory2.createExceptionData(telemetry);
            break;
          case Contracts.TelemetryType.Request:
            data2 = EnvelopeFactory2.createRequestData(telemetry);
            break;
          case Contracts.TelemetryType.Metric:
            data2 = EnvelopeFactory2.createMetricData(telemetry);
            break;
        }
        if (commonProperties && Contracts.domainSupportsProperties(data2.baseData)) {
          if (data2 && data2.baseData) {
            if (!data2.baseData.properties) {
              data2.baseData.properties = commonProperties;
            } else {
              for (var name in commonProperties) {
                if (!data2.baseData.properties[name]) {
                  data2.baseData.properties[name] = commonProperties[name];
                }
              }
            }
          }
          data2.baseData.properties = Util.validateStringMap(data2.baseData.properties);
        }
        var iKey = config ? config.instrumentationKey || "" : "";
        var envelope = new Contracts.Envelope();
        envelope.data = data2;
        envelope.iKey = iKey;
        envelope.name = "Microsoft.ApplicationInsights." + iKey.replace(/-/g, "") + "." + data2.baseType.substr(0, data2.baseType.length - 4);
        envelope.tags = this.getTags(context, telemetry.tagOverrides);
        envelope.time = new Date().toISOString();
        envelope.ver = 1;
        envelope.sampleRate = config ? config.samplingPercentage : 100;
        if (telemetryType === Contracts.TelemetryType.Metric) {
          envelope.sampleRate = 100;
        }
        return envelope;
      };
      EnvelopeFactory2.createTraceData = function(telemetry) {
        var trace = new Contracts.MessageData();
        trace.message = telemetry.message;
        trace.properties = telemetry.properties;
        if (!isNaN(telemetry.severity)) {
          trace.severityLevel = telemetry.severity;
        } else {
          trace.severityLevel = Contracts.SeverityLevel.Information;
        }
        var data2 = new Contracts.Data();
        data2.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Trace);
        data2.baseData = trace;
        return data2;
      };
      EnvelopeFactory2.createDependencyData = function(telemetry) {
        var remoteDependency = new Contracts.RemoteDependencyData();
        remoteDependency.name = telemetry.name;
        remoteDependency.data = telemetry.data;
        remoteDependency.target = telemetry.target;
        remoteDependency.duration = Util.msToTimeSpan(telemetry.duration);
        remoteDependency.success = telemetry.success;
        remoteDependency.type = telemetry.dependencyTypeName;
        remoteDependency.properties = telemetry.properties;
        remoteDependency.resultCode = telemetry.resultCode ? telemetry.resultCode + "" : "";
        if (telemetry.id) {
          remoteDependency.id = telemetry.id;
        } else {
          remoteDependency.id = Util.w3cTraceId();
        }
        var data2 = new Contracts.Data();
        data2.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Dependency);
        data2.baseData = remoteDependency;
        return data2;
      };
      EnvelopeFactory2.createEventData = function(telemetry) {
        var event = new Contracts.EventData();
        event.name = telemetry.name;
        event.properties = telemetry.properties;
        event.measurements = telemetry.measurements;
        var data2 = new Contracts.Data();
        data2.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Event);
        data2.baseData = event;
        return data2;
      };
      EnvelopeFactory2.createExceptionData = function(telemetry) {
        var exception = new Contracts.ExceptionData();
        exception.properties = telemetry.properties;
        exception.severityLevel = Contracts.SeverityLevel.Error;
        exception.measurements = telemetry.measurements;
        exception.exceptions = [];
        var stack = telemetry.exception["stack"];
        var exceptionDetails = new Contracts.ExceptionDetails();
        exceptionDetails.message = telemetry.exception.message;
        exceptionDetails.typeName = telemetry.exception.name;
        exceptionDetails.parsedStack = this.parseStack(stack);
        exceptionDetails.hasFullStack = Util.isArray(exceptionDetails.parsedStack) && exceptionDetails.parsedStack.length > 0;
        exception.exceptions.push(exceptionDetails);
        var data2 = new Contracts.Data();
        data2.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Exception);
        data2.baseData = exception;
        return data2;
      };
      EnvelopeFactory2.createRequestData = function(telemetry) {
        var requestData = new Contracts.RequestData();
        if (telemetry.id) {
          requestData.id = telemetry.id;
        } else {
          requestData.id = Util.w3cTraceId();
        }
        requestData.name = telemetry.name;
        requestData.url = telemetry.url;
        requestData.source = telemetry.source;
        requestData.duration = Util.msToTimeSpan(telemetry.duration);
        requestData.responseCode = telemetry.resultCode ? telemetry.resultCode + "" : "";
        requestData.success = telemetry.success;
        requestData.properties = telemetry.properties;
        var data2 = new Contracts.Data();
        data2.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Request);
        data2.baseData = requestData;
        return data2;
      };
      EnvelopeFactory2.createMetricData = function(telemetry) {
        var metrics = new Contracts.MetricData();
        metrics.metrics = [];
        var metric = new Contracts.DataPoint();
        metric.count = !isNaN(telemetry.count) ? telemetry.count : 1;
        metric.kind = Contracts.DataPointType.Aggregation;
        metric.max = !isNaN(telemetry.max) ? telemetry.max : telemetry.value;
        metric.min = !isNaN(telemetry.min) ? telemetry.min : telemetry.value;
        metric.name = telemetry.name;
        metric.stdDev = !isNaN(telemetry.stdDev) ? telemetry.stdDev : 0;
        metric.value = telemetry.value;
        metrics.metrics.push(metric);
        metrics.properties = telemetry.properties;
        var data2 = new Contracts.Data();
        data2.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Metric);
        data2.baseData = metrics;
        return data2;
      };
      EnvelopeFactory2.getTags = function(context, tagOverrides) {
        var correlationContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();
        var newTags = {};
        if (context && context.tags) {
          for (var key in context.tags) {
            newTags[key] = context.tags[key];
          }
        }
        if (tagOverrides) {
          for (var key in tagOverrides) {
            newTags[key] = tagOverrides[key];
          }
        }
        if (correlationContext) {
          newTags[context.keys.operationId] = newTags[context.keys.operationId] || correlationContext.operation.id;
          newTags[context.keys.operationName] = newTags[context.keys.operationName] || correlationContext.operation.name;
          newTags[context.keys.operationParentId] = newTags[context.keys.operationParentId] || correlationContext.operation.parentId;
        }
        return newTags;
      };
      EnvelopeFactory2.parseStack = function(stack) {
        var parsedStack = void 0;
        if (typeof stack === "string") {
          var frames = stack.split("\n");
          parsedStack = [];
          var level = 0;
          var totalSizeInBytes = 0;
          for (var i = 0; i <= frames.length; i++) {
            var frame = frames[i];
            if (_StackFrame.regex.test(frame)) {
              var parsedFrame = new _StackFrame(frames[i], level++);
              totalSizeInBytes += parsedFrame.sizeInBytes;
              parsedStack.push(parsedFrame);
            }
          }
          var exceptionParsedStackThreshold = 32 * 1024;
          if (totalSizeInBytes > exceptionParsedStackThreshold) {
            var left = 0;
            var right = parsedStack.length - 1;
            var size = 0;
            var acceptedLeft = left;
            var acceptedRight = right;
            while (left < right) {
              var lSize = parsedStack[left].sizeInBytes;
              var rSize = parsedStack[right].sizeInBytes;
              size += lSize + rSize;
              if (size > exceptionParsedStackThreshold) {
                var howMany = acceptedRight - acceptedLeft + 1;
                parsedStack.splice(acceptedLeft, howMany);
                break;
              }
              acceptedLeft = left;
              acceptedRight = right;
              left++;
              right--;
            }
          }
        }
        return parsedStack;
      };
      return EnvelopeFactory2;
    }();
    var _StackFrame = function() {
      function _StackFrame2(frame, level) {
        this.sizeInBytes = 0;
        this.level = level;
        this.method = "<no_method>";
        this.assembly = Util.trim(frame);
        var matches = frame.match(_StackFrame2.regex);
        if (matches && matches.length >= 5) {
          this.method = Util.trim(matches[2]) || this.method;
          this.fileName = Util.trim(matches[4]) || "<no_filename>";
          this.line = parseInt(matches[5]) || 0;
        }
        this.sizeInBytes += this.method.length;
        this.sizeInBytes += this.fileName.length;
        this.sizeInBytes += this.assembly.length;
        this.sizeInBytes += _StackFrame2.baseSize;
        this.sizeInBytes += this.level.toString().length;
        this.sizeInBytes += this.line.toString().length;
      }
      _StackFrame2.regex = /^([\s]+at)?(.*?)(\@|\s\(|\s)([^\(\@\n]+):([0-9]+):([0-9]+)(\)?)$/;
      _StackFrame2.baseSize = 58;
      return _StackFrame2;
    }();
    module2.exports = EnvelopeFactory;
  }
});

// ../../node_modules/applicationinsights/out/Library/TelemetryClient.js
var require_TelemetryClient = __commonJS({
  "../../node_modules/applicationinsights/out/Library/TelemetryClient.js"(exports2, module2) {
    "use strict";
    var url = require("url");
    var Config = require_Config();
    var Context = require_Context();
    var Contracts = require_Contracts();
    var Channel = require_Channel();
    var TelemetryProcessors = require_TelemetryProcessors();
    var CorrelationContextManager_1 = require_CorrelationContextManager();
    var Sender = require_Sender();
    var Util = require_Util();
    var Logging = require_Logging();
    var EnvelopeFactory = require_EnvelopeFactory();
    var TelemetryClient = function() {
      function TelemetryClient2(iKey) {
        this._telemetryProcessors = [];
        var config = new Config(iKey);
        this.config = config;
        this.context = new Context();
        this.commonProperties = {};
        var sender = new Sender(this.config);
        this.channel = new Channel(function() {
          return config.disableAppInsights;
        }, function() {
          return config.maxBatchSize;
        }, function() {
          return config.maxBatchIntervalMs;
        }, sender);
      }
      TelemetryClient2.prototype.trackTrace = function(telemetry) {
        this.track(telemetry, Contracts.TelemetryType.Trace);
      };
      TelemetryClient2.prototype.trackMetric = function(telemetry) {
        this.track(telemetry, Contracts.TelemetryType.Metric);
      };
      TelemetryClient2.prototype.trackException = function(telemetry) {
        if (telemetry && telemetry.exception && !Util.isError(telemetry.exception)) {
          telemetry.exception = new Error(telemetry.exception.toString());
        }
        this.track(telemetry, Contracts.TelemetryType.Exception);
      };
      TelemetryClient2.prototype.trackEvent = function(telemetry) {
        this.track(telemetry, Contracts.TelemetryType.Event);
      };
      TelemetryClient2.prototype.trackRequest = function(telemetry) {
        this.track(telemetry, Contracts.TelemetryType.Request);
      };
      TelemetryClient2.prototype.trackDependency = function(telemetry) {
        if (telemetry && !telemetry.target && telemetry.data) {
          telemetry.target = url.parse(telemetry.data).host;
        }
        this.track(telemetry, Contracts.TelemetryType.Dependency);
      };
      TelemetryClient2.prototype.flush = function(options2) {
        this.channel.triggerSend(options2 ? !!options2.isAppCrashing : false, options2 ? options2.callback : void 0);
      };
      TelemetryClient2.prototype.track = function(telemetry, telemetryType) {
        if (telemetry && Contracts.telemetryTypeToBaseType(telemetryType)) {
          var envelope = EnvelopeFactory.createEnvelope(telemetry, telemetryType, this.commonProperties, this.context, this.config);
          if (telemetry.time) {
            envelope.time = telemetry.time.toISOString();
          }
          var accepted = this.runTelemetryProcessors(envelope, telemetry.contextObjects);
          accepted = accepted && TelemetryProcessors.samplingTelemetryProcessor(envelope, { correlationContext: CorrelationContextManager_1.CorrelationContextManager.getCurrentContext() });
          TelemetryProcessors.quickPulseTelemetryProcessor(envelope, this.quickPulseClient);
          if (accepted) {
            this.channel.send(envelope);
          }
        } else {
          Logging.warn("track() requires telemetry object and telemetryType to be specified.");
        }
      };
      TelemetryClient2.prototype.addTelemetryProcessor = function(telemetryProcessor) {
        this._telemetryProcessors.push(telemetryProcessor);
      };
      TelemetryClient2.prototype.clearTelemetryProcessors = function() {
        this._telemetryProcessors = [];
      };
      TelemetryClient2.prototype.runTelemetryProcessors = function(envelope, contextObjects) {
        var accepted = true;
        var telemetryProcessorsCount = this._telemetryProcessors.length;
        if (telemetryProcessorsCount === 0) {
          return accepted;
        }
        contextObjects = contextObjects || {};
        contextObjects["correlationContext"] = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();
        for (var i = 0; i < telemetryProcessorsCount; ++i) {
          try {
            var processor = this._telemetryProcessors[i];
            if (processor) {
              if (processor.apply(null, [envelope, contextObjects]) === false) {
                accepted = false;
                break;
              }
            }
          } catch (error3) {
            accepted = true;
            Logging.warn("One of telemetry processors failed, telemetry item will be sent.", error3, envelope);
          }
        }
        return accepted;
      };
      return TelemetryClient2;
    }();
    module2.exports = TelemetryClient;
  }
});

// ../../node_modules/applicationinsights/out/Library/NodeClient.js
var require_NodeClient = __commonJS({
  "../../node_modules/applicationinsights/out/Library/NodeClient.js"(exports2, module2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (b.hasOwnProperty(p))
            d[p] = b[p];
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var TelemetryClient = require_TelemetryClient();
    var ServerRequestTracking = require_HttpRequests();
    var ClientRequestTracking = require_HttpDependencies();
    var Logging = require_Logging();
    var NodeClient = function(_super) {
      __extends2(NodeClient2, _super);
      function NodeClient2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NodeClient2.prototype.trackNodeHttpRequestSync = function(telemetry) {
        if (telemetry && telemetry.request && telemetry.response && telemetry.duration) {
          ServerRequestTracking.trackRequestSync(this, telemetry);
        } else {
          Logging.warn("trackNodeHttpRequestSync requires NodeHttpRequestTelemetry object with request, response and duration specified.");
        }
      };
      NodeClient2.prototype.trackNodeHttpRequest = function(telemetry) {
        if (telemetry.duration || telemetry.error) {
          Logging.warn("trackNodeHttpRequest will ignore supplied duration and error parameters. These values are collected from the request and response objects.");
        }
        if (telemetry && telemetry.request && telemetry.response) {
          ServerRequestTracking.trackRequest(this, telemetry);
        } else {
          Logging.warn("trackNodeHttpRequest requires NodeHttpRequestTelemetry object with request and response specified.");
        }
      };
      NodeClient2.prototype.trackNodeHttpDependency = function(telemetry) {
        if (telemetry && telemetry.request) {
          ClientRequestTracking.trackRequest(this, telemetry);
        } else {
          Logging.warn("trackNodeHttpDependency requires NodeHttpDependencyTelemetry object with request specified.");
        }
      };
      return NodeClient2;
    }(TelemetryClient);
    module2.exports = NodeClient;
  }
});

// ../../node_modules/applicationinsights/out/applicationinsights.js
var require_applicationinsights = __commonJS({
  "../../node_modules/applicationinsights/out/applicationinsights.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var CorrelationContextManager = require_CorrelationContextManager();
    var AutoCollectConsole = require_Console();
    var AutoCollectExceptions = require_Exceptions();
    var AutoCollectPerformance = require_Performance();
    var AutoCollectHttpDependencies = require_HttpDependencies();
    var AutoCollectHttpRequests = require_HttpRequests();
    var CorrelationIdManager = require_CorrelationIdManager();
    var Logging = require_Logging();
    var QuickPulseClient = require_QuickPulseStateManager();
    var NativePerformance_1 = require_NativePerformance();
    exports2.TelemetryClient = require_NodeClient();
    exports2.Contracts = require_Contracts();
    var DistributedTracingModes;
    (function(DistributedTracingModes2) {
      DistributedTracingModes2[DistributedTracingModes2["AI"] = 0] = "AI";
      DistributedTracingModes2[DistributedTracingModes2["AI_AND_W3C"] = 1] = "AI_AND_W3C";
    })(DistributedTracingModes = exports2.DistributedTracingModes || (exports2.DistributedTracingModes = {}));
    var _isConsole = true;
    var _isConsoleLog = false;
    var _isExceptions = true;
    var _isPerformance = true;
    var _isRequests = true;
    var _isDependencies = true;
    var _isDiskRetry = true;
    var _isCorrelating = true;
    var _forceClsHooked;
    var _isSendingLiveMetrics = false;
    var _isNativePerformance = true;
    var _disabledExtendedMetrics;
    var _diskRetryInterval = void 0;
    var _diskRetryMaxBytes = void 0;
    var _console;
    var _exceptions;
    var _performance;
    var _nativePerformance;
    var _serverRequests;
    var _clientRequests;
    var _isStarted = false;
    var _performanceLiveMetrics;
    function setup(instrumentationKey) {
      if (!exports2.defaultClient) {
        exports2.defaultClient = new exports2.TelemetryClient(instrumentationKey);
        _console = new AutoCollectConsole(exports2.defaultClient);
        _exceptions = new AutoCollectExceptions(exports2.defaultClient);
        _performance = new AutoCollectPerformance(exports2.defaultClient);
        _serverRequests = new AutoCollectHttpRequests(exports2.defaultClient);
        _clientRequests = new AutoCollectHttpDependencies(exports2.defaultClient);
        if (!_nativePerformance) {
          _nativePerformance = new NativePerformance_1.AutoCollectNativePerformance(exports2.defaultClient);
        }
      } else {
        Logging.info("The default client is already setup");
      }
      if (exports2.defaultClient && exports2.defaultClient.channel) {
        exports2.defaultClient.channel.setUseDiskRetryCaching(_isDiskRetry, _diskRetryInterval, _diskRetryMaxBytes);
      }
      return Configuration;
    }
    exports2.setup = setup;
    function start() {
      if (!!exports2.defaultClient) {
        _isStarted = true;
        _console.enable(_isConsole, _isConsoleLog);
        _exceptions.enable(_isExceptions);
        _performance.enable(_isPerformance);
        _nativePerformance.enable(_isNativePerformance, _disabledExtendedMetrics);
        _serverRequests.useAutoCorrelation(_isCorrelating, _forceClsHooked);
        _serverRequests.enable(_isRequests);
        _clientRequests.enable(_isDependencies);
        if (exports2.liveMetricsClient && _isSendingLiveMetrics) {
          exports2.liveMetricsClient.enable(_isSendingLiveMetrics);
        }
      } else {
        Logging.warn("Start cannot be called before setup");
      }
      return Configuration;
    }
    exports2.start = start;
    function getCorrelationContext() {
      if (_isCorrelating) {
        return CorrelationContextManager.CorrelationContextManager.getCurrentContext();
      }
      return null;
    }
    exports2.getCorrelationContext = getCorrelationContext;
    function wrapWithCorrelationContext(fn) {
      return CorrelationContextManager.CorrelationContextManager.wrapCallback(fn);
    }
    exports2.wrapWithCorrelationContext = wrapWithCorrelationContext;
    var Configuration = function() {
      function Configuration2() {
      }
      Configuration2.setDistributedTracingMode = function(value) {
        CorrelationIdManager.w3cEnabled = value === DistributedTracingModes.AI_AND_W3C;
        return Configuration2;
      };
      Configuration2.setAutoCollectConsole = function(value, collectConsoleLog) {
        if (collectConsoleLog === void 0) {
          collectConsoleLog = false;
        }
        _isConsole = value;
        _isConsoleLog = collectConsoleLog;
        if (_isStarted) {
          _console.enable(value, collectConsoleLog);
        }
        return Configuration2;
      };
      Configuration2.setAutoCollectExceptions = function(value) {
        _isExceptions = value;
        if (_isStarted) {
          _exceptions.enable(value);
        }
        return Configuration2;
      };
      Configuration2.setAutoCollectPerformance = function(value, collectExtendedMetrics) {
        if (collectExtendedMetrics === void 0) {
          collectExtendedMetrics = true;
        }
        _isPerformance = value;
        var extendedMetricsConfig = NativePerformance_1.AutoCollectNativePerformance.parseEnabled(collectExtendedMetrics);
        _isNativePerformance = extendedMetricsConfig.isEnabled;
        _disabledExtendedMetrics = extendedMetricsConfig.disabledMetrics;
        if (_isStarted) {
          _performance.enable(value);
          _nativePerformance.enable(extendedMetricsConfig.isEnabled, extendedMetricsConfig.disabledMetrics);
        }
        return Configuration2;
      };
      Configuration2.setAutoCollectRequests = function(value) {
        _isRequests = value;
        if (_isStarted) {
          _serverRequests.enable(value);
        }
        return Configuration2;
      };
      Configuration2.setAutoCollectDependencies = function(value) {
        _isDependencies = value;
        if (_isStarted) {
          _clientRequests.enable(value);
        }
        return Configuration2;
      };
      Configuration2.setAutoDependencyCorrelation = function(value, useAsyncHooks) {
        _isCorrelating = value;
        _forceClsHooked = useAsyncHooks;
        if (_isStarted) {
          _serverRequests.useAutoCorrelation(value, useAsyncHooks);
        }
        return Configuration2;
      };
      Configuration2.setUseDiskRetryCaching = function(value, resendInterval, maxBytesOnDisk) {
        _isDiskRetry = value;
        _diskRetryInterval = resendInterval;
        _diskRetryMaxBytes = maxBytesOnDisk;
        if (exports2.defaultClient && exports2.defaultClient.channel) {
          exports2.defaultClient.channel.setUseDiskRetryCaching(value, resendInterval, maxBytesOnDisk);
        }
        return Configuration2;
      };
      Configuration2.setInternalLogging = function(enableDebugLogging, enableWarningLogging) {
        if (enableDebugLogging === void 0) {
          enableDebugLogging = false;
        }
        if (enableWarningLogging === void 0) {
          enableWarningLogging = true;
        }
        Logging.enableDebug = enableDebugLogging;
        Logging.disableWarnings = !enableWarningLogging;
        return Configuration2;
      };
      Configuration2.setSendLiveMetrics = function(enable) {
        if (enable === void 0) {
          enable = false;
        }
        if (!exports2.defaultClient) {
          Logging.warn("Live metrics client cannot be setup without the default client");
          return Configuration2;
        }
        if (!exports2.liveMetricsClient) {
          exports2.liveMetricsClient = new QuickPulseClient(exports2.defaultClient.config.instrumentationKey);
          _performanceLiveMetrics = new AutoCollectPerformance(exports2.liveMetricsClient, 1e3, true);
          exports2.liveMetricsClient.addCollector(_performanceLiveMetrics);
          exports2.defaultClient.quickPulseClient = exports2.liveMetricsClient;
          _isSendingLiveMetrics = enable;
        } else {
          exports2.liveMetricsClient.enable(enable);
        }
        return Configuration2;
      };
      Configuration2.start = start;
      return Configuration2;
    }();
    exports2.Configuration = Configuration;
    function dispose() {
      exports2.defaultClient = null;
      _isStarted = false;
      if (_console) {
        _console.dispose();
      }
      if (_exceptions) {
        _exceptions.dispose();
      }
      if (_performance) {
        _performance.dispose();
      }
      if (_nativePerformance) {
        _nativePerformance.dispose();
      }
      if (_serverRequests) {
        _serverRequests.dispose();
      }
      if (_clientRequests) {
        _clientRequests.dispose();
      }
    }
    exports2.dispose = dispose;
  }
});

// ../lib/telemetry/dist/package.json
var require_package4 = __commonJS({
  "../lib/telemetry/dist/package.json"(exports2, module2) {
    module2.exports = {
      name: "@sap/ux-telemetry",
      version: "1.7.4",
      description: "SAP Fiori tools telemetry library",
      main: "dist/src/index.js",
      author: "SAP SE",
      license: "MIT",
      private: true,
      azureInstrumentationKey: "0a65e45d-6bf4-421d-b845-61e888c50e9e",
      azureProdKey: "0a65e45d-6bf4-421d-b845-61e888c50e9e",
      scripts: {
        "pre-commit": "lint-staged --quiet",
        "clean:dist": "rimraf ./dist ./generators *.tsbuildinfo",
        clean: "rimraf ./reports",
        build: "ts-node ./build-script/ && yarn run clean && tsc --build ./",
        test: "jest --maxWorkers=1 --ci --forceExit --detectOpenHandles",
        lint: "eslint . --ext .ts",
        "lint:summary": "eslint . --ext .ts -f summary",
        "lint:fix": "eslint --fix",
        "lint:fix:all": "eslint . --ext .ts --fix",
        "lint:report": "eslint . --ext .ts -f multiple ",
        "format:fix": "prettier --write --loglevel silent --ignore-path ../../../.prettierignore",
        "format:fix:all": "prettier --write '**/*.{css,scss,html,js,json,ts,tsx,yaml,yml}' '!**/{out,dist,node_modules}/**' '!**/*.{svg,png,xml}' --ignore-path ../../../.prettierignore",
        madge: "madge --warning --circular --extensions ts ./"
      },
      dependencies: {
        "@sap-ux/store": "0.3.0",
        "@sap/ux-cds": "1.7.4",
        "@sap/ux-common-utils": "1.7.4",
        "@sap/ux-feature-toggle": "1.7.4",
        "@sap/ux-project-access": "1.7.4",
        applicationinsights: "1.4.1",
        "performance-now": "2.1.0",
        yaml: "2.0.0-10"
      },
      devDependencies: {
        "ts-node": "8.5.2",
        typescript: "4.3.5"
      },
      files: [
        "dist/"
      ],
      jestSonar: {
        reportPath: "reports/test/unit",
        reportFile: "test-report.xml"
      },
      "eslint-formatter-multiple": {
        formatters: [
          {
            name: "stylish",
            output: "console"
          },
          {
            name: "json",
            output: "file",
            path: "reports/lint/eslint.json"
          },
          {
            name: "checkstyle",
            output: "file",
            path: "reports/lint/eslint.checkstyle.xml"
          }
        ]
      }
    };
  }
});

// ../lib/telemetry/dist/src/util/telemetryClientConfig.js
var require_telemetryClientConfig = __commonJS({
  "../lib/telemetry/dist/src/util/telemetryClientConfig.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.configAzureTelemetryClient = void 0;
    function configAzureTelemetryClient(client) {
      client.channel.setUseDiskRetryCaching(true);
      client.addTelemetryProcessor((envelope) => {
        envelope.tags["ai.location.ip"] = "0.0.0.0";
        envelope.tags["ai.cloud.roleInstance"] = "masked";
        envelope.tags["ai.cloud.role"] = "masked";
        envelope.tags["ai.device.type"] = "masked";
        return true;
      });
    }
    exports2.configAzureTelemetryClient = configAzureTelemetryClient;
  }
});

// ../lib/telemetry/dist/src/util/reporting.js
var require_reporting = __commonJS({
  "../lib/telemetry/dist/src/util/reporting.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.reportEnableTelemetryOnOff = exports2.reportRuntimeError = void 0;
    var EventName_1 = require_EventName();
    var appInsights = __importStar(require_applicationinsights());
    var telemetryPackageJSON = __importStar(require_package4());
    var telemetryClientConfig_1 = require_telemetryClientConfig();
    var parseErrorStack = (errorStack) => {
      const regexps = [/sap-ux.+/gi, /[a-zA-Z-]+\/ide-extension\/.+/gi, /(\/telemetry\/.+)/gi];
      const parsedStack = [];
      const filtered = errorStack.split("\n").filter((line) => !!line.match(/^\s*at .*(\S+:\d+|\(native\))/m));
      if (!filtered.length) {
        return parsedStack;
      }
      filtered.forEach((line) => {
        let sanitizedLine = line.replace(/^\s+/, "");
        const location = line.match(/ (\((.+):(\d+):(\d+)\)$)/);
        if (!location) {
          return;
        }
        let filepath = null;
        const normalizedFilepath = location[2].replace(/\\/g, "/");
        for (const regexp of regexps) {
          const match = normalizedFilepath.match(regexp);
          if (match) {
            filepath = match[0];
            break;
          }
        }
        if (!filepath) {
          return;
        }
        sanitizedLine = sanitizedLine.replace(location[0], "");
        const functionName = sanitizedLine.split(/\s+/).slice(1).join("");
        const lineNumber = location[3];
        const columnNumber = location[4];
        const parsedStackLine = `${functionName} at (${filepath}:${lineNumber}:${columnNumber});`;
        parsedStack.push(parsedStackLine);
      });
      return parsedStack;
    };
    var reportingTelemetryClient = new appInsights.TelemetryClient(telemetryPackageJSON.azureInstrumentationKey);
    telemetryClientConfig_1.configAzureTelemetryClient(reportingTelemetryClient);
    var reportRuntimeError = (error3) => {
      const properties = { message: error3.message };
      if (error3.stack) {
        const parsedStack = parseErrorStack(error3.stack);
        if (parsedStack.length) {
          properties.stack = parsedStack.join(" \n");
        }
      }
      const telemetryEvent = {
        name: EventName_1.EventName.TELEMETRY_SETTINGS_INIT_FAILED,
        properties,
        measurements: {}
      };
      if (process.env.SAP_UX_FIORI_TOOLS_DISABLE_TELEMETRY !== "true") {
        reportingTelemetryClient.trackEvent(telemetryEvent);
      }
    };
    exports2.reportRuntimeError = reportRuntimeError;
    var reportEnableTelemetryOnOff = (enableTelemetry, commonProperties) => {
      const telemetryEvent = {
        name: EventName_1.EventName.DISABLE_TELEMETRY,
        properties: {
          disableTelemetry: `${!enableTelemetry}`,
          ...commonProperties
        },
        measurements: {}
      };
      if (process.env.SAP_UX_FIORI_TOOLS_DISABLE_TELEMETRY !== "true") {
        reportingTelemetryClient.trackEvent(telemetryEvent);
      }
    };
    exports2.reportEnableTelemetryOnOff = reportEnableTelemetryOnOff;
  }
});

// ../lib/telemetry/dist/src/system/system.js
var require_system2 = __commonJS({
  "../lib/telemetry/dist/src/system/system.js"(exports2, module2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TelemetrySystem = void 0;
    var fs_1 = __importDefault(require("fs"));
    var system_1 = require_system();
    var cloudDebugger_1 = require_cloudDebugger();
    var ux_common_utils_1 = require_dist();
    var reporting_1 = require_reporting();
    var TelemetrySystem = class {
      static init() {
        cloudDebugger_1.debug(`start System.init`);
        TelemetrySystem.modules = system_1.processMatchingPaths(TelemetrySystem.modules);
        let pathBase = TelemetrySystem.getMatchingModulePath(module2);
        cloudDebugger_1.debug(`base path: ${pathBase}`);
        if (!pathBase) {
          TelemetrySystem.fallbackModules = system_1.processMatchingPaths(TelemetrySystem.fallbackModules);
          pathBase = TelemetrySystem.getMatchingModulePath(module2, true);
        }
        const manifestPath = TelemetrySystem.getManifestPath(pathBase);
        cloudDebugger_1.debug(`package.json path: ${manifestPath}`);
        TelemetrySystem.manifest = TelemetrySystem.getManifestJSON(manifestPath);
      }
      static getManifestJSON(path) {
        try {
          return JSON.parse(fs_1.default.readFileSync(path, "utf-8"));
        } catch (err) {
          console.log(`[Telemetry]: ${err.message}`);
          return null;
        }
      }
      static getManifestPath(pathBase) {
        let manifestPath = pathBase;
        if (ux_common_utils_1.isAppStudio() && manifestPath && manifestPath.indexOf("generators") < 0 && manifestPath.indexOf("deployment-generator") < 0 && manifestPath.indexOf("/ux-ui5-tooling") < 0) {
          manifestPath = manifestPath.concat("/extension");
        }
        if (manifestPath && manifestPath.indexOf("language-server") > -1) {
          manifestPath = manifestPath.replace(/\/([^/]+)\/?$/, "/ide-extension");
        }
        if (manifestPath && manifestPath.indexOf("generators") > -1 && manifestPath.indexOf("@sap/generator-fiori") < 0) {
          if (manifestPath.indexOf("deployment-generator") > -1) {
            manifestPath = `${manifestPath}/telemetry`;
          } else {
            manifestPath = manifestPath.slice(0, manifestPath.lastIndexOf("/"));
          }
        }
        if (manifestPath && manifestPath.indexOf("@sap/generator-fiori") > -1) {
          manifestPath = `${manifestPath}/telemetry`;
        }
        if (manifestPath) {
          return `${manifestPath}/package.json`;
        } else {
          return "";
        }
      }
      static getMatchingModulePath(module3, useFallbackModules) {
        let modulePath = module3.filename || __dirname;
        if ((modulePath == null ? void 0 : modulePath.indexOf("\\")) > -1) {
          modulePath = modulePath.replace(/\\/g, "/");
        }
        const matchingPaths = useFallbackModules ? TelemetrySystem.fallbackModules : TelemetrySystem.modules;
        const matchingPath = TelemetrySystem.matchModule(modulePath, matchingPaths);
        if (!matchingPath && module3.parent) {
          return TelemetrySystem.getMatchingModulePath(module3.parent, useFallbackModules);
        } else {
          return matchingPath;
        }
      }
      static matchModule(modulePath, matchingPaths) {
        let path = null;
        matchingPaths.forEach((module3) => {
          module3.patterns.forEach((patternRegExp) => {
            const matchToken = modulePath == null ? void 0 : modulePath.match(patternRegExp);
            if (matchToken && matchToken.length > 0) {
              path = matchToken[0];
              TelemetrySystem.WORKSTREAM = module3.workStream;
            }
          });
        });
        return path;
      }
    };
    exports2.TelemetrySystem = TelemetrySystem;
    TelemetrySystem.modules = [
      {
        workStream: "extension",
        patterns: ["ide-extension", "sap-ux-[\\w-.@]+"]
      },
      {
        workStream: "core",
        patterns: ["core"]
      }
    ];
    TelemetrySystem.fallbackModules = [
      {
        workStream: "extension",
        patterns: ["language-server[\\w.-]*"]
      },
      {
        workStream: "core",
        patterns: ["generators", "project-generator", "deployment-generator", "ux-ui5-tooling", "generator-common"]
      }
    ];
    try {
      TelemetrySystem.init();
    } catch (err) {
      reporting_1.reportRuntimeError(err);
    }
  }
});

// ../lib/telemetry/dist/src/client/client.js
var require_client = __commonJS({
  "../lib/telemetry/dist/src/client/client.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Client = void 0;
    var Client = class {
      constructor() {
        this.applicationKey = "";
        this.extensionName = "";
        this.extensionVersion = "";
      }
      getApplicationKey() {
        return this.applicationKey;
      }
      getExtensionVersion() {
        return this.extensionVersion;
      }
      getExtensionName() {
        return this.extensionName;
      }
    };
    exports2.Client = Client;
  }
});

// ../lib/telemetry/dist/src/client/model/EventHeader.js
var require_EventHeader = __commonJS({
  "../lib/telemetry/dist/src/client/model/EventHeader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EventHeader = void 0;
    var EventHeader = class {
      constructor(extensionName, eventName) {
        this.extensionName = extensionName;
        this.eventName = eventName;
      }
      getExtensionName() {
        return this.extensionName;
      }
      getEventName() {
        return this.eventName;
      }
      toString() {
        return `${this.extensionName}/${this.eventName}`;
      }
    };
    exports2.EventHeader = EventHeader;
  }
});

// ../lib/telemetry/dist/src/client/model/SampleRate.js
var require_SampleRate = __commonJS({
  "../lib/telemetry/dist/src/client/model/SampleRate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SampleRate = void 0;
    var SampleRate2;
    (function(SampleRate3) {
      SampleRate3[SampleRate3["OnePercent"] = 0] = "OnePercent";
      SampleRate3[SampleRate3["TenPercent"] = 1] = "TenPercent";
      SampleRate3[SampleRate3["NoSampling"] = 2] = "NoSampling";
    })(SampleRate2 = exports2.SampleRate || (exports2.SampleRate = {}));
  }
});

// ../lib/telemetry/dist/src/client/appInsightClient.js
var require_appInsightClient = __commonJS({
  "../lib/telemetry/dist/src/client/appInsightClient.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApplicationInsightClient = void 0;
    var client_1 = require_client();
    var appInsights = __importStar(require_applicationinsights());
    var EventHeader_1 = require_EventHeader();
    var SampleRate_1 = require_SampleRate();
    var system_1 = require_system2();
    var telemetryClientConfig_1 = require_telemetryClientConfig();
    var ApplicationInsightClient = class extends client_1.Client {
      constructor(applicationKey, extensionName, extensionVersion) {
        super();
        this.clients = /* @__PURE__ */ new Map();
        super.applicationKey = applicationKey;
        this.extensionVersion = extensionVersion;
        this.extensionName = extensionName;
        const clientOnePercent = this.createTelemetryClient(SampleRate_1.SampleRate.OnePercent);
        const clientTenPercent = this.createTelemetryClient(SampleRate_1.SampleRate.TenPercent);
        const clientNoSampling = this.createTelemetryClient(SampleRate_1.SampleRate.NoSampling);
        this.clients.set(SampleRate_1.SampleRate.OnePercent, clientOnePercent);
        this.clients.set(SampleRate_1.SampleRate.TenPercent, clientTenPercent);
        this.clients.set(SampleRate_1.SampleRate.NoSampling, clientNoSampling);
        return this;
      }
      async report(eventName, properties, measurements, sampleRate, telemetryHelperProperties, ignoreSettings) {
        if (ignoreSettings !== void 0 && !ignoreSettings || !system_1.TelemetrySystem.telemetryEnabled) {
          return;
        }
        const processedSampleRate = sampleRate ? sampleRate : SampleRate_1.SampleRate.NoSampling;
        const client = this.clients.get(processedSampleRate);
        const eventHeader = new EventHeader_1.EventHeader(this.extensionName, eventName);
        const event = {
          name: eventHeader.toString(),
          properties,
          measurements
        };
        this.trackEvent(client, event);
      }
      trackEvent(client, event) {
        if (process.env.SAP_UX_FIORI_TOOLS_DISABLE_TELEMETRY !== "true") {
          client.trackEvent(event);
          return true;
        }
        return false;
      }
      createTelemetryClient(sampleRate) {
        let sampleRateNumer;
        switch (sampleRate) {
          case SampleRate_1.SampleRate.OnePercent:
            sampleRateNumer = 1;
            break;
          case SampleRate_1.SampleRate.TenPercent:
            sampleRateNumer = 10;
            break;
          case SampleRate_1.SampleRate.NoSampling:
          default:
            sampleRateNumer = 100;
            break;
        }
        const client = new appInsights.TelemetryClient(this.applicationKey);
        client.config.samplingPercentage = sampleRateNumer;
        telemetryClientConfig_1.configAzureTelemetryClient(client);
        return client;
      }
    };
    exports2.ApplicationInsightClient = ApplicationInsightClient;
  }
});

// ../lib/telemetry/dist/src/util/date.js
var require_date = __commonJS({
  "../lib/telemetry/dist/src/util/date.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.localDatetimeToUTC = void 0;
    var localDatetimeToUTC = () => {
      const timeInMs = new Date().getTime();
      return new Date(timeInMs).toISOString();
    };
    exports2.localDatetimeToUTC = localDatetimeToUTC;
  }
});

// ../lib/telemetry/dist/src/toolsSuiteTelemetry/toolsSuiteTelemetryClient.js
var require_toolsSuiteTelemetryClient = __commonJS({
  "../lib/telemetry/dist/src/toolsSuiteTelemetry/toolsSuiteTelemetryClient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ToolsSuiteTelemetryClient = void 0;
    var appInsightClient_1 = require_appInsightClient();
    var toolsSuiteTelemetry_1 = require_toolsSuiteTelemetry();
    var date_1 = require_date();
    var ToolsSuiteTelemetryClient = class extends appInsightClient_1.ApplicationInsightClient {
      constructor(applicationKey, extensionName, extensionVersion) {
        super(applicationKey, extensionName, extensionVersion);
      }
      async report(eventName, properties, measurements, sampleRate, telemetryHelperProperties, ignoreSettings) {
        const fioriProjectCommonProperties = await toolsSuiteTelemetry_1.processToolsSuiteTelemetry(telemetryHelperProperties);
        const commonProperties = {
          v: this.extensionVersion,
          datetime: date_1.localDatetimeToUTC()
        };
        const finalProperties = {
          ...properties,
          ...fioriProjectCommonProperties,
          ...commonProperties
        };
        await super.report(eventName, finalProperties, measurements, sampleRate, telemetryHelperProperties, ignoreSettings);
      }
      async reportEvent(event, sampleRate, telemetryHelperProperties, ignoreSettings) {
        const fioriProjectCommonProperties = await toolsSuiteTelemetry_1.processToolsSuiteTelemetry(telemetryHelperProperties);
        const telemetryEventCommonProperties = {
          v: this.extensionVersion,
          datetime: date_1.localDatetimeToUTC()
        };
        const finalProperties = {
          ...event.properties,
          ...fioriProjectCommonProperties,
          ...telemetryEventCommonProperties
        };
        const finalMeasurements = {
          ...event.measurements
        };
        await super.report(event.eventName, finalProperties, finalMeasurements, sampleRate, telemetryHelperProperties, ignoreSettings);
      }
    };
    exports2.ToolsSuiteTelemetryClient = ToolsSuiteTelemetryClient;
  }
});

// ../../node_modules/axios/lib/helpers/bind.js
var require_bind = __commonJS({
  "../../node_modules/axios/lib/helpers/bind.js"(exports2, module2) {
    "use strict";
    module2.exports = function bind(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };
  }
});

// ../../node_modules/axios/lib/utils.js
var require_utils = __commonJS({
  "../../node_modules/axios/lib/utils.js"(exports2, module2) {
    "use strict";
    var bind = require_bind();
    var toString = Object.prototype.toString;
    function isArray(val) {
      return Array.isArray(val);
    }
    function isUndefined(val) {
      return typeof val === "undefined";
    }
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
    function isArrayBuffer(val) {
      return toString.call(val) === "[object ArrayBuffer]";
    }
    function isFormData(val) {
      return toString.call(val) === "[object FormData]";
    }
    function isArrayBufferView(val) {
      var result2;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result2 = ArrayBuffer.isView(val);
      } else {
        result2 = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result2;
    }
    function isString(val) {
      return typeof val === "string";
    }
    function isNumber(val) {
      return typeof val === "number";
    }
    function isObject(val) {
      return val !== null && typeof val === "object";
    }
    function isPlainObject(val) {
      if (toString.call(val) !== "[object Object]") {
        return false;
      }
      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }
    function isDate(val) {
      return toString.call(val) === "[object Date]";
    }
    function isFile(val) {
      return toString.call(val) === "[object File]";
    }
    function isBlob(val) {
      return toString.call(val) === "[object Blob]";
    }
    function isFunction(val) {
      return toString.call(val) === "[object Function]";
    }
    function isStream(val) {
      return isObject(val) && isFunction(val.pipe);
    }
    function isURLSearchParams(val) {
      return toString.call(val) === "[object URLSearchParams]";
    }
    function trim(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
    }
    function isStandardBrowserEnv() {
      if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach(obj, fn) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    function merge() {
      var result2 = {};
      function assignValue(val, key) {
        if (isPlainObject(result2[key]) && isPlainObject(val)) {
          result2[key] = merge(result2[key], val);
        } else if (isPlainObject(val)) {
          result2[key] = merge({}, val);
        } else if (isArray(val)) {
          result2[key] = val.slice();
        } else {
          result2[key] = val;
        }
      }
      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result2;
    }
    function extend(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === "function") {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }
    function stripBOM(content) {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    module2.exports = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isObject,
      isPlainObject,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isFunction,
      isStream,
      isURLSearchParams,
      isStandardBrowserEnv,
      forEach,
      merge,
      extend,
      trim,
      stripBOM
    };
  }
});

// ../../node_modules/axios/lib/helpers/buildURL.js
var require_buildURL = __commonJS({
  "../../node_modules/axios/lib/helpers/buildURL.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    module2.exports = function buildURL(url, params, paramsSerializer) {
      if (!params) {
        return url;
      }
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === "undefined") {
            return;
          }
          if (utils.isArray(val)) {
            key = key + "[]";
          } else {
            val = [val];
          }
          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + "=" + encode(v));
          });
        });
        serializedParams = parts.join("&");
      }
      if (serializedParams) {
        var hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    };
  }
});

// ../../node_modules/axios/lib/core/InterceptorManager.js
var require_InterceptorManager = __commonJS({
  "../../node_modules/axios/lib/core/InterceptorManager.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    function InterceptorManager() {
      this.handlers = [];
    }
    InterceptorManager.prototype.use = function use(fulfilled, rejected, options2) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options2 ? options2.synchronous : false,
        runWhen: options2 ? options2.runWhen : null
      });
      return this.handlers.length - 1;
    };
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };
    module2.exports = InterceptorManager;
  }
});

// ../../node_modules/axios/lib/helpers/normalizeHeaderName.js
var require_normalizeHeaderName = __commonJS({
  "../../node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };
  }
});

// ../../node_modules/axios/lib/core/enhanceError.js
var require_enhanceError = __commonJS({
  "../../node_modules/axios/lib/core/enhanceError.js"(exports2, module2) {
    "use strict";
    module2.exports = function enhanceError(error3, config, code, request, response) {
      error3.config = config;
      if (code) {
        error3.code = code;
      }
      error3.request = request;
      error3.response = response;
      error3.isAxiosError = true;
      error3.toJSON = function toJSON() {
        return {
          message: this.message,
          name: this.name,
          description: this.description,
          number: this.number,
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          config: this.config,
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      };
      return error3;
    };
  }
});

// ../../node_modules/axios/lib/core/createError.js
var require_createError = __commonJS({
  "../../node_modules/axios/lib/core/createError.js"(exports2, module2) {
    "use strict";
    var enhanceError = require_enhanceError();
    module2.exports = function createError(message, config, code, request, response) {
      var error3 = new Error(message);
      return enhanceError(error3, config, code, request, response);
    };
  }
});

// ../../node_modules/axios/lib/core/settle.js
var require_settle = __commonJS({
  "../../node_modules/axios/lib/core/settle.js"(exports2, module2) {
    "use strict";
    var createError = require_createError();
    module2.exports = function settle(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(createError("Request failed with status code " + response.status, response.config, null, response.request, response));
      }
    };
  }
});

// ../../node_modules/axios/lib/helpers/cookies.js
var require_cookies = __commonJS({
  "../../node_modules/axios/lib/helpers/cookies.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + "=" + encodeURIComponent(value));
          if (utils.isNumber(expires)) {
            cookie.push("expires=" + new Date(expires).toGMTString());
          }
          if (utils.isString(path)) {
            cookie.push("path=" + path);
          }
          if (utils.isString(domain)) {
            cookie.push("domain=" + domain);
          }
          if (secure === true) {
            cookie.push("secure");
          }
          document.cookie = cookie.join("; ");
        },
        read: function read(name) {
          var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match ? decodeURIComponent(match[3]) : null;
        },
        remove: function remove3(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      };
    }() : function nonStandardBrowserEnv() {
      return {
        write: function write() {
        },
        read: function read() {
          return null;
        },
        remove: function remove3() {
        }
      };
    }();
  }
});

// ../../node_modules/axios/lib/helpers/isAbsoluteURL.js
var require_isAbsoluteURL = __commonJS({
  "../../node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports2, module2) {
    "use strict";
    module2.exports = function isAbsoluteURL(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    };
  }
});

// ../../node_modules/axios/lib/helpers/combineURLs.js
var require_combineURLs = __commonJS({
  "../../node_modules/axios/lib/helpers/combineURLs.js"(exports2, module2) {
    "use strict";
    module2.exports = function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    };
  }
});

// ../../node_modules/axios/lib/core/buildFullPath.js
var require_buildFullPath = __commonJS({
  "../../node_modules/axios/lib/core/buildFullPath.js"(exports2, module2) {
    "use strict";
    var isAbsoluteURL = require_isAbsoluteURL();
    var combineURLs = require_combineURLs();
    module2.exports = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };
  }
});

// ../../node_modules/axios/lib/helpers/parseHeaders.js
var require_parseHeaders = __commonJS({
  "../../node_modules/axios/lib/helpers/parseHeaders.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var ignoreDuplicateOf = [
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ];
    module2.exports = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;
      if (!headers) {
        return parsed;
      }
      utils.forEach(headers.split("\n"), function parser(line) {
        i = line.indexOf(":");
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));
        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === "set-cookie") {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
          }
        }
      });
      return parsed;
    };
  }
});

// ../../node_modules/axios/lib/helpers/isURLSameOrigin.js
var require_isURLSameOrigin = __commonJS({
  "../../node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement("a");
      var originURL;
      function resolveURL(url) {
        var href = url;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
      }
      originURL = resolveURL(window.location.href);
      return function isURLSameOrigin(requestURL) {
        var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
      };
    }() : function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    }();
  }
});

// ../../node_modules/axios/lib/cancel/Cancel.js
var require_Cancel = __commonJS({
  "../../node_modules/axios/lib/cancel/Cancel.js"(exports2, module2) {
    "use strict";
    function Cancel(message) {
      this.message = message;
    }
    Cancel.prototype.toString = function toString() {
      return "Cancel" + (this.message ? ": " + this.message : "");
    };
    Cancel.prototype.__CANCEL__ = true;
    module2.exports = Cancel;
  }
});

// ../../node_modules/axios/lib/adapters/xhr.js
var require_xhr = __commonJS({
  "../../node_modules/axios/lib/adapters/xhr.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var settle = require_settle();
    var cookies = require_cookies();
    var buildURL = require_buildURL();
    var buildFullPath = require_buildFullPath();
    var parseHeaders = require_parseHeaders();
    var isURLSameOrigin = require_isURLSameOrigin();
    var createError = require_createError();
    var defaults = require_defaults();
    var Cancel = require_Cancel();
    module2.exports = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;
        var responseType = config.responseType;
        var onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        if (utils.isFormData(requestData)) {
          delete requestHeaders["Content-Type"];
        }
        var request = new XMLHttpRequest();
        if (config.auth) {
          var username = config.auth.username || "";
          var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request.timeout = config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(createError("Request aborted", config, "ECONNABORTED", request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(createError("Network Error", config, null, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
          var transitional = config.transitional || defaults.transitional;
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(createError(timeoutErrorMessage, config, transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED", request));
          request = null;
        };
        if (utils.isStandardBrowserEnv()) {
          var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }
        if ("setRequestHeader" in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
              delete requestHeaders[key];
            } else {
              request.setRequestHeader(key, val);
            }
          });
        }
        if (!utils.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request.addEventListener("progress", config.onDownloadProgress);
        }
        if (typeof config.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", config.onUploadProgress);
        }
        if (config.cancelToken || config.signal) {
          onCanceled = function(cancel) {
            if (!request) {
              return;
            }
            reject(!cancel || cancel && cancel.type ? new Cancel("canceled") : cancel);
            request.abort();
            request = null;
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        if (!requestData) {
          requestData = null;
        }
        request.send(requestData);
      });
    };
  }
});

// ../../node_modules/ms/index.js
var require_ms = __commonJS({
  "../../node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options2) {
      options2 = options2 || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isFinite(val)) {
        return options2.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// ../../node_modules/debug/src/common.js
var require_common = __commonJS({
  "../../node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.instances = [];
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
            if (match === "%%") {
              return match;
            }
            index++;
            const formatter = createDebug.formatters[format2];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.enabled = createDebug.enabled(namespace);
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.destroy = destroy;
        debug.extend = extend;
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        createDebug.instances.push(debug);
        return debug;
      }
      function destroy() {
        const index = createDebug.instances.indexOf(this);
        if (index !== -1) {
          createDebug.instances.splice(index, 1);
          return true;
        }
        return false;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
        for (i = 0; i < createDebug.instances.length; i++) {
          const instance = createDebug.instances[i];
          instance.enabled = createDebug.enabled(instance.namespace);
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// ../../node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "../../node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error3) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error3) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error3) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error3) {
        return "[UnexpectedJSONParseError]: " + error3.message;
      }
    };
  }
});

// ../../node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "../../node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// ../../node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "../../node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// ../../node_modules/debug/src/node.js
var require_node = __commonJS({
  "../../node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2.init = init;
    exports2.log = log4;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error3) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_45, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return new Date().toISOString() + " ";
    }
    function log4(...args) {
      return process.stderr.write(util.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).replace(/\s*\n\s*/g, " ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// ../../node_modules/debug/src/index.js
var require_src2 = __commonJS({
  "../../node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// ../../node_modules/follow-redirects/debug.js
var require_debug = __commonJS({
  "../../node_modules/follow-redirects/debug.js"(exports2, module2) {
    var debug;
    module2.exports = function() {
      if (!debug) {
        try {
          debug = require_src2()("follow-redirects");
        } catch (error3) {
        }
        if (typeof debug !== "function") {
          debug = function() {
          };
        }
      }
      debug.apply(null, arguments);
    };
  }
});

// ../../node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS({
  "../../node_modules/follow-redirects/index.js"(exports2, module2) {
    var url = require("url");
    var URL2 = url.URL;
    var http = require("http");
    var https = require("https");
    var Writable = require("stream").Writable;
    var assert = require("assert");
    var debug = require_debug();
    var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
    var eventHandlers = /* @__PURE__ */ Object.create(null);
    events.forEach(function(event) {
      eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      };
    });
    var RedirectionError = createErrorType("ERR_FR_REDIRECTION_FAILURE", "Redirected request failed");
    var TooManyRedirectsError = createErrorType("ERR_FR_TOO_MANY_REDIRECTS", "Maximum number of redirects exceeded");
    var MaxBodyLengthExceededError = createErrorType("ERR_FR_MAX_BODY_LENGTH_EXCEEDED", "Request body larger than maxBodyLength limit");
    var WriteAfterEndError = createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    function RedirectableRequest(options2, responseCallback) {
      Writable.call(this);
      this._sanitizeOptions(options2);
      this._options = options2;
      this._ended = false;
      this._ending = false;
      this._redirectCount = 0;
      this._redirects = [];
      this._requestBodyLength = 0;
      this._requestBodyBuffers = [];
      if (responseCallback) {
        this.on("response", responseCallback);
      }
      var self2 = this;
      this._onNativeResponse = function(response) {
        self2._processResponse(response);
      };
      this._performRequest();
    }
    RedirectableRequest.prototype = Object.create(Writable.prototype);
    RedirectableRequest.prototype.abort = function() {
      abortRequest(this._currentRequest);
      this.emit("abort");
    };
    RedirectableRequest.prototype.write = function(data2, encoding, callback) {
      if (this._ending) {
        throw new WriteAfterEndError();
      }
      if (!(typeof data2 === "string" || typeof data2 === "object" && "length" in data2)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
      }
      if (typeof encoding === "function") {
        callback = encoding;
        encoding = null;
      }
      if (data2.length === 0) {
        if (callback) {
          callback();
        }
        return;
      }
      if (this._requestBodyLength + data2.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data2.length;
        this._requestBodyBuffers.push({ data: data2, encoding });
        this._currentRequest.write(data2, encoding, callback);
      } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
      }
    };
    RedirectableRequest.prototype.end = function(data2, encoding, callback) {
      if (typeof data2 === "function") {
        callback = data2;
        data2 = encoding = null;
      } else if (typeof encoding === "function") {
        callback = encoding;
        encoding = null;
      }
      if (!data2) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
      } else {
        var self2 = this;
        var currentRequest = this._currentRequest;
        this.write(data2, encoding, function() {
          self2._ended = true;
          currentRequest.end(null, null, callback);
        });
        this._ending = true;
      }
    };
    RedirectableRequest.prototype.setHeader = function(name, value) {
      this._options.headers[name] = value;
      this._currentRequest.setHeader(name, value);
    };
    RedirectableRequest.prototype.removeHeader = function(name) {
      delete this._options.headers[name];
      this._currentRequest.removeHeader(name);
    };
    RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
      var self2 = this;
      function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
      }
      function startTimer(socket) {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
        }
        self2._timeout = setTimeout(function() {
          self2.emit("timeout");
          clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
      }
      function clearTimer() {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
          self2._timeout = null;
        }
        self2.removeListener("abort", clearTimer);
        self2.removeListener("error", clearTimer);
        self2.removeListener("response", clearTimer);
        if (callback) {
          self2.removeListener("timeout", callback);
        }
        if (!self2.socket) {
          self2._currentRequest.removeListener("socket", startTimer);
        }
      }
      if (callback) {
        this.on("timeout", callback);
      }
      if (this.socket) {
        startTimer(this.socket);
      } else {
        this._currentRequest.once("socket", startTimer);
      }
      this.on("socket", destroyOnTimeout);
      this.on("abort", clearTimer);
      this.on("error", clearTimer);
      this.on("response", clearTimer);
      return this;
    };
    [
      "flushHeaders",
      "getHeader",
      "setNoDelay",
      "setSocketKeepAlive"
    ].forEach(function(method) {
      RedirectableRequest.prototype[method] = function(a, b) {
        return this._currentRequest[method](a, b);
      };
    });
    ["aborted", "connection", "socket"].forEach(function(property) {
      Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
          return this._currentRequest[property];
        }
      });
    });
    RedirectableRequest.prototype._sanitizeOptions = function(options2) {
      if (!options2.headers) {
        options2.headers = {};
      }
      if (options2.host) {
        if (!options2.hostname) {
          options2.hostname = options2.host;
        }
        delete options2.host;
      }
      if (!options2.pathname && options2.path) {
        var searchPos = options2.path.indexOf("?");
        if (searchPos < 0) {
          options2.pathname = options2.path;
        } else {
          options2.pathname = options2.path.substring(0, searchPos);
          options2.search = options2.path.substring(searchPos);
        }
      }
    };
    RedirectableRequest.prototype._performRequest = function() {
      var protocol = this._options.protocol;
      var nativeProtocol = this._options.nativeProtocols[protocol];
      if (!nativeProtocol) {
        this.emit("error", new TypeError("Unsupported protocol " + protocol));
        return;
      }
      if (this._options.agents) {
        var scheme = protocol.substr(0, protocol.length - 1);
        this._options.agent = this._options.agents[scheme];
      }
      var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
      this._currentUrl = url.format(this._options);
      request._redirectable = this;
      for (var e = 0; e < events.length; e++) {
        request.on(events[e], eventHandlers[events[e]]);
      }
      if (this._isRedirect) {
        var i = 0;
        var self2 = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error3) {
          if (request === self2._currentRequest) {
            if (error3) {
              self2.emit("error", error3);
            } else if (i < buffers.length) {
              var buffer = buffers[i++];
              if (!request.finished) {
                request.write(buffer.data, buffer.encoding, writeNext);
              }
            } else if (self2._ended) {
              request.end();
            }
          }
        })();
      }
    };
    RedirectableRequest.prototype._processResponse = function(response) {
      var statusCode = response.statusCode;
      if (this._options.trackRedirects) {
        this._redirects.push({
          url: this._currentUrl,
          headers: response.headers,
          statusCode
        });
      }
      var location = response.headers.location;
      if (location && this._options.followRedirects !== false && statusCode >= 300 && statusCode < 400) {
        abortRequest(this._currentRequest);
        response.destroy();
        if (++this._redirectCount > this._options.maxRedirects) {
          this.emit("error", new TooManyRedirectsError());
          return;
        }
        if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
          this._options.method = "GET";
          this._requestBodyBuffers = [];
          removeMatchingHeaders(/^content-/i, this._options.headers);
        }
        var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
        var currentUrlParts = url.parse(this._currentUrl);
        var currentHost = currentHostHeader || currentUrlParts.host;
        var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, { host: currentHost }));
        var redirectUrl;
        try {
          redirectUrl = url.resolve(currentUrl, location);
        } catch (cause) {
          this.emit("error", new RedirectionError(cause));
          return;
        }
        debug("redirecting to", redirectUrl);
        this._isRedirect = true;
        var redirectUrlParts = url.parse(redirectUrl);
        Object.assign(this._options, redirectUrlParts);
        if (redirectUrlParts.protocol !== currentUrlParts.protocol || !isSameOrSubdomain(redirectUrlParts.host, currentHost)) {
          removeMatchingHeaders(/^(?:authorization|cookie)$/i, this._options.headers);
        }
        if (typeof this._options.beforeRedirect === "function") {
          var responseDetails = { headers: response.headers };
          try {
            this._options.beforeRedirect.call(null, this._options, responseDetails);
          } catch (err) {
            this.emit("error", err);
            return;
          }
          this._sanitizeOptions(this._options);
        }
        try {
          this._performRequest();
        } catch (cause) {
          this.emit("error", new RedirectionError(cause));
        }
      } else {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        this._requestBodyBuffers = [];
      }
    };
    function wrap(protocols) {
      var exports3 = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
      };
      var nativeProtocols = {};
      Object.keys(protocols).forEach(function(scheme) {
        var protocol = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
        var wrappedProtocol = exports3[scheme] = Object.create(nativeProtocol);
        function request(input, options2, callback) {
          if (typeof input === "string") {
            var urlStr = input;
            try {
              input = urlToOptions(new URL2(urlStr));
            } catch (err) {
              input = url.parse(urlStr);
            }
          } else if (URL2 && input instanceof URL2) {
            input = urlToOptions(input);
          } else {
            callback = options2;
            options2 = input;
            input = { protocol };
          }
          if (typeof options2 === "function") {
            callback = options2;
            options2 = null;
          }
          options2 = Object.assign({
            maxRedirects: exports3.maxRedirects,
            maxBodyLength: exports3.maxBodyLength
          }, input, options2);
          options2.nativeProtocols = nativeProtocols;
          assert.equal(options2.protocol, protocol, "protocol mismatch");
          debug("options", options2);
          return new RedirectableRequest(options2, callback);
        }
        function get3(input, options2, callback) {
          var wrappedRequest = wrappedProtocol.request(input, options2, callback);
          wrappedRequest.end();
          return wrappedRequest;
        }
        Object.defineProperties(wrappedProtocol, {
          request: { value: request, configurable: true, enumerable: true, writable: true },
          get: { value: get3, configurable: true, enumerable: true, writable: true }
        });
      });
      return exports3;
    }
    function noop3() {
    }
    function urlToOptions(urlObject) {
      var options2 = {
        protocol: urlObject.protocol,
        hostname: urlObject.hostname.startsWith("[") ? urlObject.hostname.slice(1, -1) : urlObject.hostname,
        hash: urlObject.hash,
        search: urlObject.search,
        pathname: urlObject.pathname,
        path: urlObject.pathname + urlObject.search,
        href: urlObject.href
      };
      if (urlObject.port !== "") {
        options2.port = Number(urlObject.port);
      }
      return options2;
    }
    function removeMatchingHeaders(regex, headers) {
      var lastValue;
      for (var header in headers) {
        if (regex.test(header)) {
          lastValue = headers[header];
          delete headers[header];
        }
      }
      return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
    }
    function createErrorType(code, defaultMessage) {
      function CustomError(cause) {
        Error.captureStackTrace(this, this.constructor);
        if (!cause) {
          this.message = defaultMessage;
        } else {
          this.message = defaultMessage + ": " + cause.message;
          this.cause = cause;
        }
      }
      CustomError.prototype = new Error();
      CustomError.prototype.constructor = CustomError;
      CustomError.prototype.name = "Error [" + code + "]";
      CustomError.prototype.code = code;
      return CustomError;
    }
    function abortRequest(request) {
      for (var e = 0; e < events.length; e++) {
        request.removeListener(events[e], eventHandlers[events[e]]);
      }
      request.on("error", noop3);
      request.abort();
    }
    function isSameOrSubdomain(subdomain, domain) {
      if (subdomain === domain) {
        return true;
      }
      const dot = subdomain.length - domain.length - 1;
      return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
    }
    module2.exports = wrap({ http, https });
    module2.exports.wrap = wrap;
  }
});

// ../../node_modules/axios/lib/env/data.js
var require_data = __commonJS({
  "../../node_modules/axios/lib/env/data.js"(exports2, module2) {
    module2.exports = {
      "version": "0.26.0"
    };
  }
});

// ../../node_modules/axios/lib/adapters/http.js
var require_http = __commonJS({
  "../../node_modules/axios/lib/adapters/http.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var settle = require_settle();
    var buildFullPath = require_buildFullPath();
    var buildURL = require_buildURL();
    var http = require("http");
    var https = require("https");
    var httpFollow = require_follow_redirects().http;
    var httpsFollow = require_follow_redirects().https;
    var url = require("url");
    var zlib = require("zlib");
    var VERSION = require_data().version;
    var createError = require_createError();
    var enhanceError = require_enhanceError();
    var defaults = require_defaults();
    var Cancel = require_Cancel();
    var isHttps = /https:?/;
    function setProxy(options2, proxy, location) {
      options2.hostname = proxy.host;
      options2.host = proxy.host;
      options2.port = proxy.port;
      options2.path = location;
      if (proxy.auth) {
        var base64 = Buffer.from(proxy.auth.username + ":" + proxy.auth.password, "utf8").toString("base64");
        options2.headers["Proxy-Authorization"] = "Basic " + base64;
      }
      options2.beforeRedirect = function beforeRedirect(redirection) {
        redirection.headers.host = redirection.host;
        setProxy(redirection, proxy, redirection.href);
      };
    }
    module2.exports = function httpAdapter(config) {
      return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {
        var onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        var resolve = function resolve2(value) {
          done();
          resolvePromise(value);
        };
        var rejected = false;
        var reject = function reject2(value) {
          done();
          rejected = true;
          rejectPromise(value);
        };
        var data2 = config.data;
        var headers = config.headers;
        var headerNames = {};
        Object.keys(headers).forEach(function storeLowerName(name) {
          headerNames[name.toLowerCase()] = name;
        });
        if ("user-agent" in headerNames) {
          if (!headers[headerNames["user-agent"]]) {
            delete headers[headerNames["user-agent"]];
          }
        } else {
          headers["User-Agent"] = "axios/" + VERSION;
        }
        if (data2 && !utils.isStream(data2)) {
          if (Buffer.isBuffer(data2)) {
          } else if (utils.isArrayBuffer(data2)) {
            data2 = Buffer.from(new Uint8Array(data2));
          } else if (utils.isString(data2)) {
            data2 = Buffer.from(data2, "utf-8");
          } else {
            return reject(createError("Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream", config));
          }
          if (config.maxBodyLength > -1 && data2.length > config.maxBodyLength) {
            return reject(createError("Request body larger than maxBodyLength limit", config));
          }
          if (!headerNames["content-length"]) {
            headers["Content-Length"] = data2.length;
          }
        }
        var auth = void 0;
        if (config.auth) {
          var username = config.auth.username || "";
          var password = config.auth.password || "";
          auth = username + ":" + password;
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        var parsed = url.parse(fullPath);
        var protocol = parsed.protocol || "http:";
        if (!auth && parsed.auth) {
          var urlAuth = parsed.auth.split(":");
          var urlUsername = urlAuth[0] || "";
          var urlPassword = urlAuth[1] || "";
          auth = urlUsername + ":" + urlPassword;
        }
        if (auth && headerNames.authorization) {
          delete headers[headerNames.authorization];
        }
        var isHttpsRequest = isHttps.test(protocol);
        var agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
        try {
          buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, "");
        } catch (err) {
          var customErr = new Error(err.message);
          customErr.config = config;
          customErr.url = config.url;
          customErr.exists = true;
          reject(customErr);
        }
        var options2 = {
          path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, ""),
          method: config.method.toUpperCase(),
          headers,
          agent,
          agents: { http: config.httpAgent, https: config.httpsAgent },
          auth
        };
        if (config.socketPath) {
          options2.socketPath = config.socketPath;
        } else {
          options2.hostname = parsed.hostname;
          options2.port = parsed.port;
        }
        var proxy = config.proxy;
        if (!proxy && proxy !== false) {
          var proxyEnv = protocol.slice(0, -1) + "_proxy";
          var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];
          if (proxyUrl) {
            var parsedProxyUrl = url.parse(proxyUrl);
            var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;
            var shouldProxy = true;
            if (noProxyEnv) {
              var noProxy = noProxyEnv.split(",").map(function trim(s) {
                return s.trim();
              });
              shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {
                if (!proxyElement) {
                  return false;
                }
                if (proxyElement === "*") {
                  return true;
                }
                if (proxyElement[0] === "." && parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) {
                  return true;
                }
                return parsed.hostname === proxyElement;
              });
            }
            if (shouldProxy) {
              proxy = {
                host: parsedProxyUrl.hostname,
                port: parsedProxyUrl.port,
                protocol: parsedProxyUrl.protocol
              };
              if (parsedProxyUrl.auth) {
                var proxyUrlAuth = parsedProxyUrl.auth.split(":");
                proxy.auth = {
                  username: proxyUrlAuth[0],
                  password: proxyUrlAuth[1]
                };
              }
            }
          }
        }
        if (proxy) {
          options2.headers.host = parsed.hostname + (parsed.port ? ":" + parsed.port : "");
          setProxy(options2, proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options2.path);
        }
        var transport;
        var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);
        if (config.transport) {
          transport = config.transport;
        } else if (config.maxRedirects === 0) {
          transport = isHttpsProxy ? https : http;
        } else {
          if (config.maxRedirects) {
            options2.maxRedirects = config.maxRedirects;
          }
          transport = isHttpsProxy ? httpsFollow : httpFollow;
        }
        if (config.maxBodyLength > -1) {
          options2.maxBodyLength = config.maxBodyLength;
        }
        if (config.insecureHTTPParser) {
          options2.insecureHTTPParser = config.insecureHTTPParser;
        }
        var req = transport.request(options2, function handleResponse(res) {
          if (req.aborted)
            return;
          var stream = res;
          var lastRequest = res.req || req;
          if (res.statusCode !== 204 && lastRequest.method !== "HEAD" && config.decompress !== false) {
            switch (res.headers["content-encoding"]) {
              case "gzip":
              case "compress":
              case "deflate":
                stream = stream.pipe(zlib.createUnzip());
                delete res.headers["content-encoding"];
                break;
            }
          }
          var response = {
            status: res.statusCode,
            statusText: res.statusMessage,
            headers: res.headers,
            config,
            request: lastRequest
          };
          if (config.responseType === "stream") {
            response.data = stream;
            settle(resolve, reject, response);
          } else {
            var responseBuffer = [];
            var totalResponseBytes = 0;
            stream.on("data", function handleStreamData(chunk) {
              responseBuffer.push(chunk);
              totalResponseBytes += chunk.length;
              if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
                rejected = true;
                stream.destroy();
                reject(createError("maxContentLength size of " + config.maxContentLength + " exceeded", config, null, lastRequest));
              }
            });
            stream.on("aborted", function handlerStreamAborted() {
              if (rejected) {
                return;
              }
              stream.destroy();
              reject(createError("error request aborted", config, "ERR_REQUEST_ABORTED", lastRequest));
            });
            stream.on("error", function handleStreamError(err) {
              if (req.aborted)
                return;
              reject(enhanceError(err, config, null, lastRequest));
            });
            stream.on("end", function handleStreamEnd() {
              try {
                var responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
                if (config.responseType !== "arraybuffer") {
                  responseData = responseData.toString(config.responseEncoding);
                  if (!config.responseEncoding || config.responseEncoding === "utf8") {
                    responseData = utils.stripBOM(responseData);
                  }
                }
                response.data = responseData;
              } catch (err) {
                reject(enhanceError(err, config, err.code, response.request, response));
              }
              settle(resolve, reject, response);
            });
          }
        });
        req.on("error", function handleRequestError(err) {
          if (req.aborted && err.code !== "ERR_FR_TOO_MANY_REDIRECTS")
            return;
          reject(enhanceError(err, config, null, req));
        });
        req.on("socket", function handleRequestSocket(socket) {
          socket.setKeepAlive(true, 1e3 * 60);
        });
        if (config.timeout) {
          var timeout = parseInt(config.timeout, 10);
          if (isNaN(timeout)) {
            reject(createError("error trying to parse `config.timeout` to int", config, "ERR_PARSE_TIMEOUT", req));
            return;
          }
          req.setTimeout(timeout, function handleRequestTimeout() {
            req.abort();
            var timeoutErrorMessage = "";
            if (config.timeoutErrorMessage) {
              timeoutErrorMessage = config.timeoutErrorMessage;
            } else {
              timeoutErrorMessage = "timeout of " + config.timeout + "ms exceeded";
            }
            var transitional = config.transitional || defaults.transitional;
            reject(createError(timeoutErrorMessage, config, transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED", req));
          });
        }
        if (config.cancelToken || config.signal) {
          onCanceled = function(cancel) {
            if (req.aborted)
              return;
            req.abort();
            reject(!cancel || cancel && cancel.type ? new Cancel("canceled") : cancel);
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        if (utils.isStream(data2)) {
          data2.on("error", function handleStreamError(err) {
            reject(enhanceError(err, config, null, req));
          }).pipe(req);
        } else {
          req.end(data2);
        }
      });
    };
  }
});

// ../../node_modules/axios/lib/defaults.js
var require_defaults = __commonJS({
  "../../node_modules/axios/lib/defaults.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var normalizeHeaderName = require_normalizeHeaderName();
    var enhanceError = require_enhanceError();
    var DEFAULT_CONTENT_TYPE = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value;
      }
    }
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== "undefined") {
        adapter = require_xhr();
      } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
        adapter = require_http();
      }
      return adapter;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: {
        silentJSONParsing: true,
        forcedJSONParsing: true,
        clarifyTimeoutError: false
      },
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data2, headers) {
        normalizeHeaderName(headers, "Accept");
        normalizeHeaderName(headers, "Content-Type");
        if (utils.isFormData(data2) || utils.isArrayBuffer(data2) || utils.isBuffer(data2) || utils.isStream(data2) || utils.isFile(data2) || utils.isBlob(data2)) {
          return data2;
        }
        if (utils.isArrayBufferView(data2)) {
          return data2.buffer;
        }
        if (utils.isURLSearchParams(data2)) {
          setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
          return data2.toString();
        }
        if (utils.isObject(data2) || headers && headers["Content-Type"] === "application/json") {
          setContentTypeIfUnset(headers, "application/json");
          return stringifySafely(data2);
        }
        return data2;
      }],
      transformResponse: [function transformResponse(data2) {
        var transitional = this.transitional || defaults.transitional;
        var silentJSONParsing = transitional && transitional.silentJSONParsing;
        var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
        if (strictJSONParsing || forcedJSONParsing && utils.isString(data2) && data2.length) {
          try {
            return JSON.parse(data2);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw enhanceError(e, this, "E_JSON_PARSE");
              }
              throw e;
            }
          }
        }
        return data2;
      }],
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*"
        }
      }
    };
    utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });
    module2.exports = defaults;
  }
});

// ../../node_modules/axios/lib/core/transformData.js
var require_transformData = __commonJS({
  "../../node_modules/axios/lib/core/transformData.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var defaults = require_defaults();
    module2.exports = function transformData(data2, headers, fns) {
      var context = this || defaults;
      utils.forEach(fns, function transform(fn) {
        data2 = fn.call(context, data2, headers);
      });
      return data2;
    };
  }
});

// ../../node_modules/axios/lib/cancel/isCancel.js
var require_isCancel = __commonJS({
  "../../node_modules/axios/lib/cancel/isCancel.js"(exports2, module2) {
    "use strict";
    module2.exports = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };
  }
});

// ../../node_modules/axios/lib/core/dispatchRequest.js
var require_dispatchRequest = __commonJS({
  "../../node_modules/axios/lib/core/dispatchRequest.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var transformData = require_transformData();
    var isCancel = require_isCancel();
    var defaults = require_defaults();
    var Cancel = require_Cancel();
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new Cancel("canceled");
      }
    }
    module2.exports = function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = config.headers || {};
      config.data = transformData.call(config, config.data, config.headers, config.transformRequest);
      config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
      utils.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function cleanHeaderConfig(method) {
        delete config.headers[method];
      });
      var adapter = config.adapter || defaults.adapter;
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(config, response.data, response.headers, config.transformResponse);
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(config, reason.response.data, reason.response.headers, config.transformResponse);
          }
        }
        return Promise.reject(reason);
      });
    };
  }
});

// ../../node_modules/axios/lib/core/mergeConfig.js
var require_mergeConfig = __commonJS({
  "../../node_modules/axios/lib/core/mergeConfig.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = function mergeConfig(config1, config2) {
      config2 = config2 || {};
      var config = {};
      function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function valueFromConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        }
      }
      function defaultToConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function mergeDirectKeys(prop) {
        if (prop in config2) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      var mergeMap = {
        "url": valueFromConfig2,
        "method": valueFromConfig2,
        "data": valueFromConfig2,
        "baseURL": defaultToConfig2,
        "transformRequest": defaultToConfig2,
        "transformResponse": defaultToConfig2,
        "paramsSerializer": defaultToConfig2,
        "timeout": defaultToConfig2,
        "timeoutMessage": defaultToConfig2,
        "withCredentials": defaultToConfig2,
        "adapter": defaultToConfig2,
        "responseType": defaultToConfig2,
        "xsrfCookieName": defaultToConfig2,
        "xsrfHeaderName": defaultToConfig2,
        "onUploadProgress": defaultToConfig2,
        "onDownloadProgress": defaultToConfig2,
        "decompress": defaultToConfig2,
        "maxContentLength": defaultToConfig2,
        "maxBodyLength": defaultToConfig2,
        "transport": defaultToConfig2,
        "httpAgent": defaultToConfig2,
        "httpsAgent": defaultToConfig2,
        "cancelToken": defaultToConfig2,
        "socketPath": defaultToConfig2,
        "responseEncoding": defaultToConfig2,
        "validateStatus": mergeDirectKeys
      };
      utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
        var merge = mergeMap[prop] || mergeDeepProperties;
        var configValue = merge(prop);
        utils.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    };
  }
});

// ../../node_modules/axios/lib/helpers/validator.js
var require_validator = __commonJS({
  "../../node_modules/axios/lib/helpers/validator.js"(exports2, module2) {
    "use strict";
    var VERSION = require_data().version;
    var validators = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
      validators[type] = function validator(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    validators.transitional = function transitional(validator, version, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return function(value, opt, opts) {
        if (validator === false) {
          throw new Error(formatMessage(opt, " has been removed" + (version ? " in " + version : "")));
        }
        if (version && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(formatMessage(opt, " has been deprecated since v" + version + " and will be removed in the near future"));
        }
        return validator ? validator(value, opt, opts) : true;
      };
    };
    function assertOptions(options2, schema, allowUnknown) {
      if (typeof options2 !== "object") {
        throw new TypeError("options must be an object");
      }
      var keys = Object.keys(options2);
      var i = keys.length;
      while (i-- > 0) {
        var opt = keys[i];
        var validator = schema[opt];
        if (validator) {
          var value = options2[opt];
          var result2 = value === void 0 || validator(value, opt, options2);
          if (result2 !== true) {
            throw new TypeError("option " + opt + " must be " + result2);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw Error("Unknown option " + opt);
        }
      }
    }
    module2.exports = {
      assertOptions,
      validators
    };
  }
});

// ../../node_modules/axios/lib/core/Axios.js
var require_Axios = __commonJS({
  "../../node_modules/axios/lib/core/Axios.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var buildURL = require_buildURL();
    var InterceptorManager = require_InterceptorManager();
    var dispatchRequest = require_dispatchRequest();
    var mergeConfig = require_mergeConfig();
    var validator = require_validator();
    var validators = validator.validators;
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    Axios.prototype.request = function request(configOrUrl, config) {
      if (typeof configOrUrl === "string") {
        config = config || {};
        config.url = configOrUrl;
      } else {
        config = configOrUrl || {};
      }
      config = mergeConfig(this.defaults, config);
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = "get";
      }
      var transitional = config.transitional;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      var promise;
      if (!synchronousRequestInterceptors) {
        var chain = [dispatchRequest, void 0];
        Array.prototype.unshift.apply(chain, requestInterceptorChain);
        chain = chain.concat(responseInterceptorChain);
        promise = Promise.resolve(config);
        while (chain.length) {
          promise = promise.then(chain.shift(), chain.shift());
        }
        return promise;
      }
      var newConfig = config;
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error3) {
          onRejected(error3);
          break;
        }
      }
      try {
        promise = dispatchRequest(newConfig);
      } catch (error3) {
        return Promise.reject(error3);
      }
      while (responseInterceptorChain.length) {
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
      }
      return promise;
    };
    Axios.prototype.getUri = function getUri(config) {
      config = mergeConfig(this.defaults, config);
      return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
    };
    utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      Axios.prototype[method] = function(url, data2, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data: data2
        }));
      };
    });
    module2.exports = Axios;
  }
});

// ../../node_modules/axios/lib/cancel/CancelToken.js
var require_CancelToken = __commonJS({
  "../../node_modules/axios/lib/cancel/CancelToken.js"(exports2, module2) {
    "use strict";
    var Cancel = require_Cancel();
    function CancelToken(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      var token2 = this;
      this.promise.then(function(cancel) {
        if (!token2._listeners)
          return;
        var i;
        var l = token2._listeners.length;
        for (i = 0; i < l; i++) {
          token2._listeners[i](cancel);
        }
        token2._listeners = null;
      });
      this.promise.then = function(onfulfilled) {
        var _resolve;
        var promise = new Promise(function(resolve) {
          token2.subscribe(resolve);
          _resolve = resolve;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token2.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message) {
        if (token2.reason) {
          return;
        }
        token2.reason = new Cancel(message);
        resolvePromise(token2.reason);
      });
    }
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };
    CancelToken.prototype.subscribe = function subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    };
    CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      var index = this._listeners.indexOf(listener);
      if (index !== -1) {
        this._listeners.splice(index, 1);
      }
    };
    CancelToken.source = function source() {
      var cancel;
      var token2 = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token: token2,
        cancel
      };
    };
    module2.exports = CancelToken;
  }
});

// ../../node_modules/axios/lib/helpers/spread.js
var require_spread = __commonJS({
  "../../node_modules/axios/lib/helpers/spread.js"(exports2, module2) {
    "use strict";
    module2.exports = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };
  }
});

// ../../node_modules/axios/lib/helpers/isAxiosError.js
var require_isAxiosError = __commonJS({
  "../../node_modules/axios/lib/helpers/isAxiosError.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = function isAxiosError(payload) {
      return utils.isObject(payload) && payload.isAxiosError === true;
    };
  }
});

// ../../node_modules/axios/lib/axios.js
var require_axios = __commonJS({
  "../../node_modules/axios/lib/axios.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var bind = require_bind();
    var Axios = require_Axios();
    var mergeConfig = require_mergeConfig();
    var defaults = require_defaults();
    function createInstance(defaultConfig) {
      var context = new Axios(defaultConfig);
      var instance = bind(Axios.prototype.request, context);
      utils.extend(instance, Axios.prototype, context);
      utils.extend(instance, context);
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios = createInstance(defaults);
    axios.Axios = Axios;
    axios.Cancel = require_Cancel();
    axios.CancelToken = require_CancelToken();
    axios.isCancel = require_isCancel();
    axios.VERSION = require_data().version;
    axios.all = function all(promises2) {
      return Promise.all(promises2);
    };
    axios.spread = require_spread();
    axios.isAxiosError = require_isAxiosError();
    module2.exports = axios;
    module2.exports.default = axios;
  }
});

// ../../node_modules/axios/index.js
var require_axios2 = __commonJS({
  "../../node_modules/axios/index.js"(exports2, module2) {
    module2.exports = require_axios();
  }
});

// ../../node_modules/yaml/dist/nodes/Node.js
var require_Node = __commonJS({
  "../../node_modules/yaml/dist/nodes/Node.js"(exports2) {
    "use strict";
    var ALIAS = Symbol.for("yaml.alias");
    var DOC = Symbol.for("yaml.document");
    var MAP = Symbol.for("yaml.map");
    var PAIR = Symbol.for("yaml.pair");
    var SCALAR = Symbol.for("yaml.scalar");
    var SEQ = Symbol.for("yaml.seq");
    var NODE_TYPE = Symbol.for("yaml.node.type");
    var isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
    var isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
    var isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
    var isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
    var isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
    var isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
    function isCollection(node) {
      if (node && typeof node === "object")
        switch (node[NODE_TYPE]) {
          case MAP:
          case SEQ:
            return true;
        }
      return false;
    }
    function isNode(node) {
      if (node && typeof node === "object")
        switch (node[NODE_TYPE]) {
          case ALIAS:
          case MAP:
          case SCALAR:
          case SEQ:
            return true;
        }
      return false;
    }
    var hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;
    var NodeBase = class {
      constructor(type) {
        Object.defineProperty(this, NODE_TYPE, { value: type });
      }
      clone() {
        const copy3 = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (this.range)
          copy3.range = this.range.slice();
        return copy3;
      }
    };
    exports2.ALIAS = ALIAS;
    exports2.DOC = DOC;
    exports2.MAP = MAP;
    exports2.NODE_TYPE = NODE_TYPE;
    exports2.NodeBase = NodeBase;
    exports2.PAIR = PAIR;
    exports2.SCALAR = SCALAR;
    exports2.SEQ = SEQ;
    exports2.hasAnchor = hasAnchor;
    exports2.isAlias = isAlias;
    exports2.isCollection = isCollection;
    exports2.isDocument = isDocument;
    exports2.isMap = isMap;
    exports2.isNode = isNode;
    exports2.isPair = isPair;
    exports2.isScalar = isScalar;
    exports2.isSeq = isSeq;
  }
});

// ../../node_modules/yaml/dist/visit.js
var require_visit = __commonJS({
  "../../node_modules/yaml/dist/visit.js"(exports2) {
    "use strict";
    var Node = require_Node();
    var BREAK = Symbol("break visit");
    var SKIP = Symbol("skip children");
    var REMOVE = Symbol("remove node");
    function visit(node, visitor) {
      if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
        visitor = Object.assign({
          Alias: visitor.Node,
          Map: visitor.Node,
          Scalar: visitor.Node,
          Seq: visitor.Node
        }, visitor.Value && {
          Map: visitor.Value,
          Scalar: visitor.Value,
          Seq: visitor.Value
        }, visitor.Collection && {
          Map: visitor.Collection,
          Seq: visitor.Collection
        }, visitor);
      }
      if (Node.isDocument(node)) {
        const cd = _visit(null, node.contents, visitor, Object.freeze([node]));
        if (cd === REMOVE)
          node.contents = null;
      } else
        _visit(null, node, visitor, Object.freeze([]));
    }
    visit.BREAK = BREAK;
    visit.SKIP = SKIP;
    visit.REMOVE = REMOVE;
    function _visit(key, node, visitor, path) {
      let ctrl = void 0;
      if (typeof visitor === "function")
        ctrl = visitor(key, node, path);
      else if (Node.isMap(node)) {
        if (visitor.Map)
          ctrl = visitor.Map(key, node, path);
      } else if (Node.isSeq(node)) {
        if (visitor.Seq)
          ctrl = visitor.Seq(key, node, path);
      } else if (Node.isPair(node)) {
        if (visitor.Pair)
          ctrl = visitor.Pair(key, node, path);
      } else if (Node.isScalar(node)) {
        if (visitor.Scalar)
          ctrl = visitor.Scalar(key, node, path);
      } else if (Node.isAlias(node)) {
        if (visitor.Alias)
          ctrl = visitor.Alias(key, node, path);
      }
      if (Node.isNode(ctrl) || Node.isPair(ctrl)) {
        const parent = path[path.length - 1];
        if (Node.isCollection(parent)) {
          parent.items[key] = ctrl;
        } else if (Node.isPair(parent)) {
          if (key === "key")
            parent.key = ctrl;
          else
            parent.value = ctrl;
        } else if (Node.isDocument(parent)) {
          parent.contents = ctrl;
        } else {
          const pt = Node.isAlias(parent) ? "alias" : "scalar";
          throw new Error(`Cannot replace node with ${pt} parent`);
        }
        return _visit(key, ctrl, visitor, path);
      }
      if (typeof ctrl !== "symbol") {
        if (Node.isCollection(node)) {
          path = Object.freeze(path.concat(node));
          for (let i = 0; i < node.items.length; ++i) {
            const ci = _visit(i, node.items[i], visitor, path);
            if (typeof ci === "number")
              i = ci - 1;
            else if (ci === BREAK)
              return BREAK;
            else if (ci === REMOVE) {
              node.items.splice(i, 1);
              i -= 1;
            }
          }
        } else if (Node.isPair(node)) {
          path = Object.freeze(path.concat(node));
          const ck = _visit("key", node.key, visitor, path);
          if (ck === BREAK)
            return BREAK;
          else if (ck === REMOVE)
            node.key = null;
          const cv = _visit("value", node.value, visitor, path);
          if (cv === BREAK)
            return BREAK;
          else if (cv === REMOVE)
            node.value = null;
        }
      }
      return ctrl;
    }
    exports2.visit = visit;
  }
});

// ../../node_modules/yaml/dist/doc/directives.js
var require_directives = __commonJS({
  "../../node_modules/yaml/dist/doc/directives.js"(exports2) {
    "use strict";
    var Node = require_Node();
    var visit = require_visit();
    var escapeChars = {
      "!": "%21",
      ",": "%2C",
      "[": "%5B",
      "]": "%5D",
      "{": "%7B",
      "}": "%7D"
    };
    var escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
    var Directives = class {
      constructor(yaml, tags) {
        this.marker = null;
        this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
        this.tags = Object.assign({}, Directives.defaultTags, tags);
      }
      clone() {
        const copy3 = new Directives(this.yaml, this.tags);
        copy3.marker = this.marker;
        return copy3;
      }
      atDocument() {
        const res = new Directives(this.yaml, this.tags);
        switch (this.yaml.version) {
          case "1.1":
            this.atNextDocument = true;
            break;
          case "1.2":
            this.atNextDocument = false;
            this.yaml = {
              explicit: Directives.defaultYaml.explicit,
              version: "1.2"
            };
            this.tags = Object.assign({}, Directives.defaultTags);
            break;
        }
        return res;
      }
      add(line, onError) {
        if (this.atNextDocument) {
          this.yaml = { explicit: Directives.defaultYaml.explicit, version: "1.1" };
          this.tags = Object.assign({}, Directives.defaultTags);
          this.atNextDocument = false;
        }
        const parts = line.trim().split(/[ \t]+/);
        const name = parts.shift();
        switch (name) {
          case "%TAG": {
            if (parts.length !== 2) {
              onError(0, "%TAG directive should contain exactly two parts");
              if (parts.length < 2)
                return false;
            }
            const [handle3, prefix] = parts;
            this.tags[handle3] = prefix;
            return true;
          }
          case "%YAML": {
            this.yaml.explicit = true;
            if (parts.length < 1) {
              onError(0, "%YAML directive should contain exactly one part");
              return false;
            }
            const [version] = parts;
            if (version === "1.1" || version === "1.2") {
              this.yaml.version = version;
              return true;
            } else {
              onError(6, `Unsupported YAML version ${version}`, true);
              return false;
            }
          }
          default:
            onError(0, `Unknown directive ${name}`, true);
            return false;
        }
      }
      tagName(source, onError) {
        if (source === "!")
          return "!";
        if (source[0] !== "!") {
          onError(`Not a valid tag: ${source}`);
          return null;
        }
        if (source[1] === "<") {
          const verbatim = source.slice(2, -1);
          if (verbatim === "!" || verbatim === "!!") {
            onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
            return null;
          }
          if (source[source.length - 1] !== ">")
            onError("Verbatim tags must end with a >");
          return verbatim;
        }
        const [, handle3, suffix] = source.match(/^(.*!)([^!]*)$/);
        if (!suffix)
          onError(`The ${source} tag has no suffix`);
        const prefix = this.tags[handle3];
        if (prefix)
          return prefix + decodeURIComponent(suffix);
        if (handle3 === "!")
          return source;
        onError(`Could not resolve tag: ${source}`);
        return null;
      }
      tagString(tag) {
        for (const [handle3, prefix] of Object.entries(this.tags)) {
          if (tag.startsWith(prefix))
            return handle3 + escapeTagName(tag.substring(prefix.length));
        }
        return tag[0] === "!" ? tag : `!<${tag}>`;
      }
      toString(doc) {
        const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
        const tagEntries = Object.entries(this.tags);
        let tagNames;
        if (doc && tagEntries.length > 0 && Node.isNode(doc.contents)) {
          const tags = {};
          visit.visit(doc.contents, (_key, node) => {
            if (Node.isNode(node) && node.tag)
              tags[node.tag] = true;
          });
          tagNames = Object.keys(tags);
        } else
          tagNames = [];
        for (const [handle3, prefix] of tagEntries) {
          if (handle3 === "!!" && prefix === "tag:yaml.org,2002:")
            continue;
          if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
            lines.push(`%TAG ${handle3} ${prefix}`);
        }
        return lines.join("\n");
      }
    };
    Directives.defaultYaml = { explicit: false, version: "1.2" };
    Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
    exports2.Directives = Directives;
  }
});

// ../../node_modules/yaml/dist/doc/anchors.js
var require_anchors = __commonJS({
  "../../node_modules/yaml/dist/doc/anchors.js"(exports2) {
    "use strict";
    var Node = require_Node();
    var visit = require_visit();
    function anchorIsValid(anchor) {
      if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
        const sa = JSON.stringify(anchor);
        const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
        throw new Error(msg);
      }
      return true;
    }
    function anchorNames(root) {
      const anchors = /* @__PURE__ */ new Set();
      visit.visit(root, {
        Value(_key, node) {
          if (node.anchor)
            anchors.add(node.anchor);
        }
      });
      return anchors;
    }
    function findNewAnchor(prefix, exclude) {
      for (let i = 1; true; ++i) {
        const name = `${prefix}${i}`;
        if (!exclude.has(name))
          return name;
      }
    }
    function createNodeAnchors(doc, prefix) {
      const aliasObjects = [];
      const sourceObjects = /* @__PURE__ */ new Map();
      let prevAnchors = null;
      return {
        onAnchor(source) {
          aliasObjects.push(source);
          if (!prevAnchors)
            prevAnchors = anchorNames(doc);
          const anchor = findNewAnchor(prefix, prevAnchors);
          prevAnchors.add(anchor);
          return anchor;
        },
        setAnchors() {
          for (const source of aliasObjects) {
            const ref = sourceObjects.get(source);
            if (typeof ref === "object" && ref.anchor && (Node.isScalar(ref.node) || Node.isCollection(ref.node))) {
              ref.node.anchor = ref.anchor;
            } else {
              const error3 = new Error("Failed to resolve repeated object (this should not happen)");
              error3.source = source;
              throw error3;
            }
          }
        },
        sourceObjects
      };
    }
    exports2.anchorIsValid = anchorIsValid;
    exports2.anchorNames = anchorNames;
    exports2.createNodeAnchors = createNodeAnchors;
    exports2.findNewAnchor = findNewAnchor;
  }
});

// ../../node_modules/yaml/dist/nodes/Alias.js
var require_Alias = __commonJS({
  "../../node_modules/yaml/dist/nodes/Alias.js"(exports2) {
    "use strict";
    var anchors = require_anchors();
    var visit = require_visit();
    var Node = require_Node();
    var Alias = class extends Node.NodeBase {
      constructor(source) {
        super(Node.ALIAS);
        this.source = source;
        Object.defineProperty(this, "tag", {
          set() {
            throw new Error("Alias nodes cannot have tags");
          }
        });
      }
      resolve(doc) {
        let found = void 0;
        visit.visit(doc, {
          Node: (_key, node) => {
            if (node === this)
              return visit.visit.BREAK;
            if (node.anchor === this.source)
              found = node;
          }
        });
        return found;
      }
      toJSON(_arg, ctx) {
        if (!ctx)
          return { source: this.source };
        const { anchors: anchors2, doc, maxAliasCount } = ctx;
        const source = this.resolve(doc);
        if (!source) {
          const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
          throw new ReferenceError(msg);
        }
        const data2 = anchors2.get(source);
        if (!data2 || data2.res === void 0) {
          const msg = "This should not happen: Alias anchor was not resolved?";
          throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
          data2.count += 1;
          if (data2.aliasCount === 0)
            data2.aliasCount = getAliasCount(doc, source, anchors2);
          if (data2.count * data2.aliasCount > maxAliasCount) {
            const msg = "Excessive alias count indicates a resource exhaustion attack";
            throw new ReferenceError(msg);
          }
        }
        return data2.res;
      }
      toString(ctx, _onComment, _onChompKeep) {
        const src = `*${this.source}`;
        if (ctx) {
          anchors.anchorIsValid(this.source);
          if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
            throw new Error(msg);
          }
          if (ctx.implicitKey)
            return `${src} `;
        }
        return src;
      }
    };
    function getAliasCount(doc, node, anchors2) {
      if (Node.isAlias(node)) {
        const source = node.resolve(doc);
        const anchor = anchors2 && source && anchors2.get(source);
        return anchor ? anchor.count * anchor.aliasCount : 0;
      } else if (Node.isCollection(node)) {
        let count = 0;
        for (const item of node.items) {
          const c = getAliasCount(doc, item, anchors2);
          if (c > count)
            count = c;
        }
        return count;
      } else if (Node.isPair(node)) {
        const kc = getAliasCount(doc, node.key, anchors2);
        const vc = getAliasCount(doc, node.value, anchors2);
        return Math.max(kc, vc);
      }
      return 1;
    }
    exports2.Alias = Alias;
  }
});

// ../../node_modules/yaml/dist/nodes/toJS.js
var require_toJS = __commonJS({
  "../../node_modules/yaml/dist/nodes/toJS.js"(exports2) {
    "use strict";
    var Node = require_Node();
    function toJS(value, arg, ctx) {
      if (Array.isArray(value))
        return value.map((v, i) => toJS(v, String(i), ctx));
      if (value && typeof value.toJSON === "function") {
        if (!ctx || !Node.hasAnchor(value))
          return value.toJSON(arg, ctx);
        const data2 = { aliasCount: 0, count: 1, res: void 0 };
        ctx.anchors.set(value, data2);
        ctx.onCreate = (res2) => {
          data2.res = res2;
          delete ctx.onCreate;
        };
        const res = value.toJSON(arg, ctx);
        if (ctx.onCreate)
          ctx.onCreate(res);
        return res;
      }
      if (typeof value === "bigint" && !(ctx && ctx.keep))
        return Number(value);
      return value;
    }
    exports2.toJS = toJS;
  }
});

// ../../node_modules/yaml/dist/nodes/Scalar.js
var require_Scalar = __commonJS({
  "../../node_modules/yaml/dist/nodes/Scalar.js"(exports2) {
    "use strict";
    var Node = require_Node();
    var toJS = require_toJS();
    var isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";
    var Scalar = class extends Node.NodeBase {
      constructor(value) {
        super(Node.SCALAR);
        this.value = value;
      }
      toJSON(arg, ctx) {
        return ctx && ctx.keep ? this.value : toJS.toJS(this.value, arg, ctx);
      }
      toString() {
        return String(this.value);
      }
    };
    Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
    Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
    Scalar.PLAIN = "PLAIN";
    Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
    Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
    exports2.Scalar = Scalar;
    exports2.isScalarValue = isScalarValue;
  }
});

// ../../node_modules/yaml/dist/doc/createNode.js
var require_createNode = __commonJS({
  "../../node_modules/yaml/dist/doc/createNode.js"(exports2) {
    "use strict";
    var Alias = require_Alias();
    var Node = require_Node();
    var Scalar = require_Scalar();
    var defaultTagPrefix = "tag:yaml.org,2002:";
    function findTagObject(value, tagName, tags) {
      if (tagName) {
        const match = tags.filter((t) => t.tag === tagName);
        const tagObj = match.find((t) => !t.format) || match[0];
        if (!tagObj)
          throw new Error(`Tag ${tagName} not found`);
        return tagObj;
      }
      return tags.find((t) => t.identify && t.identify(value) && !t.format);
    }
    function createNode(value, tagName, ctx) {
      var _a2, _b;
      if (Node.isDocument(value))
        value = value.contents;
      if (Node.isNode(value))
        return value;
      if (Node.isPair(value)) {
        const map = (_b = (_a2 = ctx.schema[Node.MAP]).createNode) === null || _b === void 0 ? void 0 : _b.call(_a2, ctx.schema, null, ctx);
        map.items.push(value);
        return map;
      }
      if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt === "function" && value instanceof BigInt) {
        value = value.valueOf();
      }
      const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;
      let ref = void 0;
      if (aliasDuplicateObjects && value && typeof value === "object") {
        ref = sourceObjects.get(value);
        if (ref) {
          if (!ref.anchor)
            ref.anchor = onAnchor(value);
          return new Alias.Alias(ref.anchor);
        } else {
          ref = { anchor: null, node: null };
          sourceObjects.set(value, ref);
        }
      }
      if (tagName && tagName.startsWith("!!"))
        tagName = defaultTagPrefix + tagName.slice(2);
      let tagObj = findTagObject(value, tagName, schema.tags);
      if (!tagObj) {
        if (value && typeof value.toJSON === "function")
          value = value.toJSON();
        if (!value || typeof value !== "object") {
          const node2 = new Scalar.Scalar(value);
          if (ref)
            ref.node = node2;
          return node2;
        }
        tagObj = value instanceof Map ? schema[Node.MAP] : Symbol.iterator in Object(value) ? schema[Node.SEQ] : schema[Node.MAP];
      }
      if (onTagObj) {
        onTagObj(tagObj);
        delete ctx.onTagObj;
      }
      const node = (tagObj === null || tagObj === void 0 ? void 0 : tagObj.createNode) ? tagObj.createNode(ctx.schema, value, ctx) : new Scalar.Scalar(value);
      if (tagName)
        node.tag = tagName;
      if (ref)
        ref.node = node;
      return node;
    }
    exports2.createNode = createNode;
  }
});

// ../../node_modules/yaml/dist/nodes/Collection.js
var require_Collection = __commonJS({
  "../../node_modules/yaml/dist/nodes/Collection.js"(exports2) {
    "use strict";
    var createNode = require_createNode();
    var Node = require_Node();
    function collectionFromPath(schema, path, value) {
      let v = value;
      for (let i = path.length - 1; i >= 0; --i) {
        const k = path[i];
        if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
          const a = [];
          a[k] = v;
          v = a;
        } else {
          v = /* @__PURE__ */ new Map([[k, v]]);
        }
      }
      return createNode.createNode(v, void 0, {
        aliasDuplicateObjects: false,
        keepUndefined: false,
        onAnchor: () => {
          throw new Error("This should not happen, please report a bug.");
        },
        schema,
        sourceObjects: /* @__PURE__ */ new Map()
      });
    }
    var isEmptyPath = (path) => path == null || typeof path === "object" && !!path[Symbol.iterator]().next().done;
    var Collection = class extends Node.NodeBase {
      constructor(type, schema) {
        super(type);
        Object.defineProperty(this, "schema", {
          value: schema,
          configurable: true,
          enumerable: false,
          writable: true
        });
      }
      clone(schema) {
        const copy3 = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (schema)
          copy3.schema = schema;
        copy3.items = copy3.items.map((it) => Node.isNode(it) || Node.isPair(it) ? it.clone(schema) : it);
        if (this.range)
          copy3.range = this.range.slice();
        return copy3;
      }
      addIn(path, value) {
        if (isEmptyPath(path))
          this.add(value);
        else {
          const [key, ...rest] = path;
          const node = this.get(key, true);
          if (Node.isCollection(node))
            node.addIn(rest, value);
          else if (node === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
      deleteIn(path) {
        const [key, ...rest] = path;
        if (rest.length === 0)
          return this.delete(key);
        const node = this.get(key, true);
        if (Node.isCollection(node))
          return node.deleteIn(rest);
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
      getIn(path, keepScalar) {
        const [key, ...rest] = path;
        const node = this.get(key, true);
        if (rest.length === 0)
          return !keepScalar && Node.isScalar(node) ? node.value : node;
        else
          return Node.isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
      }
      hasAllNullValues(allowScalar) {
        return this.items.every((node) => {
          if (!Node.isPair(node))
            return false;
          const n = node.value;
          return n == null || allowScalar && Node.isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
        });
      }
      hasIn(path) {
        const [key, ...rest] = path;
        if (rest.length === 0)
          return this.has(key);
        const node = this.get(key, true);
        return Node.isCollection(node) ? node.hasIn(rest) : false;
      }
      setIn(path, value) {
        const [key, ...rest] = path;
        if (rest.length === 0) {
          this.set(key, value);
        } else {
          const node = this.get(key, true);
          if (Node.isCollection(node))
            node.setIn(rest, value);
          else if (node === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
    };
    Collection.maxFlowStringSingleLineLength = 60;
    exports2.Collection = Collection;
    exports2.collectionFromPath = collectionFromPath;
    exports2.isEmptyPath = isEmptyPath;
  }
});

// ../../node_modules/yaml/dist/stringify/stringifyComment.js
var require_stringifyComment = __commonJS({
  "../../node_modules/yaml/dist/stringify/stringifyComment.js"(exports2) {
    "use strict";
    var stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
    function indentComment(comment, indent) {
      if (/^\n+$/.test(comment))
        return comment.substring(1);
      return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
    }
    var lineComment = (str, indent, comment) => comment.includes("\n") ? "\n" + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;
    exports2.indentComment = indentComment;
    exports2.lineComment = lineComment;
    exports2.stringifyComment = stringifyComment;
  }
});

// ../../node_modules/yaml/dist/stringify/foldFlowLines.js
var require_foldFlowLines = __commonJS({
  "../../node_modules/yaml/dist/stringify/foldFlowLines.js"(exports2) {
    "use strict";
    var FOLD_FLOW = "flow";
    var FOLD_BLOCK = "block";
    var FOLD_QUOTED = "quoted";
    function foldFlowLines(text, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
      if (!lineWidth || lineWidth < 0)
        return text;
      const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
      if (text.length <= endStep)
        return text;
      const folds = [];
      const escapedFolds = {};
      let end = lineWidth - indent.length;
      if (typeof indentAtStart === "number") {
        if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
          folds.push(0);
        else
          end = lineWidth - indentAtStart;
      }
      let split = void 0;
      let prev = void 0;
      let overflow = false;
      let i = -1;
      let escStart = -1;
      let escEnd = -1;
      if (mode === FOLD_BLOCK) {
        i = consumeMoreIndentedLines(text, i);
        if (i !== -1)
          end = i + endStep;
      }
      for (let ch; ch = text[i += 1]; ) {
        if (mode === FOLD_QUOTED && ch === "\\") {
          escStart = i;
          switch (text[i + 1]) {
            case "x":
              i += 3;
              break;
            case "u":
              i += 5;
              break;
            case "U":
              i += 9;
              break;
            default:
              i += 1;
          }
          escEnd = i;
        }
        if (ch === "\n") {
          if (mode === FOLD_BLOCK)
            i = consumeMoreIndentedLines(text, i);
          end = i + endStep;
          split = void 0;
        } else {
          if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
            const next = text[i + 1];
            if (next && next !== " " && next !== "\n" && next !== "	")
              split = i;
          }
          if (i >= end) {
            if (split) {
              folds.push(split);
              end = split + endStep;
              split = void 0;
            } else if (mode === FOLD_QUOTED) {
              while (prev === " " || prev === "	") {
                prev = ch;
                ch = text[i += 1];
                overflow = true;
              }
              const j = i > escEnd + 1 ? i - 2 : escStart - 1;
              if (escapedFolds[j])
                return text;
              folds.push(j);
              escapedFolds[j] = true;
              end = j + endStep;
              split = void 0;
            } else {
              overflow = true;
            }
          }
        }
        prev = ch;
      }
      if (overflow && onOverflow)
        onOverflow();
      if (folds.length === 0)
        return text;
      if (onFold)
        onFold();
      let res = text.slice(0, folds[0]);
      for (let i2 = 0; i2 < folds.length; ++i2) {
        const fold = folds[i2];
        const end2 = folds[i2 + 1] || text.length;
        if (fold === 0)
          res = `
${indent}${text.slice(0, end2)}`;
        else {
          if (mode === FOLD_QUOTED && escapedFolds[fold])
            res += `${text[fold]}\\`;
          res += `
${indent}${text.slice(fold + 1, end2)}`;
        }
      }
      return res;
    }
    function consumeMoreIndentedLines(text, i) {
      let ch = text[i + 1];
      while (ch === " " || ch === "	") {
        do {
          ch = text[i += 1];
        } while (ch && ch !== "\n");
        ch = text[i + 1];
      }
      return i;
    }
    exports2.FOLD_BLOCK = FOLD_BLOCK;
    exports2.FOLD_FLOW = FOLD_FLOW;
    exports2.FOLD_QUOTED = FOLD_QUOTED;
    exports2.foldFlowLines = foldFlowLines;
  }
});

// ../../node_modules/yaml/dist/stringify/stringifyString.js
var require_stringifyString = __commonJS({
  "../../node_modules/yaml/dist/stringify/stringifyString.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var foldFlowLines = require_foldFlowLines();
    var getFoldOptions = (ctx) => ({
      indentAtStart: ctx.indentAtStart,
      lineWidth: ctx.options.lineWidth,
      minContentWidth: ctx.options.minContentWidth
    });
    var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
    function lineLengthOverLimit(str, lineWidth, indentLength) {
      if (!lineWidth || lineWidth < 0)
        return false;
      const limit = lineWidth - indentLength;
      const strLen = str.length;
      if (strLen <= limit)
        return false;
      for (let i = 0, start = 0; i < strLen; ++i) {
        if (str[i] === "\n") {
          if (i - start > limit)
            return true;
          start = i + 1;
          if (strLen - start <= limit)
            return false;
        }
      }
      return true;
    }
    function doubleQuotedString(value, ctx) {
      const json = JSON.stringify(value);
      if (ctx.options.doubleQuotedAsJSON)
        return json;
      const { implicitKey } = ctx;
      const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
      const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
      let str = "";
      let start = 0;
      for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
        if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
          str += json.slice(start, i) + "\\ ";
          i += 1;
          start = i;
          ch = "\\";
        }
        if (ch === "\\")
          switch (json[i + 1]) {
            case "u":
              {
                str += json.slice(start, i);
                const code = json.substr(i + 2, 4);
                switch (code) {
                  case "0000":
                    str += "\\0";
                    break;
                  case "0007":
                    str += "\\a";
                    break;
                  case "000b":
                    str += "\\v";
                    break;
                  case "001b":
                    str += "\\e";
                    break;
                  case "0085":
                    str += "\\N";
                    break;
                  case "00a0":
                    str += "\\_";
                    break;
                  case "2028":
                    str += "\\L";
                    break;
                  case "2029":
                    str += "\\P";
                    break;
                  default:
                    if (code.substr(0, 2) === "00")
                      str += "\\x" + code.substr(2);
                    else
                      str += json.substr(i, 6);
                }
                i += 5;
                start = i + 1;
              }
              break;
            case "n":
              if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
                i += 1;
              } else {
                str += json.slice(start, i) + "\n\n";
                while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"') {
                  str += "\n";
                  i += 2;
                }
                str += indent;
                if (json[i + 2] === " ")
                  str += "\\";
                i += 1;
                start = i + 1;
              }
              break;
            default:
              i += 1;
          }
      }
      str = start ? str + json.slice(start) : json;
      return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx));
    }
    function singleQuotedString(value, ctx) {
      if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value))
        return doubleQuotedString(value, ctx);
      const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
      const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
      return ctx.implicitKey ? res : foldFlowLines.foldFlowLines(res, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx));
    }
    function quotedString(value, ctx) {
      const { singleQuote } = ctx.options;
      let qs;
      if (singleQuote === false)
        qs = doubleQuotedString;
      else {
        const hasDouble = value.includes('"');
        const hasSingle = value.includes("'");
        if (hasDouble && !hasSingle)
          qs = singleQuotedString;
        else if (hasSingle && !hasDouble)
          qs = doubleQuotedString;
        else
          qs = singleQuote ? singleQuotedString : doubleQuotedString;
      }
      return qs(value, ctx);
    }
    function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
      const { blockQuote, commentString, lineWidth } = ctx.options;
      if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
        return quotedString(value, ctx);
      }
      const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
      const literal2 = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.Scalar.BLOCK_FOLDED ? false : type === Scalar.Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
      if (!value)
        return literal2 ? "|\n" : ">\n";
      let chomp;
      let endStart;
      for (endStart = value.length; endStart > 0; --endStart) {
        const ch = value[endStart - 1];
        if (ch !== "\n" && ch !== "	" && ch !== " ")
          break;
      }
      let end = value.substring(endStart);
      const endNlPos = end.indexOf("\n");
      if (endNlPos === -1) {
        chomp = "-";
      } else if (value === end || endNlPos !== end.length - 1) {
        chomp = "+";
        if (onChompKeep)
          onChompKeep();
      } else {
        chomp = "";
      }
      if (end) {
        value = value.slice(0, -end.length);
        if (end[end.length - 1] === "\n")
          end = end.slice(0, -1);
        end = end.replace(/\n+(?!\n|$)/g, `$&${indent}`);
      }
      let startWithSpace = false;
      let startEnd;
      let startNlPos = -1;
      for (startEnd = 0; startEnd < value.length; ++startEnd) {
        const ch = value[startEnd];
        if (ch === " ")
          startWithSpace = true;
        else if (ch === "\n")
          startNlPos = startEnd;
        else
          break;
      }
      let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
      if (start) {
        value = value.substring(start.length);
        start = start.replace(/\n+/g, `$&${indent}`);
      }
      const indentSize = indent ? "2" : "1";
      let header = (literal2 ? "|" : ">") + (startWithSpace ? indentSize : "") + chomp;
      if (comment) {
        header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
        if (onComment)
          onComment();
      }
      if (literal2) {
        value = value.replace(/\n+/g, `$&${indent}`);
        return `${header}
${indent}${start}${value}${end}`;
      }
      value = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
      const body = foldFlowLines.foldFlowLines(`${start}${value}${end}`, indent, foldFlowLines.FOLD_BLOCK, getFoldOptions(ctx));
      return `${header}
${indent}${body}`;
    }
    function plainString(item, ctx, onComment, onChompKeep) {
      const { type, value } = item;
      const { actualString, implicitKey, indent, inFlow } = ctx;
      if (implicitKey && /[\n[\]{},]/.test(value) || inFlow && /[[\]{},]/.test(value)) {
        return quotedString(value, ctx);
      }
      if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
        return implicitKey || inFlow || value.indexOf("\n") === -1 ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
      }
      if (!implicitKey && !inFlow && type !== Scalar.Scalar.PLAIN && value.indexOf("\n") !== -1) {
        return blockString(item, ctx, onComment, onChompKeep);
      }
      if (indent === "" && containsDocumentMarker(value)) {
        ctx.forceBlockIndent = true;
        return blockString(item, ctx, onComment, onChompKeep);
      }
      const str = value.replace(/\n+/g, `$&
${indent}`);
      if (actualString) {
        const test = (tag) => {
          var _a2;
          return tag.default && tag.tag !== "tag:yaml.org,2002:str" && ((_a2 = tag.test) === null || _a2 === void 0 ? void 0 : _a2.test(str));
        };
        const { compat, tags } = ctx.doc.schema;
        if (tags.some(test) || (compat === null || compat === void 0 ? void 0 : compat.some(test)))
          return quotedString(value, ctx);
      }
      return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx));
    }
    function stringifyString(item, ctx, onComment, onChompKeep) {
      const { implicitKey, inFlow } = ctx;
      const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
      let { type } = item;
      if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
        if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
          type = Scalar.Scalar.QUOTE_DOUBLE;
      }
      const _stringify = (_type) => {
        switch (_type) {
          case Scalar.Scalar.BLOCK_FOLDED:
          case Scalar.Scalar.BLOCK_LITERAL:
            return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
          case Scalar.Scalar.QUOTE_DOUBLE:
            return doubleQuotedString(ss.value, ctx);
          case Scalar.Scalar.QUOTE_SINGLE:
            return singleQuotedString(ss.value, ctx);
          case Scalar.Scalar.PLAIN:
            return plainString(ss, ctx, onComment, onChompKeep);
          default:
            return null;
        }
      };
      let res = _stringify(type);
      if (res === null) {
        const { defaultKeyType, defaultStringType } = ctx.options;
        const t = implicitKey && defaultKeyType || defaultStringType;
        res = _stringify(t);
        if (res === null)
          throw new Error(`Unsupported default string type ${t}`);
      }
      return res;
    }
    exports2.stringifyString = stringifyString;
  }
});

// ../../node_modules/yaml/dist/stringify/stringify.js
var require_stringify = __commonJS({
  "../../node_modules/yaml/dist/stringify/stringify.js"(exports2) {
    "use strict";
    var anchors = require_anchors();
    var Node = require_Node();
    var stringifyComment = require_stringifyComment();
    var stringifyString = require_stringifyString();
    function createStringifyContext(doc, options2) {
      const opt = Object.assign({
        blockQuote: true,
        commentString: stringifyComment.stringifyComment,
        defaultKeyType: null,
        defaultStringType: "PLAIN",
        directives: null,
        doubleQuotedAsJSON: false,
        doubleQuotedMinMultiLineLength: 40,
        falseStr: "false",
        indentSeq: true,
        lineWidth: 80,
        minContentWidth: 20,
        nullStr: "null",
        simpleKeys: false,
        singleQuote: null,
        trueStr: "true",
        verifyAliasOrder: true
      }, doc.schema.toStringOptions, options2);
      let inFlow;
      switch (opt.collectionStyle) {
        case "block":
          inFlow = false;
          break;
        case "flow":
          inFlow = true;
          break;
        default:
          inFlow = null;
      }
      return {
        anchors: /* @__PURE__ */ new Set(),
        doc,
        indent: "",
        indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
        inFlow,
        options: opt
      };
    }
    function getTagObject(tags, item) {
      if (item.tag) {
        const match = tags.filter((t) => t.tag === item.tag);
        if (match.length > 0)
          return match.find((t) => t.format === item.format) || match[0];
      }
      let tagObj = void 0;
      let obj;
      if (Node.isScalar(item)) {
        obj = item.value;
        const match = tags.filter((t) => t.identify && t.identify(obj));
        tagObj = match.find((t) => t.format === item.format) || match.find((t) => !t.format);
      } else {
        obj = item;
        tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
      }
      if (!tagObj) {
        const name = obj && obj.constructor ? obj.constructor.name : typeof obj;
        throw new Error(`Tag not resolved for ${name} value`);
      }
      return tagObj;
    }
    function stringifyProps(node, tagObj, { anchors: anchors$1, doc }) {
      if (!doc.directives)
        return "";
      const props = [];
      const anchor = (Node.isScalar(node) || Node.isCollection(node)) && node.anchor;
      if (anchor && anchors.anchorIsValid(anchor)) {
        anchors$1.add(anchor);
        props.push(`&${anchor}`);
      }
      const tag = node.tag || (tagObj.default ? null : tagObj.tag);
      if (tag)
        props.push(doc.directives.tagString(tag));
      return props.join(" ");
    }
    function stringify(item, ctx, onComment, onChompKeep) {
      var _a2;
      if (Node.isPair(item))
        return item.toString(ctx, onComment, onChompKeep);
      if (Node.isAlias(item)) {
        if (ctx.doc.directives)
          return item.toString(ctx);
        if ((_a2 = ctx.resolvedAliases) === null || _a2 === void 0 ? void 0 : _a2.has(item)) {
          throw new TypeError(`Cannot stringify circular structure without alias nodes`);
        } else {
          if (ctx.resolvedAliases)
            ctx.resolvedAliases.add(item);
          else
            ctx.resolvedAliases = /* @__PURE__ */ new Set([item]);
          item = item.resolve(ctx.doc);
        }
      }
      let tagObj = void 0;
      const node = Node.isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
      if (!tagObj)
        tagObj = getTagObject(ctx.doc.schema.tags, node);
      const props = stringifyProps(node, tagObj, ctx);
      if (props.length > 0)
        ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;
      const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : Node.isScalar(node) ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
      if (!props)
        return str;
      return Node.isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
    }
    exports2.createStringifyContext = createStringifyContext;
    exports2.stringify = stringify;
  }
});

// ../../node_modules/yaml/dist/stringify/stringifyPair.js
var require_stringifyPair = __commonJS({
  "../../node_modules/yaml/dist/stringify/stringifyPair.js"(exports2) {
    "use strict";
    var Node = require_Node();
    var Scalar = require_Scalar();
    var stringify = require_stringify();
    var stringifyComment = require_stringifyComment();
    function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
      const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
      let keyComment = Node.isNode(key) && key.comment || null;
      if (simpleKeys) {
        if (keyComment) {
          throw new Error("With simple keys, key nodes cannot have comments");
        }
        if (Node.isCollection(key)) {
          const msg = "With simple keys, collection cannot be used as a key value";
          throw new Error(msg);
        }
      }
      let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || Node.isCollection(key) || (Node.isScalar(key) ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL : typeof key === "object"));
      ctx = Object.assign({}, ctx, {
        allNullValues: false,
        implicitKey: !explicitKey && (simpleKeys || !allNullValues),
        indent: indent + indentStep
      });
      let keyCommentDone = false;
      let chompKeep = false;
      let str = stringify.stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
      if (!explicitKey && !ctx.inFlow && str.length > 1024) {
        if (simpleKeys)
          throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
        explicitKey = true;
      }
      if (ctx.inFlow) {
        if (allNullValues || value == null) {
          if (keyCommentDone && onComment)
            onComment();
          return explicitKey ? `? ${str}` : str;
        }
      } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
        str = `? ${str}`;
        if (keyComment && !keyCommentDone) {
          str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
        } else if (chompKeep && onChompKeep)
          onChompKeep();
        return str;
      }
      if (keyCommentDone)
        keyComment = null;
      if (explicitKey) {
        if (keyComment)
          str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
        str = `? ${str}
${indent}:`;
      } else {
        str = `${str}:`;
        if (keyComment)
          str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
      }
      let vcb = "";
      let valueComment = null;
      if (Node.isNode(value)) {
        if (value.spaceBefore)
          vcb = "\n";
        if (value.commentBefore) {
          const cs = commentString(value.commentBefore);
          vcb += `
${stringifyComment.indentComment(cs, ctx.indent)}`;
        }
        valueComment = value.comment;
      } else if (value && typeof value === "object") {
        value = doc.createNode(value);
      }
      ctx.implicitKey = false;
      if (!explicitKey && !keyComment && Node.isScalar(value))
        ctx.indentAtStart = str.length + 1;
      chompKeep = false;
      if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && Node.isSeq(value) && !value.flow && !value.tag && !value.anchor) {
        ctx.indent = ctx.indent.substr(2);
      }
      let valueCommentDone = false;
      const valueStr = stringify.stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
      let ws = " ";
      if (vcb || keyComment) {
        ws = valueStr === "" && !ctx.inFlow ? vcb : `${vcb}
${ctx.indent}`;
      } else if (!explicitKey && Node.isCollection(value)) {
        const flow = valueStr[0] === "[" || valueStr[0] === "{";
        if (!flow || valueStr.includes("\n"))
          ws = `
${ctx.indent}`;
      } else if (valueStr === "" || valueStr[0] === "\n")
        ws = "";
      str += ws + valueStr;
      if (ctx.inFlow) {
        if (valueCommentDone && onComment)
          onComment();
      } else if (valueComment && !valueCommentDone) {
        str += stringifyComment.lineComment(str, ctx.indent, commentString(valueComment));
      } else if (chompKeep && onChompKeep) {
        onChompKeep();
      }
      return str;
    }
    exports2.stringifyPair = stringifyPair;
  }
});

// ../../node_modules/yaml/dist/log.js
var require_log = __commonJS({
  "../../node_modules/yaml/dist/log.js"(exports2) {
    "use strict";
    function debug(logLevel, ...messages) {
      if (logLevel === "debug")
        console.log(...messages);
    }
    function warn3(logLevel, warning) {
      if (logLevel === "debug" || logLevel === "warn") {
        if (typeof process !== "undefined" && process.emitWarning)
          process.emitWarning(warning);
        else
          console.warn(warning);
      }
    }
    exports2.debug = debug;
    exports2.warn = warn3;
  }
});

// ../../node_modules/yaml/dist/nodes/addPairToJSMap.js
var require_addPairToJSMap = __commonJS({
  "../../node_modules/yaml/dist/nodes/addPairToJSMap.js"(exports2) {
    "use strict";
    var log4 = require_log();
    var stringify = require_stringify();
    var Node = require_Node();
    var Scalar = require_Scalar();
    var toJS = require_toJS();
    var MERGE_KEY = "<<";
    function addPairToJSMap(ctx, map, { key, value }) {
      if (ctx && ctx.doc.schema.merge && isMergeKey(key)) {
        value = Node.isAlias(value) ? value.resolve(ctx.doc) : value;
        if (Node.isSeq(value))
          for (const it of value.items)
            mergeToJSMap(ctx, map, it);
        else if (Array.isArray(value))
          for (const it of value)
            mergeToJSMap(ctx, map, it);
        else
          mergeToJSMap(ctx, map, value);
      } else {
        const jsKey = toJS.toJS(key, "", ctx);
        if (map instanceof Map) {
          map.set(jsKey, toJS.toJS(value, jsKey, ctx));
        } else if (map instanceof Set) {
          map.add(jsKey);
        } else {
          const stringKey = stringifyKey(key, jsKey, ctx);
          const jsValue = toJS.toJS(value, stringKey, ctx);
          if (stringKey in map)
            Object.defineProperty(map, stringKey, {
              value: jsValue,
              writable: true,
              enumerable: true,
              configurable: true
            });
          else
            map[stringKey] = jsValue;
        }
      }
      return map;
    }
    var isMergeKey = (key) => key === MERGE_KEY || Node.isScalar(key) && key.value === MERGE_KEY && (!key.type || key.type === Scalar.Scalar.PLAIN);
    function mergeToJSMap(ctx, map, value) {
      const source = ctx && Node.isAlias(value) ? value.resolve(ctx.doc) : value;
      if (!Node.isMap(source))
        throw new Error("Merge sources must be maps or map aliases");
      const srcMap = source.toJSON(null, ctx, Map);
      for (const [key, value2] of srcMap) {
        if (map instanceof Map) {
          if (!map.has(key))
            map.set(key, value2);
        } else if (map instanceof Set) {
          map.add(key);
        } else if (!Object.prototype.hasOwnProperty.call(map, key)) {
          Object.defineProperty(map, key, {
            value: value2,
            writable: true,
            enumerable: true,
            configurable: true
          });
        }
      }
      return map;
    }
    function stringifyKey(key, jsKey, ctx) {
      if (jsKey === null)
        return "";
      if (typeof jsKey !== "object")
        return String(jsKey);
      if (Node.isNode(key) && ctx && ctx.doc) {
        const strCtx = stringify.createStringifyContext(ctx.doc, {});
        strCtx.anchors = /* @__PURE__ */ new Set();
        for (const node of ctx.anchors.keys())
          strCtx.anchors.add(node.anchor);
        strCtx.inFlow = true;
        strCtx.inStringifyKey = true;
        const strKey = key.toString(strCtx);
        if (!ctx.mapKeyWarned) {
          let jsonStr = JSON.stringify(strKey);
          if (jsonStr.length > 40)
            jsonStr = jsonStr.substring(0, 36) + '..."';
          log4.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
          ctx.mapKeyWarned = true;
        }
        return strKey;
      }
      return JSON.stringify(jsKey);
    }
    exports2.addPairToJSMap = addPairToJSMap;
  }
});

// ../../node_modules/yaml/dist/nodes/Pair.js
var require_Pair = __commonJS({
  "../../node_modules/yaml/dist/nodes/Pair.js"(exports2) {
    "use strict";
    var createNode = require_createNode();
    var stringifyPair = require_stringifyPair();
    var addPairToJSMap = require_addPairToJSMap();
    var Node = require_Node();
    function createPair(key, value, ctx) {
      const k = createNode.createNode(key, void 0, ctx);
      const v = createNode.createNode(value, void 0, ctx);
      return new Pair(k, v);
    }
    var Pair = class {
      constructor(key, value = null) {
        Object.defineProperty(this, Node.NODE_TYPE, { value: Node.PAIR });
        this.key = key;
        this.value = value;
      }
      clone(schema) {
        let { key, value } = this;
        if (Node.isNode(key))
          key = key.clone(schema);
        if (Node.isNode(value))
          value = value.clone(schema);
        return new Pair(key, value);
      }
      toJSON(_45, ctx) {
        const pair = ctx && ctx.mapAsMap ? /* @__PURE__ */ new Map() : {};
        return addPairToJSMap.addPairToJSMap(ctx, pair, this);
      }
      toString(ctx, onComment, onChompKeep) {
        return ctx && ctx.doc ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
      }
    };
    exports2.Pair = Pair;
    exports2.createPair = createPair;
  }
});

// ../../node_modules/yaml/dist/options.js
var require_options = __commonJS({
  "../../node_modules/yaml/dist/options.js"(exports2) {
    "use strict";
    var defaultOptions = {
      intAsBigInt: false,
      keepSourceTokens: false,
      logLevel: "warn",
      prettyErrors: true,
      strict: true,
      uniqueKeys: true,
      version: "1.2"
    };
    exports2.defaultOptions = defaultOptions;
  }
});

// ../../node_modules/yaml/dist/stringify/stringifyCollection.js
var require_stringifyCollection = __commonJS({
  "../../node_modules/yaml/dist/stringify/stringifyCollection.js"(exports2) {
    "use strict";
    var Collection = require_Collection();
    var Node = require_Node();
    var stringify = require_stringify();
    var stringifyComment = require_stringifyComment();
    function stringifyCollection(collection, ctx, options2) {
      var _a2;
      const flow = (_a2 = ctx.inFlow) !== null && _a2 !== void 0 ? _a2 : collection.flow;
      const stringify2 = flow ? stringifyFlowCollection : stringifyBlockCollection;
      return stringify2(collection, ctx, options2);
    }
    function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
      const { indent, options: { commentString } } = ctx;
      const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
      let chompKeep = false;
      const lines = [];
      for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment2 = null;
        if (Node.isNode(item)) {
          if (!chompKeep && item.spaceBefore)
            lines.push("");
          addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
          if (item.comment)
            comment2 = item.comment;
        } else if (Node.isPair(item)) {
          const ik = Node.isNode(item.key) ? item.key : null;
          if (ik) {
            if (!chompKeep && ik.spaceBefore)
              lines.push("");
            addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
          }
        }
        chompKeep = false;
        let str2 = stringify.stringify(item, itemCtx, () => comment2 = null, () => chompKeep = true);
        if (comment2)
          str2 += stringifyComment.lineComment(str2, itemIndent, commentString(comment2));
        if (chompKeep && comment2)
          chompKeep = false;
        lines.push(blockItemPrefix + str2);
      }
      let str;
      if (lines.length === 0) {
        str = flowChars.start + flowChars.end;
      } else {
        str = lines[0];
        for (let i = 1; i < lines.length; ++i) {
          const line = lines[i];
          str += line ? `
${indent}${line}` : "\n";
        }
      }
      if (comment) {
        str += "\n" + stringifyComment.indentComment(commentString(comment), indent);
        if (onComment)
          onComment();
      } else if (chompKeep && onChompKeep)
        onChompKeep();
      return str;
    }
    function stringifyFlowCollection({ comment, items }, ctx, { flowChars, itemIndent, onComment }) {
      const { indent, indentStep, options: { commentString } } = ctx;
      itemIndent += indentStep;
      const itemCtx = Object.assign({}, ctx, {
        indent: itemIndent,
        inFlow: true,
        type: null
      });
      let reqNewline = false;
      let linesAtValue = 0;
      const lines = [];
      for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment2 = null;
        if (Node.isNode(item)) {
          if (item.spaceBefore)
            lines.push("");
          addCommentBefore(ctx, lines, item.commentBefore, false);
          if (item.comment)
            comment2 = item.comment;
        } else if (Node.isPair(item)) {
          const ik = Node.isNode(item.key) ? item.key : null;
          if (ik) {
            if (ik.spaceBefore)
              lines.push("");
            addCommentBefore(ctx, lines, ik.commentBefore, false);
            if (ik.comment)
              reqNewline = true;
          }
          const iv = Node.isNode(item.value) ? item.value : null;
          if (iv) {
            if (iv.comment)
              comment2 = iv.comment;
            if (iv.commentBefore)
              reqNewline = true;
          } else if (item.value == null && ik && ik.comment) {
            comment2 = ik.comment;
          }
        }
        if (comment2)
          reqNewline = true;
        let str2 = stringify.stringify(item, itemCtx, () => comment2 = null);
        if (i < items.length - 1)
          str2 += ",";
        if (comment2)
          str2 += stringifyComment.lineComment(str2, itemIndent, commentString(comment2));
        if (!reqNewline && (lines.length > linesAtValue || str2.includes("\n")))
          reqNewline = true;
        lines.push(str2);
        linesAtValue = lines.length;
      }
      let str;
      const { start, end } = flowChars;
      if (lines.length === 0) {
        str = start + end;
      } else {
        if (!reqNewline) {
          const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
          reqNewline = len > Collection.Collection.maxFlowStringSingleLineLength;
        }
        if (reqNewline) {
          str = start;
          for (const line of lines)
            str += line ? `
${indentStep}${indent}${line}` : "\n";
          str += `
${indent}${end}`;
        } else {
          str = `${start} ${lines.join(" ")} ${end}`;
        }
      }
      if (comment) {
        str += stringifyComment.lineComment(str, commentString(comment), indent);
        if (onComment)
          onComment();
      }
      return str;
    }
    function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
      if (comment && chompKeep)
        comment = comment.replace(/^\n+/, "");
      if (comment) {
        const ic = stringifyComment.indentComment(commentString(comment), indent);
        lines.push(ic.trimStart());
      }
    }
    exports2.stringifyCollection = stringifyCollection;
  }
});

// ../../node_modules/yaml/dist/nodes/YAMLMap.js
var require_YAMLMap = __commonJS({
  "../../node_modules/yaml/dist/nodes/YAMLMap.js"(exports2) {
    "use strict";
    var stringifyCollection = require_stringifyCollection();
    var addPairToJSMap = require_addPairToJSMap();
    var Collection = require_Collection();
    var Node = require_Node();
    var Pair = require_Pair();
    var Scalar = require_Scalar();
    function findPair(items, key) {
      const k = Node.isScalar(key) ? key.value : key;
      for (const it of items) {
        if (Node.isPair(it)) {
          if (it.key === key || it.key === k)
            return it;
          if (Node.isScalar(it.key) && it.key.value === k)
            return it;
        }
      }
      return void 0;
    }
    var YAMLMap = class extends Collection.Collection {
      constructor(schema) {
        super(Node.MAP, schema);
        this.items = [];
      }
      static get tagName() {
        return "tag:yaml.org,2002:map";
      }
      add(pair, overwrite) {
        let _pair;
        if (Node.isPair(pair))
          _pair = pair;
        else if (!pair || typeof pair !== "object" || !("key" in pair)) {
          _pair = new Pair.Pair(pair, pair.value);
        } else
          _pair = new Pair.Pair(pair.key, pair.value);
        const prev = findPair(this.items, _pair.key);
        const sortEntries = this.schema && this.schema.sortMapEntries;
        if (prev) {
          if (!overwrite)
            throw new Error(`Key ${_pair.key} already set`);
          if (Node.isScalar(prev.value) && Scalar.isScalarValue(_pair.value))
            prev.value.value = _pair.value;
          else
            prev.value = _pair.value;
        } else if (sortEntries) {
          const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
          if (i === -1)
            this.items.push(_pair);
          else
            this.items.splice(i, 0, _pair);
        } else {
          this.items.push(_pair);
        }
      }
      delete(key) {
        const it = findPair(this.items, key);
        if (!it)
          return false;
        const del = this.items.splice(this.items.indexOf(it), 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const it = findPair(this.items, key);
        const node = it && it.value;
        return !keepScalar && Node.isScalar(node) ? node.value : node;
      }
      has(key) {
        return !!findPair(this.items, key);
      }
      set(key, value) {
        this.add(new Pair.Pair(key, value), true);
      }
      toJSON(_45, ctx, Type) {
        const map = Type ? new Type() : ctx && ctx.mapAsMap ? /* @__PURE__ */ new Map() : {};
        if (ctx && ctx.onCreate)
          ctx.onCreate(map);
        for (const item of this.items)
          addPairToJSMap.addPairToJSMap(ctx, map, item);
        return map;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        for (const item of this.items) {
          if (!Node.isPair(item))
            throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        }
        if (!ctx.allNullValues && this.hasAllNullValues(false))
          ctx = Object.assign({}, ctx, { allNullValues: true });
        return stringifyCollection.stringifyCollection(this, ctx, {
          blockItemPrefix: "",
          flowChars: { start: "{", end: "}" },
          itemIndent: ctx.indent || "",
          onChompKeep,
          onComment
        });
      }
    };
    exports2.YAMLMap = YAMLMap;
    exports2.findPair = findPair;
  }
});

// ../../node_modules/yaml/dist/schema/common/map.js
var require_map = __commonJS({
  "../../node_modules/yaml/dist/schema/common/map.js"(exports2) {
    "use strict";
    var Node = require_Node();
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    function createMap(schema, obj, ctx) {
      const { keepUndefined, replacer } = ctx;
      const map2 = new YAMLMap.YAMLMap(schema);
      const add = (key, value) => {
        if (typeof replacer === "function")
          value = replacer.call(obj, key, value);
        else if (Array.isArray(replacer) && !replacer.includes(key))
          return;
        if (value !== void 0 || keepUndefined)
          map2.items.push(Pair.createPair(key, value, ctx));
      };
      if (obj instanceof Map) {
        for (const [key, value] of obj)
          add(key, value);
      } else if (obj && typeof obj === "object") {
        for (const key of Object.keys(obj))
          add(key, obj[key]);
      }
      if (typeof schema.sortMapEntries === "function") {
        map2.items.sort(schema.sortMapEntries);
      }
      return map2;
    }
    var map = {
      collection: "map",
      createNode: createMap,
      default: true,
      nodeClass: YAMLMap.YAMLMap,
      tag: "tag:yaml.org,2002:map",
      resolve(map2, onError) {
        if (!Node.isMap(map2))
          onError("Expected a mapping for this tag");
        return map2;
      }
    };
    exports2.map = map;
  }
});

// ../../node_modules/yaml/dist/nodes/YAMLSeq.js
var require_YAMLSeq = __commonJS({
  "../../node_modules/yaml/dist/nodes/YAMLSeq.js"(exports2) {
    "use strict";
    var stringifyCollection = require_stringifyCollection();
    var Collection = require_Collection();
    var Node = require_Node();
    var Scalar = require_Scalar();
    var toJS = require_toJS();
    var YAMLSeq = class extends Collection.Collection {
      constructor(schema) {
        super(Node.SEQ, schema);
        this.items = [];
      }
      static get tagName() {
        return "tag:yaml.org,2002:seq";
      }
      add(value) {
        this.items.push(value);
      }
      delete(key) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return false;
        const del = this.items.splice(idx, 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return void 0;
        const it = this.items[idx];
        return !keepScalar && Node.isScalar(it) ? it.value : it;
      }
      has(key) {
        const idx = asItemIndex(key);
        return typeof idx === "number" && idx < this.items.length;
      }
      set(key, value) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          throw new Error(`Expected a valid index, not ${key}.`);
        const prev = this.items[idx];
        if (Node.isScalar(prev) && Scalar.isScalarValue(value))
          prev.value = value;
        else
          this.items[idx] = value;
      }
      toJSON(_45, ctx) {
        const seq = [];
        if (ctx && ctx.onCreate)
          ctx.onCreate(seq);
        let i = 0;
        for (const item of this.items)
          seq.push(toJS.toJS(item, String(i++), ctx));
        return seq;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        return stringifyCollection.stringifyCollection(this, ctx, {
          blockItemPrefix: "- ",
          flowChars: { start: "[", end: "]" },
          itemIndent: (ctx.indent || "") + "  ",
          onChompKeep,
          onComment
        });
      }
    };
    function asItemIndex(key) {
      let idx = Node.isScalar(key) ? key.value : key;
      if (idx && typeof idx === "string")
        idx = Number(idx);
      return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
    }
    exports2.YAMLSeq = YAMLSeq;
  }
});

// ../../node_modules/yaml/dist/schema/common/seq.js
var require_seq = __commonJS({
  "../../node_modules/yaml/dist/schema/common/seq.js"(exports2) {
    "use strict";
    var createNode = require_createNode();
    var Node = require_Node();
    var YAMLSeq = require_YAMLSeq();
    function createSeq(schema, obj, ctx) {
      const { replacer } = ctx;
      const seq2 = new YAMLSeq.YAMLSeq(schema);
      if (obj && Symbol.iterator in Object(obj)) {
        let i = 0;
        for (let it of obj) {
          if (typeof replacer === "function") {
            const key = obj instanceof Set ? it : String(i++);
            it = replacer.call(obj, key, it);
          }
          seq2.items.push(createNode.createNode(it, void 0, ctx));
        }
      }
      return seq2;
    }
    var seq = {
      collection: "seq",
      createNode: createSeq,
      default: true,
      nodeClass: YAMLSeq.YAMLSeq,
      tag: "tag:yaml.org,2002:seq",
      resolve(seq2, onError) {
        if (!Node.isSeq(seq2))
          onError("Expected a sequence for this tag");
        return seq2;
      }
    };
    exports2.seq = seq;
  }
});

// ../../node_modules/yaml/dist/schema/common/string.js
var require_string = __commonJS({
  "../../node_modules/yaml/dist/schema/common/string.js"(exports2) {
    "use strict";
    var stringifyString = require_stringifyString();
    var string = {
      identify: (value) => typeof value === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: (str) => str,
      stringify(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({ actualString: true }, ctx);
        return stringifyString.stringifyString(item, ctx, onComment, onChompKeep);
      }
    };
    exports2.string = string;
  }
});

// ../../node_modules/yaml/dist/schema/common/null.js
var require_null = __commonJS({
  "../../node_modules/yaml/dist/schema/common/null.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var nullTag = {
      identify: (value) => value == null,
      createNode: () => new Scalar.Scalar(null),
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: () => new Scalar.Scalar(null),
      stringify: ({ source }, ctx) => source && nullTag.test.test(source) ? source : ctx.options.nullStr
    };
    exports2.nullTag = nullTag;
  }
});

// ../../node_modules/yaml/dist/schema/core/bool.js
var require_bool = __commonJS({
  "../../node_modules/yaml/dist/schema/core/bool.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var boolTag = {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
      resolve: (str) => new Scalar.Scalar(str[0] === "t" || str[0] === "T"),
      stringify({ source, value }, ctx) {
        if (source && boolTag.test.test(source)) {
          const sv = source[0] === "t" || source[0] === "T";
          if (value === sv)
            return source;
        }
        return value ? ctx.options.trueStr : ctx.options.falseStr;
      }
    };
    exports2.boolTag = boolTag;
  }
});

// ../../node_modules/yaml/dist/stringify/stringifyNumber.js
var require_stringifyNumber = __commonJS({
  "../../node_modules/yaml/dist/stringify/stringifyNumber.js"(exports2) {
    "use strict";
    function stringifyNumber({ format: format2, minFractionDigits, tag, value }) {
      if (typeof value === "bigint")
        return String(value);
      const num = typeof value === "number" ? value : Number(value);
      if (!isFinite(num))
        return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
      let n = JSON.stringify(value);
      if (!format2 && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
        let i = n.indexOf(".");
        if (i < 0) {
          i = n.length;
          n += ".";
        }
        let d = minFractionDigits - (n.length - i - 1);
        while (d-- > 0)
          n += "0";
      }
      return n;
    }
    exports2.stringifyNumber = stringifyNumber;
  }
});

// ../../node_modules/yaml/dist/schema/core/float.js
var require_float = __commonJS({
  "../../node_modules/yaml/dist/schema/core/float.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var stringifyNumber = require_stringifyNumber();
    var floatNaN = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN))$/,
      resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber.stringifyNumber
    };
    var floatExp = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
      resolve: (str) => parseFloat(str),
      stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
      }
    };
    var float = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
      resolve(str) {
        const node = new Scalar.Scalar(parseFloat(str));
        const dot = str.indexOf(".");
        if (dot !== -1 && str[str.length - 1] === "0")
          node.minFractionDigits = str.length - dot - 1;
        return node;
      },
      stringify: stringifyNumber.stringifyNumber
    };
    exports2.float = float;
    exports2.floatExp = floatExp;
    exports2.floatNaN = floatNaN;
  }
});

// ../../node_modules/yaml/dist/schema/core/int.js
var require_int = __commonJS({
  "../../node_modules/yaml/dist/schema/core/int.js"(exports2) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
    var intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
    function intStringify(node, radix, prefix) {
      const { value } = node;
      if (intIdentify(value) && value >= 0)
        return prefix + value.toString(radix);
      return stringifyNumber.stringifyNumber(node);
    }
    var intOct = {
      identify: (value) => intIdentify(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^0o[0-7]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
      stringify: (node) => intStringify(node, 8, "0o")
    };
    var int = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
      stringify: stringifyNumber.stringifyNumber
    };
    var intHex = {
      identify: (value) => intIdentify(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^0x[0-9a-fA-F]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
      stringify: (node) => intStringify(node, 16, "0x")
    };
    exports2.int = int;
    exports2.intHex = intHex;
    exports2.intOct = intOct;
  }
});

// ../../node_modules/yaml/dist/schema/core/schema.js
var require_schema = __commonJS({
  "../../node_modules/yaml/dist/schema/core/schema.js"(exports2) {
    "use strict";
    var map = require_map();
    var _null = require_null();
    var seq = require_seq();
    var string = require_string();
    var bool = require_bool();
    var float = require_float();
    var int = require_int();
    var schema = [
      map.map,
      seq.seq,
      string.string,
      _null.nullTag,
      bool.boolTag,
      int.intOct,
      int.int,
      int.intHex,
      float.floatNaN,
      float.floatExp,
      float.float
    ];
    exports2.schema = schema;
  }
});

// ../../node_modules/yaml/dist/schema/json/schema.js
var require_schema2 = __commonJS({
  "../../node_modules/yaml/dist/schema/json/schema.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var map = require_map();
    var seq = require_seq();
    function intIdentify(value) {
      return typeof value === "bigint" || Number.isInteger(value);
    }
    var stringifyJSON = ({ value }) => JSON.stringify(value);
    var jsonScalars = [
      {
        identify: (value) => typeof value === "string",
        default: true,
        tag: "tag:yaml.org,2002:str",
        resolve: (str) => str,
        stringify: stringifyJSON
      },
      {
        identify: (value) => value == null,
        createNode: () => new Scalar.Scalar(null),
        default: true,
        tag: "tag:yaml.org,2002:null",
        test: /^null$/,
        resolve: () => null,
        stringify: stringifyJSON
      },
      {
        identify: (value) => typeof value === "boolean",
        default: true,
        tag: "tag:yaml.org,2002:bool",
        test: /^true|false$/,
        resolve: (str) => str === "true",
        stringify: stringifyJSON
      },
      {
        identify: intIdentify,
        default: true,
        tag: "tag:yaml.org,2002:int",
        test: /^-?(?:0|[1-9][0-9]*)$/,
        resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
        stringify: ({ value }) => intIdentify(value) ? value.toString() : JSON.stringify(value)
      },
      {
        identify: (value) => typeof value === "number",
        default: true,
        tag: "tag:yaml.org,2002:float",
        test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
        resolve: (str) => parseFloat(str),
        stringify: stringifyJSON
      }
    ];
    var jsonError = {
      default: true,
      tag: "",
      test: /^/,
      resolve(str, onError) {
        onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
        return str;
      }
    };
    var schema = [map.map, seq.seq].concat(jsonScalars, jsonError);
    exports2.schema = schema;
  }
});

// ../../node_modules/yaml/dist/schema/yaml-1.1/binary.js
var require_binary = __commonJS({
  "../../node_modules/yaml/dist/schema/yaml-1.1/binary.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var stringifyString = require_stringifyString();
    var binary = {
      identify: (value) => value instanceof Uint8Array,
      default: false,
      tag: "tag:yaml.org,2002:binary",
      resolve(src, onError) {
        if (typeof Buffer === "function") {
          return Buffer.from(src, "base64");
        } else if (typeof atob === "function") {
          const str = atob(src.replace(/[\n\r]/g, ""));
          const buffer = new Uint8Array(str.length);
          for (let i = 0; i < str.length; ++i)
            buffer[i] = str.charCodeAt(i);
          return buffer;
        } else {
          onError("This environment does not support reading binary tags; either Buffer or atob is required");
          return src;
        }
      },
      stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
        const buf = value;
        let str;
        if (typeof Buffer === "function") {
          str = buf instanceof Buffer ? buf.toString("base64") : Buffer.from(buf.buffer).toString("base64");
        } else if (typeof btoa === "function") {
          let s = "";
          for (let i = 0; i < buf.length; ++i)
            s += String.fromCharCode(buf[i]);
          str = btoa(s);
        } else {
          throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
        }
        if (!type)
          type = Scalar.Scalar.BLOCK_LITERAL;
        if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
          const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
          const n = Math.ceil(str.length / lineWidth);
          const lines = new Array(n);
          for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
            lines[i] = str.substr(o, lineWidth);
          }
          str = lines.join(type === Scalar.Scalar.BLOCK_LITERAL ? "\n" : " ");
        }
        return stringifyString.stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
      }
    };
    exports2.binary = binary;
  }
});

// ../../node_modules/yaml/dist/schema/yaml-1.1/pairs.js
var require_pairs = __commonJS({
  "../../node_modules/yaml/dist/schema/yaml-1.1/pairs.js"(exports2) {
    "use strict";
    var Node = require_Node();
    var Pair = require_Pair();
    var Scalar = require_Scalar();
    var YAMLSeq = require_YAMLSeq();
    function resolvePairs(seq, onError) {
      if (Node.isSeq(seq)) {
        for (let i = 0; i < seq.items.length; ++i) {
          let item = seq.items[i];
          if (Node.isPair(item))
            continue;
          else if (Node.isMap(item)) {
            if (item.items.length > 1)
              onError("Each pair must have its own sequence indicator");
            const pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));
            if (item.commentBefore)
              pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
            if (item.comment) {
              const cn = pair.value || pair.key;
              cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
            }
            item = pair;
          }
          seq.items[i] = Node.isPair(item) ? item : new Pair.Pair(item);
        }
      } else
        onError("Expected a sequence for this tag");
      return seq;
    }
    function createPairs(schema, iterable, ctx) {
      const { replacer } = ctx;
      const pairs2 = new YAMLSeq.YAMLSeq(schema);
      pairs2.tag = "tag:yaml.org,2002:pairs";
      let i = 0;
      if (iterable && Symbol.iterator in Object(iterable))
        for (let it of iterable) {
          if (typeof replacer === "function")
            it = replacer.call(iterable, String(i++), it);
          let key, value;
          if (Array.isArray(it)) {
            if (it.length === 2) {
              key = it[0];
              value = it[1];
            } else
              throw new TypeError(`Expected [key, value] tuple: ${it}`);
          } else if (it && it instanceof Object) {
            const keys = Object.keys(it);
            if (keys.length === 1) {
              key = keys[0];
              value = it[key];
            } else
              throw new TypeError(`Expected { key: value } tuple: ${it}`);
          } else {
            key = it;
          }
          pairs2.items.push(Pair.createPair(key, value, ctx));
        }
      return pairs2;
    }
    var pairs = {
      collection: "seq",
      default: false,
      tag: "tag:yaml.org,2002:pairs",
      resolve: resolvePairs,
      createNode: createPairs
    };
    exports2.createPairs = createPairs;
    exports2.pairs = pairs;
    exports2.resolvePairs = resolvePairs;
  }
});

// ../../node_modules/yaml/dist/schema/yaml-1.1/omap.js
var require_omap = __commonJS({
  "../../node_modules/yaml/dist/schema/yaml-1.1/omap.js"(exports2) {
    "use strict";
    var YAMLSeq = require_YAMLSeq();
    var toJS = require_toJS();
    var Node = require_Node();
    var YAMLMap = require_YAMLMap();
    var pairs = require_pairs();
    var YAMLOMap = class extends YAMLSeq.YAMLSeq {
      constructor() {
        super();
        this.add = YAMLMap.YAMLMap.prototype.add.bind(this);
        this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this);
        this.get = YAMLMap.YAMLMap.prototype.get.bind(this);
        this.has = YAMLMap.YAMLMap.prototype.has.bind(this);
        this.set = YAMLMap.YAMLMap.prototype.set.bind(this);
        this.tag = YAMLOMap.tag;
      }
      toJSON(_45, ctx) {
        if (!ctx)
          return super.toJSON(_45);
        const map = /* @__PURE__ */ new Map();
        if (ctx && ctx.onCreate)
          ctx.onCreate(map);
        for (const pair of this.items) {
          let key, value;
          if (Node.isPair(pair)) {
            key = toJS.toJS(pair.key, "", ctx);
            value = toJS.toJS(pair.value, key, ctx);
          } else {
            key = toJS.toJS(pair, "", ctx);
          }
          if (map.has(key))
            throw new Error("Ordered maps must not include duplicate keys");
          map.set(key, value);
        }
        return map;
      }
    };
    YAMLOMap.tag = "tag:yaml.org,2002:omap";
    var omap = {
      collection: "seq",
      identify: (value) => value instanceof Map,
      nodeClass: YAMLOMap,
      default: false,
      tag: "tag:yaml.org,2002:omap",
      resolve(seq, onError) {
        const pairs$1 = pairs.resolvePairs(seq, onError);
        const seenKeys = [];
        for (const { key } of pairs$1.items) {
          if (Node.isScalar(key)) {
            if (seenKeys.includes(key.value)) {
              onError(`Ordered maps must not include duplicate keys: ${key.value}`);
            } else {
              seenKeys.push(key.value);
            }
          }
        }
        return Object.assign(new YAMLOMap(), pairs$1);
      },
      createNode(schema, iterable, ctx) {
        const pairs$1 = pairs.createPairs(schema, iterable, ctx);
        const omap2 = new YAMLOMap();
        omap2.items = pairs$1.items;
        return omap2;
      }
    };
    exports2.YAMLOMap = YAMLOMap;
    exports2.omap = omap;
  }
});

// ../../node_modules/yaml/dist/schema/yaml-1.1/bool.js
var require_bool2 = __commonJS({
  "../../node_modules/yaml/dist/schema/yaml-1.1/bool.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    function boolStringify({ value, source }, ctx) {
      const boolObj = value ? trueTag : falseTag;
      if (source && boolObj.test.test(source))
        return source;
      return value ? ctx.options.trueStr : ctx.options.falseStr;
    }
    var trueTag = {
      identify: (value) => value === true,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
      resolve: () => new Scalar.Scalar(true),
      stringify: boolStringify
    };
    var falseTag = {
      identify: (value) => value === false,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
      resolve: () => new Scalar.Scalar(false),
      stringify: boolStringify
    };
    exports2.falseTag = falseTag;
    exports2.trueTag = trueTag;
  }
});

// ../../node_modules/yaml/dist/schema/yaml-1.1/float.js
var require_float2 = __commonJS({
  "../../node_modules/yaml/dist/schema/yaml-1.1/float.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var stringifyNumber = require_stringifyNumber();
    var floatNaN = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN)$/,
      resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber.stringifyNumber
    };
    var floatExp = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
      resolve: (str) => parseFloat(str.replace(/_/g, "")),
      stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
      }
    };
    var float = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
      resolve(str) {
        const node = new Scalar.Scalar(parseFloat(str.replace(/_/g, "")));
        const dot = str.indexOf(".");
        if (dot !== -1) {
          const f = str.substring(dot + 1).replace(/_/g, "");
          if (f[f.length - 1] === "0")
            node.minFractionDigits = f.length;
        }
        return node;
      },
      stringify: stringifyNumber.stringifyNumber
    };
    exports2.float = float;
    exports2.floatExp = floatExp;
    exports2.floatNaN = floatNaN;
  }
});

// ../../node_modules/yaml/dist/schema/yaml-1.1/int.js
var require_int2 = __commonJS({
  "../../node_modules/yaml/dist/schema/yaml-1.1/int.js"(exports2) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
    function intResolve(str, offset, radix, { intAsBigInt }) {
      const sign = str[0];
      if (sign === "-" || sign === "+")
        offset += 1;
      str = str.substring(offset).replace(/_/g, "");
      if (intAsBigInt) {
        switch (radix) {
          case 2:
            str = `0b${str}`;
            break;
          case 8:
            str = `0o${str}`;
            break;
          case 16:
            str = `0x${str}`;
            break;
        }
        const n2 = BigInt(str);
        return sign === "-" ? BigInt(-1) * n2 : n2;
      }
      const n = parseInt(str, radix);
      return sign === "-" ? -1 * n : n;
    }
    function intStringify(node, radix, prefix) {
      const { value } = node;
      if (intIdentify(value)) {
        const str = value.toString(radix);
        return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
      }
      return stringifyNumber.stringifyNumber(node);
    }
    var intBin = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "BIN",
      test: /^[-+]?0b[0-1_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
      stringify: (node) => intStringify(node, 2, "0b")
    };
    var intOct = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^[-+]?0[0-7_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
      stringify: (node) => intStringify(node, 8, "0")
    };
    var int = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9][0-9_]*$/,
      resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
      stringify: stringifyNumber.stringifyNumber
    };
    var intHex = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^[-+]?0x[0-9a-fA-F_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
      stringify: (node) => intStringify(node, 16, "0x")
    };
    exports2.int = int;
    exports2.intBin = intBin;
    exports2.intHex = intHex;
    exports2.intOct = intOct;
  }
});

// ../../node_modules/yaml/dist/schema/yaml-1.1/set.js
var require_set = __commonJS({
  "../../node_modules/yaml/dist/schema/yaml-1.1/set.js"(exports2) {
    "use strict";
    var Node = require_Node();
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    var YAMLSet = class extends YAMLMap.YAMLMap {
      constructor(schema) {
        super(schema);
        this.tag = YAMLSet.tag;
      }
      add(key) {
        let pair;
        if (Node.isPair(key))
          pair = key;
        else if (typeof key === "object" && "key" in key && "value" in key && key.value === null)
          pair = new Pair.Pair(key.key, null);
        else
          pair = new Pair.Pair(key, null);
        const prev = YAMLMap.findPair(this.items, pair.key);
        if (!prev)
          this.items.push(pair);
      }
      get(key, keepPair) {
        const pair = YAMLMap.findPair(this.items, key);
        return !keepPair && Node.isPair(pair) ? Node.isScalar(pair.key) ? pair.key.value : pair.key : pair;
      }
      set(key, value) {
        if (typeof value !== "boolean")
          throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
        const prev = YAMLMap.findPair(this.items, key);
        if (prev && !value) {
          this.items.splice(this.items.indexOf(prev), 1);
        } else if (!prev && value) {
          this.items.push(new Pair.Pair(key));
        }
      }
      toJSON(_45, ctx) {
        return super.toJSON(_45, ctx, Set);
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        if (this.hasAllNullValues(true))
          return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
        else
          throw new Error("Set items must all have null values");
      }
    };
    YAMLSet.tag = "tag:yaml.org,2002:set";
    var set = {
      collection: "map",
      identify: (value) => value instanceof Set,
      nodeClass: YAMLSet,
      default: false,
      tag: "tag:yaml.org,2002:set",
      resolve(map, onError) {
        if (Node.isMap(map)) {
          if (map.hasAllNullValues(true))
            return Object.assign(new YAMLSet(), map);
          else
            onError("Set items must all have null values");
        } else
          onError("Expected a mapping for this tag");
        return map;
      },
      createNode(schema, iterable, ctx) {
        const { replacer } = ctx;
        const set2 = new YAMLSet(schema);
        if (iterable && Symbol.iterator in Object(iterable))
          for (let value of iterable) {
            if (typeof replacer === "function")
              value = replacer.call(iterable, value, value);
            set2.items.push(Pair.createPair(value, null, ctx));
          }
        return set2;
      }
    };
    exports2.YAMLSet = YAMLSet;
    exports2.set = set;
  }
});

// ../../node_modules/yaml/dist/schema/yaml-1.1/timestamp.js
var require_timestamp = __commonJS({
  "../../node_modules/yaml/dist/schema/yaml-1.1/timestamp.js"(exports2) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    function parseSexagesimal(str, asBigInt) {
      const sign = str[0];
      const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
      const num = (n) => asBigInt ? BigInt(n) : Number(n);
      const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
      return sign === "-" ? num(-1) * res : res;
    }
    function stringifySexagesimal(node) {
      let { value } = node;
      let num = (n) => n;
      if (typeof value === "bigint")
        num = (n) => BigInt(n);
      else if (isNaN(value) || !isFinite(value))
        return stringifyNumber.stringifyNumber(node);
      let sign = "";
      if (value < 0) {
        sign = "-";
        value *= num(-1);
      }
      const _60 = num(60);
      const parts = [value % _60];
      if (value < 60) {
        parts.unshift(0);
      } else {
        value = (value - parts[0]) / _60;
        parts.unshift(value % _60);
        if (value >= 60) {
          value = (value - parts[0]) / _60;
          parts.unshift(value);
        }
      }
      return sign + parts.map((n) => n < 10 ? "0" + String(n) : String(n)).join(":").replace(/000000\d*$/, "");
    }
    var intTime = {
      identify: (value) => typeof value === "bigint" || Number.isInteger(value),
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
      resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
      stringify: stringifySexagesimal
    };
    var floatTime = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
      resolve: (str) => parseSexagesimal(str, false),
      stringify: stringifySexagesimal
    };
    var timestamp = {
      identify: (value) => value instanceof Date,
      default: true,
      tag: "tag:yaml.org,2002:timestamp",
      test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
      resolve(str) {
        const match = str.match(timestamp.test);
        if (!match)
          throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
        const [, year, month, day, hour, minute, second] = match.map(Number);
        const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
        const tz = match[8];
        if (tz && tz !== "Z") {
          let d = parseSexagesimal(tz, false);
          if (Math.abs(d) < 30)
            d *= 60;
          date -= 6e4 * d;
        }
        return new Date(date);
      },
      stringify: ({ value }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
    };
    exports2.floatTime = floatTime;
    exports2.intTime = intTime;
    exports2.timestamp = timestamp;
  }
});

// ../../node_modules/yaml/dist/schema/yaml-1.1/schema.js
var require_schema3 = __commonJS({
  "../../node_modules/yaml/dist/schema/yaml-1.1/schema.js"(exports2) {
    "use strict";
    var map = require_map();
    var _null = require_null();
    var seq = require_seq();
    var string = require_string();
    var binary = require_binary();
    var bool = require_bool2();
    var float = require_float2();
    var int = require_int2();
    var omap = require_omap();
    var pairs = require_pairs();
    var set = require_set();
    var timestamp = require_timestamp();
    var schema = [
      map.map,
      seq.seq,
      string.string,
      _null.nullTag,
      bool.trueTag,
      bool.falseTag,
      int.intBin,
      int.intOct,
      int.int,
      int.intHex,
      float.floatNaN,
      float.floatExp,
      float.float,
      binary.binary,
      omap.omap,
      pairs.pairs,
      set.set,
      timestamp.intTime,
      timestamp.floatTime,
      timestamp.timestamp
    ];
    exports2.schema = schema;
  }
});

// ../../node_modules/yaml/dist/schema/tags.js
var require_tags = __commonJS({
  "../../node_modules/yaml/dist/schema/tags.js"(exports2) {
    "use strict";
    var map = require_map();
    var _null = require_null();
    var seq = require_seq();
    var string = require_string();
    var bool = require_bool();
    var float = require_float();
    var int = require_int();
    var schema = require_schema();
    var schema$1 = require_schema2();
    var binary = require_binary();
    var omap = require_omap();
    var pairs = require_pairs();
    var schema$2 = require_schema3();
    var set = require_set();
    var timestamp = require_timestamp();
    var schemas = /* @__PURE__ */ new Map([
      ["core", schema.schema],
      ["failsafe", [map.map, seq.seq, string.string]],
      ["json", schema$1.schema],
      ["yaml11", schema$2.schema],
      ["yaml-1.1", schema$2.schema]
    ]);
    var tagsByName = {
      binary: binary.binary,
      bool: bool.boolTag,
      float: float.float,
      floatExp: float.floatExp,
      floatNaN: float.floatNaN,
      floatTime: timestamp.floatTime,
      int: int.int,
      intHex: int.intHex,
      intOct: int.intOct,
      intTime: timestamp.intTime,
      map: map.map,
      null: _null.nullTag,
      omap: omap.omap,
      pairs: pairs.pairs,
      seq: seq.seq,
      set: set.set,
      timestamp: timestamp.timestamp
    };
    var coreKnownTags = {
      "tag:yaml.org,2002:binary": binary.binary,
      "tag:yaml.org,2002:omap": omap.omap,
      "tag:yaml.org,2002:pairs": pairs.pairs,
      "tag:yaml.org,2002:set": set.set,
      "tag:yaml.org,2002:timestamp": timestamp.timestamp
    };
    function getTags(customTags, schemaName) {
      let tags = schemas.get(schemaName);
      if (!tags) {
        if (Array.isArray(customTags))
          tags = [];
        else {
          const keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
          throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
        }
      }
      if (Array.isArray(customTags)) {
        for (const tag of customTags)
          tags = tags.concat(tag);
      } else if (typeof customTags === "function") {
        tags = customTags(tags.slice());
      }
      return tags.map((tag) => {
        if (typeof tag !== "string")
          return tag;
        const tagObj = tagsByName[tag];
        if (tagObj)
          return tagObj;
        const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
        throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`);
      });
    }
    exports2.coreKnownTags = coreKnownTags;
    exports2.getTags = getTags;
  }
});

// ../../node_modules/yaml/dist/schema/Schema.js
var require_Schema = __commonJS({
  "../../node_modules/yaml/dist/schema/Schema.js"(exports2) {
    "use strict";
    var Node = require_Node();
    var map = require_map();
    var seq = require_seq();
    var string = require_string();
    var tags = require_tags();
    var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
    var Schema = class {
      constructor({ compat, customTags, merge, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {
        this.compat = Array.isArray(compat) ? tags.getTags(compat, "compat") : compat ? tags.getTags(null, compat) : null;
        this.merge = !!merge;
        this.name = typeof schema === "string" && schema || "core";
        this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};
        this.tags = tags.getTags(customTags, this.name);
        this.toStringOptions = toStringDefaults || null;
        Object.defineProperty(this, Node.MAP, { value: map.map });
        Object.defineProperty(this, Node.SCALAR, { value: string.string });
        Object.defineProperty(this, Node.SEQ, { value: seq.seq });
        this.sortMapEntries = sortMapEntries === true ? sortMapEntriesByKey : sortMapEntries || null;
      }
      clone() {
        const copy3 = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
        copy3.tags = this.tags.slice();
        return copy3;
      }
    };
    exports2.Schema = Schema;
  }
});

// ../../node_modules/yaml/dist/stringify/stringifyDocument.js
var require_stringifyDocument = __commonJS({
  "../../node_modules/yaml/dist/stringify/stringifyDocument.js"(exports2) {
    "use strict";
    var Node = require_Node();
    var stringify = require_stringify();
    var stringifyComment = require_stringifyComment();
    function stringifyDocument(doc, options2) {
      const lines = [];
      let hasDirectives = options2.directives === true;
      if (options2.directives !== false && doc.directives) {
        const dir = doc.directives.toString(doc);
        if (dir) {
          lines.push(dir);
          hasDirectives = true;
        } else if (doc.directives.marker)
          hasDirectives = true;
      }
      if (hasDirectives)
        lines.push("---");
      const ctx = stringify.createStringifyContext(doc, options2);
      const { commentString } = ctx.options;
      if (doc.commentBefore) {
        if (lines.length !== 1)
          lines.unshift("");
        const cs = commentString(doc.commentBefore);
        lines.unshift(stringifyComment.indentComment(cs, ""));
      }
      let chompKeep = false;
      let contentComment = null;
      if (doc.contents) {
        if (Node.isNode(doc.contents)) {
          if (doc.contents.spaceBefore && hasDirectives)
            lines.push("");
          if (doc.contents.commentBefore) {
            const cs = commentString(doc.contents.commentBefore);
            lines.push(stringifyComment.indentComment(cs, ""));
          }
          ctx.forceBlockIndent = !!doc.comment;
          contentComment = doc.contents.comment;
        }
        const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
        let body = stringify.stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
        if (contentComment)
          body += stringifyComment.lineComment(body, "", commentString(contentComment));
        if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
          lines[lines.length - 1] = `--- ${body}`;
        } else
          lines.push(body);
      } else {
        lines.push(stringify.stringify(doc.contents, ctx));
      }
      let dc = doc.comment;
      if (dc && chompKeep)
        dc = dc.replace(/^\n+/, "");
      if (dc) {
        if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
          lines.push("");
        lines.push(stringifyComment.indentComment(commentString(dc), ""));
      }
      return lines.join("\n") + "\n";
    }
    exports2.stringifyDocument = stringifyDocument;
  }
});

// ../../node_modules/yaml/dist/doc/applyReviver.js
var require_applyReviver = __commonJS({
  "../../node_modules/yaml/dist/doc/applyReviver.js"(exports2) {
    "use strict";
    function applyReviver(reviver, obj, key, val) {
      if (val && typeof val === "object") {
        if (Array.isArray(val)) {
          for (let i = 0, len = val.length; i < len; ++i) {
            const v0 = val[i];
            const v1 = applyReviver(reviver, val, String(i), v0);
            if (v1 === void 0)
              delete val[i];
            else if (v1 !== v0)
              val[i] = v1;
          }
        } else if (val instanceof Map) {
          for (const k of Array.from(val.keys())) {
            const v0 = val.get(k);
            const v1 = applyReviver(reviver, val, k, v0);
            if (v1 === void 0)
              val.delete(k);
            else if (v1 !== v0)
              val.set(k, v1);
          }
        } else if (val instanceof Set) {
          for (const v0 of Array.from(val)) {
            const v1 = applyReviver(reviver, val, v0, v0);
            if (v1 === void 0)
              val.delete(v0);
            else if (v1 !== v0) {
              val.delete(v0);
              val.add(v1);
            }
          }
        } else {
          for (const [k, v0] of Object.entries(val)) {
            const v1 = applyReviver(reviver, val, k, v0);
            if (v1 === void 0)
              delete val[k];
            else if (v1 !== v0)
              val[k] = v1;
          }
        }
      }
      return reviver.call(obj, key, val);
    }
    exports2.applyReviver = applyReviver;
  }
});

// ../../node_modules/yaml/dist/doc/Document.js
var require_Document = __commonJS({
  "../../node_modules/yaml/dist/doc/Document.js"(exports2) {
    "use strict";
    var Alias = require_Alias();
    var Collection = require_Collection();
    var Node = require_Node();
    var Pair = require_Pair();
    var toJS = require_toJS();
    var options2 = require_options();
    var Schema = require_Schema();
    var stringify = require_stringify();
    var stringifyDocument = require_stringifyDocument();
    var anchors = require_anchors();
    var applyReviver = require_applyReviver();
    var createNode = require_createNode();
    var directives = require_directives();
    var Document = class {
      constructor(value, replacer, options$1) {
        this.commentBefore = null;
        this.comment = null;
        this.errors = [];
        this.warnings = [];
        Object.defineProperty(this, Node.NODE_TYPE, { value: Node.DOC });
        let _replacer = null;
        if (typeof replacer === "function" || Array.isArray(replacer)) {
          _replacer = replacer;
        } else if (options$1 === void 0 && replacer) {
          options$1 = replacer;
          replacer = void 0;
        }
        const opt = Object.assign({}, options2.defaultOptions, options$1);
        this.options = opt;
        let { version } = opt;
        if (options$1 === null || options$1 === void 0 ? void 0 : options$1.directives) {
          this.directives = options$1.directives.atDocument();
          if (this.directives.yaml.explicit)
            version = this.directives.yaml.version;
        } else
          this.directives = new directives.Directives({ version });
        this.setSchema(version, options$1);
        if (value === void 0)
          this.contents = null;
        else {
          this.contents = this.createNode(value, _replacer, options$1);
        }
      }
      clone() {
        const copy3 = Object.create(Document.prototype, {
          [Node.NODE_TYPE]: { value: Node.DOC }
        });
        copy3.commentBefore = this.commentBefore;
        copy3.comment = this.comment;
        copy3.errors = this.errors.slice();
        copy3.warnings = this.warnings.slice();
        copy3.options = Object.assign({}, this.options);
        if (this.directives)
          copy3.directives = this.directives.clone();
        copy3.schema = this.schema.clone();
        copy3.contents = Node.isNode(this.contents) ? this.contents.clone(copy3.schema) : this.contents;
        if (this.range)
          copy3.range = this.range.slice();
        return copy3;
      }
      add(value) {
        if (assertCollection(this.contents))
          this.contents.add(value);
      }
      addIn(path, value) {
        if (assertCollection(this.contents))
          this.contents.addIn(path, value);
      }
      createAlias(node, name) {
        if (!node.anchor) {
          const prev = anchors.anchorNames(this);
          node.anchor = !name || prev.has(name) ? anchors.findNewAnchor(name || "a", prev) : name;
        }
        return new Alias.Alias(node.anchor);
      }
      createNode(value, replacer, options3) {
        let _replacer = void 0;
        if (typeof replacer === "function") {
          value = replacer.call({ "": value }, "", value);
          _replacer = replacer;
        } else if (Array.isArray(replacer)) {
          const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
          const asStr = replacer.filter(keyToStr).map(String);
          if (asStr.length > 0)
            replacer = replacer.concat(asStr);
          _replacer = replacer;
        } else if (options3 === void 0 && replacer) {
          options3 = replacer;
          replacer = void 0;
        }
        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options3 || {};
        const { onAnchor, setAnchors, sourceObjects } = anchors.createNodeAnchors(this, anchorPrefix || "a");
        const ctx = {
          aliasDuplicateObjects: aliasDuplicateObjects !== null && aliasDuplicateObjects !== void 0 ? aliasDuplicateObjects : true,
          keepUndefined: keepUndefined !== null && keepUndefined !== void 0 ? keepUndefined : false,
          onAnchor,
          onTagObj,
          replacer: _replacer,
          schema: this.schema,
          sourceObjects
        };
        const node = createNode.createNode(value, tag, ctx);
        if (flow && Node.isCollection(node))
          node.flow = true;
        setAnchors();
        return node;
      }
      createPair(key, value, options3 = {}) {
        const k = this.createNode(key, null, options3);
        const v = this.createNode(value, null, options3);
        return new Pair.Pair(k, v);
      }
      delete(key) {
        return assertCollection(this.contents) ? this.contents.delete(key) : false;
      }
      deleteIn(path) {
        if (Collection.isEmptyPath(path)) {
          if (this.contents == null)
            return false;
          this.contents = null;
          return true;
        }
        return assertCollection(this.contents) ? this.contents.deleteIn(path) : false;
      }
      get(key, keepScalar) {
        return Node.isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
      }
      getIn(path, keepScalar) {
        if (Collection.isEmptyPath(path))
          return !keepScalar && Node.isScalar(this.contents) ? this.contents.value : this.contents;
        return Node.isCollection(this.contents) ? this.contents.getIn(path, keepScalar) : void 0;
      }
      has(key) {
        return Node.isCollection(this.contents) ? this.contents.has(key) : false;
      }
      hasIn(path) {
        if (Collection.isEmptyPath(path))
          return this.contents !== void 0;
        return Node.isCollection(this.contents) ? this.contents.hasIn(path) : false;
      }
      set(key, value) {
        if (this.contents == null) {
          this.contents = Collection.collectionFromPath(this.schema, [key], value);
        } else if (assertCollection(this.contents)) {
          this.contents.set(key, value);
        }
      }
      setIn(path, value) {
        if (Collection.isEmptyPath(path))
          this.contents = value;
        else if (this.contents == null) {
          this.contents = Collection.collectionFromPath(this.schema, Array.from(path), value);
        } else if (assertCollection(this.contents)) {
          this.contents.setIn(path, value);
        }
      }
      setSchema(version, options3 = {}) {
        if (typeof version === "number")
          version = String(version);
        let opt;
        switch (version) {
          case "1.1":
            if (this.directives)
              this.directives.yaml.version = "1.1";
            else
              this.directives = new directives.Directives({ version: "1.1" });
            opt = { merge: true, resolveKnownTags: false, schema: "yaml-1.1" };
            break;
          case "1.2":
            if (this.directives)
              this.directives.yaml.version = "1.2";
            else
              this.directives = new directives.Directives({ version: "1.2" });
            opt = { merge: false, resolveKnownTags: true, schema: "core" };
            break;
          case null:
            if (this.directives)
              delete this.directives;
            opt = null;
            break;
          default: {
            const sv = JSON.stringify(version);
            throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
          }
        }
        if (options3.schema instanceof Object)
          this.schema = options3.schema;
        else if (opt)
          this.schema = new Schema.Schema(Object.assign(opt, options3));
        else
          throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
      }
      toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        const ctx = {
          anchors: /* @__PURE__ */ new Map(),
          doc: this,
          keep: !json,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100,
          stringify: stringify.stringify
        };
        const res = toJS.toJS(this.contents, jsonArg || "", ctx);
        if (typeof onAnchor === "function")
          for (const { count, res: res2 } of ctx.anchors.values())
            onAnchor(res2, count);
        return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
      }
      toJSON(jsonArg, onAnchor) {
        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
      }
      toString(options3 = {}) {
        if (this.errors.length > 0)
          throw new Error("Document with errors cannot be stringified");
        if ("indent" in options3 && (!Number.isInteger(options3.indent) || Number(options3.indent) <= 0)) {
          const s = JSON.stringify(options3.indent);
          throw new Error(`"indent" option must be a positive integer, not ${s}`);
        }
        return stringifyDocument.stringifyDocument(this, options3);
      }
    };
    function assertCollection(contents) {
      if (Node.isCollection(contents))
        return true;
      throw new Error("Expected a YAML collection as document contents");
    }
    exports2.Document = Document;
  }
});

// ../../node_modules/yaml/dist/errors.js
var require_errors = __commonJS({
  "../../node_modules/yaml/dist/errors.js"(exports2) {
    "use strict";
    var YAMLError = class extends Error {
      constructor(name, pos, code, message) {
        super();
        this.name = name;
        this.code = code;
        this.message = message;
        this.pos = pos;
      }
    };
    var YAMLParseError = class extends YAMLError {
      constructor(pos, code, message) {
        super("YAMLParseError", pos, code, message);
      }
    };
    var YAMLWarning = class extends YAMLError {
      constructor(pos, code, message) {
        super("YAMLWarning", pos, code, message);
      }
    };
    var prettifyError = (src, lc) => (error3) => {
      if (error3.pos[0] === -1)
        return;
      error3.linePos = error3.pos.map((pos) => lc.linePos(pos));
      const { line, col } = error3.linePos[0];
      error3.message += ` at line ${line}, column ${col}`;
      let ci = col - 1;
      let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
      if (ci >= 60 && lineStr.length > 80) {
        const trimStart = Math.min(ci - 39, lineStr.length - 79);
        lineStr = "\u2026" + lineStr.substring(trimStart);
        ci -= trimStart - 1;
      }
      if (lineStr.length > 80)
        lineStr = lineStr.substring(0, 79) + "\u2026";
      if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
        let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
        if (prev.length > 80)
          prev = prev.substring(0, 79) + "\u2026\n";
        lineStr = prev + lineStr;
      }
      if (/[^ ]/.test(lineStr)) {
        let count = 1;
        const end = error3.linePos[1];
        if (end && end.line === line && end.col > col) {
          count = Math.min(end.col - col, 80 - ci);
        }
        const pointer = " ".repeat(ci) + "^".repeat(count);
        error3.message += `:

${lineStr}
${pointer}
`;
      }
    };
    exports2.YAMLError = YAMLError;
    exports2.YAMLParseError = YAMLParseError;
    exports2.YAMLWarning = YAMLWarning;
    exports2.prettifyError = prettifyError;
  }
});

// ../../node_modules/yaml/dist/compose/resolve-props.js
var require_resolve_props = __commonJS({
  "../../node_modules/yaml/dist/compose/resolve-props.js"(exports2) {
    "use strict";
    function resolveProps(tokens, { flow, indicator, next, offset, onError, startOnNewline }) {
      let spaceBefore = false;
      let atNewline = startOnNewline;
      let hasSpace = startOnNewline;
      let comment = "";
      let commentSep = "";
      let hasNewline = false;
      let reqSpace = false;
      let anchor = null;
      let tag = null;
      let comma = null;
      let found = null;
      let start = null;
      for (const token2 of tokens) {
        if (reqSpace) {
          if (token2.type !== "space" && token2.type !== "newline" && token2.type !== "comma")
            onError(token2.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
          reqSpace = false;
        }
        switch (token2.type) {
          case "space":
            if (!flow && atNewline && indicator !== "doc-start" && token2.source[0] === "	")
              onError(token2, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
            hasSpace = true;
            break;
          case "comment": {
            if (!hasSpace)
              onError(token2, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
            const cb = token2.source.substring(1) || " ";
            if (!comment)
              comment = cb;
            else
              comment += commentSep + cb;
            commentSep = "";
            atNewline = false;
            break;
          }
          case "newline":
            if (atNewline) {
              if (comment)
                comment += token2.source;
              else
                spaceBefore = true;
            } else
              commentSep += token2.source;
            atNewline = true;
            hasNewline = true;
            hasSpace = true;
            break;
          case "anchor":
            if (anchor)
              onError(token2, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
            anchor = token2;
            if (start === null)
              start = token2.offset;
            atNewline = false;
            hasSpace = false;
            reqSpace = true;
            break;
          case "tag": {
            if (tag)
              onError(token2, "MULTIPLE_TAGS", "A node can have at most one tag");
            tag = token2;
            if (start === null)
              start = token2.offset;
            atNewline = false;
            hasSpace = false;
            reqSpace = true;
            break;
          }
          case indicator:
            if (anchor || tag)
              onError(token2, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token2.source} indicator`);
            if (found)
              onError(token2, "UNEXPECTED_TOKEN", `Unexpected ${token2.source} in ${flow || "collection"}`);
            found = token2;
            atNewline = false;
            hasSpace = false;
            break;
          case "comma":
            if (flow) {
              if (comma)
                onError(token2, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
              comma = token2;
              atNewline = false;
              hasSpace = false;
              break;
            }
          default:
            onError(token2, "UNEXPECTED_TOKEN", `Unexpected ${token2.type} token`);
            atNewline = false;
            hasSpace = false;
        }
      }
      const last = tokens[tokens.length - 1];
      const end = last ? last.offset + last.source.length : offset;
      if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== ""))
        onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      return {
        comma,
        found,
        spaceBefore,
        comment,
        hasNewline,
        anchor,
        tag,
        end,
        start: start !== null && start !== void 0 ? start : end
      };
    }
    exports2.resolveProps = resolveProps;
  }
});

// ../../node_modules/yaml/dist/compose/util-contains-newline.js
var require_util_contains_newline = __commonJS({
  "../../node_modules/yaml/dist/compose/util-contains-newline.js"(exports2) {
    "use strict";
    function containsNewline(key) {
      if (!key)
        return null;
      switch (key.type) {
        case "alias":
        case "scalar":
        case "double-quoted-scalar":
        case "single-quoted-scalar":
          if (key.source.includes("\n"))
            return true;
          if (key.end) {
            for (const st of key.end)
              if (st.type === "newline")
                return true;
          }
          return false;
        case "flow-collection":
          for (const it of key.items) {
            for (const st of it.start)
              if (st.type === "newline")
                return true;
            if (it.sep) {
              for (const st of it.sep)
                if (st.type === "newline")
                  return true;
            }
            if (containsNewline(it.key) || containsNewline(it.value))
              return true;
          }
          return false;
        default:
          return true;
      }
    }
    exports2.containsNewline = containsNewline;
  }
});

// ../../node_modules/yaml/dist/compose/util-flow-indent-check.js
var require_util_flow_indent_check = __commonJS({
  "../../node_modules/yaml/dist/compose/util-flow-indent-check.js"(exports2) {
    "use strict";
    var utilContainsNewline = require_util_contains_newline();
    function flowIndentCheck(indent, fc, onError) {
      if ((fc === null || fc === void 0 ? void 0 : fc.type) === "flow-collection") {
        const end = fc.end[0];
        if (end.indent === indent && (end.source === "]" || end.source === "}") && utilContainsNewline.containsNewline(fc)) {
          const msg = "Flow end indicator should be more indented than parent";
          onError(end, "BAD_INDENT", msg, true);
        }
      }
    }
    exports2.flowIndentCheck = flowIndentCheck;
  }
});

// ../../node_modules/yaml/dist/compose/util-map-includes.js
var require_util_map_includes = __commonJS({
  "../../node_modules/yaml/dist/compose/util-map-includes.js"(exports2) {
    "use strict";
    var Node = require_Node();
    function mapIncludes(ctx, items, search) {
      const { uniqueKeys } = ctx.options;
      if (uniqueKeys === false)
        return false;
      const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || Node.isScalar(a) && Node.isScalar(b) && a.value === b.value && !(a.value === "<<" && ctx.schema.merge);
      return items.some((pair) => isEqual(pair.key, search));
    }
    exports2.mapIncludes = mapIncludes;
  }
});

// ../../node_modules/yaml/dist/compose/resolve-block-map.js
var require_resolve_block_map = __commonJS({
  "../../node_modules/yaml/dist/compose/resolve-block-map.js"(exports2) {
    "use strict";
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    var resolveProps = require_resolve_props();
    var utilContainsNewline = require_util_contains_newline();
    var utilFlowIndentCheck = require_util_flow_indent_check();
    var utilMapIncludes = require_util_map_includes();
    var startColMsg = "All mapping items must start at the same column";
    function resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError) {
      var _a2;
      const map = new YAMLMap.YAMLMap(ctx.schema);
      if (ctx.atRoot)
        ctx.atRoot = false;
      let offset = bm.offset;
      for (const collItem of bm.items) {
        const { start, key, sep, value } = collItem;
        const keyProps = resolveProps.resolveProps(start, {
          indicator: "explicit-key-ind",
          next: key || (sep === null || sep === void 0 ? void 0 : sep[0]),
          offset,
          onError,
          startOnNewline: true
        });
        const implicitKey = !keyProps.found;
        if (implicitKey) {
          if (key) {
            if (key.type === "block-seq")
              onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
            else if ("indent" in key && key.indent !== bm.indent)
              onError(offset, "BAD_INDENT", startColMsg);
          }
          if (!keyProps.anchor && !keyProps.tag && !sep) {
            if (keyProps.comment) {
              if (map.comment)
                map.comment += "\n" + keyProps.comment;
              else
                map.comment = keyProps.comment;
            }
            continue;
          }
        } else if (((_a2 = keyProps.found) === null || _a2 === void 0 ? void 0 : _a2.indent) !== bm.indent)
          onError(offset, "BAD_INDENT", startColMsg);
        if (implicitKey && utilContainsNewline.containsNewline(key))
          onError(key, "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
        const keyStart = keyProps.end;
        const keyNode = key ? composeNode(ctx, key, keyProps, onError) : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
        if (ctx.schema.compat)
          utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError);
        if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
          onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        const valueProps = resolveProps.resolveProps(sep || [], {
          indicator: "map-value-ind",
          next: value,
          offset: keyNode.range[2],
          onError,
          startOnNewline: !key || key.type === "block-scalar"
        });
        offset = valueProps.end;
        if (valueProps.found) {
          if (implicitKey) {
            if ((value === null || value === void 0 ? void 0 : value.type) === "block-map" && !valueProps.hasNewline)
              onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
            if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
              onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
          }
          const valueNode = value ? composeNode(ctx, value, valueProps, onError) : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);
          if (ctx.schema.compat)
            utilFlowIndentCheck.flowIndentCheck(bm.indent, value, onError);
          offset = valueNode.range[2];
          const pair = new Pair.Pair(keyNode, valueNode);
          if (ctx.options.keepSourceTokens)
            pair.srcToken = collItem;
          map.items.push(pair);
        } else {
          if (implicitKey)
            onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
          if (valueProps.comment) {
            if (keyNode.comment)
              keyNode.comment += "\n" + valueProps.comment;
            else
              keyNode.comment = valueProps.comment;
          }
          const pair = new Pair.Pair(keyNode);
          if (ctx.options.keepSourceTokens)
            pair.srcToken = collItem;
          map.items.push(pair);
        }
      }
      map.range = [bm.offset, offset, offset];
      return map;
    }
    exports2.resolveBlockMap = resolveBlockMap;
  }
});

// ../../node_modules/yaml/dist/compose/resolve-block-seq.js
var require_resolve_block_seq = __commonJS({
  "../../node_modules/yaml/dist/compose/resolve-block-seq.js"(exports2) {
    "use strict";
    var YAMLSeq = require_YAMLSeq();
    var resolveProps = require_resolve_props();
    var utilFlowIndentCheck = require_util_flow_indent_check();
    function resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError) {
      const seq = new YAMLSeq.YAMLSeq(ctx.schema);
      if (ctx.atRoot)
        ctx.atRoot = false;
      let offset = bs.offset;
      for (const { start, value } of bs.items) {
        const props = resolveProps.resolveProps(start, {
          indicator: "seq-item-ind",
          next: value,
          offset,
          onError,
          startOnNewline: true
        });
        offset = props.end;
        if (!props.found) {
          if (props.anchor || props.tag || value) {
            if (value && value.type === "block-seq")
              onError(offset, "BAD_INDENT", "All sequence items must start at the same column");
            else
              onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
          } else {
            if (props.comment)
              seq.comment = props.comment;
            continue;
          }
        }
        const node = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, offset, start, null, props, onError);
        if (ctx.schema.compat)
          utilFlowIndentCheck.flowIndentCheck(bs.indent, value, onError);
        offset = node.range[2];
        seq.items.push(node);
      }
      seq.range = [bs.offset, offset, offset];
      return seq;
    }
    exports2.resolveBlockSeq = resolveBlockSeq;
  }
});

// ../../node_modules/yaml/dist/compose/resolve-end.js
var require_resolve_end = __commonJS({
  "../../node_modules/yaml/dist/compose/resolve-end.js"(exports2) {
    "use strict";
    function resolveEnd(end, offset, reqSpace, onError) {
      let comment = "";
      if (end) {
        let hasSpace = false;
        let sep = "";
        for (const token2 of end) {
          const { source, type } = token2;
          switch (type) {
            case "space":
              hasSpace = true;
              break;
            case "comment": {
              if (reqSpace && !hasSpace)
                onError(token2, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
              const cb = source.substring(1) || " ";
              if (!comment)
                comment = cb;
              else
                comment += sep + cb;
              sep = "";
              break;
            }
            case "newline":
              if (comment)
                sep += source;
              hasSpace = true;
              break;
            default:
              onError(token2, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
          }
          offset += source.length;
        }
      }
      return { comment, offset };
    }
    exports2.resolveEnd = resolveEnd;
  }
});

// ../../node_modules/yaml/dist/compose/resolve-flow-collection.js
var require_resolve_flow_collection = __commonJS({
  "../../node_modules/yaml/dist/compose/resolve-flow-collection.js"(exports2) {
    "use strict";
    var Node = require_Node();
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var resolveEnd = require_resolve_end();
    var resolveProps = require_resolve_props();
    var utilContainsNewline = require_util_contains_newline();
    var utilMapIncludes = require_util_map_includes();
    var blockMsg = "Block collections are not allowed within flow collections";
    var isBlock = (token2) => token2 && (token2.type === "block-map" || token2.type === "block-seq");
    function resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError) {
      const isMap = fc.start.source === "{";
      const fcName = isMap ? "flow map" : "flow sequence";
      const coll = isMap ? new YAMLMap.YAMLMap(ctx.schema) : new YAMLSeq.YAMLSeq(ctx.schema);
      coll.flow = true;
      const atRoot = ctx.atRoot;
      if (atRoot)
        ctx.atRoot = false;
      let offset = fc.offset + fc.start.source.length;
      for (let i = 0; i < fc.items.length; ++i) {
        const collItem = fc.items[i];
        const { start, key, sep, value } = collItem;
        const props = resolveProps.resolveProps(start, {
          flow: fcName,
          indicator: "explicit-key-ind",
          next: key || (sep === null || sep === void 0 ? void 0 : sep[0]),
          offset,
          onError,
          startOnNewline: false
        });
        if (!props.found) {
          if (!props.anchor && !props.tag && !sep && !value) {
            if (i === 0 && props.comma)
              onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
            else if (i < fc.items.length - 1)
              onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
            if (props.comment) {
              if (coll.comment)
                coll.comment += "\n" + props.comment;
              else
                coll.comment = props.comment;
            }
            offset = props.end;
            continue;
          }
          if (!isMap && ctx.options.strict && utilContainsNewline.containsNewline(key))
            onError(key, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
        }
        if (i === 0) {
          if (props.comma)
            onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        } else {
          if (!props.comma)
            onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
          if (props.comment) {
            let prevItemComment = "";
            loop:
              for (const st of start) {
                switch (st.type) {
                  case "comma":
                  case "space":
                    break;
                  case "comment":
                    prevItemComment = st.source.substring(1);
                    break loop;
                  default:
                    break loop;
                }
              }
            if (prevItemComment) {
              let prev = coll.items[coll.items.length - 1];
              if (Node.isPair(prev))
                prev = prev.value || prev.key;
              if (prev.comment)
                prev.comment += "\n" + prevItemComment;
              else
                prev.comment = prevItemComment;
              props.comment = props.comment.substring(prevItemComment.length + 1);
            }
          }
        }
        if (!isMap && !sep && !props.found) {
          const valueNode = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, sep, null, props, onError);
          coll.items.push(valueNode);
          offset = valueNode.range[2];
          if (isBlock(value))
            onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
        } else {
          const keyStart = props.end;
          const keyNode = key ? composeNode(ctx, key, props, onError) : composeEmptyNode(ctx, keyStart, start, null, props, onError);
          if (isBlock(key))
            onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
          const valueProps = resolveProps.resolveProps(sep || [], {
            flow: fcName,
            indicator: "map-value-ind",
            next: value,
            offset: keyNode.range[2],
            onError,
            startOnNewline: false
          });
          if (valueProps.found) {
            if (!isMap && !props.found && ctx.options.strict) {
              if (sep)
                for (const st of sep) {
                  if (st === valueProps.found)
                    break;
                  if (st.type === "newline") {
                    onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                    break;
                  }
                }
              if (props.start < valueProps.found.offset - 1024)
                onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
            }
          } else if (value) {
            if ("source" in value && value.source && value.source[0] === ":")
              onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
            else
              onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
          }
          const valueNode = value ? composeNode(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError) : null;
          if (valueNode) {
            if (isBlock(value))
              onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
          } else if (valueProps.comment) {
            if (keyNode.comment)
              keyNode.comment += "\n" + valueProps.comment;
            else
              keyNode.comment = valueProps.comment;
          }
          const pair = new Pair.Pair(keyNode, valueNode);
          if (ctx.options.keepSourceTokens)
            pair.srcToken = collItem;
          if (isMap) {
            const map = coll;
            if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
              onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
            map.items.push(pair);
          } else {
            const map = new YAMLMap.YAMLMap(ctx.schema);
            map.flow = true;
            map.items.push(pair);
            coll.items.push(map);
          }
          offset = valueNode ? valueNode.range[2] : valueProps.end;
        }
      }
      const expectedEnd = isMap ? "}" : "]";
      const [ce, ...ee] = fc.end;
      let cePos = offset;
      if (ce && ce.source === expectedEnd)
        cePos = ce.offset + ce.source.length;
      else {
        const name = fcName[0].toUpperCase() + fcName.substring(1);
        const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
        onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
        if (ce && ce.source.length !== 1)
          ee.unshift(ce);
      }
      if (ee.length > 0) {
        const end = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError);
        if (end.comment) {
          if (coll.comment)
            coll.comment += "\n" + end.comment;
          else
            coll.comment = end.comment;
        }
        coll.range = [fc.offset, cePos, end.offset];
      } else {
        coll.range = [fc.offset, cePos, cePos];
      }
      return coll;
    }
    exports2.resolveFlowCollection = resolveFlowCollection;
  }
});

// ../../node_modules/yaml/dist/compose/compose-collection.js
var require_compose_collection = __commonJS({
  "../../node_modules/yaml/dist/compose/compose-collection.js"(exports2) {
    "use strict";
    var Node = require_Node();
    var Scalar = require_Scalar();
    var resolveBlockMap = require_resolve_block_map();
    var resolveBlockSeq = require_resolve_block_seq();
    var resolveFlowCollection = require_resolve_flow_collection();
    function composeCollection(CN, ctx, token2, tagToken, onError) {
      let coll;
      switch (token2.type) {
        case "block-map": {
          coll = resolveBlockMap.resolveBlockMap(CN, ctx, token2, onError);
          break;
        }
        case "block-seq": {
          coll = resolveBlockSeq.resolveBlockSeq(CN, ctx, token2, onError);
          break;
        }
        case "flow-collection": {
          coll = resolveFlowCollection.resolveFlowCollection(CN, ctx, token2, onError);
          break;
        }
      }
      if (!tagToken)
        return coll;
      const tagName = ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
      if (!tagName)
        return coll;
      const Coll = coll.constructor;
      if (tagName === "!" || tagName === Coll.tagName) {
        coll.tag = Coll.tagName;
        return coll;
      }
      const expType = Node.isMap(coll) ? "map" : "seq";
      let tag = ctx.schema.tags.find((t) => t.collection === expType && t.tag === tagName);
      if (!tag) {
        const kt = ctx.schema.knownTags[tagName];
        if (kt && kt.collection === expType) {
          ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
          tag = kt;
        } else {
          onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
          coll.tag = tagName;
          return coll;
        }
      }
      const res = tag.resolve(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options);
      const node = Node.isNode(res) ? res : new Scalar.Scalar(res);
      node.range = coll.range;
      node.tag = tagName;
      if (tag === null || tag === void 0 ? void 0 : tag.format)
        node.format = tag.format;
      return node;
    }
    exports2.composeCollection = composeCollection;
  }
});

// ../../node_modules/yaml/dist/compose/resolve-block-scalar.js
var require_resolve_block_scalar = __commonJS({
  "../../node_modules/yaml/dist/compose/resolve-block-scalar.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    function resolveBlockScalar(scalar, strict, onError) {
      const start = scalar.offset;
      const header = parseBlockScalarHeader(scalar, strict, onError);
      if (!header)
        return { value: "", type: null, comment: "", range: [start, start, start] };
      const type = header.mode === ">" ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL;
      const lines = scalar.source ? splitLines(scalar.source) : [];
      let chompStart = lines.length;
      for (let i = lines.length - 1; i >= 0; --i) {
        const content = lines[i][1];
        if (content === "" || content === "\r")
          chompStart = i;
        else
          break;
      }
      if (!scalar.source || chompStart === 0) {
        const value2 = header.chomp === "+" ? "\n".repeat(Math.max(0, lines.length - 1)) : "";
        let end2 = start + header.length;
        if (scalar.source)
          end2 += scalar.source.length;
        return { value: value2, type, comment: header.comment, range: [start, end2, end2] };
      }
      let trimIndent = scalar.indent + header.indent;
      let offset = scalar.offset + header.length;
      let contentStart = 0;
      for (let i = 0; i < chompStart; ++i) {
        const [indent, content] = lines[i];
        if (content === "" || content === "\r") {
          if (header.indent === 0 && indent.length > trimIndent)
            trimIndent = indent.length;
        } else {
          if (indent.length < trimIndent) {
            const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
            onError(offset + indent.length, "MISSING_CHAR", message);
          }
          if (header.indent === 0)
            trimIndent = indent.length;
          contentStart = i;
          break;
        }
        offset += indent.length + content.length + 1;
      }
      let value = "";
      let sep = "";
      let prevMoreIndented = false;
      for (let i = 0; i < contentStart; ++i)
        value += lines[i][0].slice(trimIndent) + "\n";
      for (let i = contentStart; i < chompStart; ++i) {
        let [indent, content] = lines[i];
        offset += indent.length + content.length + 1;
        const crlf = content[content.length - 1] === "\r";
        if (crlf)
          content = content.slice(0, -1);
        if (content && indent.length < trimIndent) {
          const src = header.indent ? "explicit indentation indicator" : "first line";
          const message = `Block scalar lines must not be less indented than their ${src}`;
          onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
          indent = "";
        }
        if (type === Scalar.Scalar.BLOCK_LITERAL) {
          value += sep + indent.slice(trimIndent) + content;
          sep = "\n";
        } else if (indent.length > trimIndent || content[0] === "	") {
          if (sep === " ")
            sep = "\n";
          else if (!prevMoreIndented && sep === "\n")
            sep = "\n\n";
          value += sep + indent.slice(trimIndent) + content;
          sep = "\n";
          prevMoreIndented = true;
        } else if (content === "") {
          if (sep === "\n")
            value += "\n";
          else
            sep = "\n";
        } else {
          value += sep + content;
          sep = " ";
          prevMoreIndented = false;
        }
      }
      switch (header.chomp) {
        case "-":
          break;
        case "+":
          for (let i = chompStart; i < lines.length; ++i)
            value += "\n" + lines[i][0].slice(trimIndent);
          if (value[value.length - 1] !== "\n")
            value += "\n";
          break;
        default:
          value += "\n";
      }
      const end = start + header.length + scalar.source.length;
      return { value, type, comment: header.comment, range: [start, end, end] };
    }
    function parseBlockScalarHeader({ offset, props }, strict, onError) {
      if (props[0].type !== "block-scalar-header") {
        onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
        return null;
      }
      const { source } = props[0];
      const mode = source[0];
      let indent = 0;
      let chomp = "";
      let error3 = -1;
      for (let i = 1; i < source.length; ++i) {
        const ch = source[i];
        if (!chomp && (ch === "-" || ch === "+"))
          chomp = ch;
        else {
          const n = Number(ch);
          if (!indent && n)
            indent = n;
          else if (error3 === -1)
            error3 = offset + i;
        }
      }
      if (error3 !== -1)
        onError(error3, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
      let hasSpace = false;
      let comment = "";
      let length = source.length;
      for (let i = 1; i < props.length; ++i) {
        const token2 = props[i];
        switch (token2.type) {
          case "space":
            hasSpace = true;
          case "newline":
            length += token2.source.length;
            break;
          case "comment":
            if (strict && !hasSpace) {
              const message = "Comments must be separated from other tokens by white space characters";
              onError(token2, "MISSING_CHAR", message);
            }
            length += token2.source.length;
            comment = token2.source.substring(1);
            break;
          case "error":
            onError(token2, "UNEXPECTED_TOKEN", token2.message);
            length += token2.source.length;
            break;
          default: {
            const message = `Unexpected token in block scalar header: ${token2.type}`;
            onError(token2, "UNEXPECTED_TOKEN", message);
            const ts = token2.source;
            if (ts && typeof ts === "string")
              length += ts.length;
          }
        }
      }
      return { mode, indent, chomp, comment, length };
    }
    function splitLines(source) {
      const split = source.split(/\n( *)/);
      const first = split[0];
      const m = first.match(/^( *)/);
      const line0 = m && m[1] ? [m[1], first.slice(m[1].length)] : ["", first];
      const lines = [line0];
      for (let i = 1; i < split.length; i += 2)
        lines.push([split[i], split[i + 1]]);
      return lines;
    }
    exports2.resolveBlockScalar = resolveBlockScalar;
  }
});

// ../../node_modules/yaml/dist/compose/resolve-flow-scalar.js
var require_resolve_flow_scalar = __commonJS({
  "../../node_modules/yaml/dist/compose/resolve-flow-scalar.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var resolveEnd = require_resolve_end();
    function resolveFlowScalar(scalar, strict, onError) {
      const { offset, type, source, end } = scalar;
      let _type;
      let value;
      const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
      switch (type) {
        case "scalar":
          _type = Scalar.Scalar.PLAIN;
          value = plainValue(source, _onError);
          break;
        case "single-quoted-scalar":
          _type = Scalar.Scalar.QUOTE_SINGLE;
          value = singleQuotedValue(source, _onError);
          break;
        case "double-quoted-scalar":
          _type = Scalar.Scalar.QUOTE_DOUBLE;
          value = doubleQuotedValue(source, _onError);
          break;
        default:
          onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
          return {
            value: "",
            type: null,
            comment: "",
            range: [offset, offset + source.length, offset + source.length]
          };
      }
      const valueEnd = offset + source.length;
      const re = resolveEnd.resolveEnd(end, valueEnd, strict, onError);
      return {
        value,
        type: _type,
        comment: re.comment,
        range: [offset, valueEnd, re.offset]
      };
    }
    function plainValue(source, onError) {
      let badChar = "";
      switch (source[0]) {
        case "	":
          badChar = "a tab character";
          break;
        case ",":
          badChar = "flow indicator character ,";
          break;
        case "%":
          badChar = "directive indicator character %";
          break;
        case "|":
        case ">": {
          badChar = `block scalar indicator ${source[0]}`;
          break;
        }
        case "@":
        case "`": {
          badChar = `reserved character ${source[0]}`;
          break;
        }
      }
      if (badChar)
        onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
      return foldLines(source);
    }
    function singleQuotedValue(source, onError) {
      if (source[source.length - 1] !== "'" || source.length === 1)
        onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
      return foldLines(source.slice(1, -1)).replace(/''/g, "'");
    }
    function foldLines(source) {
      let first, line;
      try {
        first = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
        line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
      } catch (_45) {
        first = /(.*?)[ \t]*\r?\n/sy;
        line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
      }
      let match = first.exec(source);
      if (!match)
        return source;
      let res = match[1];
      let sep = " ";
      let pos = first.lastIndex;
      line.lastIndex = pos;
      while (match = line.exec(source)) {
        if (match[1] === "") {
          if (sep === "\n")
            res += sep;
          else
            sep = "\n";
        } else {
          res += sep + match[1];
          sep = " ";
        }
        pos = line.lastIndex;
      }
      const last = /[ \t]*(.*)/sy;
      last.lastIndex = pos;
      match = last.exec(source);
      return res + sep + (match && match[1] || "");
    }
    function doubleQuotedValue(source, onError) {
      let res = "";
      for (let i = 1; i < source.length - 1; ++i) {
        const ch = source[i];
        if (ch === "\r" && source[i + 1] === "\n")
          continue;
        if (ch === "\n") {
          const { fold, offset } = foldNewline(source, i);
          res += fold;
          i = offset;
        } else if (ch === "\\") {
          let next = source[++i];
          const cc = escapeCodes[next];
          if (cc)
            res += cc;
          else if (next === "\n") {
            next = source[i + 1];
            while (next === " " || next === "	")
              next = source[++i + 1];
          } else if (next === "\r" && source[i + 1] === "\n") {
            next = source[++i + 1];
            while (next === " " || next === "	")
              next = source[++i + 1];
          } else if (next === "x" || next === "u" || next === "U") {
            const length = { x: 2, u: 4, U: 8 }[next];
            res += parseCharCode(source, i + 1, length, onError);
            i += length;
          } else {
            const raw = source.substr(i - 1, 2);
            onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
            res += raw;
          }
        } else if (ch === " " || ch === "	") {
          const wsStart = i;
          let next = source[i + 1];
          while (next === " " || next === "	")
            next = source[++i + 1];
          if (next !== "\n" && !(next === "\r" && source[i + 2] === "\n"))
            res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
        } else {
          res += ch;
        }
      }
      if (source[source.length - 1] !== '"' || source.length === 1)
        onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
      return res;
    }
    function foldNewline(source, offset) {
      let fold = "";
      let ch = source[offset + 1];
      while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
        if (ch === "\r" && source[offset + 2] !== "\n")
          break;
        if (ch === "\n")
          fold += "\n";
        offset += 1;
        ch = source[offset + 1];
      }
      if (!fold)
        fold = " ";
      return { fold, offset };
    }
    var escapeCodes = {
      "0": "\0",
      a: "\x07",
      b: "\b",
      e: "\x1B",
      f: "\f",
      n: "\n",
      r: "\r",
      t: "	",
      v: "\v",
      N: "\x85",
      _: "\xA0",
      L: "\u2028",
      P: "\u2029",
      " ": " ",
      '"': '"',
      "/": "/",
      "\\": "\\",
      "	": "	"
    };
    function parseCharCode(source, offset, length, onError) {
      const cc = source.substr(offset, length);
      const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
      const code = ok ? parseInt(cc, 16) : NaN;
      if (isNaN(code)) {
        const raw = source.substr(offset - 2, length + 2);
        onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        return raw;
      }
      return String.fromCodePoint(code);
    }
    exports2.resolveFlowScalar = resolveFlowScalar;
  }
});

// ../../node_modules/yaml/dist/compose/compose-scalar.js
var require_compose_scalar = __commonJS({
  "../../node_modules/yaml/dist/compose/compose-scalar.js"(exports2) {
    "use strict";
    var Node = require_Node();
    var Scalar = require_Scalar();
    var resolveBlockScalar = require_resolve_block_scalar();
    var resolveFlowScalar = require_resolve_flow_scalar();
    function composeScalar(ctx, token2, tagToken, onError) {
      const { value, type, comment, range } = token2.type === "block-scalar" ? resolveBlockScalar.resolveBlockScalar(token2, ctx.options.strict, onError) : resolveFlowScalar.resolveFlowScalar(token2, ctx.options.strict, onError);
      const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
      const tag = tagToken && tagName ? findScalarTagByName(ctx.schema, value, tagName, tagToken, onError) : token2.type === "scalar" ? findScalarTagByTest(ctx, value, token2, onError) : ctx.schema[Node.SCALAR];
      let scalar;
      try {
        const res = tag.resolve(value, (msg) => onError(tagToken || token2, "TAG_RESOLVE_FAILED", msg), ctx.options);
        scalar = Node.isScalar(res) ? res : new Scalar.Scalar(res);
      } catch (error3) {
        const msg = error3 instanceof Error ? error3.message : String(error3);
        onError(tagToken || token2, "TAG_RESOLVE_FAILED", msg);
        scalar = new Scalar.Scalar(value);
      }
      scalar.range = range;
      scalar.source = value;
      if (type)
        scalar.type = type;
      if (tagName)
        scalar.tag = tagName;
      if (tag.format)
        scalar.format = tag.format;
      if (comment)
        scalar.comment = comment;
      return scalar;
    }
    function findScalarTagByName(schema, value, tagName, tagToken, onError) {
      var _a2;
      if (tagName === "!")
        return schema[Node.SCALAR];
      const matchWithTest = [];
      for (const tag of schema.tags) {
        if (!tag.collection && tag.tag === tagName) {
          if (tag.default && tag.test)
            matchWithTest.push(tag);
          else
            return tag;
        }
      }
      for (const tag of matchWithTest)
        if ((_a2 = tag.test) === null || _a2 === void 0 ? void 0 : _a2.test(value))
          return tag;
      const kt = schema.knownTags[tagName];
      if (kt && !kt.collection) {
        schema.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
        return kt;
      }
      onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
      return schema[Node.SCALAR];
    }
    function findScalarTagByTest({ directives, schema }, value, token2, onError) {
      const tag = schema.tags.find((tag2) => {
        var _a2;
        return tag2.default && ((_a2 = tag2.test) === null || _a2 === void 0 ? void 0 : _a2.test(value));
      }) || schema[Node.SCALAR];
      if (schema.compat) {
        const compat = schema.compat.find((tag2) => {
          var _a2;
          return tag2.default && ((_a2 = tag2.test) === null || _a2 === void 0 ? void 0 : _a2.test(value));
        }) || schema[Node.SCALAR];
        if (tag.tag !== compat.tag) {
          const ts = directives.tagString(tag.tag);
          const cs = directives.tagString(compat.tag);
          const msg = `Value may be parsed as either ${ts} or ${cs}`;
          onError(token2, "TAG_RESOLVE_FAILED", msg, true);
        }
      }
      return tag;
    }
    exports2.composeScalar = composeScalar;
  }
});

// ../../node_modules/yaml/dist/compose/util-empty-scalar-position.js
var require_util_empty_scalar_position = __commonJS({
  "../../node_modules/yaml/dist/compose/util-empty-scalar-position.js"(exports2) {
    "use strict";
    function emptyScalarPosition(offset, before, pos) {
      if (before) {
        if (pos === null)
          pos = before.length;
        for (let i = pos - 1; i >= 0; --i) {
          let st = before[i];
          switch (st.type) {
            case "space":
            case "comment":
            case "newline":
              offset -= st.source.length;
              continue;
          }
          st = before[++i];
          while ((st === null || st === void 0 ? void 0 : st.type) === "space") {
            offset += st.source.length;
            st = before[++i];
          }
          break;
        }
      }
      return offset;
    }
    exports2.emptyScalarPosition = emptyScalarPosition;
  }
});

// ../../node_modules/yaml/dist/compose/compose-node.js
var require_compose_node = __commonJS({
  "../../node_modules/yaml/dist/compose/compose-node.js"(exports2) {
    "use strict";
    var Alias = require_Alias();
    var composeCollection = require_compose_collection();
    var composeScalar = require_compose_scalar();
    var resolveEnd = require_resolve_end();
    var utilEmptyScalarPosition = require_util_empty_scalar_position();
    var CN = { composeNode, composeEmptyNode };
    function composeNode(ctx, token2, props, onError) {
      const { spaceBefore, comment, anchor, tag } = props;
      let node;
      switch (token2.type) {
        case "alias":
          node = composeAlias(ctx, token2, onError);
          if (anchor || tag)
            onError(token2, "ALIAS_PROPS", "An alias node must not specify any properties");
          break;
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
        case "block-scalar":
          node = composeScalar.composeScalar(ctx, token2, tag, onError);
          if (anchor)
            node.anchor = anchor.source.substring(1);
          break;
        case "block-map":
        case "block-seq":
        case "flow-collection":
          node = composeCollection.composeCollection(CN, ctx, token2, tag, onError);
          if (anchor)
            node.anchor = anchor.source.substring(1);
          break;
        default:
          console.log(token2);
          throw new Error(`Unsupporten token type: ${token2.type}`);
      }
      if (anchor && node.anchor === "")
        onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
      if (spaceBefore)
        node.spaceBefore = true;
      if (comment) {
        if (token2.type === "scalar" && token2.source === "")
          node.comment = comment;
        else
          node.commentBefore = comment;
      }
      if (ctx.options.keepSourceTokens)
        node.srcToken = token2;
      return node;
    }
    function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag }, onError) {
      const token2 = {
        type: "scalar",
        offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),
        indent: -1,
        source: ""
      };
      const node = composeScalar.composeScalar(ctx, token2, tag, onError);
      if (anchor) {
        node.anchor = anchor.source.substring(1);
        if (node.anchor === "")
          onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
      }
      if (spaceBefore)
        node.spaceBefore = true;
      if (comment)
        node.comment = comment;
      return node;
    }
    function composeAlias({ options: options2 }, { offset, source, end }, onError) {
      const alias = new Alias.Alias(source.substring(1));
      if (alias.source === "")
        onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
      const valueEnd = offset + source.length;
      const re = resolveEnd.resolveEnd(end, valueEnd, options2.strict, onError);
      alias.range = [offset, valueEnd, re.offset];
      if (re.comment)
        alias.comment = re.comment;
      return alias;
    }
    exports2.composeEmptyNode = composeEmptyNode;
    exports2.composeNode = composeNode;
  }
});

// ../../node_modules/yaml/dist/compose/compose-doc.js
var require_compose_doc = __commonJS({
  "../../node_modules/yaml/dist/compose/compose-doc.js"(exports2) {
    "use strict";
    var Document = require_Document();
    var composeNode = require_compose_node();
    var resolveEnd = require_resolve_end();
    var resolveProps = require_resolve_props();
    function composeDoc(options2, directives, { offset, start, value, end }, onError) {
      const opts = Object.assign({ directives }, options2);
      const doc = new Document.Document(void 0, opts);
      const ctx = {
        atRoot: true,
        directives: doc.directives,
        options: doc.options,
        schema: doc.schema
      };
      const props = resolveProps.resolveProps(start, {
        indicator: "doc-start",
        next: value || (end === null || end === void 0 ? void 0 : end[0]),
        offset,
        onError,
        startOnNewline: true
      });
      if (props.found) {
        doc.directives.marker = true;
        if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
          onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
      }
      doc.contents = value ? composeNode.composeNode(ctx, value, props, onError) : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError);
      const contentEnd = doc.contents.range[2];
      const re = resolveEnd.resolveEnd(end, contentEnd, false, onError);
      if (re.comment)
        doc.comment = re.comment;
      doc.range = [offset, contentEnd, re.offset];
      return doc;
    }
    exports2.composeDoc = composeDoc;
  }
});

// ../../node_modules/yaml/dist/compose/composer.js
var require_composer = __commonJS({
  "../../node_modules/yaml/dist/compose/composer.js"(exports2) {
    "use strict";
    var directives = require_directives();
    var Document = require_Document();
    var errors = require_errors();
    var Node = require_Node();
    var options2 = require_options();
    var composeDoc = require_compose_doc();
    var resolveEnd = require_resolve_end();
    function getErrorPos(src) {
      if (typeof src === "number")
        return [src, src + 1];
      if (Array.isArray(src))
        return src.length === 2 ? src : [src[0], src[1]];
      const { offset, source } = src;
      return [offset, offset + (typeof source === "string" ? source.length : 1)];
    }
    function parsePrelude(prelude) {
      var _a2;
      let comment = "";
      let atComment = false;
      let afterEmptyLine = false;
      for (let i = 0; i < prelude.length; ++i) {
        const source = prelude[i];
        switch (source[0]) {
          case "#":
            comment += (comment === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
            atComment = true;
            afterEmptyLine = false;
            break;
          case "%":
            if (((_a2 = prelude[i + 1]) === null || _a2 === void 0 ? void 0 : _a2[0]) !== "#")
              i += 1;
            atComment = false;
            break;
          default:
            if (!atComment)
              afterEmptyLine = true;
            atComment = false;
        }
      }
      return { comment, afterEmptyLine };
    }
    var Composer = class {
      constructor(options$1 = {}) {
        this.doc = null;
        this.atDirectives = false;
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
        this.onError = (source, code, message, warning) => {
          const pos = getErrorPos(source);
          if (warning)
            this.warnings.push(new errors.YAMLWarning(pos, code, message));
          else
            this.errors.push(new errors.YAMLParseError(pos, code, message));
        };
        this.directives = new directives.Directives({
          version: options$1.version || options2.defaultOptions.version
        });
        this.options = options$1;
      }
      decorate(doc, afterDoc) {
        const { comment, afterEmptyLine } = parsePrelude(this.prelude);
        if (comment) {
          const dc = doc.contents;
          if (afterDoc) {
            doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
          } else if (afterEmptyLine || doc.directives.marker || !dc) {
            doc.commentBefore = comment;
          } else if (Node.isCollection(dc) && !dc.flow && dc.items.length > 0) {
            let it = dc.items[0];
            if (Node.isPair(it))
              it = it.key;
            const cb = it.commentBefore;
            it.commentBefore = cb ? `${comment}
${cb}` : comment;
          } else {
            const cb = dc.commentBefore;
            dc.commentBefore = cb ? `${comment}
${cb}` : comment;
          }
        }
        if (afterDoc) {
          Array.prototype.push.apply(doc.errors, this.errors);
          Array.prototype.push.apply(doc.warnings, this.warnings);
        } else {
          doc.errors = this.errors;
          doc.warnings = this.warnings;
        }
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
      }
      streamInfo() {
        return {
          comment: parsePrelude(this.prelude).comment,
          directives: this.directives,
          errors: this.errors,
          warnings: this.warnings
        };
      }
      *compose(tokens, forceDoc = false, endOffset = -1) {
        for (const token2 of tokens)
          yield* this.next(token2);
        yield* this.end(forceDoc, endOffset);
      }
      *next(token2) {
        if (process.env.LOG_STREAM)
          console.dir(token2, { depth: null });
        switch (token2.type) {
          case "directive":
            this.directives.add(token2.source, (offset, message, warning) => {
              const pos = getErrorPos(token2);
              pos[0] += offset;
              this.onError(pos, "BAD_DIRECTIVE", message, warning);
            });
            this.prelude.push(token2.source);
            this.atDirectives = true;
            break;
          case "document": {
            const doc = composeDoc.composeDoc(this.options, this.directives, token2, this.onError);
            if (this.atDirectives && !doc.directives.marker)
              this.onError(token2, "MISSING_CHAR", "Missing directives-end indicator line");
            this.decorate(doc, false);
            if (this.doc)
              yield this.doc;
            this.doc = doc;
            this.atDirectives = false;
            break;
          }
          case "byte-order-mark":
          case "space":
            break;
          case "comment":
          case "newline":
            this.prelude.push(token2.source);
            break;
          case "error": {
            const msg = token2.source ? `${token2.message}: ${JSON.stringify(token2.source)}` : token2.message;
            const error3 = new errors.YAMLParseError(getErrorPos(token2), "UNEXPECTED_TOKEN", msg);
            if (this.atDirectives || !this.doc)
              this.errors.push(error3);
            else
              this.doc.errors.push(error3);
            break;
          }
          case "doc-end": {
            if (!this.doc) {
              const msg = "Unexpected doc-end without preceding document";
              this.errors.push(new errors.YAMLParseError(getErrorPos(token2), "UNEXPECTED_TOKEN", msg));
              break;
            }
            const end = resolveEnd.resolveEnd(token2.end, token2.offset + token2.source.length, this.doc.options.strict, this.onError);
            this.decorate(this.doc, true);
            if (end.comment) {
              const dc = this.doc.comment;
              this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
            }
            this.doc.range[2] = end.offset;
            break;
          }
          default:
            this.errors.push(new errors.YAMLParseError(getErrorPos(token2), "UNEXPECTED_TOKEN", `Unsupported token ${token2.type}`));
        }
      }
      *end(forceDoc = false, endOffset = -1) {
        if (this.doc) {
          this.decorate(this.doc, true);
          yield this.doc;
          this.doc = null;
        } else if (forceDoc) {
          const opts = Object.assign({ directives: this.directives }, this.options);
          const doc = new Document.Document(void 0, opts);
          if (this.atDirectives)
            this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
          doc.range = [0, endOffset, endOffset];
          this.decorate(doc, false);
          yield doc;
        }
      }
    };
    exports2.Composer = Composer;
  }
});

// ../../node_modules/yaml/dist/parse/cst-scalar.js
var require_cst_scalar = __commonJS({
  "../../node_modules/yaml/dist/parse/cst-scalar.js"(exports2) {
    "use strict";
    var resolveBlockScalar = require_resolve_block_scalar();
    var resolveFlowScalar = require_resolve_flow_scalar();
    var errors = require_errors();
    var stringifyString = require_stringifyString();
    function resolveAsScalar(token2, strict = true, onError) {
      if (token2) {
        const _onError = (pos, code, message) => {
          const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
          if (onError)
            onError(offset, code, message);
          else
            throw new errors.YAMLParseError([offset, offset + 1], code, message);
        };
        switch (token2.type) {
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return resolveFlowScalar.resolveFlowScalar(token2, strict, _onError);
          case "block-scalar":
            return resolveBlockScalar.resolveBlockScalar(token2, strict, _onError);
        }
      }
      return null;
    }
    function createScalarToken(value, context) {
      var _a2;
      const { implicitKey = false, indent, inFlow = false, offset = -1, type = "PLAIN" } = context;
      const source = stringifyString.stringifyString({ type, value }, {
        implicitKey,
        indent: indent > 0 ? " ".repeat(indent) : "",
        inFlow,
        options: { blockQuote: true, lineWidth: -1 }
      });
      const end = (_a2 = context.end) !== null && _a2 !== void 0 ? _a2 : [
        { type: "newline", offset: -1, indent, source: "\n" }
      ];
      switch (source[0]) {
        case "|":
        case ">": {
          const he = source.indexOf("\n");
          const head = source.substring(0, he);
          const body = source.substring(he + 1) + "\n";
          const props = [
            { type: "block-scalar-header", offset, indent, source: head }
          ];
          if (!addEndtoBlockProps(props, end))
            props.push({ type: "newline", offset: -1, indent, source: "\n" });
          return { type: "block-scalar", offset, indent, props, source: body };
        }
        case '"':
          return { type: "double-quoted-scalar", offset, indent, source, end };
        case "'":
          return { type: "single-quoted-scalar", offset, indent, source, end };
        default:
          return { type: "scalar", offset, indent, source, end };
      }
    }
    function setScalarValue(token2, value, context = {}) {
      let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
      let indent = "indent" in token2 ? token2.indent : null;
      if (afterKey && typeof indent === "number")
        indent += 2;
      if (!type)
        switch (token2.type) {
          case "single-quoted-scalar":
            type = "QUOTE_SINGLE";
            break;
          case "double-quoted-scalar":
            type = "QUOTE_DOUBLE";
            break;
          case "block-scalar": {
            const header = token2.props[0];
            if (header.type !== "block-scalar-header")
              throw new Error("Invalid block scalar header");
            type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
            break;
          }
          default:
            type = "PLAIN";
        }
      const source = stringifyString.stringifyString({ type, value }, {
        implicitKey: implicitKey || indent === null,
        indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
        inFlow,
        options: { blockQuote: true, lineWidth: -1 }
      });
      switch (source[0]) {
        case "|":
        case ">":
          setBlockScalarValue(token2, source);
          break;
        case '"':
          setFlowScalarValue(token2, source, "double-quoted-scalar");
          break;
        case "'":
          setFlowScalarValue(token2, source, "single-quoted-scalar");
          break;
        default:
          setFlowScalarValue(token2, source, "scalar");
      }
    }
    function setBlockScalarValue(token2, source) {
      const he = source.indexOf("\n");
      const head = source.substring(0, he);
      const body = source.substring(he + 1) + "\n";
      if (token2.type === "block-scalar") {
        const header = token2.props[0];
        if (header.type !== "block-scalar-header")
          throw new Error("Invalid block scalar header");
        header.source = head;
        token2.source = body;
      } else {
        const { offset } = token2;
        const indent = "indent" in token2 ? token2.indent : -1;
        const props = [
          { type: "block-scalar-header", offset, indent, source: head }
        ];
        if (!addEndtoBlockProps(props, "end" in token2 ? token2.end : void 0))
          props.push({ type: "newline", offset: -1, indent, source: "\n" });
        for (const key of Object.keys(token2))
          if (key !== "type" && key !== "offset")
            delete token2[key];
        Object.assign(token2, { type: "block-scalar", indent, props, source: body });
      }
    }
    function addEndtoBlockProps(props, end) {
      if (end)
        for (const st of end)
          switch (st.type) {
            case "space":
            case "comment":
              props.push(st);
              break;
            case "newline":
              props.push(st);
              return true;
          }
      return false;
    }
    function setFlowScalarValue(token2, source, type) {
      switch (token2.type) {
        case "scalar":
        case "double-quoted-scalar":
        case "single-quoted-scalar":
          token2.type = type;
          token2.source = source;
          break;
        case "block-scalar": {
          const end = token2.props.slice(1);
          let oa = source.length;
          if (token2.props[0].type === "block-scalar-header")
            oa -= token2.props[0].source.length;
          for (const tok of end)
            tok.offset += oa;
          delete token2.props;
          Object.assign(token2, { type, source, end });
          break;
        }
        case "block-map":
        case "block-seq": {
          const offset = token2.offset + source.length;
          const nl = { type: "newline", offset, indent: token2.indent, source: "\n" };
          delete token2.items;
          Object.assign(token2, { type, source, end: [nl] });
          break;
        }
        default: {
          const indent = "indent" in token2 ? token2.indent : -1;
          const end = "end" in token2 && Array.isArray(token2.end) ? token2.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
          for (const key of Object.keys(token2))
            if (key !== "type" && key !== "offset")
              delete token2[key];
          Object.assign(token2, { type, indent, source, end });
        }
      }
    }
    exports2.createScalarToken = createScalarToken;
    exports2.resolveAsScalar = resolveAsScalar;
    exports2.setScalarValue = setScalarValue;
  }
});

// ../../node_modules/yaml/dist/parse/cst-stringify.js
var require_cst_stringify = __commonJS({
  "../../node_modules/yaml/dist/parse/cst-stringify.js"(exports2) {
    "use strict";
    var stringify = (cst) => "type" in cst ? stringifyToken(cst) : stringifyItem(cst);
    function stringifyToken(token2) {
      switch (token2.type) {
        case "block-scalar": {
          let res = "";
          for (const tok of token2.props)
            res += stringifyToken(tok);
          return res + token2.source;
        }
        case "block-map":
        case "block-seq": {
          let res = "";
          for (const item of token2.items)
            res += stringifyItem(item);
          return res;
        }
        case "flow-collection": {
          let res = token2.start.source;
          for (const item of token2.items)
            res += stringifyItem(item);
          for (const st of token2.end)
            res += st.source;
          return res;
        }
        case "document": {
          let res = stringifyItem(token2);
          if (token2.end)
            for (const st of token2.end)
              res += st.source;
          return res;
        }
        default: {
          let res = token2.source;
          if ("end" in token2 && token2.end)
            for (const st of token2.end)
              res += st.source;
          return res;
        }
      }
    }
    function stringifyItem({ start, key, sep, value }) {
      let res = "";
      for (const st of start)
        res += st.source;
      if (key)
        res += stringifyToken(key);
      if (sep)
        for (const st of sep)
          res += st.source;
      if (value)
        res += stringifyToken(value);
      return res;
    }
    exports2.stringify = stringify;
  }
});

// ../../node_modules/yaml/dist/parse/cst-visit.js
var require_cst_visit = __commonJS({
  "../../node_modules/yaml/dist/parse/cst-visit.js"(exports2) {
    "use strict";
    var BREAK = Symbol("break visit");
    var SKIP = Symbol("skip children");
    var REMOVE = Symbol("remove item");
    function visit(cst, visitor) {
      if ("type" in cst && cst.type === "document")
        cst = { start: cst.start, value: cst.value };
      _visit(Object.freeze([]), cst, visitor);
    }
    visit.BREAK = BREAK;
    visit.SKIP = SKIP;
    visit.REMOVE = REMOVE;
    visit.itemAtPath = (cst, path) => {
      let item = cst;
      for (const [field, index] of path) {
        const tok = item && item[field];
        if (tok && "items" in tok) {
          item = tok.items[index];
        } else
          return void 0;
      }
      return item;
    };
    visit.parentCollection = (cst, path) => {
      const parent = visit.itemAtPath(cst, path.slice(0, -1));
      const field = path[path.length - 1][0];
      const coll = parent && parent[field];
      if (coll && "items" in coll)
        return coll;
      throw new Error("Parent collection not found");
    };
    function _visit(path, item, visitor) {
      let ctrl = visitor(item, path);
      if (typeof ctrl === "symbol")
        return ctrl;
      for (const field of ["key", "value"]) {
        const token2 = item[field];
        if (token2 && "items" in token2) {
          for (let i = 0; i < token2.items.length; ++i) {
            const ci = _visit(Object.freeze(path.concat([[field, i]])), token2.items[i], visitor);
            if (typeof ci === "number")
              i = ci - 1;
            else if (ci === BREAK)
              return BREAK;
            else if (ci === REMOVE) {
              token2.items.splice(i, 1);
              i -= 1;
            }
          }
          if (typeof ctrl === "function" && field === "key")
            ctrl = ctrl(item, path);
        }
      }
      return typeof ctrl === "function" ? ctrl(item, path) : ctrl;
    }
    exports2.visit = visit;
  }
});

// ../../node_modules/yaml/dist/parse/cst.js
var require_cst = __commonJS({
  "../../node_modules/yaml/dist/parse/cst.js"(exports2) {
    "use strict";
    var cstScalar = require_cst_scalar();
    var cstStringify = require_cst_stringify();
    var cstVisit = require_cst_visit();
    var BOM = "\uFEFF";
    var DOCUMENT = "";
    var FLOW_END = "";
    var SCALAR = "";
    var isCollection = (token2) => !!token2 && "items" in token2;
    var isScalar = (token2) => !!token2 && (token2.type === "scalar" || token2.type === "single-quoted-scalar" || token2.type === "double-quoted-scalar" || token2.type === "block-scalar");
    function prettyToken(token2) {
      switch (token2) {
        case BOM:
          return "<BOM>";
        case DOCUMENT:
          return "<DOC>";
        case FLOW_END:
          return "<FLOW_END>";
        case SCALAR:
          return "<SCALAR>";
        default:
          return JSON.stringify(token2);
      }
    }
    function tokenType(source) {
      switch (source) {
        case BOM:
          return "byte-order-mark";
        case DOCUMENT:
          return "doc-mode";
        case FLOW_END:
          return "flow-error-end";
        case SCALAR:
          return "scalar";
        case "---":
          return "doc-start";
        case "...":
          return "doc-end";
        case "":
        case "\n":
        case "\r\n":
          return "newline";
        case "-":
          return "seq-item-ind";
        case "?":
          return "explicit-key-ind";
        case ":":
          return "map-value-ind";
        case "{":
          return "flow-map-start";
        case "}":
          return "flow-map-end";
        case "[":
          return "flow-seq-start";
        case "]":
          return "flow-seq-end";
        case ",":
          return "comma";
      }
      switch (source[0]) {
        case " ":
        case "	":
          return "space";
        case "#":
          return "comment";
        case "%":
          return "directive-line";
        case "*":
          return "alias";
        case "&":
          return "anchor";
        case "!":
          return "tag";
        case "'":
          return "single-quoted-scalar";
        case '"':
          return "double-quoted-scalar";
        case "|":
        case ">":
          return "block-scalar-header";
      }
      return null;
    }
    exports2.createScalarToken = cstScalar.createScalarToken;
    exports2.resolveAsScalar = cstScalar.resolveAsScalar;
    exports2.setScalarValue = cstScalar.setScalarValue;
    exports2.stringify = cstStringify.stringify;
    exports2.visit = cstVisit.visit;
    exports2.BOM = BOM;
    exports2.DOCUMENT = DOCUMENT;
    exports2.FLOW_END = FLOW_END;
    exports2.SCALAR = SCALAR;
    exports2.isCollection = isCollection;
    exports2.isScalar = isScalar;
    exports2.prettyToken = prettyToken;
    exports2.tokenType = tokenType;
  }
});

// ../../node_modules/yaml/dist/parse/lexer.js
var require_lexer = __commonJS({
  "../../node_modules/yaml/dist/parse/lexer.js"(exports2) {
    "use strict";
    var cst = require_cst();
    function isEmpty(ch) {
      switch (ch) {
        case void 0:
        case " ":
        case "\n":
        case "\r":
        case "	":
          return true;
        default:
          return false;
      }
    }
    var hexDigits = "0123456789ABCDEFabcdef".split("");
    var tagChars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()".split("");
    var invalidFlowScalarChars = ",[]{}".split("");
    var invalidAnchorChars = " ,[]{}\n\r	".split("");
    var isNotAnchorChar = (ch) => !ch || invalidAnchorChars.includes(ch);
    var Lexer = class {
      constructor() {
        this.atEnd = false;
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        this.buffer = "";
        this.flowKey = false;
        this.flowLevel = 0;
        this.indentNext = 0;
        this.indentValue = 0;
        this.lineEndPos = null;
        this.next = null;
        this.pos = 0;
      }
      *lex(source, incomplete = false) {
        if (source) {
          this.buffer = this.buffer ? this.buffer + source : source;
          this.lineEndPos = null;
        }
        this.atEnd = !incomplete;
        let next = this.next || "stream";
        while (next && (incomplete || this.hasChars(1)))
          next = yield* this.parseNext(next);
      }
      atLineEnd() {
        let i = this.pos;
        let ch = this.buffer[i];
        while (ch === " " || ch === "	")
          ch = this.buffer[++i];
        if (!ch || ch === "#" || ch === "\n")
          return true;
        if (ch === "\r")
          return this.buffer[i + 1] === "\n";
        return false;
      }
      charAt(n) {
        return this.buffer[this.pos + n];
      }
      continueScalar(offset) {
        let ch = this.buffer[offset];
        if (this.indentNext > 0) {
          let indent = 0;
          while (ch === " ")
            ch = this.buffer[++indent + offset];
          if (ch === "\r") {
            const next = this.buffer[indent + offset + 1];
            if (next === "\n" || !next && !this.atEnd)
              return offset + indent + 1;
          }
          return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
        }
        if (ch === "-" || ch === ".") {
          const dt = this.buffer.substr(offset, 3);
          if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset + 3]))
            return -1;
        }
        return offset;
      }
      getLine() {
        let end = this.lineEndPos;
        if (typeof end !== "number" || end !== -1 && end < this.pos) {
          end = this.buffer.indexOf("\n", this.pos);
          this.lineEndPos = end;
        }
        if (end === -1)
          return this.atEnd ? this.buffer.substring(this.pos) : null;
        if (this.buffer[end - 1] === "\r")
          end -= 1;
        return this.buffer.substring(this.pos, end);
      }
      hasChars(n) {
        return this.pos + n <= this.buffer.length;
      }
      setNext(state) {
        this.buffer = this.buffer.substring(this.pos);
        this.pos = 0;
        this.lineEndPos = null;
        this.next = state;
        return null;
      }
      peek(n) {
        return this.buffer.substr(this.pos, n);
      }
      *parseNext(next) {
        switch (next) {
          case "stream":
            return yield* this.parseStream();
          case "line-start":
            return yield* this.parseLineStart();
          case "block-start":
            return yield* this.parseBlockStart();
          case "doc":
            return yield* this.parseDocument();
          case "flow":
            return yield* this.parseFlowCollection();
          case "quoted-scalar":
            return yield* this.parseQuotedScalar();
          case "block-scalar":
            return yield* this.parseBlockScalar();
          case "plain-scalar":
            return yield* this.parsePlainScalar();
        }
      }
      *parseStream() {
        let line = this.getLine();
        if (line === null)
          return this.setNext("stream");
        if (line[0] === cst.BOM) {
          yield* this.pushCount(1);
          line = line.substring(1);
        }
        if (line[0] === "%") {
          let dirEnd = line.length;
          const cs = line.indexOf("#");
          if (cs !== -1) {
            const ch = line[cs - 1];
            if (ch === " " || ch === "	")
              dirEnd = cs - 1;
          }
          while (true) {
            const ch = line[dirEnd - 1];
            if (ch === " " || ch === "	")
              dirEnd -= 1;
            else
              break;
          }
          const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
          yield* this.pushCount(line.length - n);
          this.pushNewline();
          return "stream";
        }
        if (this.atLineEnd()) {
          const sp = yield* this.pushSpaces(true);
          yield* this.pushCount(line.length - sp);
          yield* this.pushNewline();
          return "stream";
        }
        yield cst.DOCUMENT;
        return yield* this.parseLineStart();
      }
      *parseLineStart() {
        const ch = this.charAt(0);
        if (!ch && !this.atEnd)
          return this.setNext("line-start");
        if (ch === "-" || ch === ".") {
          if (!this.atEnd && !this.hasChars(4))
            return this.setNext("line-start");
          const s = this.peek(3);
          if (s === "---" && isEmpty(this.charAt(3))) {
            yield* this.pushCount(3);
            this.indentValue = 0;
            this.indentNext = 0;
            return "doc";
          } else if (s === "..." && isEmpty(this.charAt(3))) {
            yield* this.pushCount(3);
            return "stream";
          }
        }
        this.indentValue = yield* this.pushSpaces(false);
        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
          this.indentNext = this.indentValue;
        return yield* this.parseBlockStart();
      }
      *parseBlockStart() {
        const [ch0, ch1] = this.peek(2);
        if (!ch1 && !this.atEnd)
          return this.setNext("block-start");
        if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
          const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
          this.indentNext = this.indentValue + 1;
          this.indentValue += n;
          return yield* this.parseBlockStart();
        }
        return "doc";
      }
      *parseDocument() {
        yield* this.pushSpaces(true);
        const line = this.getLine();
        if (line === null)
          return this.setNext("doc");
        let n = yield* this.pushIndicators();
        switch (line[n]) {
          case "#":
            yield* this.pushCount(line.length - n);
          case void 0:
            yield* this.pushNewline();
            return yield* this.parseLineStart();
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel = 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            return "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar);
            return "doc";
          case '"':
          case "'":
            return yield* this.parseQuotedScalar();
          case "|":
          case ">":
            n += yield* this.parseBlockScalarHeader();
            n += yield* this.pushSpaces(true);
            yield* this.pushCount(line.length - n);
            yield* this.pushNewline();
            return yield* this.parseBlockScalar();
          default:
            return yield* this.parsePlainScalar();
        }
      }
      *parseFlowCollection() {
        let nl, sp;
        let indent = -1;
        do {
          nl = yield* this.pushNewline();
          sp = yield* this.pushSpaces(true);
          if (nl > 0)
            this.indentValue = indent = sp;
        } while (nl + sp > 0);
        const line = this.getLine();
        if (line === null)
          return this.setNext("flow");
        if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
          const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
          if (!atFlowEndMarker) {
            this.flowLevel = 0;
            yield cst.FLOW_END;
            return yield* this.parseLineStart();
          }
        }
        let n = 0;
        while (line[n] === ",") {
          n += yield* this.pushCount(1);
          n += yield* this.pushSpaces(true);
          this.flowKey = false;
        }
        n += yield* this.pushIndicators();
        switch (line[n]) {
          case void 0:
            return "flow";
          case "#":
            yield* this.pushCount(line.length - n);
            return "flow";
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel += 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            this.flowKey = true;
            this.flowLevel -= 1;
            return this.flowLevel ? "flow" : "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar);
            return "flow";
          case '"':
          case "'":
            this.flowKey = true;
            return yield* this.parseQuotedScalar();
          case ":": {
            const next = this.charAt(1);
            if (this.flowKey || isEmpty(next) || next === ",") {
              this.flowKey = false;
              yield* this.pushCount(1);
              yield* this.pushSpaces(true);
              return "flow";
            }
          }
          default:
            this.flowKey = false;
            return yield* this.parsePlainScalar();
        }
      }
      *parseQuotedScalar() {
        const quote = this.charAt(0);
        let end = this.buffer.indexOf(quote, this.pos + 1);
        if (quote === "'") {
          while (end !== -1 && this.buffer[end + 1] === "'")
            end = this.buffer.indexOf("'", end + 2);
        } else {
          while (end !== -1) {
            let n = 0;
            while (this.buffer[end - 1 - n] === "\\")
              n += 1;
            if (n % 2 === 0)
              break;
            end = this.buffer.indexOf('"', end + 1);
          }
        }
        const qb = this.buffer.substring(0, end);
        let nl = qb.indexOf("\n", this.pos);
        if (nl !== -1) {
          while (nl !== -1) {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = qb.indexOf("\n", cs);
          }
          if (nl !== -1) {
            end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
          }
        }
        if (end === -1) {
          if (!this.atEnd)
            return this.setNext("quoted-scalar");
          end = this.buffer.length;
        }
        yield* this.pushToIndex(end + 1, false);
        return this.flowLevel ? "flow" : "doc";
      }
      *parseBlockScalarHeader() {
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        let i = this.pos;
        while (true) {
          const ch = this.buffer[++i];
          if (ch === "+")
            this.blockScalarKeep = true;
          else if (ch > "0" && ch <= "9")
            this.blockScalarIndent = Number(ch) - 1;
          else if (ch !== "-")
            break;
        }
        return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
      }
      *parseBlockScalar() {
        let nl = this.pos - 1;
        let indent = 0;
        let ch;
        loop:
          for (let i = this.pos; ch = this.buffer[i]; ++i) {
            switch (ch) {
              case " ":
                indent += 1;
                break;
              case "\n":
                nl = i;
                indent = 0;
                break;
              case "\r": {
                const next = this.buffer[i + 1];
                if (!next && !this.atEnd)
                  return this.setNext("block-scalar");
                if (next === "\n")
                  break;
              }
              default:
                break loop;
            }
          }
        if (!ch && !this.atEnd)
          return this.setNext("block-scalar");
        if (indent >= this.indentNext) {
          if (this.blockScalarIndent === -1)
            this.indentNext = indent;
          else
            this.indentNext += this.blockScalarIndent;
          do {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = this.buffer.indexOf("\n", cs);
          } while (nl !== -1);
          if (nl === -1) {
            if (!this.atEnd)
              return this.setNext("block-scalar");
            nl = this.buffer.length;
          }
        }
        if (!this.blockScalarKeep) {
          do {
            let i = nl - 1;
            let ch2 = this.buffer[i];
            if (ch2 === "\r")
              ch2 = this.buffer[--i];
            while (ch2 === " " || ch2 === "	")
              ch2 = this.buffer[--i];
            if (ch2 === "\n" && i >= this.pos)
              nl = i;
            else
              break;
          } while (true);
        }
        yield cst.SCALAR;
        yield* this.pushToIndex(nl + 1, true);
        return yield* this.parseLineStart();
      }
      *parsePlainScalar() {
        const inFlow = this.flowLevel > 0;
        let end = this.pos - 1;
        let i = this.pos - 1;
        let ch;
        while (ch = this.buffer[++i]) {
          if (ch === ":") {
            const next = this.buffer[i + 1];
            if (isEmpty(next) || inFlow && next === ",")
              break;
            end = i;
          } else if (isEmpty(ch)) {
            let next = this.buffer[i + 1];
            if (ch === "\r") {
              if (next === "\n") {
                i += 1;
                ch = "\n";
                next = this.buffer[i + 1];
              } else
                end = i;
            }
            if (next === "#" || inFlow && invalidFlowScalarChars.includes(next))
              break;
            if (ch === "\n") {
              const cs = this.continueScalar(i + 1);
              if (cs === -1)
                break;
              i = Math.max(i, cs - 2);
            }
          } else {
            if (inFlow && invalidFlowScalarChars.includes(ch))
              break;
            end = i;
          }
        }
        if (!ch && !this.atEnd)
          return this.setNext("plain-scalar");
        yield cst.SCALAR;
        yield* this.pushToIndex(end + 1, true);
        return inFlow ? "flow" : "doc";
      }
      *pushCount(n) {
        if (n > 0) {
          yield this.buffer.substr(this.pos, n);
          this.pos += n;
          return n;
        }
        return 0;
      }
      *pushToIndex(i, allowEmpty) {
        const s = this.buffer.slice(this.pos, i);
        if (s) {
          yield s;
          this.pos += s.length;
          return s.length;
        } else if (allowEmpty)
          yield "";
        return 0;
      }
      *pushIndicators() {
        switch (this.charAt(0)) {
          case "!":
            return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case "&":
            return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case ":":
          case "?":
          case "-":
            if (isEmpty(this.charAt(1))) {
              if (this.flowLevel === 0)
                this.indentNext = this.indentValue + 1;
              else if (this.flowKey)
                this.flowKey = false;
              return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
            }
        }
        return 0;
      }
      *pushTag() {
        if (this.charAt(1) === "<") {
          let i = this.pos + 2;
          let ch = this.buffer[i];
          while (!isEmpty(ch) && ch !== ">")
            ch = this.buffer[++i];
          return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
        } else {
          let i = this.pos + 1;
          let ch = this.buffer[i];
          while (ch) {
            if (tagChars.includes(ch))
              ch = this.buffer[++i];
            else if (ch === "%" && hexDigits.includes(this.buffer[i + 1]) && hexDigits.includes(this.buffer[i + 2])) {
              ch = this.buffer[i += 3];
            } else
              break;
          }
          return yield* this.pushToIndex(i, false);
        }
      }
      *pushNewline() {
        const ch = this.buffer[this.pos];
        if (ch === "\n")
          return yield* this.pushCount(1);
        else if (ch === "\r" && this.charAt(1) === "\n")
          return yield* this.pushCount(2);
        else
          return 0;
      }
      *pushSpaces(allowTabs) {
        let i = this.pos - 1;
        let ch;
        do {
          ch = this.buffer[++i];
        } while (ch === " " || allowTabs && ch === "	");
        const n = i - this.pos;
        if (n > 0) {
          yield this.buffer.substr(this.pos, n);
          this.pos = i;
        }
        return n;
      }
      *pushUntil(test) {
        let i = this.pos;
        let ch = this.buffer[i];
        while (!test(ch))
          ch = this.buffer[++i];
        return yield* this.pushToIndex(i, false);
      }
    };
    exports2.Lexer = Lexer;
  }
});

// ../../node_modules/yaml/dist/parse/line-counter.js
var require_line_counter = __commonJS({
  "../../node_modules/yaml/dist/parse/line-counter.js"(exports2) {
    "use strict";
    var LineCounter = class {
      constructor() {
        this.lineStarts = [];
        this.addNewLine = (offset) => this.lineStarts.push(offset);
        this.linePos = (offset) => {
          let low = 0;
          let high = this.lineStarts.length;
          while (low < high) {
            const mid = low + high >> 1;
            if (this.lineStarts[mid] < offset)
              low = mid + 1;
            else
              high = mid;
          }
          if (this.lineStarts[low] === offset)
            return { line: low + 1, col: 1 };
          if (low === 0)
            return { line: 0, col: offset };
          const start = this.lineStarts[low - 1];
          return { line: low, col: offset - start + 1 };
        };
      }
    };
    exports2.LineCounter = LineCounter;
  }
});

// ../../node_modules/yaml/dist/parse/parser.js
var require_parser = __commonJS({
  "../../node_modules/yaml/dist/parse/parser.js"(exports2) {
    "use strict";
    var cst = require_cst();
    var lexer = require_lexer();
    function includesToken(list, type) {
      for (let i = 0; i < list.length; ++i)
        if (list[i].type === type)
          return true;
      return false;
    }
    function includesNonEmpty(list) {
      for (let i = 0; i < list.length; ++i) {
        switch (list[i].type) {
          case "space":
          case "comment":
          case "newline":
            break;
          default:
            return true;
        }
      }
      return false;
    }
    function isFlowToken(token2) {
      switch (token2 === null || token2 === void 0 ? void 0 : token2.type) {
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
        case "flow-collection":
          return true;
        default:
          return false;
      }
    }
    function getPrevProps(parent) {
      switch (parent.type) {
        case "document":
          return parent.start;
        case "block-map": {
          const it = parent.items[parent.items.length - 1];
          return it.sep || it.start;
        }
        case "block-seq":
          return parent.items[parent.items.length - 1].start;
        default:
          return [];
      }
    }
    function getFirstKeyStartProps(prev) {
      var _a2;
      if (prev.length === 0)
        return [];
      let i = prev.length;
      loop:
        while (--i >= 0) {
          switch (prev[i].type) {
            case "doc-start":
            case "explicit-key-ind":
            case "map-value-ind":
            case "seq-item-ind":
            case "newline":
              break loop;
          }
        }
      while (((_a2 = prev[++i]) === null || _a2 === void 0 ? void 0 : _a2.type) === "space") {
      }
      return prev.splice(i, prev.length);
    }
    function fixFlowSeqItems(fc) {
      if (fc.start.type === "flow-seq-start") {
        for (const it of fc.items) {
          if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
            if (it.key)
              it.value = it.key;
            delete it.key;
            if (isFlowToken(it.value)) {
              if (it.value.end)
                Array.prototype.push.apply(it.value.end, it.sep);
              else
                it.value.end = it.sep;
            } else
              Array.prototype.push.apply(it.start, it.sep);
            delete it.sep;
          }
        }
      }
    }
    var Parser = class {
      constructor(onNewLine) {
        this.atNewLine = true;
        this.atScalar = false;
        this.indent = 0;
        this.offset = 0;
        this.onKeyLine = false;
        this.stack = [];
        this.source = "";
        this.type = "";
        this.lexer = new lexer.Lexer();
        this.onNewLine = onNewLine;
      }
      *parse(source, incomplete = false) {
        if (this.onNewLine && this.offset === 0)
          this.onNewLine(0);
        for (const lexeme of this.lexer.lex(source, incomplete))
          yield* this.next(lexeme);
        if (!incomplete)
          yield* this.end();
      }
      *next(source) {
        this.source = source;
        if (process.env.LOG_TOKENS)
          console.log("|", cst.prettyToken(source));
        if (this.atScalar) {
          this.atScalar = false;
          yield* this.step();
          this.offset += source.length;
          return;
        }
        const type = cst.tokenType(source);
        if (!type) {
          const message = `Not a YAML token: ${source}`;
          yield* this.pop({ type: "error", offset: this.offset, message, source });
          this.offset += source.length;
        } else if (type === "scalar") {
          this.atNewLine = false;
          this.atScalar = true;
          this.type = "scalar";
        } else {
          this.type = type;
          yield* this.step();
          switch (type) {
            case "newline":
              this.atNewLine = true;
              this.indent = 0;
              if (this.onNewLine)
                this.onNewLine(this.offset + source.length);
              break;
            case "space":
              if (this.atNewLine && source[0] === " ")
                this.indent += source.length;
              break;
            case "explicit-key-ind":
            case "map-value-ind":
            case "seq-item-ind":
              if (this.atNewLine)
                this.indent += source.length;
              break;
            case "doc-mode":
            case "flow-error-end":
              return;
            default:
              this.atNewLine = false;
          }
          this.offset += source.length;
        }
      }
      *end() {
        while (this.stack.length > 0)
          yield* this.pop();
      }
      get sourceToken() {
        const st = {
          type: this.type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
        return st;
      }
      *step() {
        const top = this.peek(1);
        if (this.type === "doc-end" && (!top || top.type !== "doc-end")) {
          while (this.stack.length > 0)
            yield* this.pop();
          this.stack.push({
            type: "doc-end",
            offset: this.offset,
            source: this.source
          });
          return;
        }
        if (!top)
          return yield* this.stream();
        switch (top.type) {
          case "document":
            return yield* this.document(top);
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return yield* this.scalar(top);
          case "block-scalar":
            return yield* this.blockScalar(top);
          case "block-map":
            return yield* this.blockMap(top);
          case "block-seq":
            return yield* this.blockSequence(top);
          case "flow-collection":
            return yield* this.flowCollection(top);
          case "doc-end":
            return yield* this.documentEnd(top);
        }
        yield* this.pop();
      }
      peek(n) {
        return this.stack[this.stack.length - n];
      }
      *pop(error3) {
        const token2 = error3 || this.stack.pop();
        if (!token2) {
          const message = "Tried to pop an empty stack";
          yield { type: "error", offset: this.offset, source: "", message };
        } else if (this.stack.length === 0) {
          yield token2;
        } else {
          const top = this.peek(1);
          if (token2.type === "block-scalar") {
            token2.indent = "indent" in top ? top.indent : 0;
          } else if (token2.type === "flow-collection" && top.type === "document") {
            token2.indent = 0;
          }
          if (token2.type === "flow-collection")
            fixFlowSeqItems(token2);
          switch (top.type) {
            case "document":
              top.value = token2;
              break;
            case "block-scalar":
              top.props.push(token2);
              break;
            case "block-map": {
              const it = top.items[top.items.length - 1];
              if (it.value) {
                top.items.push({ start: [], key: token2, sep: [] });
                this.onKeyLine = true;
                return;
              } else if (it.sep) {
                it.value = token2;
              } else {
                Object.assign(it, { key: token2, sep: [] });
                this.onKeyLine = !includesToken(it.start, "explicit-key-ind");
                return;
              }
              break;
            }
            case "block-seq": {
              const it = top.items[top.items.length - 1];
              if (it.value)
                top.items.push({ start: [], value: token2 });
              else
                it.value = token2;
              break;
            }
            case "flow-collection": {
              const it = top.items[top.items.length - 1];
              if (!it || it.value)
                top.items.push({ start: [], key: token2, sep: [] });
              else if (it.sep)
                it.value = token2;
              else
                Object.assign(it, { key: token2, sep: [] });
              return;
            }
            default:
              yield* this.pop();
              yield* this.pop(token2);
          }
          if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token2.type === "block-map" || token2.type === "block-seq")) {
            const last = token2.items[token2.items.length - 1];
            if (last && !last.sep && !last.value && last.start.length > 0 && !includesNonEmpty(last.start) && (token2.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token2.indent))) {
              if (top.type === "document")
                top.end = last.start;
              else
                top.items.push({ start: last.start });
              token2.items.splice(-1, 1);
            }
          }
        }
      }
      *stream() {
        switch (this.type) {
          case "directive-line":
            yield { type: "directive", offset: this.offset, source: this.source };
            return;
          case "byte-order-mark":
          case "space":
          case "comment":
          case "newline":
            yield this.sourceToken;
            return;
          case "doc-mode":
          case "doc-start": {
            const doc = {
              type: "document",
              offset: this.offset,
              start: []
            };
            if (this.type === "doc-start")
              doc.start.push(this.sourceToken);
            this.stack.push(doc);
            return;
          }
        }
        yield {
          type: "error",
          offset: this.offset,
          message: `Unexpected ${this.type} token in YAML stream`,
          source: this.source
        };
      }
      *document(doc) {
        if (doc.value)
          return yield* this.lineEnd(doc);
        switch (this.type) {
          case "doc-start": {
            if (includesNonEmpty(doc.start)) {
              yield* this.pop();
              yield* this.step();
            } else
              doc.start.push(this.sourceToken);
            return;
          }
          case "anchor":
          case "tag":
          case "space":
          case "comment":
          case "newline":
            doc.start.push(this.sourceToken);
            return;
        }
        const bv = this.startBlockValue(doc);
        if (bv)
          this.stack.push(bv);
        else {
          yield {
            type: "error",
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML document`,
            source: this.source
          };
        }
      }
      *scalar(scalar) {
        if (this.type === "map-value-ind") {
          const prev = getPrevProps(this.peek(2));
          const start = getFirstKeyStartProps(prev);
          let sep;
          if (scalar.end) {
            sep = scalar.end;
            sep.push(this.sourceToken);
            delete scalar.end;
          } else
            sep = [this.sourceToken];
          const map = {
            type: "block-map",
            offset: scalar.offset,
            indent: scalar.indent,
            items: [{ start, key: scalar, sep }]
          };
          this.onKeyLine = true;
          this.stack[this.stack.length - 1] = map;
        } else
          yield* this.lineEnd(scalar);
      }
      *blockScalar(scalar) {
        switch (this.type) {
          case "space":
          case "comment":
          case "newline":
            scalar.props.push(this.sourceToken);
            return;
          case "scalar":
            scalar.source = this.source;
            this.atNewLine = true;
            this.indent = 0;
            if (this.onNewLine) {
              let nl = this.source.indexOf("\n") + 1;
              while (nl !== 0) {
                this.onNewLine(this.offset + nl);
                nl = this.source.indexOf("\n", nl) + 1;
              }
            }
            yield* this.pop();
            break;
          default:
            yield* this.pop();
            yield* this.step();
        }
      }
      *blockMap(map) {
        var _a2;
        const it = map.items[map.items.length - 1];
        switch (this.type) {
          case "newline":
            this.onKeyLine = false;
            if (it.value) {
              const end = "end" in it.value ? it.value.end : void 0;
              const last = Array.isArray(end) ? end[end.length - 1] : void 0;
              if ((last === null || last === void 0 ? void 0 : last.type) === "comment")
                end === null || end === void 0 ? void 0 : end.push(this.sourceToken);
              else
                map.items.push({ start: [this.sourceToken] });
            } else if (it.sep)
              it.sep.push(this.sourceToken);
            else
              it.start.push(this.sourceToken);
            return;
          case "space":
          case "comment":
            if (it.value)
              map.items.push({ start: [this.sourceToken] });
            else if (it.sep)
              it.sep.push(this.sourceToken);
            else {
              if (this.atIndentedComment(it.start, map.indent)) {
                const prev = map.items[map.items.length - 2];
                const end = (_a2 = prev === null || prev === void 0 ? void 0 : prev.value) === null || _a2 === void 0 ? void 0 : _a2.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it.start);
                  end.push(this.sourceToken);
                  map.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
        }
        if (this.indent >= map.indent) {
          const atNextItem = !this.onKeyLine && this.indent === map.indent && (it.sep || includesNonEmpty(it.start));
          switch (this.type) {
            case "anchor":
            case "tag":
              if (atNextItem || it.value) {
                map.items.push({ start: [this.sourceToken] });
                this.onKeyLine = true;
              } else if (it.sep)
                it.sep.push(this.sourceToken);
              else
                it.start.push(this.sourceToken);
              return;
            case "explicit-key-ind":
              if (!it.sep && !includesToken(it.start, "explicit-key-ind"))
                it.start.push(this.sourceToken);
              else if (atNextItem || it.value)
                map.items.push({ start: [this.sourceToken] });
              else
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: [this.sourceToken] }]
                });
              this.onKeyLine = true;
              return;
            case "map-value-ind":
              if (!it.sep)
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              else if (it.value || atNextItem && !includesToken(it.start, "explicit-key-ind"))
                map.items.push({ start: [], key: null, sep: [this.sourceToken] });
              else if (includesToken(it.sep, "map-value-ind"))
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: [], key: null, sep: [this.sourceToken] }]
                });
              else if (includesToken(it.start, "explicit-key-ind") && isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
                const start = getFirstKeyStartProps(it.start);
                const key = it.key;
                const sep = it.sep;
                sep.push(this.sourceToken);
                delete it.key, delete it.sep;
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start, key, sep }]
                });
              } else
                it.sep.push(this.sourceToken);
              this.onKeyLine = true;
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs2 = this.flowScalar(this.type);
              if (atNextItem || it.value) {
                map.items.push({ start: [], key: fs2, sep: [] });
                this.onKeyLine = true;
              } else if (it.sep) {
                this.stack.push(fs2);
              } else {
                Object.assign(it, { key: fs2, sep: [] });
                this.onKeyLine = true;
              }
              return;
            }
            default: {
              const bv = this.startBlockValue(map);
              if (bv) {
                if (atNextItem && bv.type !== "block-seq" && includesToken(it.start, "explicit-key-ind"))
                  map.items.push({ start: [] });
                this.stack.push(bv);
                return;
              }
            }
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *blockSequence(seq) {
        var _a2;
        const it = seq.items[seq.items.length - 1];
        switch (this.type) {
          case "newline":
            if (it.value) {
              const end = "end" in it.value ? it.value.end : void 0;
              const last = Array.isArray(end) ? end[end.length - 1] : void 0;
              if ((last === null || last === void 0 ? void 0 : last.type) === "comment")
                end === null || end === void 0 ? void 0 : end.push(this.sourceToken);
              else
                seq.items.push({ start: [this.sourceToken] });
            } else
              it.start.push(this.sourceToken);
            return;
          case "space":
          case "comment":
            if (it.value)
              seq.items.push({ start: [this.sourceToken] });
            else {
              if (this.atIndentedComment(it.start, seq.indent)) {
                const prev = seq.items[seq.items.length - 2];
                const end = (_a2 = prev === null || prev === void 0 ? void 0 : prev.value) === null || _a2 === void 0 ? void 0 : _a2.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it.start);
                  end.push(this.sourceToken);
                  seq.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
          case "anchor":
          case "tag":
            if (it.value || this.indent <= seq.indent)
              break;
            it.start.push(this.sourceToken);
            return;
          case "seq-item-ind":
            if (this.indent !== seq.indent)
              break;
            if (it.value || includesToken(it.start, "seq-item-ind"))
              seq.items.push({ start: [this.sourceToken] });
            else
              it.start.push(this.sourceToken);
            return;
        }
        if (this.indent > seq.indent) {
          const bv = this.startBlockValue(seq);
          if (bv) {
            this.stack.push(bv);
            return;
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *flowCollection(fc) {
        const it = fc.items[fc.items.length - 1];
        if (this.type === "flow-error-end") {
          let top;
          do {
            yield* this.pop();
            top = this.peek(1);
          } while (top && top.type === "flow-collection");
        } else if (fc.end.length === 0) {
          switch (this.type) {
            case "comma":
            case "explicit-key-ind":
              if (!it || it.sep)
                fc.items.push({ start: [this.sourceToken] });
              else
                it.start.push(this.sourceToken);
              return;
            case "map-value-ind":
              if (!it || it.value)
                fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
              else if (it.sep)
                it.sep.push(this.sourceToken);
              else
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              return;
            case "space":
            case "comment":
            case "newline":
            case "anchor":
            case "tag":
              if (!it || it.value)
                fc.items.push({ start: [this.sourceToken] });
              else if (it.sep)
                it.sep.push(this.sourceToken);
              else
                it.start.push(this.sourceToken);
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs2 = this.flowScalar(this.type);
              if (!it || it.value)
                fc.items.push({ start: [], key: fs2, sep: [] });
              else if (it.sep)
                this.stack.push(fs2);
              else
                Object.assign(it, { key: fs2, sep: [] });
              return;
            }
            case "flow-map-end":
            case "flow-seq-end":
              fc.end.push(this.sourceToken);
              return;
          }
          const bv = this.startBlockValue(fc);
          if (bv)
            this.stack.push(bv);
          else {
            yield* this.pop();
            yield* this.step();
          }
        } else {
          const parent = this.peek(2);
          if (parent.type === "block-map" && (this.type === "map-value-ind" || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
            yield* this.pop();
            yield* this.step();
          } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            fixFlowSeqItems(fc);
            const sep = fc.end.splice(1, fc.end.length);
            sep.push(this.sourceToken);
            const map = {
              type: "block-map",
              offset: fc.offset,
              indent: fc.indent,
              items: [{ start, key: fc, sep }]
            };
            this.onKeyLine = true;
            this.stack[this.stack.length - 1] = map;
          } else {
            yield* this.lineEnd(fc);
          }
        }
      }
      flowScalar(type) {
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        return {
          type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
      }
      startBlockValue(parent) {
        switch (this.type) {
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return this.flowScalar(this.type);
          case "block-scalar-header":
            return {
              type: "block-scalar",
              offset: this.offset,
              indent: this.indent,
              props: [this.sourceToken],
              source: ""
            };
          case "flow-map-start":
          case "flow-seq-start":
            return {
              type: "flow-collection",
              offset: this.offset,
              indent: this.indent,
              start: this.sourceToken,
              items: [],
              end: []
            };
          case "seq-item-ind":
            return {
              type: "block-seq",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken] }]
            };
          case "explicit-key-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            start.push(this.sourceToken);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start }]
            };
          }
          case "map-value-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start, key: null, sep: [this.sourceToken] }]
            };
          }
        }
        return null;
      }
      atIndentedComment(start, indent) {
        if (this.type !== "comment")
          return false;
        if (this.indent <= indent)
          return false;
        return start.every((st) => st.type === "newline" || st.type === "space");
      }
      *documentEnd(docEnd) {
        if (this.type !== "doc-mode") {
          if (docEnd.end)
            docEnd.end.push(this.sourceToken);
          else
            docEnd.end = [this.sourceToken];
          if (this.type === "newline")
            yield* this.pop();
        }
      }
      *lineEnd(token2) {
        switch (this.type) {
          case "comma":
          case "doc-start":
          case "doc-end":
          case "flow-seq-end":
          case "flow-map-end":
          case "map-value-ind":
            yield* this.pop();
            yield* this.step();
            break;
          case "newline":
            this.onKeyLine = false;
          case "space":
          case "comment":
          default:
            if (token2.end)
              token2.end.push(this.sourceToken);
            else
              token2.end = [this.sourceToken];
            if (this.type === "newline")
              yield* this.pop();
        }
      }
    };
    exports2.Parser = Parser;
  }
});

// ../../node_modules/yaml/dist/public-api.js
var require_public_api = __commonJS({
  "../../node_modules/yaml/dist/public-api.js"(exports2) {
    "use strict";
    var composer = require_composer();
    var Document = require_Document();
    var errors = require_errors();
    var log4 = require_log();
    var lineCounter = require_line_counter();
    var parser = require_parser();
    function parseOptions(options2) {
      const prettyErrors = options2.prettyErrors !== false;
      const lineCounter$1 = options2.lineCounter || prettyErrors && new lineCounter.LineCounter() || null;
      return { lineCounter: lineCounter$1, prettyErrors };
    }
    function parseAllDocuments(source, options2 = {}) {
      const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options2);
      const parser$1 = new parser.Parser(lineCounter2 === null || lineCounter2 === void 0 ? void 0 : lineCounter2.addNewLine);
      const composer$1 = new composer.Composer(options2);
      const docs = Array.from(composer$1.compose(parser$1.parse(source)));
      if (prettyErrors && lineCounter2)
        for (const doc of docs) {
          doc.errors.forEach(errors.prettifyError(source, lineCounter2));
          doc.warnings.forEach(errors.prettifyError(source, lineCounter2));
        }
      if (docs.length > 0)
        return docs;
      return Object.assign([], { empty: true }, composer$1.streamInfo());
    }
    function parseDocument(source, options2 = {}) {
      const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options2);
      const parser$1 = new parser.Parser(lineCounter2 === null || lineCounter2 === void 0 ? void 0 : lineCounter2.addNewLine);
      const composer$1 = new composer.Composer(options2);
      let doc = null;
      for (const _doc of composer$1.compose(parser$1.parse(source), true, source.length)) {
        if (!doc)
          doc = _doc;
        else if (doc.options.logLevel !== "silent") {
          doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
          break;
        }
      }
      if (prettyErrors && lineCounter2) {
        doc.errors.forEach(errors.prettifyError(source, lineCounter2));
        doc.warnings.forEach(errors.prettifyError(source, lineCounter2));
      }
      return doc;
    }
    function parse2(src, reviver, options2) {
      let _reviver = void 0;
      if (typeof reviver === "function") {
        _reviver = reviver;
      } else if (options2 === void 0 && reviver && typeof reviver === "object") {
        options2 = reviver;
      }
      const doc = parseDocument(src, options2);
      if (!doc)
        return null;
      doc.warnings.forEach((warning) => log4.warn(doc.options.logLevel, warning));
      if (doc.errors.length > 0) {
        if (doc.options.logLevel !== "silent")
          throw doc.errors[0];
        else
          doc.errors = [];
      }
      return doc.toJS(Object.assign({ reviver: _reviver }, options2));
    }
    function stringify(value, replacer, options2) {
      let _replacer = null;
      if (typeof replacer === "function" || Array.isArray(replacer)) {
        _replacer = replacer;
      } else if (options2 === void 0 && replacer) {
        options2 = replacer;
      }
      if (typeof options2 === "string")
        options2 = options2.length;
      if (typeof options2 === "number") {
        const indent = Math.round(options2);
        options2 = indent < 1 ? void 0 : indent > 8 ? { indent: 8 } : { indent };
      }
      if (value === void 0) {
        const { keepUndefined } = options2 || replacer || {};
        if (!keepUndefined)
          return void 0;
      }
      return new Document.Document(value, _replacer, options2).toString(options2);
    }
    exports2.parse = parse2;
    exports2.parseAllDocuments = parseAllDocuments;
    exports2.parseDocument = parseDocument;
    exports2.stringify = stringify;
  }
});

// ../../node_modules/yaml/dist/index.js
var require_dist2 = __commonJS({
  "../../node_modules/yaml/dist/index.js"(exports2) {
    "use strict";
    var composer = require_composer();
    var Document = require_Document();
    var Schema = require_Schema();
    var errors = require_errors();
    var Alias = require_Alias();
    var Node = require_Node();
    var Pair = require_Pair();
    var Scalar = require_Scalar();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var options2 = require_options();
    var cst = require_cst();
    var lexer = require_lexer();
    var lineCounter = require_line_counter();
    var parser = require_parser();
    var publicApi = require_public_api();
    var visit = require_visit();
    exports2.Composer = composer.Composer;
    exports2.Document = Document.Document;
    exports2.Schema = Schema.Schema;
    exports2.YAMLError = errors.YAMLError;
    exports2.YAMLParseError = errors.YAMLParseError;
    exports2.YAMLWarning = errors.YAMLWarning;
    exports2.Alias = Alias.Alias;
    exports2.isAlias = Node.isAlias;
    exports2.isCollection = Node.isCollection;
    exports2.isDocument = Node.isDocument;
    exports2.isMap = Node.isMap;
    exports2.isNode = Node.isNode;
    exports2.isPair = Node.isPair;
    exports2.isScalar = Node.isScalar;
    exports2.isSeq = Node.isSeq;
    exports2.Pair = Pair.Pair;
    exports2.Scalar = Scalar.Scalar;
    exports2.YAMLMap = YAMLMap.YAMLMap;
    exports2.YAMLSeq = YAMLSeq.YAMLSeq;
    exports2.defaultOptions = options2.defaultOptions;
    exports2.CST = cst;
    exports2.Lexer = lexer.Lexer;
    exports2.LineCounter = lineCounter.LineCounter;
    exports2.Parser = parser.Parser;
    exports2.parse = publicApi.parse;
    exports2.parseAllDocuments = publicApi.parseAllDocuments;
    exports2.parseDocument = publicApi.parseDocument;
    exports2.stringify = publicApi.stringify;
    exports2.visit = visit.visit;
  }
});

// ../../node_modules/findit2/index.js
var require_findit2 = __commonJS({
  "../../node_modules/findit2/index.js"(exports2, module2) {
    var EventEmitter3 = require("events").EventEmitter;
    var fs2 = require("fs");
    var path = require("path");
    module2.exports = findit;
    function findit(basedir, opts) {
      opts = opts || {};
      var followSymlinks = !!opts.followSymlinks;
      var myFs = opts.fs || fs2;
      var emitter = new EventEmitter3();
      var stopped = false;
      var pending = 0;
      var seen = {};
      emitter.stop = stop;
      walkPath(basedir);
      return emitter;
      function recursiveReadDir(basedir2, linkPath) {
        pendStart();
        myFs.readdir(basedir2, function(err, entries) {
          if (stopped)
            return;
          if (err) {
            handleError(err, basedir2);
            pendEnd();
            return;
          }
          entries.forEach(function(entry) {
            var fullPath = path.join(basedir2, entry);
            var fullLinkPath = linkPath && path.join(linkPath, entry);
            walkPath(fullPath, fullLinkPath);
          });
          pendEnd();
        });
      }
      function walkPath(fullPath, linkPath) {
        pendStart();
        myFs.lstat(fullPath, function(err, stats) {
          if (stopped)
            return;
          if (err) {
            handleError(err, fullPath);
            pendEnd();
            return;
          }
          emitter.emit("path", fullPath, stats, linkPath);
          var dirStopped = false;
          if (stats.isDirectory()) {
            if (seen[fullPath]) {
              err = new Error("file system loop detected");
              err.code = "ELOOP";
              handleError(err, fullPath);
              pendEnd();
              return;
            }
            seen[fullPath] = true;
            emitter.emit("directory", fullPath, stats, stopDir, linkPath);
            if (!dirStopped)
              recursiveReadDir(fullPath, linkPath);
          } else if (stats.isFile()) {
            if (!seen[fullPath]) {
              seen[fullPath] = true;
              emitter.emit("file", fullPath, stats, linkPath);
            }
          } else if (stats.isSymbolicLink()) {
            emitter.emit("link", fullPath, stats, linkPath);
            if (followSymlinks)
              recursiveReadLink(fullPath);
          }
          pendEnd();
          function stopDir() {
            dirStopped = true;
          }
        });
      }
      function recursiveReadLink(linkPath) {
        pendStart();
        myFs.readlink(linkPath, function(err, linkString) {
          if (stopped)
            return;
          if (err) {
            handleError(err, linkPath);
            pendEnd();
            return;
          }
          var fullPath = path.resolve(path.dirname(linkPath), linkString);
          emitter.emit("readlink", linkPath, fullPath);
          walkPath(fullPath, linkPath);
          pendEnd();
        });
      }
      function stop() {
        if (stopped)
          return;
        stopped = true;
        emitter.emit("stop");
      }
      function handleError(err, errPath) {
        if (!err || stopped)
          return;
        err.path = errPath;
        emitter.emit("error", err);
      }
      function pendStart() {
        pending += 1;
      }
      function pendEnd() {
        if (stopped)
          return;
        pending -= 1;
        if (pending === 0) {
          emitter.emit("end");
        } else if (pending < 0) {
          throw new Error("pendEnd called too many times");
        }
      }
    }
  }
});

// ../../node_modules/fast-xml-parser/src/util.js
var require_util = __commonJS({
  "../../node_modules/fast-xml-parser/src/util.js"(exports2) {
    "use strict";
    var getAllMatches = function(string, regex) {
      const matches = [];
      let match = regex.exec(string);
      while (match) {
        const allmatches = [];
        const len = match.length;
        for (let index = 0; index < len; index++) {
          allmatches.push(match[index]);
        }
        matches.push(allmatches);
        match = regex.exec(string);
      }
      return matches;
    };
    var doesMatch = function(string, regex) {
      const match = regex.exec(string);
      return !(match === null || typeof match === "undefined");
    };
    var doesNotMatch = function(string, regex) {
      return !doesMatch(string, regex);
    };
    exports2.isExist = function(v) {
      return typeof v !== "undefined";
    };
    exports2.isEmptyObject = function(obj) {
      return Object.keys(obj).length === 0;
    };
    exports2.merge = function(target, a) {
      if (a) {
        const keys = Object.keys(a);
        const len = keys.length;
        for (let i = 0; i < len; i++) {
          target[keys[i]] = a[keys[i]];
        }
      }
    };
    exports2.getValue = function(v) {
      if (exports2.isExist(v)) {
        return v;
      } else {
        return "";
      }
    };
    exports2.buildOptions = function(options2, defaultOptions, props) {
      var newOptions = {};
      if (!options2) {
        return defaultOptions;
      }
      for (let i = 0; i < props.length; i++) {
        if (options2[props[i]] !== void 0) {
          newOptions[props[i]] = options2[props[i]];
        } else {
          newOptions[props[i]] = defaultOptions[props[i]];
        }
      }
      return newOptions;
    };
    exports2.doesMatch = doesMatch;
    exports2.doesNotMatch = doesNotMatch;
    exports2.getAllMatches = getAllMatches;
  }
});

// ../../node_modules/fast-xml-parser/src/node2json.js
var require_node2json = __commonJS({
  "../../node_modules/fast-xml-parser/src/node2json.js"(exports2) {
    "use strict";
    var util = require_util();
    var convertToJson = function(node, options2) {
      const jObj = {};
      if ((!node.child || util.isEmptyObject(node.child)) && (!node.attrsMap || util.isEmptyObject(node.attrsMap))) {
        return util.isExist(node.val) ? node.val : "";
      } else {
        if (util.isExist(node.val)) {
          if (!(typeof node.val === "string" && (node.val === "" || node.val === options2.cdataPositionChar))) {
            jObj[options2.textNodeName] = node.val;
          }
        }
      }
      util.merge(jObj, node.attrsMap);
      const keys = Object.keys(node.child);
      for (let index = 0; index < keys.length; index++) {
        var tagname = keys[index];
        if (node.child[tagname] && node.child[tagname].length > 1) {
          jObj[tagname] = [];
          for (var tag in node.child[tagname]) {
            jObj[tagname].push(convertToJson(node.child[tagname][tag], options2));
          }
        } else {
          jObj[tagname] = convertToJson(node.child[tagname][0], options2);
        }
      }
      return jObj;
    };
    exports2.convertToJson = convertToJson;
  }
});

// ../../node_modules/fast-xml-parser/src/xmlNode.js
var require_xmlNode = __commonJS({
  "../../node_modules/fast-xml-parser/src/xmlNode.js"(exports2, module2) {
    "use strict";
    module2.exports = function(tagname, parent, val) {
      this.tagname = tagname;
      this.parent = parent;
      this.child = {};
      this.attrsMap = {};
      this.val = val;
      this.addChild = function(child) {
        if (Array.isArray(this.child[child.tagname])) {
          this.child[child.tagname].push(child);
        } else {
          this.child[child.tagname] = [child];
        }
      };
    };
  }
});

// ../../node_modules/fast-xml-parser/src/xmlstr2xmlnode.js
var require_xmlstr2xmlnode = __commonJS({
  "../../node_modules/fast-xml-parser/src/xmlstr2xmlnode.js"(exports2) {
    "use strict";
    var util = require_util();
    var buildOptions = require_util().buildOptions;
    var xmlNode = require_xmlNode();
    var TagType = { OPENING: 1, CLOSING: 2, SELF: 3, CDATA: 4 };
    var regx = "<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|(([\\w:\\-._]*:)?([\\w:\\-._]+))([^>]*)>|((\\/)(([\\w:\\-._]*:)?([\\w:\\-._]+))\\s*>))([^<]*)";
    if (!Number.parseInt && window.parseInt) {
      Number.parseInt = window.parseInt;
    }
    if (!Number.parseFloat && window.parseFloat) {
      Number.parseFloat = window.parseFloat;
    }
    var defaultOptions = {
      attributeNamePrefix: "@_",
      attrNodeName: false,
      textNodeName: "#text",
      ignoreAttributes: true,
      ignoreNameSpace: false,
      allowBooleanAttributes: false,
      parseNodeValue: true,
      parseAttributeValue: false,
      arrayMode: false,
      trimValues: true,
      cdataTagName: false,
      cdataPositionChar: "\\c",
      localeRange: "",
      tagValueProcessor: function(a) {
        return a;
      },
      attrValueProcessor: function(a) {
        return a;
      },
      stopNodes: []
    };
    exports2.defaultOptions = defaultOptions;
    var props = [
      "attributeNamePrefix",
      "attrNodeName",
      "textNodeName",
      "ignoreAttributes",
      "ignoreNameSpace",
      "allowBooleanAttributes",
      "parseNodeValue",
      "parseAttributeValue",
      "arrayMode",
      "trimValues",
      "cdataTagName",
      "cdataPositionChar",
      "localeRange",
      "tagValueProcessor",
      "attrValueProcessor",
      "parseTrueNumberOnly",
      "stopNodes"
    ];
    exports2.props = props;
    var getTraversalObj = function(xmlData, options2) {
      options2 = buildOptions(options2, defaultOptions, props);
      xmlData = xmlData.replace(/<!--[\s\S]*?-->/g, "");
      const xmlObj = new xmlNode("!xml");
      let currentNode = xmlObj;
      regx = regx.replace(/\[\\w/g, "[" + options2.localeRange + "\\w");
      const tagsRegx = new RegExp(regx, "g");
      let tag = tagsRegx.exec(xmlData);
      let nextTag = tagsRegx.exec(xmlData);
      while (tag) {
        const tagType = checkForTagType(tag);
        if (tagType === TagType.CLOSING) {
          if (currentNode.parent && tag[14]) {
            currentNode.parent.val = util.getValue(currentNode.parent.val) + "" + processTagValue(tag[14], options2);
          }
          if (options2.stopNodes.length && options2.stopNodes.includes(currentNode.tagname)) {
            currentNode.child = [];
            if (currentNode.attrsMap == void 0) {
              currentNode.attrsMap = {};
            }
            currentNode.val = xmlData.substr(currentNode.startIndex + 1, tag.index - currentNode.startIndex - 1);
          }
          currentNode = currentNode.parent;
        } else if (tagType === TagType.CDATA) {
          if (options2.cdataTagName) {
            const childNode = new xmlNode(options2.cdataTagName, currentNode, tag[3]);
            childNode.attrsMap = buildAttributesMap(tag[8], options2);
            currentNode.addChild(childNode);
            currentNode.val = util.getValue(currentNode.val) + options2.cdataPositionChar;
            if (tag[14]) {
              currentNode.val += processTagValue(tag[14], options2);
            }
          } else {
            currentNode.val = (currentNode.val || "") + (tag[3] || "") + processTagValue(tag[14], options2);
          }
        } else if (tagType === TagType.SELF) {
          if (currentNode && tag[14]) {
            currentNode.val = util.getValue(currentNode.val) + "" + processTagValue(tag[14], options2);
          }
          const childNode = new xmlNode(options2.ignoreNameSpace ? tag[7] : tag[5], currentNode, "");
          if (tag[8] && tag[8].length > 0) {
            tag[8] = tag[8].substr(0, tag[8].length - 1);
          }
          childNode.attrsMap = buildAttributesMap(tag[8], options2);
          currentNode.addChild(childNode);
        } else {
          const childNode = new xmlNode(options2.ignoreNameSpace ? tag[7] : tag[5], currentNode, processTagValue(tag[14], options2));
          if (options2.stopNodes.length && options2.stopNodes.includes(childNode.tagname)) {
            childNode.startIndex = tag.index + tag[1].length;
          }
          childNode.attrsMap = buildAttributesMap(tag[8], options2);
          currentNode.addChild(childNode);
          currentNode = childNode;
        }
        tag = nextTag;
        nextTag = tagsRegx.exec(xmlData);
      }
      return xmlObj;
    };
    function processTagValue(val, options2) {
      if (val) {
        if (options2.trimValues) {
          val = val.trim();
        }
        val = options2.tagValueProcessor(val);
        val = parseValue(val, options2.parseNodeValue, options2.parseTrueNumberOnly);
      }
      return val;
    }
    function checkForTagType(match) {
      if (match[4] === "]]>") {
        return TagType.CDATA;
      } else if (match[10] === "/") {
        return TagType.CLOSING;
      } else if (typeof match[8] !== "undefined" && match[8].substr(match[8].length - 1) === "/") {
        return TagType.SELF;
      } else {
        return TagType.OPENING;
      }
    }
    function resolveNameSpace(tagname, options2) {
      if (options2.ignoreNameSpace) {
        const tags = tagname.split(":");
        const prefix = tagname.charAt(0) === "/" ? "/" : "";
        if (tags[0] === "xmlns") {
          return "";
        }
        if (tags.length === 2) {
          tagname = prefix + tags[1];
        }
      }
      return tagname;
    }
    function parseValue(val, shouldParse, parseTrueNumberOnly) {
      if (shouldParse && typeof val === "string") {
        let parsed;
        if (val.trim() === "" || isNaN(val)) {
          parsed = val === "true" ? true : val === "false" ? false : val;
        } else {
          if (val.indexOf("0x") !== -1) {
            parsed = Number.parseInt(val, 16);
          } else if (val.indexOf(".") !== -1) {
            parsed = Number.parseFloat(val);
          } else {
            parsed = Number.parseInt(val, 10);
          }
          if (parseTrueNumberOnly) {
            parsed = String(parsed) === val ? parsed : val;
          }
        }
        return parsed;
      } else {
        if (util.isExist(val)) {
          return val;
        } else {
          return "";
        }
      }
    }
    var attrsRegx = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])(.*?)\\3)?`, "g");
    function buildAttributesMap(attrStr, options2) {
      if (!options2.ignoreAttributes && typeof attrStr === "string") {
        attrStr = attrStr.replace(/\r?\n/g, " ");
        const matches = util.getAllMatches(attrStr, attrsRegx);
        const len = matches.length;
        const attrs = {};
        for (let i = 0; i < len; i++) {
          const attrName = resolveNameSpace(matches[i][1], options2);
          if (attrName.length) {
            if (matches[i][4] !== void 0) {
              if (options2.trimValues) {
                matches[i][4] = matches[i][4].trim();
              }
              matches[i][4] = options2.attrValueProcessor(matches[i][4]);
              attrs[options2.attributeNamePrefix + attrName] = parseValue(matches[i][4], options2.parseAttributeValue, options2.parseTrueNumberOnly);
            } else if (options2.allowBooleanAttributes) {
              attrs[options2.attributeNamePrefix + attrName] = true;
            }
          }
        }
        if (!Object.keys(attrs).length) {
          return;
        }
        if (options2.attrNodeName) {
          const attrCollection = {};
          attrCollection[options2.attrNodeName] = attrs;
          return attrCollection;
        }
        return attrs;
      }
    }
    exports2.getTraversalObj = getTraversalObj;
  }
});

// ../../node_modules/fast-xml-parser/src/nimndata.js
var require_nimndata = __commonJS({
  "../../node_modules/fast-xml-parser/src/nimndata.js"(exports2) {
    "use strict";
    var char = function(a) {
      return String.fromCharCode(a);
    };
    var chars = {
      nilChar: char(176),
      missingChar: char(201),
      nilPremitive: char(175),
      missingPremitive: char(200),
      emptyChar: char(178),
      emptyValue: char(177),
      boundryChar: char(179),
      objStart: char(198),
      arrStart: char(204),
      arrayEnd: char(185)
    };
    var charsArr = [
      chars.nilChar,
      chars.nilPremitive,
      chars.missingChar,
      chars.missingPremitive,
      chars.boundryChar,
      chars.emptyChar,
      chars.emptyValue,
      chars.arrayEnd,
      chars.objStart,
      chars.arrStart
    ];
    var _e = function(node, e_schema, options2) {
      if (typeof e_schema === "string") {
        if (node && node[0] && node[0].val !== void 0) {
          return getValue(node[0].val, e_schema);
        } else {
          return getValue(node, e_schema);
        }
      } else {
        const hasValidData = hasData(node);
        if (hasValidData === true) {
          let str = "";
          if (Array.isArray(e_schema)) {
            str += chars.arrStart;
            const itemSchema = e_schema[0];
            const arr_len = node.length;
            if (typeof itemSchema === "string") {
              for (let arr_i = 0; arr_i < arr_len; arr_i++) {
                const r = getValue(node[arr_i].val, itemSchema);
                str = processValue(str, r);
              }
            } else {
              for (let arr_i = 0; arr_i < arr_len; arr_i++) {
                const r = _e(node[arr_i], itemSchema, options2);
                str = processValue(str, r);
              }
            }
            str += chars.arrayEnd;
          } else {
            str += chars.objStart;
            const keys = Object.keys(e_schema);
            if (Array.isArray(node)) {
              node = node[0];
            }
            for (let i in keys) {
              const key = keys[i];
              let r;
              if (!options2.ignoreAttributes && node.attrsMap && node.attrsMap[key]) {
                r = _e(node.attrsMap[key], e_schema[key], options2);
              } else if (key === options2.textNodeName) {
                r = _e(node.val, e_schema[key], options2);
              } else {
                r = _e(node.child[key], e_schema[key], options2);
              }
              str = processValue(str, r);
            }
          }
          return str;
        } else {
          return hasValidData;
        }
      }
    };
    var getValue = function(a) {
      switch (a) {
        case void 0:
          return chars.missingPremitive;
        case null:
          return chars.nilPremitive;
        case "":
          return chars.emptyValue;
        default:
          return a;
      }
    };
    var processValue = function(str, r) {
      if (!isAppChar(r[0]) && !isAppChar(str[str.length - 1])) {
        str += chars.boundryChar;
      }
      return str + r;
    };
    var isAppChar = function(ch) {
      return charsArr.indexOf(ch) !== -1;
    };
    function hasData(jObj) {
      if (jObj === void 0) {
        return chars.missingChar;
      } else if (jObj === null) {
        return chars.nilChar;
      } else if (jObj.child && Object.keys(jObj.child).length === 0 && (!jObj.attrsMap || Object.keys(jObj.attrsMap).length === 0)) {
        return chars.emptyChar;
      } else {
        return true;
      }
    }
    var x2j = require_xmlstr2xmlnode();
    var buildOptions = require_util().buildOptions;
    var convert2nimn = function(node, e_schema, options2) {
      options2 = buildOptions(options2, x2j.defaultOptions, x2j.props);
      return _e(node, e_schema, options2);
    };
    exports2.convert2nimn = convert2nimn;
  }
});

// ../../node_modules/fast-xml-parser/src/node2json_str.js
var require_node2json_str = __commonJS({
  "../../node_modules/fast-xml-parser/src/node2json_str.js"(exports2) {
    "use strict";
    var util = require_util();
    var buildOptions = require_util().buildOptions;
    var x2j = require_xmlstr2xmlnode();
    var convertToJsonString = function(node, options2) {
      options2 = buildOptions(options2, x2j.defaultOptions, x2j.props);
      options2.indentBy = options2.indentBy || "";
      return _cToJsonStr(node, options2, 0);
    };
    var _cToJsonStr = function(node, options2, level) {
      let jObj = "{";
      const keys = Object.keys(node.child);
      for (let index = 0; index < keys.length; index++) {
        var tagname = keys[index];
        if (node.child[tagname] && node.child[tagname].length > 1) {
          jObj += '"' + tagname + '" : [ ';
          for (var tag in node.child[tagname]) {
            jObj += _cToJsonStr(node.child[tagname][tag], options2) + " , ";
          }
          jObj = jObj.substr(0, jObj.length - 1) + " ] ";
        } else {
          jObj += '"' + tagname + '" : ' + _cToJsonStr(node.child[tagname][0], options2) + " ,";
        }
      }
      util.merge(jObj, node.attrsMap);
      if (util.isEmptyObject(jObj)) {
        return util.isExist(node.val) ? node.val : "";
      } else {
        if (util.isExist(node.val)) {
          if (!(typeof node.val === "string" && (node.val === "" || node.val === options2.cdataPositionChar))) {
            jObj += '"' + options2.textNodeName + '" : ' + stringval(node.val);
          }
        }
      }
      if (jObj[jObj.length - 1] === ",") {
        jObj = jObj.substr(0, jObj.length - 2);
      }
      return jObj + "}";
    };
    function stringval(v) {
      if (v === true || v === false || !isNaN(v)) {
        return v;
      } else {
        return '"' + v + '"';
      }
    }
    exports2.convertToJsonString = convertToJsonString;
  }
});

// ../../node_modules/fast-xml-parser/src/validator.js
var require_validator2 = __commonJS({
  "../../node_modules/fast-xml-parser/src/validator.js"(exports2) {
    "use strict";
    var util = require_util();
    var defaultOptions = {
      allowBooleanAttributes: false,
      localeRange: "a-zA-Z"
    };
    var props = ["allowBooleanAttributes", "localeRange"];
    exports2.validate = function(xmlData, options2) {
      options2 = util.buildOptions(options2, defaultOptions, props);
      const tags = [];
      let tagFound = false;
      if (xmlData[0] === "\uFEFF") {
        xmlData = xmlData.substr(1);
      }
      const regxAttrName = new RegExp("^[_w][\\w\\-.:]*$".replace("_w", "_" + options2.localeRange));
      const regxTagName = new RegExp("^([w]|_)[\\w.\\-_:]*".replace("([w", "([" + options2.localeRange));
      for (let i = 0; i < xmlData.length; i++) {
        if (xmlData[i] === "<") {
          i++;
          if (xmlData[i] === "?") {
            i = readPI(xmlData, ++i);
            if (i.err) {
              return i;
            }
          } else if (xmlData[i] === "!") {
            i = readCommentAndCDATA(xmlData, i);
            continue;
          } else {
            let closingTag = false;
            if (xmlData[i] === "/") {
              closingTag = true;
              i++;
            }
            let tagName = "";
            for (; i < xmlData.length && xmlData[i] !== ">" && xmlData[i] !== " " && xmlData[i] !== "	" && xmlData[i] !== "\n" && xmlData[i] !== "\r"; i++) {
              tagName += xmlData[i];
            }
            tagName = tagName.trim();
            if (tagName[tagName.length - 1] === "/") {
              tagName = tagName.substring(0, tagName.length - 1);
              continue;
            }
            if (!validateTagName(tagName, regxTagName)) {
              return { err: { code: "InvalidTag", msg: "Tag " + tagName + " is an invalid name." } };
            }
            const result2 = readAttributeStr(xmlData, i);
            if (result2 === false) {
              return { err: { code: "InvalidAttr", msg: "Attributes for " + tagName + " have open quote" } };
            }
            let attrStr = result2.value;
            i = result2.index;
            if (attrStr[attrStr.length - 1] === "/") {
              attrStr = attrStr.substring(0, attrStr.length - 1);
              const isValid = validateAttributeString(attrStr, options2, regxAttrName);
              if (isValid === true) {
                tagFound = true;
              } else {
                return isValid;
              }
            } else if (closingTag) {
              if (attrStr.trim().length > 0) {
                return {
                  err: { code: "InvalidTag", msg: "closing tag " + tagName + " can't have attributes or invalid starting." }
                };
              } else {
                const otg = tags.pop();
                if (tagName !== otg) {
                  return {
                    err: { code: "InvalidTag", msg: "closing tag " + otg + " is expected inplace of " + tagName + "." }
                  };
                }
              }
            } else {
              const isValid = validateAttributeString(attrStr, options2, regxAttrName);
              if (isValid !== true) {
                return isValid;
              }
              tags.push(tagName);
              tagFound = true;
            }
            for (i++; i < xmlData.length; i++) {
              if (xmlData[i] === "<") {
                if (xmlData[i + 1] === "!") {
                  i++;
                  i = readCommentAndCDATA(xmlData, i);
                  continue;
                } else {
                  break;
                }
              }
            }
            if (xmlData[i] === "<") {
              i--;
            }
          }
        } else {
          if (xmlData[i] === " " || xmlData[i] === "	" || xmlData[i] === "\n" || xmlData[i] === "\r") {
            continue;
          }
          return { err: { code: "InvalidChar", msg: "char " + xmlData[i] + " is not expected ." } };
        }
      }
      if (!tagFound) {
        return { err: { code: "InvalidXml", msg: "Start tag expected." } };
      } else if (tags.length > 0) {
        return {
          err: { code: "InvalidXml", msg: "Invalid " + JSON.stringify(tags, null, 4).replace(/\r?\n/g, "") + " found." }
        };
      }
      return true;
    };
    function readPI(xmlData, i) {
      var start = i;
      for (; i < xmlData.length; i++) {
        if (xmlData[i] == "?" || xmlData[i] == " ") {
          var tagname = xmlData.substr(start, i - start);
          if (i > 5 && tagname === "xml") {
            return { err: { code: "InvalidXml", msg: "XML declaration allowed only at the start of the document." } };
          } else if (xmlData[i] == "?" && xmlData[i + 1] == ">") {
            i++;
            break;
          } else {
            continue;
          }
        }
      }
      return i;
    }
    function readCommentAndCDATA(xmlData, i) {
      if (xmlData.length > i + 5 && xmlData[i + 1] === "-" && xmlData[i + 2] === "-") {
        for (i += 3; i < xmlData.length; i++) {
          if (xmlData[i] === "-" && xmlData[i + 1] === "-" && xmlData[i + 2] === ">") {
            i += 2;
            break;
          }
        }
      } else if (xmlData.length > i + 8 && xmlData[i + 1] === "D" && xmlData[i + 2] === "O" && xmlData[i + 3] === "C" && xmlData[i + 4] === "T" && xmlData[i + 5] === "Y" && xmlData[i + 6] === "P" && xmlData[i + 7] === "E") {
        let angleBracketsCount = 1;
        for (i += 8; i < xmlData.length; i++) {
          if (xmlData[i] === "<") {
            angleBracketsCount++;
          } else if (xmlData[i] === ">") {
            angleBracketsCount--;
            if (angleBracketsCount === 0) {
              break;
            }
          }
        }
      } else if (xmlData.length > i + 9 && xmlData[i + 1] === "[" && xmlData[i + 2] === "C" && xmlData[i + 3] === "D" && xmlData[i + 4] === "A" && xmlData[i + 5] === "T" && xmlData[i + 6] === "A" && xmlData[i + 7] === "[") {
        for (i += 8; i < xmlData.length; i++) {
          if (xmlData[i] === "]" && xmlData[i + 1] === "]" && xmlData[i + 2] === ">") {
            i += 2;
            break;
          }
        }
      }
      return i;
    }
    var doubleQuote = '"';
    var singleQuote = "'";
    function readAttributeStr(xmlData, i) {
      let attrStr = "";
      let startChar = "";
      for (; i < xmlData.length; i++) {
        if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {
          if (startChar === "") {
            startChar = xmlData[i];
          } else if (startChar !== xmlData[i]) {
            continue;
          } else {
            startChar = "";
          }
        } else if (xmlData[i] === ">") {
          if (startChar === "") {
            break;
          }
        }
        attrStr += xmlData[i];
      }
      if (startChar !== "") {
        return false;
      }
      return { value: attrStr, index: i };
    }
    var validAttrStrRegxp = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
    function validateAttributeString(attrStr, options2, regxAttrName) {
      const matches = util.getAllMatches(attrStr, validAttrStrRegxp);
      const attrNames = {};
      for (let i = 0; i < matches.length; i++) {
        if (matches[i][1].length === 0) {
          return { err: { code: "InvalidAttr", msg: "attribute " + matches[i][2] + " has no space in starting." } };
        } else if (matches[i][3] === void 0 && !options2.allowBooleanAttributes) {
          return { err: { code: "InvalidAttr", msg: "boolean attribute " + matches[i][2] + " is not allowed." } };
        }
        const attrName = matches[i][2];
        if (!validateAttrName(attrName, regxAttrName)) {
          return { err: { code: "InvalidAttr", msg: "attribute " + attrName + " is an invalid name." } };
        }
        if (!attrNames.hasOwnProperty(attrName)) {
          attrNames[attrName] = 1;
        } else {
          return { err: { code: "InvalidAttr", msg: "attribute " + attrName + " is repeated." } };
        }
      }
      return true;
    }
    function validateAttrName(attrName, regxAttrName) {
      return util.doesMatch(attrName, regxAttrName);
    }
    function validateTagName(tagname, regxTagName) {
      return !util.doesNotMatch(tagname, regxTagName);
    }
  }
});

// ../../node_modules/fast-xml-parser/src/json2xml.js
var require_json2xml = __commonJS({
  "../../node_modules/fast-xml-parser/src/json2xml.js"(exports2, module2) {
    "use strict";
    var buildOptions = require_util().buildOptions;
    var defaultOptions = {
      attributeNamePrefix: "@_",
      attrNodeName: false,
      textNodeName: "#text",
      ignoreAttributes: true,
      cdataTagName: false,
      cdataPositionChar: "\\c",
      format: false,
      indentBy: "  ",
      supressEmptyNode: false,
      tagValueProcessor: function(a) {
        return a;
      },
      attrValueProcessor: function(a) {
        return a;
      }
    };
    var props = [
      "attributeNamePrefix",
      "attrNodeName",
      "textNodeName",
      "ignoreAttributes",
      "cdataTagName",
      "cdataPositionChar",
      "format",
      "indentBy",
      "supressEmptyNode",
      "tagValueProcessor",
      "attrValueProcessor"
    ];
    function Parser(options2) {
      this.options = buildOptions(options2, defaultOptions, props);
      if (this.options.ignoreAttributes || this.options.attrNodeName) {
        this.isAttribute = function() {
          return false;
        };
      } else {
        this.attrPrefixLen = this.options.attributeNamePrefix.length;
        this.isAttribute = isAttribute;
      }
      if (this.options.cdataTagName) {
        this.isCDATA = isCDATA;
      } else {
        this.isCDATA = function() {
          return false;
        };
      }
      this.replaceCDATAstr = replaceCDATAstr;
      this.replaceCDATAarr = replaceCDATAarr;
      if (this.options.format) {
        this.indentate = indentate;
        this.tagEndChar = ">\n";
        this.newLine = "\n";
      } else {
        this.indentate = function() {
          return "";
        };
        this.tagEndChar = ">";
        this.newLine = "";
      }
      if (this.options.supressEmptyNode) {
        this.buildTextNode = buildEmptyTextNode;
        this.buildObjNode = buildEmptyObjNode;
      } else {
        this.buildTextNode = buildTextValNode;
        this.buildObjNode = buildObjectNode;
      }
      this.buildTextValNode = buildTextValNode;
      this.buildObjectNode = buildObjectNode;
    }
    Parser.prototype.parse = function(jObj) {
      return this.j2x(jObj, 0).val;
    };
    Parser.prototype.j2x = function(jObj, level) {
      let attrStr = "";
      let val = "";
      const keys = Object.keys(jObj);
      const len = keys.length;
      for (let i = 0; i < len; i++) {
        const key = keys[i];
        if (typeof jObj[key] === "undefined") {
        } else if (jObj[key] === null) {
          val += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
        } else if (jObj[key] instanceof Date) {
          val += this.buildTextNode(jObj[key], key, "", level);
        } else if (typeof jObj[key] !== "object") {
          const attr = this.isAttribute(key);
          if (attr) {
            attrStr += " " + attr + '="' + this.options.attrValueProcessor("" + jObj[key]) + '"';
          } else if (this.isCDATA(key)) {
            if (jObj[this.options.textNodeName]) {
              val += this.replaceCDATAstr(jObj[this.options.textNodeName], jObj[key]);
            } else {
              val += this.replaceCDATAstr("", jObj[key]);
            }
          } else {
            if (key === this.options.textNodeName) {
              if (jObj[this.options.cdataTagName]) {
              } else {
                val += this.options.tagValueProcessor("" + jObj[key]);
              }
            } else {
              val += this.buildTextNode(jObj[key], key, "", level);
            }
          }
        } else if (Array.isArray(jObj[key])) {
          if (this.isCDATA(key)) {
            val += this.indentate(level);
            if (jObj[this.options.textNodeName]) {
              val += this.replaceCDATAarr(jObj[this.options.textNodeName], jObj[key]);
            } else {
              val += this.replaceCDATAarr("", jObj[key]);
            }
          } else {
            const arrLen = jObj[key].length;
            for (let j = 0; j < arrLen; j++) {
              const item = jObj[key][j];
              if (typeof item === "undefined") {
              } else if (item === null) {
                val += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
              } else if (typeof item === "object") {
                const result2 = this.j2x(item, level + 1);
                val += this.buildObjNode(result2.val, key, result2.attrStr, level);
              } else {
                val += this.buildTextNode(item, key, "", level);
              }
            }
          }
        } else {
          if (this.options.attrNodeName && key === this.options.attrNodeName) {
            const Ks = Object.keys(jObj[key]);
            const L = Ks.length;
            for (let j = 0; j < L; j++) {
              attrStr += " " + Ks[j] + '="' + this.options.attrValueProcessor("" + jObj[key][Ks[j]]) + '"';
            }
          } else {
            const result2 = this.j2x(jObj[key], level + 1);
            val += this.buildObjNode(result2.val, key, result2.attrStr, level);
          }
        }
      }
      return { attrStr, val };
    };
    function replaceCDATAstr(str, cdata) {
      str = this.options.tagValueProcessor("" + str);
      if (this.options.cdataPositionChar === "" || str === "") {
        return str + "<![CDATA[" + cdata + "]]" + this.tagEndChar;
      } else {
        return str.replace(this.options.cdataPositionChar, "<![CDATA[" + cdata + "]]" + this.tagEndChar);
      }
    }
    function replaceCDATAarr(str, cdata) {
      str = this.options.tagValueProcessor("" + str);
      if (this.options.cdataPositionChar === "" || str === "") {
        return str + "<![CDATA[" + cdata.join("]]><![CDATA[") + "]]" + this.tagEndChar;
      } else {
        for (let v in cdata) {
          str = str.replace(this.options.cdataPositionChar, "<![CDATA[" + cdata[v] + "]]>");
        }
        return str + this.newLine;
      }
    }
    function buildObjectNode(val, key, attrStr, level) {
      if (attrStr && !val.includes("<")) {
        return this.indentate(level) + "<" + key + attrStr + ">" + val + "</" + key + this.tagEndChar;
      } else {
        return this.indentate(level) + "<" + key + attrStr + this.tagEndChar + val + this.indentate(level) + "</" + key + this.tagEndChar;
      }
    }
    function buildEmptyObjNode(val, key, attrStr, level) {
      if (val !== "") {
        return this.buildObjectNode(val, key, attrStr, level);
      } else {
        return this.indentate(level) + "<" + key + attrStr + "/" + this.tagEndChar;
      }
    }
    function buildTextValNode(val, key, attrStr, level) {
      return this.indentate(level) + "<" + key + attrStr + ">" + this.options.tagValueProcessor(val) + "</" + key + this.tagEndChar;
    }
    function buildEmptyTextNode(val, key, attrStr, level) {
      if (val !== "") {
        return this.buildTextValNode(val, key, attrStr, level);
      } else {
        return this.indentate(level) + "<" + key + attrStr + "/" + this.tagEndChar;
      }
    }
    function indentate(level) {
      return this.options.indentBy.repeat(level);
    }
    function isAttribute(name) {
      if (name.startsWith(this.options.attributeNamePrefix)) {
        return name.substr(this.attrPrefixLen);
      } else {
        return false;
      }
    }
    function isCDATA(name) {
      return name === this.options.cdataTagName;
    }
    module2.exports = Parser;
  }
});

// ../../node_modules/fast-xml-parser/src/parser.js
var require_parser2 = __commonJS({
  "../../node_modules/fast-xml-parser/src/parser.js"(exports2) {
    "use strict";
    var nodeToJson = require_node2json();
    var xmlToNodeobj = require_xmlstr2xmlnode();
    var x2xmlnode = require_xmlstr2xmlnode();
    var buildOptions = require_util().buildOptions;
    exports2.parse = function(xmlData, options2) {
      options2 = buildOptions(options2, x2xmlnode.defaultOptions, x2xmlnode.props);
      return nodeToJson.convertToJson(xmlToNodeobj.getTraversalObj(xmlData, options2), options2);
    };
    exports2.convertTonimn = require_nimndata().convert2nimn;
    exports2.getTraversalObj = xmlToNodeobj.getTraversalObj;
    exports2.convertToJson = nodeToJson.convertToJson;
    exports2.convertToJsonString = require_node2json_str().convertToJsonString;
    exports2.validate = require_validator2().validate;
    exports2.j2xParser = require_json2xml();
    exports2.parseToNimn = function(xmlData, schema, options2) {
      return exports2.convertTonimn(exports2.getTraversalObj(xmlData, options2), schema, options2);
    };
  }
});

// ../lib/sapux-spec/dist/application.js
var require_application = __commonJS({
  "../lib/sapux-spec/dist/application.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AppPomXmlArtifactIdPlaceholder = exports2.AppType = exports2.RootIntent = exports2.PageHeaderType = exports2.OdataVersion = exports2.FioriElementsVersion = void 0;
    var FioriElementsVersion;
    (function(FioriElementsVersion2) {
      FioriElementsVersion2["v2"] = "v2";
      FioriElementsVersion2["v4"] = "v4";
    })(FioriElementsVersion = exports2.FioriElementsVersion || (exports2.FioriElementsVersion = {}));
    var OdataVersion;
    (function(OdataVersion2) {
      OdataVersion2["v2"] = "v2";
      OdataVersion2["v4"] = "v4";
    })(OdataVersion = exports2.OdataVersion || (exports2.OdataVersion = {}));
    var PageHeaderType;
    (function(PageHeaderType2) {
      PageHeaderType2["Dynamic"] = "Dynamic";
    })(PageHeaderType = exports2.PageHeaderType || (exports2.PageHeaderType = {}));
    var RootIntent;
    (function(RootIntent2) {
      RootIntent2["listReportV2"] = "masterDetail-display";
      RootIntent2["listReportV4"] = "fe-lrop-v4";
      RootIntent2["ovp"] = "OVP-display";
    })(RootIntent = exports2.RootIntent || (exports2.RootIntent = {}));
    var AppType;
    (function(AppType2) {
      AppType2["FioriElement"] = "SAP Fiori elements";
      AppType2["UI5Freestyle"] = "SAPUI5 freestyle";
    })(AppType = exports2.AppType || (exports2.AppType = {}));
    exports2.AppPomXmlArtifactIdPlaceholder = `\${project.artifactId}`;
  }
});

// ../lib/sapux-spec/dist/controls/filterBar.js
var require_filterBar = __commonJS({
  "../lib/sapux-spec/dist/controls/filterBar.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../lib/sapux-spec/dist/controls/table.js
var require_table = __commonJS({
  "../lib/sapux-spec/dist/controls/table.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TableMode = exports2.HAlign = void 0;
    var HAlign;
    (function(HAlign2) {
      HAlign2["initial"] = "Initial";
      HAlign2["left"] = "Left";
      HAlign2["center"] = "Center";
      HAlign2["right"] = "Right";
      HAlign2["begin"] = "Begin";
      HAlign2["end"] = "End";
    })(HAlign = exports2.HAlign || (exports2.HAlign = {}));
    var TableMode;
    (function(TableMode2) {
      TableMode2["None"] = "None";
      TableMode2["SingleSelect"] = "SingleSelect";
      TableMode2["SingleSelectLeft"] = "SingleSelectLeft";
      TableMode2["SingleSelectMaster"] = "SingleSelectMaster";
      TableMode2["MultiSelect"] = "MultiSelect";
      TableMode2["Delete"] = "Delete";
    })(TableMode = exports2.TableMode || (exports2.TableMode = {}));
  }
});

// ../lib/sapux-spec/dist/controls/objectHeader.js
var require_objectHeader = __commonJS({
  "../lib/sapux-spec/dist/controls/objectHeader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../lib/sapux-spec/dist/controls/chart.js
var require_chart = __commonJS({
  "../lib/sapux-spec/dist/controls/chart.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../lib/sapux-spec/dist/controls/facets.js
var require_facets = __commonJS({
  "../lib/sapux-spec/dist/controls/facets.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../lib/sapux-spec/dist/controls/index.js
var require_controls = __commonJS({
  "../lib/sapux-spec/dist/controls/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_filterBar(), exports2);
    __exportStar(require_table(), exports2);
    __exportStar(require_objectHeader(), exports2);
    __exportStar(require_chart(), exports2);
    __exportStar(require_facets(), exports2);
  }
});

// ../lib/sapux-spec/dist/pages/page.js
var require_page = __commonJS({
  "../lib/sapux-spec/dist/pages/page.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PageType = void 0;
    var PageType;
    (function(PageType2) {
      PageType2["ObjectPage"] = "ObjectPage";
      PageType2["ListReport"] = "ListReport";
      PageType2["OverviewPage"] = "OverviewPage";
      PageType2["CustomPage"] = "CustomPage";
      PageType2["AnalyticalListPage"] = "AnalyticalListPage";
    })(PageType = exports2.PageType || (exports2.PageType = {}));
  }
});

// ../lib/sapux-spec/dist/pages/index.js
var require_pages = __commonJS({
  "../lib/sapux-spec/dist/pages/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_page(), exports2);
  }
});

// ../lib/sapux-spec/dist/webapp/controllers.js
var require_controllers = __commonJS({
  "../lib/sapux-spec/dist/webapp/controllers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../lib/sapux-spec/dist/webapp/flex.js
var require_flex = __commonJS({
  "../lib/sapux-spec/dist/webapp/flex.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../lib/sapux-spec/dist/webapp/manifest/sapUiGeneric.js
var require_sapUiGeneric = __commonJS({
  "../lib/sapux-spec/dist/webapp/manifest/sapUiGeneric.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../lib/sapux-spec/dist/webapp/manifest/sapUi5.js
var require_sapUi5 = __commonJS({
  "../lib/sapux-spec/dist/webapp/manifest/sapUi5.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ViewTypes = exports2.FlexibleColumnLayoutType = exports2.FlexibleColumnLayoutAggregations = exports2.FIORI_FCL_ROOT_ID = exports2.FIORI_FCL_ROOT_VIEW_NAME = exports2.FIORI_FCL_ROUTER_CLASS = void 0;
    exports2.FIORI_FCL_ROUTER_CLASS = "sap.f.routing.Router";
    exports2.FIORI_FCL_ROOT_VIEW_NAME = "sap.fe.templates.RootContainer.view.Fcl";
    exports2.FIORI_FCL_ROOT_ID = "appRootView";
    var FlexibleColumnLayoutAggregations;
    (function(FlexibleColumnLayoutAggregations2) {
      FlexibleColumnLayoutAggregations2["BeginColumnPages"] = "beginColumnPages";
      FlexibleColumnLayoutAggregations2["MidColumnPages"] = "midColumnPages";
      FlexibleColumnLayoutAggregations2["EndColumnPages"] = "endColumnPages";
    })(FlexibleColumnLayoutAggregations = exports2.FlexibleColumnLayoutAggregations || (exports2.FlexibleColumnLayoutAggregations = {}));
    var FlexibleColumnLayoutType;
    (function(FlexibleColumnLayoutType2) {
      FlexibleColumnLayoutType2["OneColumn"] = "OneColumn";
      FlexibleColumnLayoutType2["TwoColumnsBeginExpanded"] = "TwoColumnsBeginExpanded";
      FlexibleColumnLayoutType2["TwoColumnsMidExpanded"] = "TwoColumnsMidExpanded";
      FlexibleColumnLayoutType2["MidColumnFullScreen"] = "MidColumnFullScreen";
      FlexibleColumnLayoutType2["ThreeColumnsMidExpanded"] = "ThreeColumnsMidExpanded";
      FlexibleColumnLayoutType2["ThreeColumnsEndExpanded"] = "ThreeColumnsEndExpanded";
      FlexibleColumnLayoutType2["ThreeColumnsMidExpandedEndHidden"] = "ThreeColumnsMidExpandedEndHidden";
      FlexibleColumnLayoutType2["ThreeColumnsBeginExpandedEndHidden"] = "ThreeColumnsBeginExpandedEndHidden";
      FlexibleColumnLayoutType2["EndColumnFullScreen"] = "EndColumnFullScreen";
    })(FlexibleColumnLayoutType = exports2.FlexibleColumnLayoutType || (exports2.FlexibleColumnLayoutType = {}));
    var ViewTypes;
    (function(ViewTypes2) {
      ViewTypes2["XML"] = "XML";
      ViewTypes2["HTML"] = "HTML";
      ViewTypes2["JS"] = "JS";
      ViewTypes2["JSON"] = "JSON";
    })(ViewTypes = exports2.ViewTypes || (exports2.ViewTypes = {}));
  }
});

// ../lib/sapux-spec/dist/webapp/manifest/sapOvp.js
var require_sapOvp = __commonJS({
  "../lib/sapux-spec/dist/webapp/manifest/sapOvp.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../lib/sapux-spec/dist/webapp/manifest/index.js
var require_manifest = __commonJS({
  "../lib/sapux-spec/dist/webapp/manifest/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DataSourceType = void 0;
    __exportStar(require_sapUiGeneric(), exports2);
    __exportStar(require_sapUi5(), exports2);
    __exportStar(require_sapOvp(), exports2);
    var DataSourceType;
    (function(DataSourceType2) {
      DataSourceType2["OData"] = "OData";
      DataSourceType2["ODataAnnotation"] = "ODataAnnotation";
    })(DataSourceType = exports2.DataSourceType || (exports2.DataSourceType = {}));
  }
});

// ../lib/sapux-spec/dist/webapp/metadata.js
var require_metadata = __commonJS({
  "../lib/sapux-spec/dist/webapp/metadata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../lib/sapux-spec/dist/webapp/index.js
var require_webapp = __commonJS({
  "../lib/sapux-spec/dist/webapp/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_controllers(), exports2);
    __exportStar(require_flex(), exports2);
    __exportStar(require_manifest(), exports2);
    __exportStar(require_metadata(), exports2);
  }
});

// ../lib/sapux-spec/dist/constants.js
var require_constants = __commonJS({
  "../lib/sapux-spec/dist/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SchemeName = exports2.getFioriToolsDirectory = exports2.FioriToolsSettings = exports2.FileName = exports2.DirName = void 0;
    var os_1 = require("os");
    var path_1 = require("path");
    var DirName;
    (function(DirName2) {
      DirName2["Sapux"] = "src";
      DirName2["Schemas"] = ".schemas";
      DirName2["Pages"] = "pages";
      DirName2["Webapp"] = "webapp";
      DirName2["Temp"] = ".tmp";
      DirName2["Changes"] = "changes";
      DirName2["LocalService"] = "localService";
      DirName2["Controller"] = "controller";
      DirName2["View"] = "view";
      DirName2["Fragment"] = "fragment";
      DirName2["Ext"] = "ext";
      DirName2["VSCode"] = ".vscode";
      DirName2["AppConfig"] = "appconfig";
      DirName2["Db"] = "db";
      DirName2["Csv"] = "csv";
      DirName2["Data"] = "data";
      DirName2["Mockdata"] = "mockdata";
      DirName2["Dist"] = "dist";
    })(DirName = exports2.DirName || (exports2.DirName = {}));
    var FileName;
    (function(FileName2) {
      FileName2["Manifest"] = "manifest.json";
      FileName2["App"] = "app.json";
      FileName2["Package"] = "package.json";
      FileName2["ServiceMetadata"] = "metadata.xml";
      FileName2["NeoApp"] = "neo-app.json";
      FileName2["Pom"] = "pom.xml";
      FileName2["Fragment"] = "fragment.xml";
      FileName2["LaunchConfig"] = "launch.json";
      FileName2["ServiceCds"] = "services.cds";
      FileName2["IndexCds"] = "index.cds";
      FileName2["Ui5Yaml"] = "ui5.yaml";
      FileName2["Ui5LocalYaml"] = "ui5-local.yaml";
      FileName2["Ui5MockYaml"] = "ui5-mock.yaml";
      FileName2["Ui5DeployYaml"] = "ui5-deploy.yaml";
      FileName2["fioriSandboxConfig"] = "fioriSandboxConfig.json";
      FileName2["View"] = "view.xml";
    })(FileName = exports2.FileName || (exports2.FileName = {}));
    var FioriToolsSettings;
    (function(FioriToolsSettings2) {
      FioriToolsSettings2["dir"] = ".fioritools";
      FioriToolsSettings2["migrationSettingsFile"] = "migrationSettings.json";
    })(FioriToolsSettings = exports2.FioriToolsSettings || (exports2.FioriToolsSettings = {}));
    var getFioriToolsDirectory = () => {
      return path_1.join(os_1.homedir(), FioriToolsSettings.dir);
    };
    exports2.getFioriToolsDirectory = getFioriToolsDirectory;
    var SchemeName;
    (function(SchemeName2) {
      SchemeName2["Ftfs"] = "ftfs";
    })(SchemeName = exports2.SchemeName || (exports2.SchemeName = {}));
  }
});

// ../lib/sapux-spec/dist/package.js
var require_package5 = __commonJS({
  "../lib/sapux-spec/dist/package.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UI5FlexLayer = void 0;
    var UI5FlexLayer;
    (function(UI5FlexLayer2) {
      UI5FlexLayer2["VENDOR"] = "VENDOR";
      UI5FlexLayer2["CUSTOMER_BASE"] = "CUSTOMER_BASE";
    })(UI5FlexLayer = exports2.UI5FlexLayer || (exports2.UI5FlexLayer = {}));
  }
});

// ../lib/sapux-spec/dist/project.js
var require_project = __commonJS({
  "../lib/sapux-spec/dist/project.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DetailedProjectType = exports2.ProjectType = void 0;
    var ProjectType;
    (function(ProjectType2) {
      ProjectType2["Cap"] = "Cap";
      ProjectType2["Edmx"] = "Edmx";
    })(ProjectType = exports2.ProjectType || (exports2.ProjectType = {}));
    var DetailedProjectType;
    (function(DetailedProjectType2) {
      DetailedProjectType2["Edxm"] = "EDMX Backend";
      DetailedProjectType2["CAPNode"] = "CAP Node.js";
      DetailedProjectType2["CAPJava"] = "CAP Java";
    })(DetailedProjectType = exports2.DetailedProjectType || (exports2.DetailedProjectType = {}));
  }
});

// ../lib/sapux-spec/dist/index.js
var require_dist3 = __commonJS({
  "../lib/sapux-spec/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.location = void 0;
    __exportStar(require_application(), exports2);
    __exportStar(require_controls(), exports2);
    __exportStar(require_pages(), exports2);
    __exportStar(require_webapp(), exports2);
    __exportStar(require_constants(), exports2);
    __exportStar(require_package5(), exports2);
    __exportStar(require_project(), exports2);
    var location = () => {
      return __dirname.replace(/\\/g, "/");
    };
    exports2.location = location;
  }
});

// ../../node_modules/@sap/ux-specification/dist/src/specification/common/page.js
var require_page2 = __commonJS({
  "../../node_modules/@sap/ux-specification/dist/src/specification/common/page.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var PageType;
    (function(PageType2) {
      PageType2["ObjectPage"] = "ObjectPage";
      PageType2["ListReport"] = "ListReport";
      PageType2["OverviewPage"] = "OverviewPage";
      PageType2["CustomPage"] = "CustomPage";
      PageType2["AnalyticalListPage"] = "AnalyticalListPage";
    })(PageType = exports2.PageType || (exports2.PageType = {}));
    var PageTypeV4;
    (function(PageTypeV42) {
      PageTypeV42["ObjectPage"] = "ObjectPage";
      PageTypeV42["ListReport"] = "ListReport";
      PageTypeV42["CustomPage"] = "CustomPage";
      PageTypeV42["AnalyticalListPage"] = "AnalyticalListPage";
    })(PageTypeV4 = exports2.PageTypeV4 || (exports2.PageTypeV4 = {}));
    var FioriElementsVersion;
    (function(FioriElementsVersion2) {
      FioriElementsVersion2["v2"] = "v2";
      FioriElementsVersion2["v4"] = "v4";
    })(FioriElementsVersion = exports2.FioriElementsVersion || (exports2.FioriElementsVersion = {}));
    var OdataVersion;
    (function(OdataVersion2) {
      OdataVersion2["v2"] = "v2";
      OdataVersion2["v4"] = "v4";
    })(OdataVersion = exports2.OdataVersion || (exports2.OdataVersion = {}));
    exports2.PAGETYPE_VIEW_EXTENSION_TEMPLATE_MAP = /* @__PURE__ */ new Map([
      [PageType.ListReport, "sap.suite.ui.generic.template.ListReport.view.ListReport"],
      [PageType.AnalyticalListPage, "sap.suite.ui.generic.template.AnalyticalListPage.view.AnalyticalListPage"],
      [PageType.ObjectPage, "sap.suite.ui.generic.template.ObjectPage.view.Details"]
    ]);
  }
});

// ../../node_modules/p-try/index.js
var require_p_try = __commonJS({
  "../../node_modules/p-try/index.js"(exports2, module2) {
    "use strict";
    var pTry = (fn, ...arguments_) => new Promise((resolve) => {
      resolve(fn(...arguments_));
    });
    module2.exports = pTry;
    module2.exports.default = pTry;
  }
});

// ../../node_modules/p-limit/index.js
var require_p_limit = __commonJS({
  "../../node_modules/p-limit/index.js"(exports2, module2) {
    "use strict";
    var pTry = require_p_try();
    var pLimit = (concurrency) => {
      if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
        return Promise.reject(new TypeError("Expected `concurrency` to be a number from 1 and up"));
      }
      const queue = [];
      let activeCount = 0;
      const next = () => {
        activeCount--;
        if (queue.length > 0) {
          queue.shift()();
        }
      };
      const run = (fn, resolve, ...args) => {
        activeCount++;
        const result2 = pTry(fn, ...args);
        resolve(result2);
        result2.then(next, next);
      };
      const enqueue = (fn, resolve, ...args) => {
        if (activeCount < concurrency) {
          run(fn, resolve, ...args);
        } else {
          queue.push(run.bind(null, fn, resolve, ...args));
        }
      };
      const generator = (fn, ...args) => new Promise((resolve) => enqueue(fn, resolve, ...args));
      Object.defineProperties(generator, {
        activeCount: {
          get: () => activeCount
        },
        pendingCount: {
          get: () => queue.length
        },
        clearQueue: {
          value: () => {
            queue.length = 0;
          }
        }
      });
      return generator;
    };
    module2.exports = pLimit;
    module2.exports.default = pLimit;
  }
});

// ../../node_modules/p-locate/index.js
var require_p_locate = __commonJS({
  "../../node_modules/p-locate/index.js"(exports2, module2) {
    "use strict";
    var pLimit = require_p_limit();
    var EndError = class extends Error {
      constructor(value) {
        super();
        this.value = value;
      }
    };
    var testElement = async (element, tester) => tester(await element);
    var finder = async (element) => {
      const values = await Promise.all(element);
      if (values[1] === true) {
        throw new EndError(values[0]);
      }
      return false;
    };
    var pLocate = async (iterable, tester, options2) => {
      options2 = {
        concurrency: Infinity,
        preserveOrder: true,
        ...options2
      };
      const limit = pLimit(options2.concurrency);
      const items = [...iterable].map((element) => [element, limit(testElement, element, tester)]);
      const checkLimit = pLimit(options2.preserveOrder ? 1 : Infinity);
      try {
        await Promise.all(items.map((element) => checkLimit(finder, element)));
      } catch (error3) {
        if (error3 instanceof EndError) {
          return error3.value;
        }
        throw error3;
      }
    };
    module2.exports = pLocate;
    module2.exports.default = pLocate;
  }
});

// ../../node_modules/locate-path/index.js
var require_locate_path = __commonJS({
  "../../node_modules/locate-path/index.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var fs2 = require("fs");
    var { promisify } = require("util");
    var pLocate = require_p_locate();
    var fsStat = promisify(fs2.stat);
    var fsLStat = promisify(fs2.lstat);
    var typeMappings = {
      directory: "isDirectory",
      file: "isFile"
    };
    function checkType({ type }) {
      if (type in typeMappings) {
        return;
      }
      throw new Error(`Invalid type specified: ${type}`);
    }
    var matchType = (type, stat) => type === void 0 || stat[typeMappings[type]]();
    module2.exports = async (paths, options2) => {
      options2 = {
        cwd: process.cwd(),
        type: "file",
        allowSymlinks: true,
        ...options2
      };
      checkType(options2);
      const statFn = options2.allowSymlinks ? fsStat : fsLStat;
      return pLocate(paths, async (path_) => {
        try {
          const stat = await statFn(path.resolve(options2.cwd, path_));
          return matchType(options2.type, stat);
        } catch (_45) {
          return false;
        }
      }, options2);
    };
    module2.exports.sync = (paths, options2) => {
      options2 = {
        cwd: process.cwd(),
        allowSymlinks: true,
        type: "file",
        ...options2
      };
      checkType(options2);
      const statFn = options2.allowSymlinks ? fs2.statSync : fs2.lstatSync;
      for (const path_ of paths) {
        try {
          const stat = statFn(path.resolve(options2.cwd, path_));
          if (matchType(options2.type, stat)) {
            return path_;
          }
        } catch (_45) {
        }
      }
    };
  }
});

// ../../node_modules/path-exists/index.js
var require_path_exists = __commonJS({
  "../../node_modules/path-exists/index.js"(exports2, module2) {
    "use strict";
    var fs2 = require("fs");
    var { promisify } = require("util");
    var pAccess = promisify(fs2.access);
    module2.exports = async (path) => {
      try {
        await pAccess(path);
        return true;
      } catch (_45) {
        return false;
      }
    };
    module2.exports.sync = (path) => {
      try {
        fs2.accessSync(path);
        return true;
      } catch (_45) {
        return false;
      }
    };
  }
});

// ../../node_modules/find-up/index.js
var require_find_up = __commonJS({
  "../../node_modules/find-up/index.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var locatePath = require_locate_path();
    var pathExists = require_path_exists();
    var stop = Symbol("findUp.stop");
    module2.exports = async (name, options2 = {}) => {
      let directory = path.resolve(options2.cwd || "");
      const { root } = path.parse(directory);
      const paths = [].concat(name);
      const runMatcher = async (locateOptions) => {
        if (typeof name !== "function") {
          return locatePath(paths, locateOptions);
        }
        const foundPath = await name(locateOptions.cwd);
        if (typeof foundPath === "string") {
          return locatePath([foundPath], locateOptions);
        }
        return foundPath;
      };
      while (true) {
        const foundPath = await runMatcher({ ...options2, cwd: directory });
        if (foundPath === stop) {
          return;
        }
        if (foundPath) {
          return path.resolve(directory, foundPath);
        }
        if (directory === root) {
          return;
        }
        directory = path.dirname(directory);
      }
    };
    module2.exports.sync = (name, options2 = {}) => {
      let directory = path.resolve(options2.cwd || "");
      const { root } = path.parse(directory);
      const paths = [].concat(name);
      const runMatcher = (locateOptions) => {
        if (typeof name !== "function") {
          return locatePath.sync(paths, locateOptions);
        }
        const foundPath = name(locateOptions.cwd);
        if (typeof foundPath === "string") {
          return locatePath.sync([foundPath], locateOptions);
        }
        return foundPath;
      };
      while (true) {
        const foundPath = runMatcher({ ...options2, cwd: directory });
        if (foundPath === stop) {
          return;
        }
        if (foundPath) {
          return path.resolve(directory, foundPath);
        }
        if (directory === root) {
          return;
        }
        directory = path.dirname(directory);
      }
    };
    module2.exports.exists = pathExists;
    module2.exports.sync.exists = pathExists.sync;
    module2.exports.stop = stop;
  }
});

// ../../node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof2(obj) {
  "@babel/helpers - typeof";
  return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof2(obj);
}
var init_typeof = __esm({
  "../../node_modules/@babel/runtime/helpers/esm/typeof.js"() {
  }
});

// ../../node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var init_defineProperty = __esm({
  "../../node_modules/@babel/runtime/helpers/esm/defineProperty.js"() {
  }
});

// ../../node_modules/@babel/runtime/helpers/esm/objectSpread.js
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? Object(arguments[i]) : {};
    var ownKeys = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys.push.apply(ownKeys, Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys.forEach(function(key) {
      _defineProperty(target, key, source[key]);
    });
  }
  return target;
}
var init_objectSpread = __esm({
  "../../node_modules/@babel/runtime/helpers/esm/objectSpread.js"() {
    init_defineProperty();
  }
});

// ../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var init_classCallCheck = __esm({
  "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js"() {
  }
});

// ../../node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
var init_createClass = __esm({
  "../../node_modules/@babel/runtime/helpers/esm/createClass.js"() {
  }
});

// ../../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
var init_assertThisInitialized = __esm({
  "../../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js"() {
  }
});

// ../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof2(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
var init_possibleConstructorReturn = __esm({
  "../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js"() {
    init_typeof();
    init_assertThisInitialized();
  }
});

// ../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
var init_getPrototypeOf = __esm({
  "../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js"() {
  }
});

// ../../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
var init_setPrototypeOf = __esm({
  "../../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js"() {
  }
});

// ../../node_modules/@babel/runtime/helpers/esm/inherits.js
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
var init_inherits = __esm({
  "../../node_modules/@babel/runtime/helpers/esm/inherits.js"() {
    init_setPrototypeOf();
  }
});

// ../../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
var init_arrayLikeToArray = __esm({
  "../../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js"() {
  }
});

// ../../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
var init_arrayWithoutHoles = __esm({
  "../../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js"() {
    init_arrayLikeToArray();
  }
});

// ../../node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
var init_iterableToArray = __esm({
  "../../node_modules/@babel/runtime/helpers/esm/iterableToArray.js"() {
  }
});

// ../../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
var init_unsupportedIterableToArray = __esm({
  "../../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js"() {
    init_arrayLikeToArray();
  }
});

// ../../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var init_nonIterableSpread = __esm({
  "../../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js"() {
  }
});

// ../../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
var init_toConsumableArray = __esm({
  "../../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js"() {
    init_arrayWithoutHoles();
    init_iterableToArray();
    init_unsupportedIterableToArray();
    init_nonIterableSpread();
  }
});

// ../../node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
var init_arrayWithHoles = __esm({
  "../../node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js"() {
  }
});

// ../../node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
var init_iterableToArrayLimit = __esm({
  "../../node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js"() {
  }
});

// ../../node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var init_nonIterableRest = __esm({
  "../../node_modules/@babel/runtime/helpers/esm/nonIterableRest.js"() {
  }
});

// ../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
var init_slicedToArray = __esm({
  "../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js"() {
    init_arrayWithHoles();
    init_iterableToArrayLimit();
    init_unsupportedIterableToArray();
    init_nonIterableRest();
  }
});

// ../../node_modules/i18next/dist/esm/i18next.js
var i18next_exports = {};
__export(i18next_exports, {
  default: () => i18next_default
});
function defer() {
  var res;
  var rej;
  var promise = new Promise(function(resolve, reject) {
    res = resolve;
    rej = reject;
  });
  promise.resolve = res;
  promise.reject = rej;
  return promise;
}
function makeString(object) {
  if (object == null)
    return "";
  return "" + object;
}
function copy(a, s, t) {
  a.forEach(function(m) {
    if (s[m])
      t[m] = s[m];
  });
}
function getLastOfPath(object, path, Empty) {
  function cleanKey(key2) {
    return key2 && key2.indexOf("###") > -1 ? key2.replace(/###/g, ".") : key2;
  }
  function canNotTraverseDeeper() {
    return !object || typeof object === "string";
  }
  var stack = typeof path !== "string" ? [].concat(path) : path.split(".");
  while (stack.length > 1) {
    if (canNotTraverseDeeper())
      return {};
    var key = cleanKey(stack.shift());
    if (!object[key] && Empty)
      object[key] = new Empty();
    object = object[key];
  }
  if (canNotTraverseDeeper())
    return {};
  return {
    obj: object,
    k: cleanKey(stack.shift())
  };
}
function setPath(object, path, newValue) {
  var _getLastOfPath = getLastOfPath(object, path, Object), obj = _getLastOfPath.obj, k = _getLastOfPath.k;
  obj[k] = newValue;
}
function pushPath(object, path, newValue, concat) {
  var _getLastOfPath2 = getLastOfPath(object, path, Object), obj = _getLastOfPath2.obj, k = _getLastOfPath2.k;
  obj[k] = obj[k] || [];
  if (concat)
    obj[k] = obj[k].concat(newValue);
  if (!concat)
    obj[k].push(newValue);
}
function getPath(object, path) {
  var _getLastOfPath3 = getLastOfPath(object, path), obj = _getLastOfPath3.obj, k = _getLastOfPath3.k;
  if (!obj)
    return void 0;
  return obj[k];
}
function getPathWithDefaults(data2, defaultData, key) {
  var value = getPath(data2, key);
  if (value !== void 0) {
    return value;
  }
  return getPath(defaultData, key);
}
function deepExtend(target, source, overwrite) {
  for (var prop in source) {
    if (prop in target) {
      if (typeof target[prop] === "string" || target[prop] instanceof String || typeof source[prop] === "string" || source[prop] instanceof String) {
        if (overwrite)
          target[prop] = source[prop];
      } else {
        deepExtend(target[prop], source[prop], overwrite);
      }
    } else {
      target[prop] = source[prop];
    }
  }
  return target;
}
function regexEscape(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
function escape2(data2) {
  if (typeof data2 === "string") {
    return data2.replace(/[&<>"'\/]/g, function(s) {
      return _entityMap[s];
    });
  }
  return data2;
}
function capitalize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}
function createRules() {
  var rules = {};
  sets.forEach(function(set) {
    set.lngs.forEach(function(l) {
      rules[l] = {
        numbers: set.nr,
        plurals: _rulesPluralsTypes[set.fc]
      };
    });
  });
  return rules;
}
function remove(arr, what) {
  var found = arr.indexOf(what);
  while (found !== -1) {
    arr.splice(found, 1);
    found = arr.indexOf(what);
  }
}
function get() {
  return {
    debug: false,
    initImmediate: true,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: false,
    whitelist: false,
    nonExplicitWhitelist: false,
    load: "all",
    preload: false,
    simplifyPluralSuffix: true,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: false,
    saveMissing: false,
    updateMissing: false,
    saveMissingTo: "fallback",
    saveMissingPlurals: true,
    missingKeyHandler: false,
    missingInterpolationHandler: false,
    postProcess: false,
    postProcessPassResolved: false,
    returnNull: true,
    returnEmptyString: true,
    returnObjects: false,
    joinArrays: false,
    returnedObjectHandler: false,
    parseMissingKeyHandler: false,
    appendNamespaceToMissingKey: false,
    appendNamespaceToCIMode: false,
    overloadTranslationOptionHandler: function handle3(args) {
      var ret = {};
      if (_typeof2(args[1]) === "object")
        ret = args[1];
      if (typeof args[1] === "string")
        ret.defaultValue = args[1];
      if (typeof args[2] === "string")
        ret.tDescription = args[2];
      if (_typeof2(args[2]) === "object" || _typeof2(args[3]) === "object") {
        var options2 = args[3] || args[2];
        Object.keys(options2).forEach(function(key) {
          ret[key] = options2[key];
        });
      }
      return ret;
    },
    interpolation: {
      escapeValue: true,
      format: function format2(value, _format, lng) {
        return value;
      },
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      maxReplaces: 1e3
    }
  };
}
function transformOptions(options2) {
  if (typeof options2.ns === "string")
    options2.ns = [options2.ns];
  if (typeof options2.fallbackLng === "string")
    options2.fallbackLng = [options2.fallbackLng];
  if (typeof options2.fallbackNS === "string")
    options2.fallbackNS = [options2.fallbackNS];
  if (options2.whitelist && options2.whitelist.indexOf("cimode") < 0) {
    options2.whitelist = options2.whitelist.concat(["cimode"]);
  }
  return options2;
}
function noop() {
}
var consoleLogger, Logger, baseLogger, EventEmitter, _entityMap, ResourceStore, postProcessor, checkedLoadedFor, Translator, LanguageUtil, sets, _rulesPluralsTypes, PluralResolver, Interpolator, Connector, I18n, i18next, i18next_default;
var init_i18next = __esm({
  "../../node_modules/i18next/dist/esm/i18next.js"() {
    init_typeof();
    init_objectSpread();
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_assertThisInitialized();
    init_inherits();
    init_toConsumableArray();
    init_slicedToArray();
    consoleLogger = {
      type: "logger",
      log: function log(args) {
        this.output("log", args);
      },
      warn: function warn(args) {
        this.output("warn", args);
      },
      error: function error(args) {
        this.output("error", args);
      },
      output: function output(type, args) {
        var _console;
        if (console && console[type])
          (_console = console)[type].apply(_console, _toConsumableArray(args));
      }
    };
    Logger = /* @__PURE__ */ function() {
      function Logger3(concreteLogger) {
        var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        _classCallCheck(this, Logger3);
        this.init(concreteLogger, options2);
      }
      _createClass(Logger3, [{
        key: "init",
        value: function init(concreteLogger) {
          var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          this.prefix = options2.prefix || "i18next:";
          this.logger = concreteLogger || consoleLogger;
          this.options = options2;
          this.debug = options2.debug;
        }
      }, {
        key: "setDebug",
        value: function setDebug(bool) {
          this.debug = bool;
        }
      }, {
        key: "log",
        value: function log4() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return this.forward(args, "log", "", true);
        }
      }, {
        key: "warn",
        value: function warn3() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          return this.forward(args, "warn", "", true);
        }
      }, {
        key: "error",
        value: function error3() {
          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }
          return this.forward(args, "error", "");
        }
      }, {
        key: "deprecate",
        value: function deprecate() {
          for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            args[_key4] = arguments[_key4];
          }
          return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
        }
      }, {
        key: "forward",
        value: function forward(args, lvl, prefix, debugOnly) {
          if (debugOnly && !this.debug)
            return null;
          if (typeof args[0] === "string")
            args[0] = "".concat(prefix).concat(this.prefix, " ").concat(args[0]);
          return this.logger[lvl](args);
        }
      }, {
        key: "create",
        value: function create(moduleName) {
          return new Logger3(this.logger, _objectSpread({}, {
            prefix: "".concat(this.prefix, ":").concat(moduleName, ":")
          }, this.options));
        }
      }]);
      return Logger3;
    }();
    baseLogger = new Logger();
    EventEmitter = /* @__PURE__ */ function() {
      function EventEmitter3() {
        _classCallCheck(this, EventEmitter3);
        this.observers = {};
      }
      _createClass(EventEmitter3, [{
        key: "on",
        value: function on(events, listener) {
          var _this = this;
          events.split(" ").forEach(function(event) {
            _this.observers[event] = _this.observers[event] || [];
            _this.observers[event].push(listener);
          });
          return this;
        }
      }, {
        key: "off",
        value: function off(event, listener) {
          if (!this.observers[event])
            return;
          if (!listener) {
            delete this.observers[event];
            return;
          }
          this.observers[event] = this.observers[event].filter(function(l) {
            return l !== listener;
          });
        }
      }, {
        key: "emit",
        value: function emit(event) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          if (this.observers[event]) {
            var cloned = [].concat(this.observers[event]);
            cloned.forEach(function(observer) {
              observer.apply(void 0, args);
            });
          }
          if (this.observers["*"]) {
            var _cloned = [].concat(this.observers["*"]);
            _cloned.forEach(function(observer) {
              observer.apply(observer, [event].concat(args));
            });
          }
        }
      }]);
      return EventEmitter3;
    }();
    _entityMap = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;",
      "/": "&#x2F;"
    };
    ResourceStore = /* @__PURE__ */ function(_EventEmitter) {
      _inherits(ResourceStore3, _EventEmitter);
      function ResourceStore3(data2) {
        var _this;
        var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
          ns: ["translation"],
          defaultNS: "translation"
        };
        _classCallCheck(this, ResourceStore3);
        _this = _possibleConstructorReturn(this, _getPrototypeOf(ResourceStore3).call(this));
        EventEmitter.call(_assertThisInitialized(_this));
        _this.data = data2 || {};
        _this.options = options2;
        if (_this.options.keySeparator === void 0) {
          _this.options.keySeparator = ".";
        }
        return _this;
      }
      _createClass(ResourceStore3, [{
        key: "addNamespaces",
        value: function addNamespaces(ns) {
          if (this.options.ns.indexOf(ns) < 0) {
            this.options.ns.push(ns);
          }
        }
      }, {
        key: "removeNamespaces",
        value: function removeNamespaces(ns) {
          var index = this.options.ns.indexOf(ns);
          if (index > -1) {
            this.options.ns.splice(index, 1);
          }
        }
      }, {
        key: "getResource",
        value: function getResource(lng, ns, key) {
          var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
          var keySeparator = options2.keySeparator !== void 0 ? options2.keySeparator : this.options.keySeparator;
          var path = [lng, ns];
          if (key && typeof key !== "string")
            path = path.concat(key);
          if (key && typeof key === "string")
            path = path.concat(keySeparator ? key.split(keySeparator) : key);
          if (lng.indexOf(".") > -1) {
            path = lng.split(".");
          }
          return getPath(this.data, path);
        }
      }, {
        key: "addResource",
        value: function addResource(lng, ns, key, value) {
          var options2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
            silent: false
          };
          var keySeparator = this.options.keySeparator;
          if (keySeparator === void 0)
            keySeparator = ".";
          var path = [lng, ns];
          if (key)
            path = path.concat(keySeparator ? key.split(keySeparator) : key);
          if (lng.indexOf(".") > -1) {
            path = lng.split(".");
            value = ns;
            ns = path[1];
          }
          this.addNamespaces(ns);
          setPath(this.data, path, value);
          if (!options2.silent)
            this.emit("added", lng, ns, key, value);
        }
      }, {
        key: "addResources",
        value: function addResources(lng, ns, resources) {
          var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
            silent: false
          };
          for (var m in resources) {
            if (typeof resources[m] === "string" || Object.prototype.toString.apply(resources[m]) === "[object Array]")
              this.addResource(lng, ns, m, resources[m], {
                silent: true
              });
          }
          if (!options2.silent)
            this.emit("added", lng, ns, resources);
        }
      }, {
        key: "addResourceBundle",
        value: function addResourceBundle(lng, ns, resources, deep, overwrite) {
          var options2 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
            silent: false
          };
          var path = [lng, ns];
          if (lng.indexOf(".") > -1) {
            path = lng.split(".");
            deep = resources;
            resources = ns;
            ns = path[1];
          }
          this.addNamespaces(ns);
          var pack = getPath(this.data, path) || {};
          if (deep) {
            deepExtend(pack, resources, overwrite);
          } else {
            pack = _objectSpread({}, pack, resources);
          }
          setPath(this.data, path, pack);
          if (!options2.silent)
            this.emit("added", lng, ns, resources);
        }
      }, {
        key: "removeResourceBundle",
        value: function removeResourceBundle(lng, ns) {
          if (this.hasResourceBundle(lng, ns)) {
            delete this.data[lng][ns];
          }
          this.removeNamespaces(ns);
          this.emit("removed", lng, ns);
        }
      }, {
        key: "hasResourceBundle",
        value: function hasResourceBundle(lng, ns) {
          return this.getResource(lng, ns) !== void 0;
        }
      }, {
        key: "getResourceBundle",
        value: function getResourceBundle(lng, ns) {
          if (!ns)
            ns = this.options.defaultNS;
          if (this.options.compatibilityAPI === "v1")
            return _objectSpread({}, {}, this.getResource(lng, ns));
          return this.getResource(lng, ns);
        }
      }, {
        key: "getDataByLanguage",
        value: function getDataByLanguage(lng) {
          return this.data[lng];
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          return this.data;
        }
      }]);
      return ResourceStore3;
    }(EventEmitter);
    postProcessor = {
      processors: {},
      addPostProcessor: function addPostProcessor(module2) {
        this.processors[module2.name] = module2;
      },
      handle: function handle(processors, value, key, options2, translator) {
        var _this = this;
        processors.forEach(function(processor) {
          if (_this.processors[processor])
            value = _this.processors[processor].process(value, key, options2, translator);
        });
        return value;
      }
    };
    checkedLoadedFor = {};
    Translator = /* @__PURE__ */ function(_EventEmitter) {
      _inherits(Translator3, _EventEmitter);
      function Translator3(services) {
        var _this;
        var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        _classCallCheck(this, Translator3);
        _this = _possibleConstructorReturn(this, _getPrototypeOf(Translator3).call(this));
        EventEmitter.call(_assertThisInitialized(_this));
        copy(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, _assertThisInitialized(_this));
        _this.options = options2;
        if (_this.options.keySeparator === void 0) {
          _this.options.keySeparator = ".";
        }
        _this.logger = baseLogger.create("translator");
        return _this;
      }
      _createClass(Translator3, [{
        key: "changeLanguage",
        value: function changeLanguage(lng) {
          if (lng)
            this.language = lng;
        }
      }, {
        key: "exists",
        value: function exists(key) {
          var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
            interpolation: {}
          };
          var resolved = this.resolve(key, options2);
          return resolved && resolved.res !== void 0;
        }
      }, {
        key: "extractFromKey",
        value: function extractFromKey(key, options2) {
          var nsSeparator = options2.nsSeparator || this.options.nsSeparator;
          if (nsSeparator === void 0)
            nsSeparator = ":";
          var keySeparator = options2.keySeparator !== void 0 ? options2.keySeparator : this.options.keySeparator;
          var namespaces = options2.ns || this.options.defaultNS;
          if (nsSeparator && key.indexOf(nsSeparator) > -1) {
            var parts = key.split(nsSeparator);
            if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1)
              namespaces = parts.shift();
            key = parts.join(keySeparator);
          }
          if (typeof namespaces === "string")
            namespaces = [namespaces];
          return {
            key,
            namespaces
          };
        }
      }, {
        key: "translate",
        value: function translate(keys, options2) {
          var _this2 = this;
          if (_typeof2(options2) !== "object" && this.options.overloadTranslationOptionHandler) {
            options2 = this.options.overloadTranslationOptionHandler(arguments);
          }
          if (!options2)
            options2 = {};
          if (keys === void 0 || keys === null)
            return "";
          if (!Array.isArray(keys))
            keys = [String(keys)];
          var keySeparator = options2.keySeparator !== void 0 ? options2.keySeparator : this.options.keySeparator;
          var _this$extractFromKey = this.extractFromKey(keys[keys.length - 1], options2), key = _this$extractFromKey.key, namespaces = _this$extractFromKey.namespaces;
          var namespace = namespaces[namespaces.length - 1];
          var lng = options2.lng || this.language;
          var appendNamespaceToCIMode = options2.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
          if (lng && lng.toLowerCase() === "cimode") {
            if (appendNamespaceToCIMode) {
              var nsSeparator = options2.nsSeparator || this.options.nsSeparator;
              return namespace + nsSeparator + key;
            }
            return key;
          }
          var resolved = this.resolve(keys, options2);
          var res = resolved && resolved.res;
          var resUsedKey = resolved && resolved.usedKey || key;
          var resExactUsedKey = resolved && resolved.exactUsedKey || key;
          var resType = Object.prototype.toString.apply(res);
          var noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
          var joinArrays = options2.joinArrays !== void 0 ? options2.joinArrays : this.options.joinArrays;
          var handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
          var handleAsObject = typeof res !== "string" && typeof res !== "boolean" && typeof res !== "number";
          if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === "string" && resType === "[object Array]")) {
            if (!options2.returnObjects && !this.options.returnObjects) {
              this.logger.warn("accessing an object - but returnObjects options is not enabled!");
              return this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, options2) : "key '".concat(key, " (").concat(this.language, ")' returned an object instead of string.");
            }
            if (keySeparator) {
              var resTypeIsArray = resType === "[object Array]";
              var copy$$1 = resTypeIsArray ? [] : {};
              var newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
              for (var m in res) {
                if (Object.prototype.hasOwnProperty.call(res, m)) {
                  var deepKey = "".concat(newKeyToUse).concat(keySeparator).concat(m);
                  copy$$1[m] = this.translate(deepKey, _objectSpread({}, options2, {
                    joinArrays: false,
                    ns: namespaces
                  }));
                  if (copy$$1[m] === deepKey)
                    copy$$1[m] = res[m];
                }
              }
              res = copy$$1;
            }
          } else if (handleAsObjectInI18nFormat && typeof joinArrays === "string" && resType === "[object Array]") {
            res = res.join(joinArrays);
            if (res)
              res = this.extendTranslation(res, keys, options2);
          } else {
            var usedDefault = false;
            var usedKey = false;
            if (!this.isValidLookup(res) && options2.defaultValue !== void 0) {
              usedDefault = true;
              if (options2.count !== void 0) {
                var suffix = this.pluralResolver.getSuffix(lng, options2.count);
                res = options2["defaultValue".concat(suffix)];
              }
              if (!res)
                res = options2.defaultValue;
            }
            if (!this.isValidLookup(res)) {
              usedKey = true;
              res = key;
            }
            var updateMissing = options2.defaultValue && options2.defaultValue !== res && this.options.updateMissing;
            if (usedKey || usedDefault || updateMissing) {
              this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key, updateMissing ? options2.defaultValue : res);
              var lngs = [];
              var fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options2.lng || this.language);
              if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
                for (var i = 0; i < fallbackLngs.length; i++) {
                  lngs.push(fallbackLngs[i]);
                }
              } else if (this.options.saveMissingTo === "all") {
                lngs = this.languageUtils.toResolveHierarchy(options2.lng || this.language);
              } else {
                lngs.push(options2.lng || this.language);
              }
              var send = function send2(l, k) {
                if (_this2.options.missingKeyHandler) {
                  _this2.options.missingKeyHandler(l, namespace, k, updateMissing ? options2.defaultValue : res, updateMissing, options2);
                } else if (_this2.backendConnector && _this2.backendConnector.saveMissing) {
                  _this2.backendConnector.saveMissing(l, namespace, k, updateMissing ? options2.defaultValue : res, updateMissing, options2);
                }
                _this2.emit("missingKey", l, namespace, k, res);
              };
              if (this.options.saveMissing) {
                var needsPluralHandling = options2.count !== void 0 && typeof options2.count !== "string";
                if (this.options.saveMissingPlurals && needsPluralHandling) {
                  lngs.forEach(function(l) {
                    var plurals = _this2.pluralResolver.getPluralFormsOfKey(l, key);
                    plurals.forEach(function(p) {
                      return send([l], p);
                    });
                  });
                } else {
                  send(lngs, key);
                }
              }
            }
            res = this.extendTranslation(res, keys, options2, resolved);
            if (usedKey && res === key && this.options.appendNamespaceToMissingKey)
              res = "".concat(namespace, ":").concat(key);
            if (usedKey && this.options.parseMissingKeyHandler)
              res = this.options.parseMissingKeyHandler(res);
          }
          return res;
        }
      }, {
        key: "extendTranslation",
        value: function extendTranslation(res, key, options2, resolved) {
          var _this3 = this;
          if (this.i18nFormat && this.i18nFormat.parse) {
            res = this.i18nFormat.parse(res, options2, resolved.usedLng, resolved.usedNS, resolved.usedKey, {
              resolved
            });
          } else if (!options2.skipInterpolation) {
            if (options2.interpolation)
              this.interpolator.init(_objectSpread({}, options2, {
                interpolation: _objectSpread({}, this.options.interpolation, options2.interpolation)
              }));
            var data2 = options2.replace && typeof options2.replace !== "string" ? options2.replace : options2;
            if (this.options.interpolation.defaultVariables)
              data2 = _objectSpread({}, this.options.interpolation.defaultVariables, data2);
            res = this.interpolator.interpolate(res, data2, options2.lng || this.language, options2);
            if (options2.nest !== false)
              res = this.interpolator.nest(res, function() {
                return _this3.translate.apply(_this3, arguments);
              }, options2);
            if (options2.interpolation)
              this.interpolator.reset();
          }
          var postProcess = options2.postProcess || this.options.postProcess;
          var postProcessorNames = typeof postProcess === "string" ? [postProcess] : postProcess;
          if (res !== void 0 && res !== null && postProcessorNames && postProcessorNames.length && options2.applyPostProcessor !== false) {
            res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? _objectSpread({
              i18nResolved: resolved
            }, options2) : options2, this);
          }
          return res;
        }
      }, {
        key: "resolve",
        value: function resolve(keys) {
          var _this4 = this;
          var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var found;
          var usedKey;
          var exactUsedKey;
          var usedLng;
          var usedNS;
          if (typeof keys === "string")
            keys = [keys];
          keys.forEach(function(k) {
            if (_this4.isValidLookup(found))
              return;
            var extracted = _this4.extractFromKey(k, options2);
            var key = extracted.key;
            usedKey = key;
            var namespaces = extracted.namespaces;
            if (_this4.options.fallbackNS)
              namespaces = namespaces.concat(_this4.options.fallbackNS);
            var needsPluralHandling = options2.count !== void 0 && typeof options2.count !== "string";
            var needsContextHandling = options2.context !== void 0 && typeof options2.context === "string" && options2.context !== "";
            var codes = options2.lngs ? options2.lngs : _this4.languageUtils.toResolveHierarchy(options2.lng || _this4.language, options2.fallbackLng);
            namespaces.forEach(function(ns) {
              if (_this4.isValidLookup(found))
                return;
              usedNS = ns;
              if (!checkedLoadedFor["".concat(codes[0], "-").concat(ns)] && _this4.utils && _this4.utils.hasLoadedNamespace && !_this4.utils.hasLoadedNamespace(usedNS)) {
                checkedLoadedFor["".concat(codes[0], "-").concat(ns)] = true;
                _this4.logger.warn('key "'.concat(usedKey, '" for namespace "').concat(usedNS, '" for languages "').concat(codes.join(", "), `" won't get resolved as namespace was not yet loaded`), "This means something IS WRONG in your application setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
              }
              codes.forEach(function(code) {
                if (_this4.isValidLookup(found))
                  return;
                usedLng = code;
                var finalKey = key;
                var finalKeys = [finalKey];
                if (_this4.i18nFormat && _this4.i18nFormat.addLookupKeys) {
                  _this4.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options2);
                } else {
                  var pluralSuffix;
                  if (needsPluralHandling)
                    pluralSuffix = _this4.pluralResolver.getSuffix(code, options2.count);
                  if (needsPluralHandling && needsContextHandling)
                    finalKeys.push(finalKey + pluralSuffix);
                  if (needsContextHandling)
                    finalKeys.push(finalKey += "".concat(_this4.options.contextSeparator).concat(options2.context));
                  if (needsPluralHandling)
                    finalKeys.push(finalKey += pluralSuffix);
                }
                var possibleKey;
                while (possibleKey = finalKeys.pop()) {
                  if (!_this4.isValidLookup(found)) {
                    exactUsedKey = possibleKey;
                    found = _this4.getResource(code, ns, possibleKey, options2);
                  }
                }
              });
            });
          });
          return {
            res: found,
            usedKey,
            exactUsedKey,
            usedLng,
            usedNS
          };
        }
      }, {
        key: "isValidLookup",
        value: function isValidLookup(res) {
          return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
        }
      }, {
        key: "getResource",
        value: function getResource(code, ns, key) {
          var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
          if (this.i18nFormat && this.i18nFormat.getResource)
            return this.i18nFormat.getResource(code, ns, key, options2);
          return this.resourceStore.getResource(code, ns, key, options2);
        }
      }]);
      return Translator3;
    }(EventEmitter);
    LanguageUtil = /* @__PURE__ */ function() {
      function LanguageUtil3(options2) {
        _classCallCheck(this, LanguageUtil3);
        this.options = options2;
        this.whitelist = this.options.whitelist || false;
        this.logger = baseLogger.create("languageUtils");
      }
      _createClass(LanguageUtil3, [{
        key: "getScriptPartFromCode",
        value: function getScriptPartFromCode(code) {
          if (!code || code.indexOf("-") < 0)
            return null;
          var p = code.split("-");
          if (p.length === 2)
            return null;
          p.pop();
          return this.formatLanguageCode(p.join("-"));
        }
      }, {
        key: "getLanguagePartFromCode",
        value: function getLanguagePartFromCode(code) {
          if (!code || code.indexOf("-") < 0)
            return code;
          var p = code.split("-");
          return this.formatLanguageCode(p[0]);
        }
      }, {
        key: "formatLanguageCode",
        value: function formatLanguageCode(code) {
          if (typeof code === "string" && code.indexOf("-") > -1) {
            var specialCases = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
            var p = code.split("-");
            if (this.options.lowerCaseLng) {
              p = p.map(function(part) {
                return part.toLowerCase();
              });
            } else if (p.length === 2) {
              p[0] = p[0].toLowerCase();
              p[1] = p[1].toUpperCase();
              if (specialCases.indexOf(p[1].toLowerCase()) > -1)
                p[1] = capitalize(p[1].toLowerCase());
            } else if (p.length === 3) {
              p[0] = p[0].toLowerCase();
              if (p[1].length === 2)
                p[1] = p[1].toUpperCase();
              if (p[0] !== "sgn" && p[2].length === 2)
                p[2] = p[2].toUpperCase();
              if (specialCases.indexOf(p[1].toLowerCase()) > -1)
                p[1] = capitalize(p[1].toLowerCase());
              if (specialCases.indexOf(p[2].toLowerCase()) > -1)
                p[2] = capitalize(p[2].toLowerCase());
            }
            return p.join("-");
          }
          return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
        }
      }, {
        key: "isWhitelisted",
        value: function isWhitelisted(code) {
          if (this.options.load === "languageOnly" || this.options.nonExplicitWhitelist) {
            code = this.getLanguagePartFromCode(code);
          }
          return !this.whitelist || !this.whitelist.length || this.whitelist.indexOf(code) > -1;
        }
      }, {
        key: "getFallbackCodes",
        value: function getFallbackCodes(fallbacks, code) {
          if (!fallbacks)
            return [];
          if (typeof fallbacks === "string")
            fallbacks = [fallbacks];
          if (Object.prototype.toString.apply(fallbacks) === "[object Array]")
            return fallbacks;
          if (!code)
            return fallbacks["default"] || [];
          var found = fallbacks[code];
          if (!found)
            found = fallbacks[this.getScriptPartFromCode(code)];
          if (!found)
            found = fallbacks[this.formatLanguageCode(code)];
          if (!found)
            found = fallbacks["default"];
          return found || [];
        }
      }, {
        key: "toResolveHierarchy",
        value: function toResolveHierarchy(code, fallbackCode) {
          var _this = this;
          var fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
          var codes = [];
          var addCode = function addCode2(c) {
            if (!c)
              return;
            if (_this.isWhitelisted(c)) {
              codes.push(c);
            } else {
              _this.logger.warn("rejecting non-whitelisted language code: ".concat(c));
            }
          };
          if (typeof code === "string" && code.indexOf("-") > -1) {
            if (this.options.load !== "languageOnly")
              addCode(this.formatLanguageCode(code));
            if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly")
              addCode(this.getScriptPartFromCode(code));
            if (this.options.load !== "currentOnly")
              addCode(this.getLanguagePartFromCode(code));
          } else if (typeof code === "string") {
            addCode(this.formatLanguageCode(code));
          }
          fallbackCodes.forEach(function(fc) {
            if (codes.indexOf(fc) < 0)
              addCode(_this.formatLanguageCode(fc));
          });
          return codes;
        }
      }]);
      return LanguageUtil3;
    }();
    sets = [{
      lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "ti", "tr", "uz", "wa"],
      nr: [1, 2],
      fc: 1
    }, {
      lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
      nr: [1, 2],
      fc: 2
    }, {
      lngs: ["ay", "bo", "cgg", "fa", "id", "ja", "jbo", "ka", "kk", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
      nr: [1],
      fc: 3
    }, {
      lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
      nr: [1, 2, 5],
      fc: 4
    }, {
      lngs: ["ar"],
      nr: [0, 1, 2, 3, 11, 100],
      fc: 5
    }, {
      lngs: ["cs", "sk"],
      nr: [1, 2, 5],
      fc: 6
    }, {
      lngs: ["csb", "pl"],
      nr: [1, 2, 5],
      fc: 7
    }, {
      lngs: ["cy"],
      nr: [1, 2, 3, 8],
      fc: 8
    }, {
      lngs: ["fr"],
      nr: [1, 2],
      fc: 9
    }, {
      lngs: ["ga"],
      nr: [1, 2, 3, 7, 11],
      fc: 10
    }, {
      lngs: ["gd"],
      nr: [1, 2, 3, 20],
      fc: 11
    }, {
      lngs: ["is"],
      nr: [1, 2],
      fc: 12
    }, {
      lngs: ["jv"],
      nr: [0, 1],
      fc: 13
    }, {
      lngs: ["kw"],
      nr: [1, 2, 3, 4],
      fc: 14
    }, {
      lngs: ["lt"],
      nr: [1, 2, 10],
      fc: 15
    }, {
      lngs: ["lv"],
      nr: [1, 2, 0],
      fc: 16
    }, {
      lngs: ["mk"],
      nr: [1, 2],
      fc: 17
    }, {
      lngs: ["mnk"],
      nr: [0, 1, 2],
      fc: 18
    }, {
      lngs: ["mt"],
      nr: [1, 2, 11, 20],
      fc: 19
    }, {
      lngs: ["or"],
      nr: [2, 1],
      fc: 2
    }, {
      lngs: ["ro"],
      nr: [1, 2, 20],
      fc: 20
    }, {
      lngs: ["sl"],
      nr: [5, 1, 2, 3],
      fc: 21
    }, {
      lngs: ["he"],
      nr: [1, 2, 20, 21],
      fc: 22
    }];
    _rulesPluralsTypes = {
      1: function _(n) {
        return Number(n > 1);
      },
      2: function _2(n) {
        return Number(n != 1);
      },
      3: function _3(n) {
        return 0;
      },
      4: function _4(n) {
        return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
      },
      5: function _5(n) {
        return Number(n === 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5);
      },
      6: function _6(n) {
        return Number(n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2);
      },
      7: function _7(n) {
        return Number(n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
      },
      8: function _8(n) {
        return Number(n == 1 ? 0 : n == 2 ? 1 : n != 8 && n != 11 ? 2 : 3);
      },
      9: function _9(n) {
        return Number(n >= 2);
      },
      10: function _10(n) {
        return Number(n == 1 ? 0 : n == 2 ? 1 : n < 7 ? 2 : n < 11 ? 3 : 4);
      },
      11: function _11(n) {
        return Number(n == 1 || n == 11 ? 0 : n == 2 || n == 12 ? 1 : n > 2 && n < 20 ? 2 : 3);
      },
      12: function _12(n) {
        return Number(n % 10 != 1 || n % 100 == 11);
      },
      13: function _13(n) {
        return Number(n !== 0);
      },
      14: function _14(n) {
        return Number(n == 1 ? 0 : n == 2 ? 1 : n == 3 ? 2 : 3);
      },
      15: function _15(n) {
        return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
      },
      16: function _16(n) {
        return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n !== 0 ? 1 : 2);
      },
      17: function _17(n) {
        return Number(n == 1 || n % 10 == 1 ? 0 : 1);
      },
      18: function _18(n) {
        return Number(n == 0 ? 0 : n == 1 ? 1 : 2);
      },
      19: function _19(n) {
        return Number(n == 1 ? 0 : n === 0 || n % 100 > 1 && n % 100 < 11 ? 1 : n % 100 > 10 && n % 100 < 20 ? 2 : 3);
      },
      20: function _20(n) {
        return Number(n == 1 ? 0 : n === 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2);
      },
      21: function _21(n) {
        return Number(n % 100 == 1 ? 1 : n % 100 == 2 ? 2 : n % 100 == 3 || n % 100 == 4 ? 3 : 0);
      },
      22: function _22(n) {
        return Number(n === 1 ? 0 : n === 2 ? 1 : (n < 0 || n > 10) && n % 10 == 0 ? 2 : 3);
      }
    };
    PluralResolver = /* @__PURE__ */ function() {
      function PluralResolver3(languageUtils) {
        var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        _classCallCheck(this, PluralResolver3);
        this.languageUtils = languageUtils;
        this.options = options2;
        this.logger = baseLogger.create("pluralResolver");
        this.rules = createRules();
      }
      _createClass(PluralResolver3, [{
        key: "addRule",
        value: function addRule(lng, obj) {
          this.rules[lng] = obj;
        }
      }, {
        key: "getRule",
        value: function getRule(code) {
          return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
        }
      }, {
        key: "needsPlural",
        value: function needsPlural(code) {
          var rule = this.getRule(code);
          return rule && rule.numbers.length > 1;
        }
      }, {
        key: "getPluralFormsOfKey",
        value: function getPluralFormsOfKey(code, key) {
          var _this = this;
          var ret = [];
          var rule = this.getRule(code);
          if (!rule)
            return ret;
          rule.numbers.forEach(function(n) {
            var suffix = _this.getSuffix(code, n);
            ret.push("".concat(key).concat(suffix));
          });
          return ret;
        }
      }, {
        key: "getSuffix",
        value: function getSuffix(code, count) {
          var _this2 = this;
          var rule = this.getRule(code);
          if (rule) {
            var idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
            var suffix = rule.numbers[idx];
            if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
              if (suffix === 2) {
                suffix = "plural";
              } else if (suffix === 1) {
                suffix = "";
              }
            }
            var returnSuffix = function returnSuffix2() {
              return _this2.options.prepend && suffix.toString() ? _this2.options.prepend + suffix.toString() : suffix.toString();
            };
            if (this.options.compatibilityJSON === "v1") {
              if (suffix === 1)
                return "";
              if (typeof suffix === "number")
                return "_plural_".concat(suffix.toString());
              return returnSuffix();
            } else if (this.options.compatibilityJSON === "v2") {
              return returnSuffix();
            } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
              return returnSuffix();
            }
            return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
          }
          this.logger.warn("no plural rule found for: ".concat(code));
          return "";
        }
      }]);
      return PluralResolver3;
    }();
    Interpolator = /* @__PURE__ */ function() {
      function Interpolator3() {
        var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _classCallCheck(this, Interpolator3);
        this.logger = baseLogger.create("interpolator");
        this.options = options2;
        this.format = options2.interpolation && options2.interpolation.format || function(value) {
          return value;
        };
        this.init(options2);
      }
      _createClass(Interpolator3, [{
        key: "init",
        value: function init() {
          var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          if (!options2.interpolation)
            options2.interpolation = {
              escapeValue: true
            };
          var iOpts = options2.interpolation;
          this.escape = iOpts.escape !== void 0 ? iOpts.escape : escape2;
          this.escapeValue = iOpts.escapeValue !== void 0 ? iOpts.escapeValue : true;
          this.useRawValueToEscape = iOpts.useRawValueToEscape !== void 0 ? iOpts.useRawValueToEscape : false;
          this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || "{{";
          this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || "}}";
          this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
          this.unescapePrefix = iOpts.unescapeSuffix ? "" : iOpts.unescapePrefix || "-";
          this.unescapeSuffix = this.unescapePrefix ? "" : iOpts.unescapeSuffix || "";
          this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape("$t(");
          this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(")");
          this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1e3;
          this.resetRegExp();
        }
      }, {
        key: "reset",
        value: function reset() {
          if (this.options)
            this.init(this.options);
        }
      }, {
        key: "resetRegExp",
        value: function resetRegExp() {
          var regexpStr = "".concat(this.prefix, "(.+?)").concat(this.suffix);
          this.regexp = new RegExp(regexpStr, "g");
          var regexpUnescapeStr = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
          this.regexpUnescape = new RegExp(regexpUnescapeStr, "g");
          var nestingRegexpStr = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
          this.nestingRegexp = new RegExp(nestingRegexpStr, "g");
        }
      }, {
        key: "interpolate",
        value: function interpolate(str, data2, lng, options2) {
          var _this = this;
          var match;
          var value;
          var replaces;
          var defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
          function regexSafe(val) {
            return val.replace(/\$/g, "$$$$");
          }
          var handleFormat = function handleFormat2(key) {
            if (key.indexOf(_this.formatSeparator) < 0) {
              return getPathWithDefaults(data2, defaultData, key);
            }
            var p = key.split(_this.formatSeparator);
            var k = p.shift().trim();
            var f = p.join(_this.formatSeparator).trim();
            return _this.format(getPathWithDefaults(data2, defaultData, k), f, lng);
          };
          this.resetRegExp();
          var missingInterpolationHandler = options2 && options2.missingInterpolationHandler || this.options.missingInterpolationHandler;
          replaces = 0;
          while (match = this.regexpUnescape.exec(str)) {
            value = handleFormat(match[1].trim());
            if (value === void 0) {
              if (typeof missingInterpolationHandler === "function") {
                var temp = missingInterpolationHandler(str, match, options2);
                value = typeof temp === "string" ? temp : "";
              } else {
                this.logger.warn("missed to pass in variable ".concat(match[1], " for interpolating ").concat(str));
                value = "";
              }
            } else if (typeof value !== "string" && !this.useRawValueToEscape) {
              value = makeString(value);
            }
            str = str.replace(match[0], regexSafe(value));
            this.regexpUnescape.lastIndex = 0;
            replaces++;
            if (replaces >= this.maxReplaces) {
              break;
            }
          }
          replaces = 0;
          while (match = this.regexp.exec(str)) {
            value = handleFormat(match[1].trim());
            if (value === void 0) {
              if (typeof missingInterpolationHandler === "function") {
                var _temp = missingInterpolationHandler(str, match, options2);
                value = typeof _temp === "string" ? _temp : "";
              } else {
                this.logger.warn("missed to pass in variable ".concat(match[1], " for interpolating ").concat(str));
                value = "";
              }
            } else if (typeof value !== "string" && !this.useRawValueToEscape) {
              value = makeString(value);
            }
            value = this.escapeValue ? regexSafe(this.escape(value)) : regexSafe(value);
            str = str.replace(match[0], value);
            this.regexp.lastIndex = 0;
            replaces++;
            if (replaces >= this.maxReplaces) {
              break;
            }
          }
          return str;
        }
      }, {
        key: "nest",
        value: function nest(str, fc) {
          var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          var match;
          var value;
          var clonedOptions = _objectSpread({}, options2);
          clonedOptions.applyPostProcessor = false;
          delete clonedOptions.defaultValue;
          function handleHasOptions(key, inheritedOptions) {
            if (key.indexOf(",") < 0)
              return key;
            var p = key.split(",");
            key = p.shift();
            var optionsString = p.join(",");
            optionsString = this.interpolate(optionsString, clonedOptions);
            optionsString = optionsString.replace(/'/g, '"');
            try {
              clonedOptions = JSON.parse(optionsString);
              if (inheritedOptions)
                clonedOptions = _objectSpread({}, inheritedOptions, clonedOptions);
            } catch (e) {
              this.logger.error("failed parsing options string in nesting for key ".concat(key), e);
            }
            delete clonedOptions.defaultValue;
            return key;
          }
          while (match = this.nestingRegexp.exec(str)) {
            value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
            if (value && match[0] === str && typeof value !== "string")
              return value;
            if (typeof value !== "string")
              value = makeString(value);
            if (!value) {
              this.logger.warn("missed to resolve ".concat(match[1], " for nesting ").concat(str));
              value = "";
            }
            str = str.replace(match[0], value);
            this.regexp.lastIndex = 0;
          }
          return str;
        }
      }]);
      return Interpolator3;
    }();
    Connector = /* @__PURE__ */ function(_EventEmitter) {
      _inherits(Connector3, _EventEmitter);
      function Connector3(backend, store, services) {
        var _this;
        var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        _classCallCheck(this, Connector3);
        _this = _possibleConstructorReturn(this, _getPrototypeOf(Connector3).call(this));
        EventEmitter.call(_assertThisInitialized(_this));
        _this.backend = backend;
        _this.store = store;
        _this.services = services;
        _this.languageUtils = services.languageUtils;
        _this.options = options2;
        _this.logger = baseLogger.create("backendConnector");
        _this.state = {};
        _this.queue = [];
        if (_this.backend && _this.backend.init) {
          _this.backend.init(services, options2.backend, options2);
        }
        return _this;
      }
      _createClass(Connector3, [{
        key: "queueLoad",
        value: function queueLoad(languages, namespaces, options2, callback) {
          var _this2 = this;
          var toLoad = [];
          var pending = [];
          var toLoadLanguages = [];
          var toLoadNamespaces = [];
          languages.forEach(function(lng) {
            var hasAllNamespaces = true;
            namespaces.forEach(function(ns) {
              var name = "".concat(lng, "|").concat(ns);
              if (!options2.reload && _this2.store.hasResourceBundle(lng, ns)) {
                _this2.state[name] = 2;
              } else if (_this2.state[name] < 0)
                ;
              else if (_this2.state[name] === 1) {
                if (pending.indexOf(name) < 0)
                  pending.push(name);
              } else {
                _this2.state[name] = 1;
                hasAllNamespaces = false;
                if (pending.indexOf(name) < 0)
                  pending.push(name);
                if (toLoad.indexOf(name) < 0)
                  toLoad.push(name);
                if (toLoadNamespaces.indexOf(ns) < 0)
                  toLoadNamespaces.push(ns);
              }
            });
            if (!hasAllNamespaces)
              toLoadLanguages.push(lng);
          });
          if (toLoad.length || pending.length) {
            this.queue.push({
              pending,
              loaded: {},
              errors: [],
              callback
            });
          }
          return {
            toLoad,
            pending,
            toLoadLanguages,
            toLoadNamespaces
          };
        }
      }, {
        key: "loaded",
        value: function loaded(name, err, data2) {
          var _name$split = name.split("|"), _name$split2 = _slicedToArray(_name$split, 2), lng = _name$split2[0], ns = _name$split2[1];
          if (err)
            this.emit("failedLoading", lng, ns, err);
          if (data2) {
            this.store.addResourceBundle(lng, ns, data2);
          }
          this.state[name] = err ? -1 : 2;
          var loaded2 = {};
          this.queue.forEach(function(q) {
            pushPath(q.loaded, [lng], ns);
            remove(q.pending, name);
            if (err)
              q.errors.push(err);
            if (q.pending.length === 0 && !q.done) {
              Object.keys(q.loaded).forEach(function(l) {
                if (!loaded2[l])
                  loaded2[l] = [];
                if (q.loaded[l].length) {
                  q.loaded[l].forEach(function(ns2) {
                    if (loaded2[l].indexOf(ns2) < 0)
                      loaded2[l].push(ns2);
                  });
                }
              });
              q.done = true;
              if (q.errors.length) {
                q.callback(q.errors);
              } else {
                q.callback();
              }
            }
          });
          this.emit("loaded", loaded2);
          this.queue = this.queue.filter(function(q) {
            return !q.done;
          });
        }
      }, {
        key: "read",
        value: function read(lng, ns, fcName) {
          var _this3 = this;
          var tried = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
          var wait = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 250;
          var callback = arguments.length > 5 ? arguments[5] : void 0;
          if (!lng.length)
            return callback(null, {});
          return this.backend[fcName](lng, ns, function(err, data2) {
            if (err && data2 && tried < 5) {
              setTimeout(function() {
                _this3.read.call(_this3, lng, ns, fcName, tried + 1, wait * 2, callback);
              }, wait);
              return;
            }
            callback(err, data2);
          });
        }
      }, {
        key: "prepareLoading",
        value: function prepareLoading(languages, namespaces) {
          var _this4 = this;
          var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          var callback = arguments.length > 3 ? arguments[3] : void 0;
          if (!this.backend) {
            this.logger.warn("No backend was added via i18next.use. Will not load resources.");
            return callback && callback();
          }
          if (typeof languages === "string")
            languages = this.languageUtils.toResolveHierarchy(languages);
          if (typeof namespaces === "string")
            namespaces = [namespaces];
          var toLoad = this.queueLoad(languages, namespaces, options2, callback);
          if (!toLoad.toLoad.length) {
            if (!toLoad.pending.length)
              callback();
            return null;
          }
          toLoad.toLoad.forEach(function(name) {
            _this4.loadOne(name);
          });
        }
      }, {
        key: "load",
        value: function load(languages, namespaces, callback) {
          this.prepareLoading(languages, namespaces, {}, callback);
        }
      }, {
        key: "reload",
        value: function reload(languages, namespaces, callback) {
          this.prepareLoading(languages, namespaces, {
            reload: true
          }, callback);
        }
      }, {
        key: "loadOne",
        value: function loadOne(name) {
          var _this5 = this;
          var prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
          var _name$split3 = name.split("|"), _name$split4 = _slicedToArray(_name$split3, 2), lng = _name$split4[0], ns = _name$split4[1];
          this.read(lng, ns, "read", null, null, function(err, data2) {
            if (err)
              _this5.logger.warn("".concat(prefix, "loading namespace ").concat(ns, " for language ").concat(lng, " failed"), err);
            if (!err && data2)
              _this5.logger.log("".concat(prefix, "loaded namespace ").concat(ns, " for language ").concat(lng), data2);
            _this5.loaded(name, err, data2);
          });
        }
      }, {
        key: "saveMissing",
        value: function saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
          var options2 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
          if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
            this.logger.warn('did not save key "'.concat(key, '" for namespace "').concat(namespace, '" as the namespace was not yet loaded'), "This means something IS WRONG in your application setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
            return;
          }
          if (key === void 0 || key === null || key === "")
            return;
          if (this.backend && this.backend.create) {
            this.backend.create(languages, namespace, key, fallbackValue, null, _objectSpread({}, options2, {
              isUpdate
            }));
          }
          if (!languages || !languages[0])
            return;
          this.store.addResource(languages[0], namespace, key, fallbackValue);
        }
      }]);
      return Connector3;
    }(EventEmitter);
    I18n = /* @__PURE__ */ function(_EventEmitter) {
      _inherits(I18n3, _EventEmitter);
      function I18n3() {
        var _this;
        var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var callback = arguments.length > 1 ? arguments[1] : void 0;
        _classCallCheck(this, I18n3);
        _this = _possibleConstructorReturn(this, _getPrototypeOf(I18n3).call(this));
        EventEmitter.call(_assertThisInitialized(_this));
        _this.options = transformOptions(options2);
        _this.services = {};
        _this.logger = baseLogger;
        _this.modules = {
          external: []
        };
        if (callback && !_this.isInitialized && !options2.isClone) {
          if (!_this.options.initImmediate) {
            _this.init(options2, callback);
            return _possibleConstructorReturn(_this, _assertThisInitialized(_this));
          }
          setTimeout(function() {
            _this.init(options2, callback);
          }, 0);
        }
        return _this;
      }
      _createClass(I18n3, [{
        key: "init",
        value: function init() {
          var _this2 = this;
          var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var callback = arguments.length > 1 ? arguments[1] : void 0;
          if (typeof options2 === "function") {
            callback = options2;
            options2 = {};
          }
          this.options = _objectSpread({}, get(), this.options, transformOptions(options2));
          this.format = this.options.interpolation.format;
          if (!callback)
            callback = noop;
          function createClassOnDemand(ClassOrObject) {
            if (!ClassOrObject)
              return null;
            if (typeof ClassOrObject === "function")
              return new ClassOrObject();
            return ClassOrObject;
          }
          if (!this.options.isClone) {
            if (this.modules.logger) {
              baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
            } else {
              baseLogger.init(null, this.options);
            }
            var lu = new LanguageUtil(this.options);
            this.store = new ResourceStore(this.options.resources, this.options);
            var s = this.services;
            s.logger = baseLogger;
            s.resourceStore = this.store;
            s.languageUtils = lu;
            s.pluralResolver = new PluralResolver(lu, {
              prepend: this.options.pluralSeparator,
              compatibilityJSON: this.options.compatibilityJSON,
              simplifyPluralSuffix: this.options.simplifyPluralSuffix
            });
            s.interpolator = new Interpolator(this.options);
            s.utils = {
              hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
            };
            s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);
            s.backendConnector.on("*", function(event) {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              _this2.emit.apply(_this2, [event].concat(args));
            });
            if (this.modules.languageDetector) {
              s.languageDetector = createClassOnDemand(this.modules.languageDetector);
              s.languageDetector.init(s, this.options.detection, this.options);
            }
            if (this.modules.i18nFormat) {
              s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
              if (s.i18nFormat.init)
                s.i18nFormat.init(this);
            }
            this.translator = new Translator(this.services, this.options);
            this.translator.on("*", function(event) {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              _this2.emit.apply(_this2, [event].concat(args));
            });
            this.modules.external.forEach(function(m) {
              if (m.init)
                m.init(_this2);
            });
          }
          var storeApi = ["getResource", "addResource", "addResources", "addResourceBundle", "removeResourceBundle", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
          storeApi.forEach(function(fcName) {
            _this2[fcName] = function() {
              var _this2$store;
              return (_this2$store = _this2.store)[fcName].apply(_this2$store, arguments);
            };
          });
          var deferred = defer();
          var load = function load2() {
            _this2.changeLanguage(_this2.options.lng, function(err, t) {
              _this2.isInitialized = true;
              _this2.logger.log("initialized", _this2.options);
              _this2.emit("initialized", _this2.options);
              deferred.resolve(t);
              callback(err, t);
            });
          };
          if (this.options.resources || !this.options.initImmediate) {
            load();
          } else {
            setTimeout(load, 0);
          }
          return deferred;
        }
      }, {
        key: "loadResources",
        value: function loadResources(language) {
          var _this3 = this;
          var callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop;
          var usedCallback = callback;
          var usedLng = typeof language === "string" ? language : this.language;
          if (typeof language === "function")
            usedCallback = language;
          if (!this.options.resources || this.options.partialBundledLanguages) {
            if (usedLng && usedLng.toLowerCase() === "cimode")
              return usedCallback();
            var toLoad = [];
            var append = function append2(lng) {
              if (!lng)
                return;
              var lngs = _this3.services.languageUtils.toResolveHierarchy(lng);
              lngs.forEach(function(l) {
                if (toLoad.indexOf(l) < 0)
                  toLoad.push(l);
              });
            };
            if (!usedLng) {
              var fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
              fallbacks.forEach(function(l) {
                return append(l);
              });
            } else {
              append(usedLng);
            }
            if (this.options.preload) {
              this.options.preload.forEach(function(l) {
                return append(l);
              });
            }
            this.services.backendConnector.load(toLoad, this.options.ns, usedCallback);
          } else {
            usedCallback(null);
          }
        }
      }, {
        key: "reloadResources",
        value: function reloadResources(lngs, ns, callback) {
          var deferred = defer();
          if (!lngs)
            lngs = this.languages;
          if (!ns)
            ns = this.options.ns;
          if (!callback)
            callback = noop;
          this.services.backendConnector.reload(lngs, ns, function(err) {
            deferred.resolve();
            callback(err);
          });
          return deferred;
        }
      }, {
        key: "use",
        value: function use(module2) {
          if (module2.type === "backend") {
            this.modules.backend = module2;
          }
          if (module2.type === "logger" || module2.log && module2.warn && module2.error) {
            this.modules.logger = module2;
          }
          if (module2.type === "languageDetector") {
            this.modules.languageDetector = module2;
          }
          if (module2.type === "i18nFormat") {
            this.modules.i18nFormat = module2;
          }
          if (module2.type === "postProcessor") {
            postProcessor.addPostProcessor(module2);
          }
          if (module2.type === "3rdParty") {
            this.modules.external.push(module2);
          }
          return this;
        }
      }, {
        key: "changeLanguage",
        value: function changeLanguage(lng, callback) {
          var _this4 = this;
          this.isLanguageChangingTo = lng;
          var deferred = defer();
          this.emit("languageChanging", lng);
          var done = function done2(err, l) {
            if (l) {
              _this4.language = l;
              _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l);
              _this4.translator.changeLanguage(l);
              _this4.isLanguageChangingTo = void 0;
              _this4.emit("languageChanged", l);
              _this4.logger.log("languageChanged", l);
            } else {
              _this4.isLanguageChangingTo = void 0;
            }
            deferred.resolve(function() {
              return _this4.t.apply(_this4, arguments);
            });
            if (callback)
              callback(err, function() {
                return _this4.t.apply(_this4, arguments);
              });
          };
          var setLng = function setLng2(l) {
            if (l) {
              if (!_this4.language) {
                _this4.language = l;
                _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l);
              }
              if (!_this4.translator.language)
                _this4.translator.changeLanguage(l);
              if (_this4.services.languageDetector)
                _this4.services.languageDetector.cacheUserLanguage(l);
            }
            _this4.loadResources(l, function(err) {
              done(err, l);
            });
          };
          if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
            setLng(this.services.languageDetector.detect());
          } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
            this.services.languageDetector.detect(setLng);
          } else {
            setLng(lng);
          }
          return deferred;
        }
      }, {
        key: "getFixedT",
        value: function getFixedT(lng, ns) {
          var _this5 = this;
          var fixedT = function fixedT2(key, opts) {
            var options2;
            if (_typeof2(opts) !== "object") {
              for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
                rest[_key3 - 2] = arguments[_key3];
              }
              options2 = _this5.options.overloadTranslationOptionHandler([key, opts].concat(rest));
            } else {
              options2 = _objectSpread({}, opts);
            }
            options2.lng = options2.lng || fixedT2.lng;
            options2.lngs = options2.lngs || fixedT2.lngs;
            options2.ns = options2.ns || fixedT2.ns;
            return _this5.t(key, options2);
          };
          if (typeof lng === "string") {
            fixedT.lng = lng;
          } else {
            fixedT.lngs = lng;
          }
          fixedT.ns = ns;
          return fixedT;
        }
      }, {
        key: "t",
        value: function t() {
          var _this$translator;
          return this.translator && (_this$translator = this.translator).translate.apply(_this$translator, arguments);
        }
      }, {
        key: "exists",
        value: function exists() {
          var _this$translator2;
          return this.translator && (_this$translator2 = this.translator).exists.apply(_this$translator2, arguments);
        }
      }, {
        key: "setDefaultNamespace",
        value: function setDefaultNamespace(ns) {
          this.options.defaultNS = ns;
        }
      }, {
        key: "hasLoadedNamespace",
        value: function hasLoadedNamespace(ns) {
          var _this6 = this;
          if (!this.isInitialized) {
            this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
            return false;
          }
          if (!this.languages || !this.languages.length) {
            this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
            return false;
          }
          var lng = this.languages[0];
          var fallbackLng = this.options ? this.options.fallbackLng : false;
          var lastLng = this.languages[this.languages.length - 1];
          if (lng.toLowerCase() === "cimode")
            return true;
          var loadNotPending = function loadNotPending2(l, n) {
            var loadState = _this6.services.backendConnector.state["".concat(l, "|").concat(n)];
            return loadState === -1 || loadState === 2;
          };
          if (this.hasResourceBundle(lng, ns))
            return true;
          if (!this.services.backendConnector.backend)
            return true;
          if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns)))
            return true;
          return false;
        }
      }, {
        key: "loadNamespaces",
        value: function loadNamespaces(ns, callback) {
          var _this7 = this;
          var deferred = defer();
          if (!this.options.ns) {
            callback && callback();
            return Promise.resolve();
          }
          if (typeof ns === "string")
            ns = [ns];
          ns.forEach(function(n) {
            if (_this7.options.ns.indexOf(n) < 0)
              _this7.options.ns.push(n);
          });
          this.loadResources(function(err) {
            deferred.resolve();
            if (callback)
              callback(err);
          });
          return deferred;
        }
      }, {
        key: "loadLanguages",
        value: function loadLanguages(lngs, callback) {
          var deferred = defer();
          if (typeof lngs === "string")
            lngs = [lngs];
          var preloaded = this.options.preload || [];
          var newLngs = lngs.filter(function(lng) {
            return preloaded.indexOf(lng) < 0;
          });
          if (!newLngs.length) {
            if (callback)
              callback();
            return Promise.resolve();
          }
          this.options.preload = preloaded.concat(newLngs);
          this.loadResources(function(err) {
            deferred.resolve();
            if (callback)
              callback(err);
          });
          return deferred;
        }
      }, {
        key: "dir",
        value: function dir(lng) {
          if (!lng)
            lng = this.languages && this.languages.length > 0 ? this.languages[0] : this.language;
          if (!lng)
            return "rtl";
          var rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam"];
          return rtlLngs.indexOf(this.services.languageUtils.getLanguagePartFromCode(lng)) >= 0 ? "rtl" : "ltr";
        }
      }, {
        key: "createInstance",
        value: function createInstance() {
          var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var callback = arguments.length > 1 ? arguments[1] : void 0;
          return new I18n3(options2, callback);
        }
      }, {
        key: "cloneInstance",
        value: function cloneInstance() {
          var _this8 = this;
          var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop;
          var mergedOptions = _objectSpread({}, this.options, options2, {
            isClone: true
          });
          var clone = new I18n3(mergedOptions);
          var membersToCopy = ["store", "services", "language"];
          membersToCopy.forEach(function(m) {
            clone[m] = _this8[m];
          });
          clone.translator = new Translator(clone.services, clone.options);
          clone.translator.on("*", function(event) {
            for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
              args[_key4 - 1] = arguments[_key4];
            }
            clone.emit.apply(clone, [event].concat(args));
          });
          clone.init(mergedOptions, callback);
          clone.translator.options = clone.options;
          return clone;
        }
      }]);
      return I18n3;
    }(EventEmitter);
    i18next = new I18n();
    i18next_default = i18next;
  }
});

// ../lib/project-access/core/dist/i18n/i18n.json
var require_i18n = __commonJS({
  "../lib/project-access/core/dist/i18n/i18n.json"(exports2, module2) {
    module2.exports = {
      ERROR_SPECIFICATION_MISSING: "Seems specification package is missing. Please execute command 'npm i @sap/ux-specification --save-dev' in root (where package.json is) of your project. '{{root}}'. Error was: {{error.message}}`",
      ERROR_VOCABULARY_NOT_FOUND: "Vocabulary not found! namespace: {{namespace}}, uri: {{- uri}} ",
      ERROR_READING_METADATA: "Error while reading service metadata {{path}}. Error was: {{error}}",
      ERROR_SERVICE_NOT_FOUND: "Service for uri: '{{- uri}}' not found. Available services: {{- services}}",
      ERROR_READING_CAP_SERVICE_METADATA: "Error while reading CAP service metadata. Path: {{- root}}, service uri: {{- uri}}, error: {{- error}}",
      ERROR_RESOLVING_CDS_ROOTS: "Error while resolving cds roots for '{{projectRoot}}'. {{error}}",
      ERROR_RETRIEVING_CDS_FILES: "Error while retrieving the list of cds files for project {{projectRoot}}, envRoot ${envRoot}. Error was: {{error}}",
      ERROR_PROJECT_ROOT_WORKSPACE: "Error while trying to find project in workspace root {{root}}. Error was: {{error}}",
      ERROR_INVALID_PACKAGE_JSON: "Found invalid package.json. {{error}}",
      ERROR_INVALIND_PACKAGE_JSON_FOR_APP: "Found invalid package.json in '{{- root}}'",
      ERROR_REQUIRED_APP: "Appication ID required.",
      ERROR_INVALID_APP_ID: "Invalid application ID.",
      CONSOLE_SHOULD_NOT_BE_HERE: "Should not be here ' {{currentValue}}",
      ERROR_LOADING_ANNOTATIONS_FROM_CAP: "Loading annotations from CAP project failed. {{error}}",
      ERROR_LOADING_ANNOTATIONS: "Loading annotations failed. {{error}}",
      ERROR_DEL_CAP_APP_SAPUX: "Property 'sapux' in '{{- packageJsonPath}}' is not an array. Leaving..",
      ERROR_DEL_CAP_APP_MODIFY_CDS: "Could not modify file '{{- cdsFilePath}}'. Skipping this file.",
      INFO_DEL_CAP_APP: "Deleting app '{{appName}}' from CAP project '{{- projectRoot}}'.",
      INFO_DEL_LAST_CAP_APP: "This was the last app in this CAP project. Deleting property 'sapux' from '{{- packageJsonPath}}'.",
      INFO_DEL_CAP_APP_FILE_UPDATED: "File '{{- packageJsonPath}}' updated.",
      INFO_DEL_CAP_APP_DIR_DELETED: "Directory '{{- appPath}}' deleted.",
      INFO_DEL_CAP_APP_DELETE_USING: "Removing using statement for './{{appName}}/annotations' from '{{- cdsFilePath}}'.",
      INFO_DEL_CAP_APP_DEL_CDS: "File '{{- cdsFilePath}}' is now empty, removing it.",
      INFO_DEL_CAP_APP_FOLDER_EMPTY: "Directory '{{- appPath}}' is now empty. Deleting it.",
      ERROR_DETAIL_PROJECT_TYPE: "Cannot determine project type for app '{{- appRoot}}' with project root '{{- projectRoot}}'",
      ERROR_UI5_YAML_PARSING: "Cannot parse ui5 config file '{{- filePath}}'. Cause - '{{- parsingError}}'",
      ERROR_UI5_YAML_DYNAMIC_CFG_IMPORT: "Cannot import dynamic config from '{{- filePath}}', defined in - '{{- yamlFile}}'"
    };
  }
});

// ../lib/project-access/core/dist/i18n.js
var require_i18n2 = __commonJS({
  "../lib/project-access/core/dist/i18n.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.initI18n = exports2.i18n = void 0;
    var i18next_1 = __importDefault((init_i18next(), __toCommonJS(i18next_exports)));
    var i18n_json_1 = __importDefault(require_i18n());
    exports2.i18n = i18next_1.default.createInstance();
    async function initI18n() {
      await exports2.i18n.init({
        resources: {
          en: {
            translation: i18n_json_1.default
          }
        },
        lng: "en",
        fallbackLng: "en",
        joinArrays: "\n\n"
      });
    }
    exports2.initI18n = initI18n;
  }
});

// ../lib/project-access/core/node_modules/vscode-uri/lib/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  URI: () => URI
});
function _validateUri(ret, _strict) {
  if (!ret.scheme && _strict) {
    throw new Error('[UriError]: Scheme is missing: {scheme: "", authority: "' + ret.authority + '", path: "' + ret.path + '", query: "' + ret.query + '", fragment: "' + ret.fragment + '"}');
  }
  if (ret.scheme && !_schemePattern.test(ret.scheme)) {
    throw new Error("[UriError]: Scheme contains illegal characters.");
  }
  if (ret.path) {
    if (ret.authority) {
      if (!_singleSlashStart.test(ret.path)) {
        throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
      }
    } else {
      if (_doubleSlashStart.test(ret.path)) {
        throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
      }
    }
  }
}
function _schemeFix(scheme, _strict) {
  if (!scheme && !_strict) {
    return "file";
  }
  return scheme;
}
function _referenceResolution(scheme, path) {
  switch (scheme) {
    case "https":
    case "http":
    case "file":
      if (!path) {
        path = _slash;
      } else if (path[0] !== _slash) {
        path = _slash + path;
      }
      break;
  }
  return path;
}
function encodeURIComponentFast(uriComponent, allowSlash) {
  var res = void 0;
  var nativeEncodePos = -1;
  for (var pos = 0; pos < uriComponent.length; pos++) {
    var code = uriComponent.charCodeAt(pos);
    if (code >= 97 && code <= 122 || code >= 65 && code <= 90 || code >= 48 && code <= 57 || code === 45 || code === 46 || code === 95 || code === 126 || allowSlash && code === 47) {
      if (nativeEncodePos !== -1) {
        res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
        nativeEncodePos = -1;
      }
      if (res !== void 0) {
        res += uriComponent.charAt(pos);
      }
    } else {
      if (res === void 0) {
        res = uriComponent.substr(0, pos);
      }
      var escaped = encodeTable[code];
      if (escaped !== void 0) {
        if (nativeEncodePos !== -1) {
          res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
          nativeEncodePos = -1;
        }
        res += escaped;
      } else if (nativeEncodePos === -1) {
        nativeEncodePos = pos;
      }
    }
  }
  if (nativeEncodePos !== -1) {
    res += encodeURIComponent(uriComponent.substring(nativeEncodePos));
  }
  return res !== void 0 ? res : uriComponent;
}
function encodeURIComponentMinimal(path) {
  var res = void 0;
  for (var pos = 0; pos < path.length; pos++) {
    var code = path.charCodeAt(pos);
    if (code === 35 || code === 63) {
      if (res === void 0) {
        res = path.substr(0, pos);
      }
      res += encodeTable[code];
    } else {
      if (res !== void 0) {
        res += path[pos];
      }
    }
  }
  return res !== void 0 ? res : path;
}
function _makeFsPath(uri) {
  var value;
  if (uri.authority && uri.path.length > 1 && uri.scheme === "file") {
    value = "//" + uri.authority + uri.path;
  } else if (uri.path.charCodeAt(0) === 47 && (uri.path.charCodeAt(1) >= 65 && uri.path.charCodeAt(1) <= 90 || uri.path.charCodeAt(1) >= 97 && uri.path.charCodeAt(1) <= 122) && uri.path.charCodeAt(2) === 58) {
    value = uri.path[1].toLowerCase() + uri.path.substr(2);
  } else {
    value = uri.path;
  }
  if (isWindows) {
    value = value.replace(/\//g, "\\");
  }
  return value;
}
function _asFormatted(uri, skipEncoding) {
  var encoder = !skipEncoding ? encodeURIComponentFast : encodeURIComponentMinimal;
  var res = "";
  var scheme = uri.scheme, authority = uri.authority, path = uri.path, query = uri.query, fragment = uri.fragment;
  if (scheme) {
    res += scheme;
    res += ":";
  }
  if (authority || scheme === "file") {
    res += _slash;
    res += _slash;
  }
  if (authority) {
    var idx = authority.indexOf("@");
    if (idx !== -1) {
      var userinfo = authority.substr(0, idx);
      authority = authority.substr(idx + 1);
      idx = userinfo.indexOf(":");
      if (idx === -1) {
        res += encoder(userinfo, false);
      } else {
        res += encoder(userinfo.substr(0, idx), false);
        res += ":";
        res += encoder(userinfo.substr(idx + 1), false);
      }
      res += "@";
    }
    authority = authority.toLowerCase();
    idx = authority.indexOf(":");
    if (idx === -1) {
      res += encoder(authority, false);
    } else {
      res += encoder(authority.substr(0, idx), false);
      res += authority.substr(idx);
    }
  }
  if (path) {
    if (path.length >= 3 && path.charCodeAt(0) === 47 && path.charCodeAt(2) === 58) {
      var code = path.charCodeAt(1);
      if (code >= 65 && code <= 90) {
        path = "/" + String.fromCharCode(code + 32) + ":" + path.substr(3);
      }
    } else if (path.length >= 2 && path.charCodeAt(1) === 58) {
      var code = path.charCodeAt(0);
      if (code >= 65 && code <= 90) {
        path = String.fromCharCode(code + 32) + ":" + path.substr(2);
      }
    }
    res += encoder(path, true);
  }
  if (query) {
    res += "?";
    res += encoder(query, false);
  }
  if (fragment) {
    res += "#";
    res += !skipEncoding ? encodeURIComponentFast(fragment, false) : fragment;
  }
  return res;
}
var __extends, _a, isWindows, userAgent, _schemePattern, _singleSlashStart, _doubleSlashStart, _empty, _slash, _regexp, URI, _pathSepMarker, _URI, encodeTable;
var init_esm = __esm({
  "../lib/project-access/core/node_modules/vscode-uri/lib/esm/index.js"() {
    "use strict";
    __extends = function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    if (typeof process === "object") {
      isWindows = process.platform === "win32";
    } else if (typeof navigator === "object") {
      userAgent = navigator.userAgent;
      isWindows = userAgent.indexOf("Windows") >= 0;
    }
    _schemePattern = /^\w[\w\d+.-]*$/;
    _singleSlashStart = /^\//;
    _doubleSlashStart = /^\/\//;
    _empty = "";
    _slash = "/";
    _regexp = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
    URI = function() {
      function URI2(schemeOrData, authority, path, query, fragment, _strict) {
        if (_strict === void 0) {
          _strict = false;
        }
        if (typeof schemeOrData === "object") {
          this.scheme = schemeOrData.scheme || _empty;
          this.authority = schemeOrData.authority || _empty;
          this.path = schemeOrData.path || _empty;
          this.query = schemeOrData.query || _empty;
          this.fragment = schemeOrData.fragment || _empty;
        } else {
          this.scheme = _schemeFix(schemeOrData, _strict);
          this.authority = authority || _empty;
          this.path = _referenceResolution(this.scheme, path || _empty);
          this.query = query || _empty;
          this.fragment = fragment || _empty;
          _validateUri(this, _strict);
        }
      }
      URI2.isUri = function(thing) {
        if (thing instanceof URI2) {
          return true;
        }
        if (!thing) {
          return false;
        }
        return typeof thing.authority === "string" && typeof thing.fragment === "string" && typeof thing.path === "string" && typeof thing.query === "string" && typeof thing.scheme === "string" && typeof thing.fsPath === "function" && typeof thing.with === "function" && typeof thing.toString === "function";
      };
      Object.defineProperty(URI2.prototype, "fsPath", {
        get: function() {
          return _makeFsPath(this);
        },
        enumerable: true,
        configurable: true
      });
      URI2.prototype.with = function(change) {
        if (!change) {
          return this;
        }
        var scheme = change.scheme, authority = change.authority, path = change.path, query = change.query, fragment = change.fragment;
        if (scheme === void 0) {
          scheme = this.scheme;
        } else if (scheme === null) {
          scheme = _empty;
        }
        if (authority === void 0) {
          authority = this.authority;
        } else if (authority === null) {
          authority = _empty;
        }
        if (path === void 0) {
          path = this.path;
        } else if (path === null) {
          path = _empty;
        }
        if (query === void 0) {
          query = this.query;
        } else if (query === null) {
          query = _empty;
        }
        if (fragment === void 0) {
          fragment = this.fragment;
        } else if (fragment === null) {
          fragment = _empty;
        }
        if (scheme === this.scheme && authority === this.authority && path === this.path && query === this.query && fragment === this.fragment) {
          return this;
        }
        return new _URI(scheme, authority, path, query, fragment);
      };
      URI2.parse = function(value, _strict) {
        if (_strict === void 0) {
          _strict = false;
        }
        var match = _regexp.exec(value);
        if (!match) {
          return new _URI(_empty, _empty, _empty, _empty, _empty);
        }
        return new _URI(match[2] || _empty, decodeURIComponent(match[4] || _empty), decodeURIComponent(match[5] || _empty), decodeURIComponent(match[7] || _empty), decodeURIComponent(match[9] || _empty), _strict);
      };
      URI2.file = function(path) {
        var authority = _empty;
        if (isWindows) {
          path = path.replace(/\\/g, _slash);
        }
        if (path[0] === _slash && path[1] === _slash) {
          var idx = path.indexOf(_slash, 2);
          if (idx === -1) {
            authority = path.substring(2);
            path = _slash;
          } else {
            authority = path.substring(2, idx);
            path = path.substring(idx) || _slash;
          }
        }
        return new _URI("file", authority, path, _empty, _empty);
      };
      URI2.from = function(components) {
        return new _URI(components.scheme, components.authority, components.path, components.query, components.fragment);
      };
      URI2.prototype.toString = function(skipEncoding) {
        if (skipEncoding === void 0) {
          skipEncoding = false;
        }
        return _asFormatted(this, skipEncoding);
      };
      URI2.prototype.toJSON = function() {
        return this;
      };
      URI2.revive = function(data2) {
        if (!data2) {
          return data2;
        } else if (data2 instanceof URI2) {
          return data2;
        } else {
          var result2 = new _URI(data2);
          result2._formatted = data2.external;
          result2._fsPath = data2._sep === _pathSepMarker ? data2.fsPath : null;
          return result2;
        }
      };
      return URI2;
    }();
    _pathSepMarker = isWindows ? 1 : void 0;
    _URI = function(_super) {
      __extends(_URI2, _super);
      function _URI2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._formatted = null;
        _this._fsPath = null;
        return _this;
      }
      Object.defineProperty(_URI2.prototype, "fsPath", {
        get: function() {
          if (!this._fsPath) {
            this._fsPath = _makeFsPath(this);
          }
          return this._fsPath;
        },
        enumerable: true,
        configurable: true
      });
      _URI2.prototype.toString = function(skipEncoding) {
        if (skipEncoding === void 0) {
          skipEncoding = false;
        }
        if (!skipEncoding) {
          if (!this._formatted) {
            this._formatted = _asFormatted(this, false);
          }
          return this._formatted;
        } else {
          return _asFormatted(this, true);
        }
      };
      _URI2.prototype.toJSON = function() {
        var res = {
          $mid: 1
        };
        if (this._fsPath) {
          res.fsPath = this._fsPath;
          res._sep = _pathSepMarker;
        }
        if (this._formatted) {
          res.external = this._formatted;
        }
        if (this.path) {
          res.path = this.path;
        }
        if (this.scheme) {
          res.scheme = this.scheme;
        }
        if (this.authority) {
          res.authority = this.authority;
        }
        if (this.query) {
          res.query = this.query;
        }
        if (this.fragment) {
          res.fragment = this.fragment;
        }
        return res;
      };
      return _URI2;
    }(URI);
    encodeTable = (_a = {}, _a[58] = "%3A", _a[47] = "%2F", _a[63] = "%3F", _a[35] = "%23", _a[91] = "%5B", _a[93] = "%5D", _a[64] = "%40", _a[33] = "%21", _a[36] = "%24", _a[38] = "%26", _a[39] = "%27", _a[40] = "%28", _a[41] = "%29", _a[42] = "%2A", _a[43] = "%2B", _a[44] = "%2C", _a[59] = "%3B", _a[61] = "%3D", _a[32] = "%20", _a);
  }
});

// ../lib/project-access/core/dist/common/file.js
var require_file2 = __commonJS({
  "../lib/project-access/core/dist/common/file.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fsPathToFtfsPath = exports2.moveFile = exports2.deleteDirectory = exports2.isDirectory = exports2.fileExists = exports2.createDirectory = exports2.readDirectory = exports2.updateJSON = exports2.updateFile = exports2.deleteFile = exports2.readJSON = exports2.readFile = void 0;
    var fs2 = __importStar(require("fs"));
    var path_1 = require("path");
    var vscode_uri_1 = (init_esm(), __toCommonJS(esm_exports));
    var project_spec_1 = require_dist3();
    async function readFile2(path) {
      return new Promise((resolve, reject) => {
        fs2.readFile(path, { encoding: "utf8" }, (err, data2) => {
          if (err) {
            reject(err);
          } else {
            resolve(data2);
          }
        });
      });
    }
    exports2.readFile = readFile2;
    async function readJSON(path) {
      return JSON.parse(await readFile2(path));
    }
    exports2.readJSON = readJSON;
    async function deleteFile(path) {
      return new Promise((resolve, reject) => {
        fs2.unlink(path, (err) => {
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      });
    }
    exports2.deleteFile = deleteFile;
    async function updateFile(path, content) {
      if (content === null || content === void 0) {
        return deleteFile(path);
      } else {
        return new Promise((resolve, reject) => {
          fs2.writeFile(path, content, { encoding: "utf8" }, (err) => {
            if (err) {
              reject(err);
            } else {
              resolve();
            }
          });
        });
      }
    }
    exports2.updateFile = updateFile;
    async function updateJSON(path, content) {
      await updateFile(path, content ? JSON.stringify(content, null, 4) : null);
    }
    exports2.updateJSON = updateJSON;
    async function readDirectory(path) {
      return new Promise((resolve, reject) => {
        fs2.readdir(path, { encoding: "utf8" }, (err, data2) => {
          if (err) {
            reject(err);
          } else {
            resolve(data2);
          }
        });
      });
    }
    exports2.readDirectory = readDirectory;
    async function createDirectory(path) {
      return new Promise((resolve, reject) => {
        fs2.mkdir(path, (err) => {
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      });
    }
    exports2.createDirectory = createDirectory;
    async function fileExists(path) {
      return new Promise((resolve) => {
        fs2.exists(path, (exists) => {
          resolve(exists);
        });
      });
    }
    exports2.fileExists = fileExists;
    async function isDirectory(path) {
      return new Promise((resolve, reject) => {
        fs2.stat(path, (err, stats) => {
          if (err) {
            reject(err);
          } else {
            resolve(stats.isDirectory());
          }
        });
      });
    }
    exports2.isDirectory = isDirectory;
    async function deleteDirectory(path) {
      if (await fileExists(path)) {
        const files = await readDirectory(path);
        for (const name of files) {
          const fullPath = path_1.join(path, name);
          if (await isDirectory(fullPath)) {
            await deleteDirectory(fullPath);
          } else {
            await deleteFile(fullPath);
          }
        }
        return new Promise((resolve, reject) => {
          fs2.rmdir(path, (err) => {
            if (err) {
              reject();
            } else {
              resolve();
            }
          });
        });
      }
    }
    exports2.deleteDirectory = deleteDirectory;
    async function moveFile(oldPath, newPath) {
      return new Promise((resolve, reject) => {
        fs2.rename(oldPath, newPath, (err) => {
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      });
    }
    exports2.moveFile = moveFile;
    function fsPathToFtfsPath(path) {
      let posixPath = path.replace(/\\/g, "/");
      if (!path_1.posix.isAbsolute(posixPath)) {
        posixPath = `/${posixPath}`;
      }
      return vscode_uri_1.URI.parse(`${project_spec_1.SchemeName.Ftfs}:${posixPath}`).toString();
    }
    exports2.fsPathToFtfsPath = fsPathToFtfsPath;
  }
});

// ../../node_modules/yamljs/lib/Pattern.js
var require_Pattern = __commonJS({
  "../../node_modules/yamljs/lib/Pattern.js"(exports2, module2) {
    var Pattern;
    Pattern = function() {
      Pattern2.prototype.regex = null;
      Pattern2.prototype.rawRegex = null;
      Pattern2.prototype.cleanedRegex = null;
      Pattern2.prototype.mapping = null;
      function Pattern2(rawRegex, modifiers) {
        var _char, capturingBracketNumber, cleanedRegex, i, len, mapping, name, part, subChar;
        if (modifiers == null) {
          modifiers = "";
        }
        cleanedRegex = "";
        len = rawRegex.length;
        mapping = null;
        capturingBracketNumber = 0;
        i = 0;
        while (i < len) {
          _char = rawRegex.charAt(i);
          if (_char === "\\") {
            cleanedRegex += rawRegex.slice(i, +(i + 1) + 1 || 9e9);
            i++;
          } else if (_char === "(") {
            if (i < len - 2) {
              part = rawRegex.slice(i, +(i + 2) + 1 || 9e9);
              if (part === "(?:") {
                i += 2;
                cleanedRegex += part;
              } else if (part === "(?<") {
                capturingBracketNumber++;
                i += 2;
                name = "";
                while (i + 1 < len) {
                  subChar = rawRegex.charAt(i + 1);
                  if (subChar === ">") {
                    cleanedRegex += "(";
                    i++;
                    if (name.length > 0) {
                      if (mapping == null) {
                        mapping = {};
                      }
                      mapping[name] = capturingBracketNumber;
                    }
                    break;
                  } else {
                    name += subChar;
                  }
                  i++;
                }
              } else {
                cleanedRegex += _char;
                capturingBracketNumber++;
              }
            } else {
              cleanedRegex += _char;
            }
          } else {
            cleanedRegex += _char;
          }
          i++;
        }
        this.rawRegex = rawRegex;
        this.cleanedRegex = cleanedRegex;
        this.regex = new RegExp(this.cleanedRegex, "g" + modifiers.replace("g", ""));
        this.mapping = mapping;
      }
      Pattern2.prototype.exec = function(str) {
        var index, matches, name, ref;
        this.regex.lastIndex = 0;
        matches = this.regex.exec(str);
        if (matches == null) {
          return null;
        }
        if (this.mapping != null) {
          ref = this.mapping;
          for (name in ref) {
            index = ref[name];
            matches[name] = matches[index];
          }
        }
        return matches;
      };
      Pattern2.prototype.test = function(str) {
        this.regex.lastIndex = 0;
        return this.regex.test(str);
      };
      Pattern2.prototype.replace = function(str, replacement) {
        this.regex.lastIndex = 0;
        return str.replace(this.regex, replacement);
      };
      Pattern2.prototype.replaceAll = function(str, replacement, limit) {
        var count;
        if (limit == null) {
          limit = 0;
        }
        this.regex.lastIndex = 0;
        count = 0;
        while (this.regex.test(str) && (limit === 0 || count < limit)) {
          this.regex.lastIndex = 0;
          str = str.replace(this.regex, replacement);
          count++;
        }
        return [str, count];
      };
      return Pattern2;
    }();
    module2.exports = Pattern;
  }
});

// ../../node_modules/yamljs/lib/Utils.js
var require_Utils = __commonJS({
  "../../node_modules/yamljs/lib/Utils.js"(exports2, module2) {
    var Pattern;
    var Utils;
    var hasProp = {}.hasOwnProperty;
    Pattern = require_Pattern();
    Utils = function() {
      function Utils2() {
      }
      Utils2.REGEX_LEFT_TRIM_BY_CHAR = {};
      Utils2.REGEX_RIGHT_TRIM_BY_CHAR = {};
      Utils2.REGEX_SPACES = /\s+/g;
      Utils2.REGEX_DIGITS = /^\d+$/;
      Utils2.REGEX_OCTAL = /[^0-7]/gi;
      Utils2.REGEX_HEXADECIMAL = /[^a-f0-9]/gi;
      Utils2.PATTERN_DATE = new Pattern("^(?<year>[0-9][0-9][0-9][0-9])-(?<month>[0-9][0-9]?)-(?<day>[0-9][0-9]?)(?:(?:[Tt]|[ 	]+)(?<hour>[0-9][0-9]?):(?<minute>[0-9][0-9]):(?<second>[0-9][0-9])(?:.(?<fraction>[0-9]*))?(?:[ 	]*(?<tz>Z|(?<tz_sign>[-+])(?<tz_hour>[0-9][0-9]?)(?::(?<tz_minute>[0-9][0-9]))?))?)?$", "i");
      Utils2.LOCAL_TIMEZONE_OFFSET = new Date().getTimezoneOffset() * 60 * 1e3;
      Utils2.trim = function(str, _char) {
        var regexLeft, regexRight;
        if (_char == null) {
          _char = "\\s";
        }
        regexLeft = this.REGEX_LEFT_TRIM_BY_CHAR[_char];
        if (regexLeft == null) {
          this.REGEX_LEFT_TRIM_BY_CHAR[_char] = regexLeft = new RegExp("^" + _char + _char + "*");
        }
        regexLeft.lastIndex = 0;
        regexRight = this.REGEX_RIGHT_TRIM_BY_CHAR[_char];
        if (regexRight == null) {
          this.REGEX_RIGHT_TRIM_BY_CHAR[_char] = regexRight = new RegExp(_char + "" + _char + "*$");
        }
        regexRight.lastIndex = 0;
        return str.replace(regexLeft, "").replace(regexRight, "");
      };
      Utils2.ltrim = function(str, _char) {
        var regexLeft;
        if (_char == null) {
          _char = "\\s";
        }
        regexLeft = this.REGEX_LEFT_TRIM_BY_CHAR[_char];
        if (regexLeft == null) {
          this.REGEX_LEFT_TRIM_BY_CHAR[_char] = regexLeft = new RegExp("^" + _char + _char + "*");
        }
        regexLeft.lastIndex = 0;
        return str.replace(regexLeft, "");
      };
      Utils2.rtrim = function(str, _char) {
        var regexRight;
        if (_char == null) {
          _char = "\\s";
        }
        regexRight = this.REGEX_RIGHT_TRIM_BY_CHAR[_char];
        if (regexRight == null) {
          this.REGEX_RIGHT_TRIM_BY_CHAR[_char] = regexRight = new RegExp(_char + "" + _char + "*$");
        }
        regexRight.lastIndex = 0;
        return str.replace(regexRight, "");
      };
      Utils2.isEmpty = function(value) {
        return !value || value === "" || value === "0" || value instanceof Array && value.length === 0 || this.isEmptyObject(value);
      };
      Utils2.isEmptyObject = function(value) {
        var k;
        return value instanceof Object && function() {
          var results;
          results = [];
          for (k in value) {
            if (!hasProp.call(value, k))
              continue;
            results.push(k);
          }
          return results;
        }().length === 0;
      };
      Utils2.subStrCount = function(string, subString, start, length) {
        var c, i, j, len, ref, sublen;
        c = 0;
        string = "" + string;
        subString = "" + subString;
        if (start != null) {
          string = string.slice(start);
        }
        if (length != null) {
          string = string.slice(0, length);
        }
        len = string.length;
        sublen = subString.length;
        for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          if (subString === string.slice(i, sublen)) {
            c++;
            i += sublen - 1;
          }
        }
        return c;
      };
      Utils2.isDigits = function(input) {
        this.REGEX_DIGITS.lastIndex = 0;
        return this.REGEX_DIGITS.test(input);
      };
      Utils2.octDec = function(input) {
        this.REGEX_OCTAL.lastIndex = 0;
        return parseInt((input + "").replace(this.REGEX_OCTAL, ""), 8);
      };
      Utils2.hexDec = function(input) {
        this.REGEX_HEXADECIMAL.lastIndex = 0;
        input = this.trim(input);
        if ((input + "").slice(0, 2) === "0x") {
          input = (input + "").slice(2);
        }
        return parseInt((input + "").replace(this.REGEX_HEXADECIMAL, ""), 16);
      };
      Utils2.utf8chr = function(c) {
        var ch;
        ch = String.fromCharCode;
        if (128 > (c %= 2097152)) {
          return ch(c);
        }
        if (2048 > c) {
          return ch(192 | c >> 6) + ch(128 | c & 63);
        }
        if (65536 > c) {
          return ch(224 | c >> 12) + ch(128 | c >> 6 & 63) + ch(128 | c & 63);
        }
        return ch(240 | c >> 18) + ch(128 | c >> 12 & 63) + ch(128 | c >> 6 & 63) + ch(128 | c & 63);
      };
      Utils2.parseBoolean = function(input, strict) {
        var lowerInput;
        if (strict == null) {
          strict = true;
        }
        if (typeof input === "string") {
          lowerInput = input.toLowerCase();
          if (!strict) {
            if (lowerInput === "no") {
              return false;
            }
          }
          if (lowerInput === "0") {
            return false;
          }
          if (lowerInput === "false") {
            return false;
          }
          if (lowerInput === "") {
            return false;
          }
          return true;
        }
        return !!input;
      };
      Utils2.isNumeric = function(input) {
        this.REGEX_SPACES.lastIndex = 0;
        return typeof input === "number" || typeof input === "string" && !isNaN(input) && input.replace(this.REGEX_SPACES, "") !== "";
      };
      Utils2.stringToDate = function(str) {
        var date, day, fraction, hour, info, minute, month, second, tz_hour, tz_minute, tz_offset, year;
        if (!(str != null ? str.length : void 0)) {
          return null;
        }
        info = this.PATTERN_DATE.exec(str);
        if (!info) {
          return null;
        }
        year = parseInt(info.year, 10);
        month = parseInt(info.month, 10) - 1;
        day = parseInt(info.day, 10);
        if (info.hour == null) {
          date = new Date(Date.UTC(year, month, day));
          return date;
        }
        hour = parseInt(info.hour, 10);
        minute = parseInt(info.minute, 10);
        second = parseInt(info.second, 10);
        if (info.fraction != null) {
          fraction = info.fraction.slice(0, 3);
          while (fraction.length < 3) {
            fraction += "0";
          }
          fraction = parseInt(fraction, 10);
        } else {
          fraction = 0;
        }
        if (info.tz != null) {
          tz_hour = parseInt(info.tz_hour, 10);
          if (info.tz_minute != null) {
            tz_minute = parseInt(info.tz_minute, 10);
          } else {
            tz_minute = 0;
          }
          tz_offset = (tz_hour * 60 + tz_minute) * 6e4;
          if ("-" === info.tz_sign) {
            tz_offset *= -1;
          }
        }
        date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
        if (tz_offset) {
          date.setTime(date.getTime() - tz_offset);
        }
        return date;
      };
      Utils2.strRepeat = function(str, number) {
        var i, res;
        res = "";
        i = 0;
        while (i < number) {
          res += str;
          i++;
        }
        return res;
      };
      Utils2.getStringFromFile = function(path, callback) {
        var data2, fs2, j, len1, name, ref, req, xhr;
        if (callback == null) {
          callback = null;
        }
        xhr = null;
        if (typeof window !== "undefined" && window !== null) {
          if (window.XMLHttpRequest) {
            xhr = new XMLHttpRequest();
          } else if (window.ActiveXObject) {
            ref = ["Msxml2.XMLHTTP.6.0", "Msxml2.XMLHTTP.3.0", "Msxml2.XMLHTTP", "Microsoft.XMLHTTP"];
            for (j = 0, len1 = ref.length; j < len1; j++) {
              name = ref[j];
              try {
                xhr = new ActiveXObject(name);
              } catch (error3) {
              }
            }
          }
        }
        if (xhr != null) {
          if (callback != null) {
            xhr.onreadystatechange = function() {
              if (xhr.readyState === 4) {
                if (xhr.status === 200 || xhr.status === 0) {
                  return callback(xhr.responseText);
                } else {
                  return callback(null);
                }
              }
            };
            xhr.open("GET", path, true);
            return xhr.send(null);
          } else {
            xhr.open("GET", path, false);
            xhr.send(null);
            if (xhr.status === 200 || xhr.status === 0) {
              return xhr.responseText;
            }
            return null;
          }
        } else {
          req = require;
          fs2 = req("fs");
          if (callback != null) {
            return fs2.readFile(path, function(err, data3) {
              if (err) {
                return callback(null);
              } else {
                return callback(String(data3));
              }
            });
          } else {
            data2 = fs2.readFileSync(path);
            if (data2 != null) {
              return String(data2);
            }
            return null;
          }
        }
      };
      return Utils2;
    }();
    module2.exports = Utils;
  }
});

// ../../node_modules/yamljs/lib/Unescaper.js
var require_Unescaper = __commonJS({
  "../../node_modules/yamljs/lib/Unescaper.js"(exports2, module2) {
    var Pattern;
    var Unescaper;
    var Utils;
    Utils = require_Utils();
    Pattern = require_Pattern();
    Unescaper = function() {
      function Unescaper2() {
      }
      Unescaper2.PATTERN_ESCAPED_CHARACTER = new Pattern('\\\\([0abt	nvfre "\\/\\\\N_LP]|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|U[0-9a-fA-F]{8})');
      Unescaper2.unescapeSingleQuotedString = function(value) {
        return value.replace(/\'\'/g, "'");
      };
      Unescaper2.unescapeDoubleQuotedString = function(value) {
        if (this._unescapeCallback == null) {
          this._unescapeCallback = function(_this) {
            return function(str) {
              return _this.unescapeCharacter(str);
            };
          }(this);
        }
        return this.PATTERN_ESCAPED_CHARACTER.replace(value, this._unescapeCallback);
      };
      Unescaper2.unescapeCharacter = function(value) {
        var ch;
        ch = String.fromCharCode;
        switch (value.charAt(1)) {
          case "0":
            return ch(0);
          case "a":
            return ch(7);
          case "b":
            return ch(8);
          case "t":
            return "	";
          case "	":
            return "	";
          case "n":
            return "\n";
          case "v":
            return ch(11);
          case "f":
            return ch(12);
          case "r":
            return ch(13);
          case "e":
            return ch(27);
          case " ":
            return " ";
          case '"':
            return '"';
          case "/":
            return "/";
          case "\\":
            return "\\";
          case "N":
            return ch(133);
          case "_":
            return ch(160);
          case "L":
            return ch(8232);
          case "P":
            return ch(8233);
          case "x":
            return Utils.utf8chr(Utils.hexDec(value.substr(2, 2)));
          case "u":
            return Utils.utf8chr(Utils.hexDec(value.substr(2, 4)));
          case "U":
            return Utils.utf8chr(Utils.hexDec(value.substr(2, 8)));
          default:
            return "";
        }
      };
      return Unescaper2;
    }();
    module2.exports = Unescaper;
  }
});

// ../../node_modules/yamljs/lib/Escaper.js
var require_Escaper = __commonJS({
  "../../node_modules/yamljs/lib/Escaper.js"(exports2, module2) {
    var Escaper;
    var Pattern;
    Pattern = require_Pattern();
    Escaper = function() {
      var ch;
      function Escaper2() {
      }
      Escaper2.LIST_ESCAPEES = ["\\", "\\\\", '\\"', '"', "\0", "", "", "", "", "", "", "\x07", "\b", "	", "\n", "\v", "\f", "\r", "", "", "", "", "", "", "", "", "", "", "", "", "", "\x1B", "", "", "", "", (ch = String.fromCharCode)(133), ch(160), ch(8232), ch(8233)];
      Escaper2.LIST_ESCAPED = ["\\\\", '\\"', '\\"', '\\"', "\\0", "\\x01", "\\x02", "\\x03", "\\x04", "\\x05", "\\x06", "\\a", "\\b", "\\t", "\\n", "\\v", "\\f", "\\r", "\\x0e", "\\x0f", "\\x10", "\\x11", "\\x12", "\\x13", "\\x14", "\\x15", "\\x16", "\\x17", "\\x18", "\\x19", "\\x1a", "\\e", "\\x1c", "\\x1d", "\\x1e", "\\x1f", "\\N", "\\_", "\\L", "\\P"];
      Escaper2.MAPPING_ESCAPEES_TO_ESCAPED = function() {
        var i, j, mapping, ref;
        mapping = {};
        for (i = j = 0, ref = Escaper2.LIST_ESCAPEES.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          mapping[Escaper2.LIST_ESCAPEES[i]] = Escaper2.LIST_ESCAPED[i];
        }
        return mapping;
      }();
      Escaper2.PATTERN_CHARACTERS_TO_ESCAPE = new Pattern("[\\x00-\\x1f]|\xC2\x85|\xC2\xA0|\xE2\x80\xA8|\xE2\x80\xA9");
      Escaper2.PATTERN_MAPPING_ESCAPEES = new Pattern(Escaper2.LIST_ESCAPEES.join("|").split("\\").join("\\\\"));
      Escaper2.PATTERN_SINGLE_QUOTING = new Pattern("[\\s'\":{}[\\],&*#?]|^[-?|<>=!%@`]");
      Escaper2.requiresDoubleQuoting = function(value) {
        return this.PATTERN_CHARACTERS_TO_ESCAPE.test(value);
      };
      Escaper2.escapeWithDoubleQuotes = function(value) {
        var result2;
        result2 = this.PATTERN_MAPPING_ESCAPEES.replace(value, function(_this) {
          return function(str) {
            return _this.MAPPING_ESCAPEES_TO_ESCAPED[str];
          };
        }(this));
        return '"' + result2 + '"';
      };
      Escaper2.requiresSingleQuoting = function(value) {
        return this.PATTERN_SINGLE_QUOTING.test(value);
      };
      Escaper2.escapeWithSingleQuotes = function(value) {
        return "'" + value.replace(/'/g, "''") + "'";
      };
      return Escaper2;
    }();
    module2.exports = Escaper;
  }
});

// ../../node_modules/yamljs/lib/Exception/ParseException.js
var require_ParseException = __commonJS({
  "../../node_modules/yamljs/lib/Exception/ParseException.js"(exports2, module2) {
    var ParseException;
    var extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    };
    var hasProp = {}.hasOwnProperty;
    ParseException = function(superClass) {
      extend(ParseException2, superClass);
      function ParseException2(message, parsedLine, snippet) {
        this.message = message;
        this.parsedLine = parsedLine;
        this.snippet = snippet;
      }
      ParseException2.prototype.toString = function() {
        if (this.parsedLine != null && this.snippet != null) {
          return "<ParseException> " + this.message + " (line " + this.parsedLine + ": '" + this.snippet + "')";
        } else {
          return "<ParseException> " + this.message;
        }
      };
      return ParseException2;
    }(Error);
    module2.exports = ParseException;
  }
});

// ../../node_modules/yamljs/lib/Exception/ParseMore.js
var require_ParseMore = __commonJS({
  "../../node_modules/yamljs/lib/Exception/ParseMore.js"(exports2, module2) {
    var ParseMore;
    var extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    };
    var hasProp = {}.hasOwnProperty;
    ParseMore = function(superClass) {
      extend(ParseMore2, superClass);
      function ParseMore2(message, parsedLine, snippet) {
        this.message = message;
        this.parsedLine = parsedLine;
        this.snippet = snippet;
      }
      ParseMore2.prototype.toString = function() {
        if (this.parsedLine != null && this.snippet != null) {
          return "<ParseMore> " + this.message + " (line " + this.parsedLine + ": '" + this.snippet + "')";
        } else {
          return "<ParseMore> " + this.message;
        }
      };
      return ParseMore2;
    }(Error);
    module2.exports = ParseMore;
  }
});

// ../../node_modules/yamljs/lib/Exception/DumpException.js
var require_DumpException = __commonJS({
  "../../node_modules/yamljs/lib/Exception/DumpException.js"(exports2, module2) {
    var DumpException;
    var extend = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    };
    var hasProp = {}.hasOwnProperty;
    DumpException = function(superClass) {
      extend(DumpException2, superClass);
      function DumpException2(message, parsedLine, snippet) {
        this.message = message;
        this.parsedLine = parsedLine;
        this.snippet = snippet;
      }
      DumpException2.prototype.toString = function() {
        if (this.parsedLine != null && this.snippet != null) {
          return "<DumpException> " + this.message + " (line " + this.parsedLine + ": '" + this.snippet + "')";
        } else {
          return "<DumpException> " + this.message;
        }
      };
      return DumpException2;
    }(Error);
    module2.exports = DumpException;
  }
});

// ../../node_modules/yamljs/lib/Inline.js
var require_Inline = __commonJS({
  "../../node_modules/yamljs/lib/Inline.js"(exports2, module2) {
    var DumpException;
    var Escaper;
    var Inline;
    var ParseException;
    var ParseMore;
    var Pattern;
    var Unescaper;
    var Utils;
    var indexOf = [].indexOf || function(item) {
      for (var i = 0, l = this.length; i < l; i++) {
        if (i in this && this[i] === item)
          return i;
      }
      return -1;
    };
    Pattern = require_Pattern();
    Unescaper = require_Unescaper();
    Escaper = require_Escaper();
    Utils = require_Utils();
    ParseException = require_ParseException();
    ParseMore = require_ParseMore();
    DumpException = require_DumpException();
    Inline = function() {
      function Inline2() {
      }
      Inline2.REGEX_QUOTED_STRING = `(?:"(?:[^"\\\\]*(?:\\\\.[^"\\\\]*)*)"|'(?:[^']*(?:''[^']*)*)')`;
      Inline2.PATTERN_TRAILING_COMMENTS = new Pattern("^\\s*#.*$");
      Inline2.PATTERN_QUOTED_SCALAR = new Pattern("^" + Inline2.REGEX_QUOTED_STRING);
      Inline2.PATTERN_THOUSAND_NUMERIC_SCALAR = new Pattern("^(-|\\+)?[0-9,]+(\\.[0-9]+)?$");
      Inline2.PATTERN_SCALAR_BY_DELIMITERS = {};
      Inline2.settings = {};
      Inline2.configure = function(exceptionOnInvalidType, objectDecoder) {
        if (exceptionOnInvalidType == null) {
          exceptionOnInvalidType = null;
        }
        if (objectDecoder == null) {
          objectDecoder = null;
        }
        this.settings.exceptionOnInvalidType = exceptionOnInvalidType;
        this.settings.objectDecoder = objectDecoder;
      };
      Inline2.parse = function(value, exceptionOnInvalidType, objectDecoder) {
        var context, result2;
        if (exceptionOnInvalidType == null) {
          exceptionOnInvalidType = false;
        }
        if (objectDecoder == null) {
          objectDecoder = null;
        }
        this.settings.exceptionOnInvalidType = exceptionOnInvalidType;
        this.settings.objectDecoder = objectDecoder;
        if (value == null) {
          return "";
        }
        value = Utils.trim(value);
        if (0 === value.length) {
          return "";
        }
        context = {
          exceptionOnInvalidType,
          objectDecoder,
          i: 0
        };
        switch (value.charAt(0)) {
          case "[":
            result2 = this.parseSequence(value, context);
            ++context.i;
            break;
          case "{":
            result2 = this.parseMapping(value, context);
            ++context.i;
            break;
          default:
            result2 = this.parseScalar(value, null, ['"', "'"], context);
        }
        if (this.PATTERN_TRAILING_COMMENTS.replace(value.slice(context.i), "") !== "") {
          throw new ParseException('Unexpected characters near "' + value.slice(context.i) + '".');
        }
        return result2;
      };
      Inline2.dump = function(value, exceptionOnInvalidType, objectEncoder) {
        var ref, result2, type;
        if (exceptionOnInvalidType == null) {
          exceptionOnInvalidType = false;
        }
        if (objectEncoder == null) {
          objectEncoder = null;
        }
        if (value == null) {
          return "null";
        }
        type = typeof value;
        if (type === "object") {
          if (value instanceof Date) {
            return value.toISOString();
          } else if (objectEncoder != null) {
            result2 = objectEncoder(value);
            if (typeof result2 === "string" || result2 != null) {
              return result2;
            }
          }
          return this.dumpObject(value);
        }
        if (type === "boolean") {
          return value ? "true" : "false";
        }
        if (Utils.isDigits(value)) {
          return type === "string" ? "'" + value + "'" : String(parseInt(value));
        }
        if (Utils.isNumeric(value)) {
          return type === "string" ? "'" + value + "'" : String(parseFloat(value));
        }
        if (type === "number") {
          return value === Infinity ? ".Inf" : value === -Infinity ? "-.Inf" : isNaN(value) ? ".NaN" : value;
        }
        if (Escaper.requiresDoubleQuoting(value)) {
          return Escaper.escapeWithDoubleQuotes(value);
        }
        if (Escaper.requiresSingleQuoting(value)) {
          return Escaper.escapeWithSingleQuotes(value);
        }
        if ("" === value) {
          return '""';
        }
        if (Utils.PATTERN_DATE.test(value)) {
          return "'" + value + "'";
        }
        if ((ref = value.toLowerCase()) === "null" || ref === "~" || ref === "true" || ref === "false") {
          return "'" + value + "'";
        }
        return value;
      };
      Inline2.dumpObject = function(value, exceptionOnInvalidType, objectSupport) {
        var j, key, len1, output3, val;
        if (objectSupport == null) {
          objectSupport = null;
        }
        if (value instanceof Array) {
          output3 = [];
          for (j = 0, len1 = value.length; j < len1; j++) {
            val = value[j];
            output3.push(this.dump(val));
          }
          return "[" + output3.join(", ") + "]";
        } else {
          output3 = [];
          for (key in value) {
            val = value[key];
            output3.push(this.dump(key) + ": " + this.dump(val));
          }
          return "{" + output3.join(", ") + "}";
        }
      };
      Inline2.parseScalar = function(scalar, delimiters, stringDelimiters, context, evaluate) {
        var i, joinedDelimiters, match, output3, pattern, ref, ref1, strpos, tmp;
        if (delimiters == null) {
          delimiters = null;
        }
        if (stringDelimiters == null) {
          stringDelimiters = ['"', "'"];
        }
        if (context == null) {
          context = null;
        }
        if (evaluate == null) {
          evaluate = true;
        }
        if (context == null) {
          context = {
            exceptionOnInvalidType: this.settings.exceptionOnInvalidType,
            objectDecoder: this.settings.objectDecoder,
            i: 0
          };
        }
        i = context.i;
        if (ref = scalar.charAt(i), indexOf.call(stringDelimiters, ref) >= 0) {
          output3 = this.parseQuotedScalar(scalar, context);
          i = context.i;
          if (delimiters != null) {
            tmp = Utils.ltrim(scalar.slice(i), " ");
            if (!(ref1 = tmp.charAt(0), indexOf.call(delimiters, ref1) >= 0)) {
              throw new ParseException("Unexpected characters (" + scalar.slice(i) + ").");
            }
          }
        } else {
          if (!delimiters) {
            output3 = scalar.slice(i);
            i += output3.length;
            strpos = output3.indexOf(" #");
            if (strpos !== -1) {
              output3 = Utils.rtrim(output3.slice(0, strpos));
            }
          } else {
            joinedDelimiters = delimiters.join("|");
            pattern = this.PATTERN_SCALAR_BY_DELIMITERS[joinedDelimiters];
            if (pattern == null) {
              pattern = new Pattern("^(.+?)(" + joinedDelimiters + ")");
              this.PATTERN_SCALAR_BY_DELIMITERS[joinedDelimiters] = pattern;
            }
            if (match = pattern.exec(scalar.slice(i))) {
              output3 = match[1];
              i += output3.length;
            } else {
              throw new ParseException("Malformed inline YAML string (" + scalar + ").");
            }
          }
          if (evaluate) {
            output3 = this.evaluateScalar(output3, context);
          }
        }
        context.i = i;
        return output3;
      };
      Inline2.parseQuotedScalar = function(scalar, context) {
        var i, match, output3;
        i = context.i;
        if (!(match = this.PATTERN_QUOTED_SCALAR.exec(scalar.slice(i)))) {
          throw new ParseMore("Malformed inline YAML string (" + scalar.slice(i) + ").");
        }
        output3 = match[0].substr(1, match[0].length - 2);
        if ('"' === scalar.charAt(i)) {
          output3 = Unescaper.unescapeDoubleQuotedString(output3);
        } else {
          output3 = Unescaper.unescapeSingleQuotedString(output3);
        }
        i += match[0].length;
        context.i = i;
        return output3;
      };
      Inline2.parseSequence = function(sequence, context) {
        var e, i, isQuoted, len, output3, ref, value;
        output3 = [];
        len = sequence.length;
        i = context.i;
        i += 1;
        while (i < len) {
          context.i = i;
          switch (sequence.charAt(i)) {
            case "[":
              output3.push(this.parseSequence(sequence, context));
              i = context.i;
              break;
            case "{":
              output3.push(this.parseMapping(sequence, context));
              i = context.i;
              break;
            case "]":
              return output3;
            case ",":
            case " ":
            case "\n":
              break;
            default:
              isQuoted = (ref = sequence.charAt(i)) === '"' || ref === "'";
              value = this.parseScalar(sequence, [",", "]"], ['"', "'"], context);
              i = context.i;
              if (!isQuoted && typeof value === "string" && (value.indexOf(": ") !== -1 || value.indexOf(":\n") !== -1)) {
                try {
                  value = this.parseMapping("{" + value + "}");
                } catch (error3) {
                  e = error3;
                }
              }
              output3.push(value);
              --i;
          }
          ++i;
        }
        throw new ParseMore("Malformed inline YAML string " + sequence);
      };
      Inline2.parseMapping = function(mapping, context) {
        var done, i, key, len, output3, shouldContinueWhileLoop, value;
        output3 = {};
        len = mapping.length;
        i = context.i;
        i += 1;
        shouldContinueWhileLoop = false;
        while (i < len) {
          context.i = i;
          switch (mapping.charAt(i)) {
            case " ":
            case ",":
            case "\n":
              ++i;
              context.i = i;
              shouldContinueWhileLoop = true;
              break;
            case "}":
              return output3;
          }
          if (shouldContinueWhileLoop) {
            shouldContinueWhileLoop = false;
            continue;
          }
          key = this.parseScalar(mapping, [":", " ", "\n"], ['"', "'"], context, false);
          i = context.i;
          done = false;
          while (i < len) {
            context.i = i;
            switch (mapping.charAt(i)) {
              case "[":
                value = this.parseSequence(mapping, context);
                i = context.i;
                if (output3[key] === void 0) {
                  output3[key] = value;
                }
                done = true;
                break;
              case "{":
                value = this.parseMapping(mapping, context);
                i = context.i;
                if (output3[key] === void 0) {
                  output3[key] = value;
                }
                done = true;
                break;
              case ":":
              case " ":
              case "\n":
                break;
              default:
                value = this.parseScalar(mapping, [",", "}"], ['"', "'"], context);
                i = context.i;
                if (output3[key] === void 0) {
                  output3[key] = value;
                }
                done = true;
                --i;
            }
            ++i;
            if (done) {
              break;
            }
          }
        }
        throw new ParseMore("Malformed inline YAML string " + mapping);
      };
      Inline2.evaluateScalar = function(scalar, context) {
        var cast, date, exceptionOnInvalidType, firstChar, firstSpace, firstWord, objectDecoder, raw, scalarLower, subValue, trimmedScalar;
        scalar = Utils.trim(scalar);
        scalarLower = scalar.toLowerCase();
        switch (scalarLower) {
          case "null":
          case "":
          case "~":
            return null;
          case "true":
            return true;
          case "false":
            return false;
          case ".inf":
            return Infinity;
          case ".nan":
            return 0 / 0;
          case "-.inf":
            return Infinity;
          default:
            firstChar = scalarLower.charAt(0);
            switch (firstChar) {
              case "!":
                firstSpace = scalar.indexOf(" ");
                if (firstSpace === -1) {
                  firstWord = scalarLower;
                } else {
                  firstWord = scalarLower.slice(0, firstSpace);
                }
                switch (firstWord) {
                  case "!":
                    if (firstSpace !== -1) {
                      return parseInt(this.parseScalar(scalar.slice(2)));
                    }
                    return null;
                  case "!str":
                    return Utils.ltrim(scalar.slice(4));
                  case "!!str":
                    return Utils.ltrim(scalar.slice(5));
                  case "!!int":
                    return parseInt(this.parseScalar(scalar.slice(5)));
                  case "!!bool":
                    return Utils.parseBoolean(this.parseScalar(scalar.slice(6)), false);
                  case "!!float":
                    return parseFloat(this.parseScalar(scalar.slice(7)));
                  case "!!timestamp":
                    return Utils.stringToDate(Utils.ltrim(scalar.slice(11)));
                  default:
                    if (context == null) {
                      context = {
                        exceptionOnInvalidType: this.settings.exceptionOnInvalidType,
                        objectDecoder: this.settings.objectDecoder,
                        i: 0
                      };
                    }
                    objectDecoder = context.objectDecoder, exceptionOnInvalidType = context.exceptionOnInvalidType;
                    if (objectDecoder) {
                      trimmedScalar = Utils.rtrim(scalar);
                      firstSpace = trimmedScalar.indexOf(" ");
                      if (firstSpace === -1) {
                        return objectDecoder(trimmedScalar, null);
                      } else {
                        subValue = Utils.ltrim(trimmedScalar.slice(firstSpace + 1));
                        if (!(subValue.length > 0)) {
                          subValue = null;
                        }
                        return objectDecoder(trimmedScalar.slice(0, firstSpace), subValue);
                      }
                    }
                    if (exceptionOnInvalidType) {
                      throw new ParseException("Custom object support when parsing a YAML file has been disabled.");
                    }
                    return null;
                }
                break;
              case "0":
                if ("0x" === scalar.slice(0, 2)) {
                  return Utils.hexDec(scalar);
                } else if (Utils.isDigits(scalar)) {
                  return Utils.octDec(scalar);
                } else if (Utils.isNumeric(scalar)) {
                  return parseFloat(scalar);
                } else {
                  return scalar;
                }
                break;
              case "+":
                if (Utils.isDigits(scalar)) {
                  raw = scalar;
                  cast = parseInt(raw);
                  if (raw === String(cast)) {
                    return cast;
                  } else {
                    return raw;
                  }
                } else if (Utils.isNumeric(scalar)) {
                  return parseFloat(scalar);
                } else if (this.PATTERN_THOUSAND_NUMERIC_SCALAR.test(scalar)) {
                  return parseFloat(scalar.replace(",", ""));
                }
                return scalar;
              case "-":
                if (Utils.isDigits(scalar.slice(1))) {
                  if ("0" === scalar.charAt(1)) {
                    return -Utils.octDec(scalar.slice(1));
                  } else {
                    raw = scalar.slice(1);
                    cast = parseInt(raw);
                    if (raw === String(cast)) {
                      return -cast;
                    } else {
                      return -raw;
                    }
                  }
                } else if (Utils.isNumeric(scalar)) {
                  return parseFloat(scalar);
                } else if (this.PATTERN_THOUSAND_NUMERIC_SCALAR.test(scalar)) {
                  return parseFloat(scalar.replace(",", ""));
                }
                return scalar;
              default:
                if (date = Utils.stringToDate(scalar)) {
                  return date;
                } else if (Utils.isNumeric(scalar)) {
                  return parseFloat(scalar);
                } else if (this.PATTERN_THOUSAND_NUMERIC_SCALAR.test(scalar)) {
                  return parseFloat(scalar.replace(",", ""));
                }
                return scalar;
            }
        }
      };
      return Inline2;
    }();
    module2.exports = Inline;
  }
});

// ../../node_modules/yamljs/lib/Parser.js
var require_Parser = __commonJS({
  "../../node_modules/yamljs/lib/Parser.js"(exports2, module2) {
    var Inline;
    var ParseException;
    var ParseMore;
    var Parser;
    var Pattern;
    var Utils;
    Inline = require_Inline();
    Pattern = require_Pattern();
    Utils = require_Utils();
    ParseException = require_ParseException();
    ParseMore = require_ParseMore();
    Parser = function() {
      Parser2.prototype.PATTERN_FOLDED_SCALAR_ALL = new Pattern("^(?:(?<type>![^\\|>]*)\\s+)?(?<separator>\\||>)(?<modifiers>\\+|\\-|\\d+|\\+\\d+|\\-\\d+|\\d+\\+|\\d+\\-)?(?<comments> +#.*)?$");
      Parser2.prototype.PATTERN_FOLDED_SCALAR_END = new Pattern("(?<separator>\\||>)(?<modifiers>\\+|\\-|\\d+|\\+\\d+|\\-\\d+|\\d+\\+|\\d+\\-)?(?<comments> +#.*)?$");
      Parser2.prototype.PATTERN_SEQUENCE_ITEM = new Pattern("^\\-((?<leadspaces>\\s+)(?<value>.+?))?\\s*$");
      Parser2.prototype.PATTERN_ANCHOR_VALUE = new Pattern("^&(?<ref>[^ ]+) *(?<value>.*)");
      Parser2.prototype.PATTERN_COMPACT_NOTATION = new Pattern("^(?<key>" + Inline.REGEX_QUOTED_STRING + `|[^ '"\\{\\[].*?) *\\:(\\s+(?<value>.+?))?\\s*$`);
      Parser2.prototype.PATTERN_MAPPING_ITEM = new Pattern("^(?<key>" + Inline.REGEX_QUOTED_STRING + `|[^ '"\\[\\{].*?) *\\:(\\s+(?<value>.+?))?\\s*$`);
      Parser2.prototype.PATTERN_DECIMAL = new Pattern("\\d+");
      Parser2.prototype.PATTERN_INDENT_SPACES = new Pattern("^ +");
      Parser2.prototype.PATTERN_TRAILING_LINES = new Pattern("(\n*)$");
      Parser2.prototype.PATTERN_YAML_HEADER = new Pattern("^\\%YAML[: ][\\d\\.]+.*\n", "m");
      Parser2.prototype.PATTERN_LEADING_COMMENTS = new Pattern("^(\\#.*?\n)+", "m");
      Parser2.prototype.PATTERN_DOCUMENT_MARKER_START = new Pattern("^\\-\\-\\-.*?\n", "m");
      Parser2.prototype.PATTERN_DOCUMENT_MARKER_END = new Pattern("^\\.\\.\\.\\s*$", "m");
      Parser2.prototype.PATTERN_FOLDED_SCALAR_BY_INDENTATION = {};
      Parser2.prototype.CONTEXT_NONE = 0;
      Parser2.prototype.CONTEXT_SEQUENCE = 1;
      Parser2.prototype.CONTEXT_MAPPING = 2;
      function Parser2(offset) {
        this.offset = offset != null ? offset : 0;
        this.lines = [];
        this.currentLineNb = -1;
        this.currentLine = "";
        this.refs = {};
      }
      Parser2.prototype.parse = function(value, exceptionOnInvalidType, objectDecoder) {
        var alias, allowOverwrite, block, c, context, data2, e, first, i, indent, isRef, j, k, key, l, lastKey, len, len1, len2, len3, lineCount, m, matches, mergeNode, n, name, parsed, parsedItem, parser, ref, ref1, ref2, refName, refValue, val, values;
        if (exceptionOnInvalidType == null) {
          exceptionOnInvalidType = false;
        }
        if (objectDecoder == null) {
          objectDecoder = null;
        }
        this.currentLineNb = -1;
        this.currentLine = "";
        this.lines = this.cleanup(value).split("\n");
        data2 = null;
        context = this.CONTEXT_NONE;
        allowOverwrite = false;
        while (this.moveToNextLine()) {
          if (this.isCurrentLineEmpty()) {
            continue;
          }
          if ("	" === this.currentLine[0]) {
            throw new ParseException("A YAML file cannot contain tabs as indentation.", this.getRealCurrentLineNb() + 1, this.currentLine);
          }
          isRef = mergeNode = false;
          if (values = this.PATTERN_SEQUENCE_ITEM.exec(this.currentLine)) {
            if (this.CONTEXT_MAPPING === context) {
              throw new ParseException("You cannot define a sequence item when in a mapping");
            }
            context = this.CONTEXT_SEQUENCE;
            if (data2 == null) {
              data2 = [];
            }
            if (values.value != null && (matches = this.PATTERN_ANCHOR_VALUE.exec(values.value))) {
              isRef = matches.ref;
              values.value = matches.value;
            }
            if (!(values.value != null) || "" === Utils.trim(values.value, " ") || Utils.ltrim(values.value, " ").indexOf("#") === 0) {
              if (this.currentLineNb < this.lines.length - 1 && !this.isNextLineUnIndentedCollection()) {
                c = this.getRealCurrentLineNb() + 1;
                parser = new Parser2(c);
                parser.refs = this.refs;
                data2.push(parser.parse(this.getNextEmbedBlock(null, true), exceptionOnInvalidType, objectDecoder));
              } else {
                data2.push(null);
              }
            } else {
              if (((ref = values.leadspaces) != null ? ref.length : void 0) && (matches = this.PATTERN_COMPACT_NOTATION.exec(values.value))) {
                c = this.getRealCurrentLineNb();
                parser = new Parser2(c);
                parser.refs = this.refs;
                block = values.value;
                indent = this.getCurrentLineIndentation();
                if (this.isNextLineIndented(false)) {
                  block += "\n" + this.getNextEmbedBlock(indent + values.leadspaces.length + 1, true);
                }
                data2.push(parser.parse(block, exceptionOnInvalidType, objectDecoder));
              } else {
                data2.push(this.parseValue(values.value, exceptionOnInvalidType, objectDecoder));
              }
            }
          } else if ((values = this.PATTERN_MAPPING_ITEM.exec(this.currentLine)) && values.key.indexOf(" #") === -1) {
            if (this.CONTEXT_SEQUENCE === context) {
              throw new ParseException("You cannot define a mapping item when in a sequence");
            }
            context = this.CONTEXT_MAPPING;
            if (data2 == null) {
              data2 = {};
            }
            Inline.configure(exceptionOnInvalidType, objectDecoder);
            try {
              key = Inline.parseScalar(values.key);
            } catch (error3) {
              e = error3;
              e.parsedLine = this.getRealCurrentLineNb() + 1;
              e.snippet = this.currentLine;
              throw e;
            }
            if ("<<" === key) {
              mergeNode = true;
              allowOverwrite = true;
              if (((ref1 = values.value) != null ? ref1.indexOf("*") : void 0) === 0) {
                refName = values.value.slice(1);
                if (this.refs[refName] == null) {
                  throw new ParseException('Reference "' + refName + '" does not exist.', this.getRealCurrentLineNb() + 1, this.currentLine);
                }
                refValue = this.refs[refName];
                if (typeof refValue !== "object") {
                  throw new ParseException("YAML merge keys used with a scalar value instead of an object.", this.getRealCurrentLineNb() + 1, this.currentLine);
                }
                if (refValue instanceof Array) {
                  for (i = j = 0, len = refValue.length; j < len; i = ++j) {
                    value = refValue[i];
                    if (data2[name = String(i)] == null) {
                      data2[name] = value;
                    }
                  }
                } else {
                  for (key in refValue) {
                    value = refValue[key];
                    if (data2[key] == null) {
                      data2[key] = value;
                    }
                  }
                }
              } else {
                if (values.value != null && values.value !== "") {
                  value = values.value;
                } else {
                  value = this.getNextEmbedBlock();
                }
                c = this.getRealCurrentLineNb() + 1;
                parser = new Parser2(c);
                parser.refs = this.refs;
                parsed = parser.parse(value, exceptionOnInvalidType);
                if (typeof parsed !== "object") {
                  throw new ParseException("YAML merge keys used with a scalar value instead of an object.", this.getRealCurrentLineNb() + 1, this.currentLine);
                }
                if (parsed instanceof Array) {
                  for (l = 0, len1 = parsed.length; l < len1; l++) {
                    parsedItem = parsed[l];
                    if (typeof parsedItem !== "object") {
                      throw new ParseException("Merge items must be objects.", this.getRealCurrentLineNb() + 1, parsedItem);
                    }
                    if (parsedItem instanceof Array) {
                      for (i = m = 0, len2 = parsedItem.length; m < len2; i = ++m) {
                        value = parsedItem[i];
                        k = String(i);
                        if (!data2.hasOwnProperty(k)) {
                          data2[k] = value;
                        }
                      }
                    } else {
                      for (key in parsedItem) {
                        value = parsedItem[key];
                        if (!data2.hasOwnProperty(key)) {
                          data2[key] = value;
                        }
                      }
                    }
                  }
                } else {
                  for (key in parsed) {
                    value = parsed[key];
                    if (!data2.hasOwnProperty(key)) {
                      data2[key] = value;
                    }
                  }
                }
              }
            } else if (values.value != null && (matches = this.PATTERN_ANCHOR_VALUE.exec(values.value))) {
              isRef = matches.ref;
              values.value = matches.value;
            }
            if (mergeNode) {
            } else if (!(values.value != null) || "" === Utils.trim(values.value, " ") || Utils.ltrim(values.value, " ").indexOf("#") === 0) {
              if (!this.isNextLineIndented() && !this.isNextLineUnIndentedCollection()) {
                if (allowOverwrite || data2[key] === void 0) {
                  data2[key] = null;
                }
              } else {
                c = this.getRealCurrentLineNb() + 1;
                parser = new Parser2(c);
                parser.refs = this.refs;
                val = parser.parse(this.getNextEmbedBlock(), exceptionOnInvalidType, objectDecoder);
                if (allowOverwrite || data2[key] === void 0) {
                  data2[key] = val;
                }
              }
            } else {
              val = this.parseValue(values.value, exceptionOnInvalidType, objectDecoder);
              if (allowOverwrite || data2[key] === void 0) {
                data2[key] = val;
              }
            }
          } else {
            lineCount = this.lines.length;
            if (1 === lineCount || 2 === lineCount && Utils.isEmpty(this.lines[1])) {
              try {
                value = Inline.parse(this.lines[0], exceptionOnInvalidType, objectDecoder);
              } catch (error3) {
                e = error3;
                e.parsedLine = this.getRealCurrentLineNb() + 1;
                e.snippet = this.currentLine;
                throw e;
              }
              if (typeof value === "object") {
                if (value instanceof Array) {
                  first = value[0];
                } else {
                  for (key in value) {
                    first = value[key];
                    break;
                  }
                }
                if (typeof first === "string" && first.indexOf("*") === 0) {
                  data2 = [];
                  for (n = 0, len3 = value.length; n < len3; n++) {
                    alias = value[n];
                    data2.push(this.refs[alias.slice(1)]);
                  }
                  value = data2;
                }
              }
              return value;
            } else if ((ref2 = Utils.ltrim(value).charAt(0)) === "[" || ref2 === "{") {
              try {
                return Inline.parse(value, exceptionOnInvalidType, objectDecoder);
              } catch (error3) {
                e = error3;
                e.parsedLine = this.getRealCurrentLineNb() + 1;
                e.snippet = this.currentLine;
                throw e;
              }
            }
            throw new ParseException("Unable to parse.", this.getRealCurrentLineNb() + 1, this.currentLine);
          }
          if (isRef) {
            if (data2 instanceof Array) {
              this.refs[isRef] = data2[data2.length - 1];
            } else {
              lastKey = null;
              for (key in data2) {
                lastKey = key;
              }
              this.refs[isRef] = data2[lastKey];
            }
          }
        }
        if (Utils.isEmpty(data2)) {
          return null;
        } else {
          return data2;
        }
      };
      Parser2.prototype.getRealCurrentLineNb = function() {
        return this.currentLineNb + this.offset;
      };
      Parser2.prototype.getCurrentLineIndentation = function() {
        return this.currentLine.length - Utils.ltrim(this.currentLine, " ").length;
      };
      Parser2.prototype.getNextEmbedBlock = function(indentation, includeUnindentedCollection) {
        var data2, indent, isItUnindentedCollection, newIndent, removeComments, removeCommentsPattern, unindentedEmbedBlock;
        if (indentation == null) {
          indentation = null;
        }
        if (includeUnindentedCollection == null) {
          includeUnindentedCollection = false;
        }
        this.moveToNextLine();
        if (indentation == null) {
          newIndent = this.getCurrentLineIndentation();
          unindentedEmbedBlock = this.isStringUnIndentedCollectionItem(this.currentLine);
          if (!this.isCurrentLineEmpty() && 0 === newIndent && !unindentedEmbedBlock) {
            throw new ParseException("Indentation problem.", this.getRealCurrentLineNb() + 1, this.currentLine);
          }
        } else {
          newIndent = indentation;
        }
        data2 = [this.currentLine.slice(newIndent)];
        if (!includeUnindentedCollection) {
          isItUnindentedCollection = this.isStringUnIndentedCollectionItem(this.currentLine);
        }
        removeCommentsPattern = this.PATTERN_FOLDED_SCALAR_END;
        removeComments = !removeCommentsPattern.test(this.currentLine);
        while (this.moveToNextLine()) {
          indent = this.getCurrentLineIndentation();
          if (indent === newIndent) {
            removeComments = !removeCommentsPattern.test(this.currentLine);
          }
          if (removeComments && this.isCurrentLineComment()) {
            continue;
          }
          if (this.isCurrentLineBlank()) {
            data2.push(this.currentLine.slice(newIndent));
            continue;
          }
          if (isItUnindentedCollection && !this.isStringUnIndentedCollectionItem(this.currentLine) && indent === newIndent) {
            this.moveToPreviousLine();
            break;
          }
          if (indent >= newIndent) {
            data2.push(this.currentLine.slice(newIndent));
          } else if (Utils.ltrim(this.currentLine).charAt(0) === "#") {
          } else if (0 === indent) {
            this.moveToPreviousLine();
            break;
          } else {
            throw new ParseException("Indentation problem.", this.getRealCurrentLineNb() + 1, this.currentLine);
          }
        }
        return data2.join("\n");
      };
      Parser2.prototype.moveToNextLine = function() {
        if (this.currentLineNb >= this.lines.length - 1) {
          return false;
        }
        this.currentLine = this.lines[++this.currentLineNb];
        return true;
      };
      Parser2.prototype.moveToPreviousLine = function() {
        this.currentLine = this.lines[--this.currentLineNb];
      };
      Parser2.prototype.parseValue = function(value, exceptionOnInvalidType, objectDecoder) {
        var e, foldedIndent, matches, modifiers, pos, ref, ref1, val;
        if (0 === value.indexOf("*")) {
          pos = value.indexOf("#");
          if (pos !== -1) {
            value = value.substr(1, pos - 2);
          } else {
            value = value.slice(1);
          }
          if (this.refs[value] === void 0) {
            throw new ParseException('Reference "' + value + '" does not exist.', this.currentLine);
          }
          return this.refs[value];
        }
        if (matches = this.PATTERN_FOLDED_SCALAR_ALL.exec(value)) {
          modifiers = (ref = matches.modifiers) != null ? ref : "";
          foldedIndent = Math.abs(parseInt(modifiers));
          if (isNaN(foldedIndent)) {
            foldedIndent = 0;
          }
          val = this.parseFoldedScalar(matches.separator, this.PATTERN_DECIMAL.replace(modifiers, ""), foldedIndent);
          if (matches.type != null) {
            Inline.configure(exceptionOnInvalidType, objectDecoder);
            return Inline.parseScalar(matches.type + " " + val);
          } else {
            return val;
          }
        }
        if ((ref1 = value.charAt(0)) === "[" || ref1 === "{" || ref1 === '"' || ref1 === "'") {
          while (true) {
            try {
              return Inline.parse(value, exceptionOnInvalidType, objectDecoder);
            } catch (error3) {
              e = error3;
              if (e instanceof ParseMore && this.moveToNextLine()) {
                value += "\n" + Utils.trim(this.currentLine, " ");
              } else {
                e.parsedLine = this.getRealCurrentLineNb() + 1;
                e.snippet = this.currentLine;
                throw e;
              }
            }
          }
        } else {
          if (this.isNextLineIndented()) {
            value += "\n" + this.getNextEmbedBlock();
          }
          return Inline.parse(value, exceptionOnInvalidType, objectDecoder);
        }
      };
      Parser2.prototype.parseFoldedScalar = function(separator, indicator, indentation) {
        var isCurrentLineBlank, j, len, line, matches, newText, notEOF, pattern, ref, text;
        if (indicator == null) {
          indicator = "";
        }
        if (indentation == null) {
          indentation = 0;
        }
        notEOF = this.moveToNextLine();
        if (!notEOF) {
          return "";
        }
        isCurrentLineBlank = this.isCurrentLineBlank();
        text = "";
        while (notEOF && isCurrentLineBlank) {
          if (notEOF = this.moveToNextLine()) {
            text += "\n";
            isCurrentLineBlank = this.isCurrentLineBlank();
          }
        }
        if (0 === indentation) {
          if (matches = this.PATTERN_INDENT_SPACES.exec(this.currentLine)) {
            indentation = matches[0].length;
          }
        }
        if (indentation > 0) {
          pattern = this.PATTERN_FOLDED_SCALAR_BY_INDENTATION[indentation];
          if (pattern == null) {
            pattern = new Pattern("^ {" + indentation + "}(.*)$");
            Parser2.prototype.PATTERN_FOLDED_SCALAR_BY_INDENTATION[indentation] = pattern;
          }
          while (notEOF && (isCurrentLineBlank || (matches = pattern.exec(this.currentLine)))) {
            if (isCurrentLineBlank) {
              text += this.currentLine.slice(indentation);
            } else {
              text += matches[1];
            }
            if (notEOF = this.moveToNextLine()) {
              text += "\n";
              isCurrentLineBlank = this.isCurrentLineBlank();
            }
          }
        } else if (notEOF) {
          text += "\n";
        }
        if (notEOF) {
          this.moveToPreviousLine();
        }
        if (">" === separator) {
          newText = "";
          ref = text.split("\n");
          for (j = 0, len = ref.length; j < len; j++) {
            line = ref[j];
            if (line.length === 0 || line.charAt(0) === " ") {
              newText = Utils.rtrim(newText, " ") + line + "\n";
            } else {
              newText += line + " ";
            }
          }
          text = newText;
        }
        if ("+" !== indicator) {
          text = Utils.rtrim(text);
        }
        if ("" === indicator) {
          text = this.PATTERN_TRAILING_LINES.replace(text, "\n");
        } else if ("-" === indicator) {
          text = this.PATTERN_TRAILING_LINES.replace(text, "");
        }
        return text;
      };
      Parser2.prototype.isNextLineIndented = function(ignoreComments) {
        var EOF, currentIndentation, ret;
        if (ignoreComments == null) {
          ignoreComments = true;
        }
        currentIndentation = this.getCurrentLineIndentation();
        EOF = !this.moveToNextLine();
        if (ignoreComments) {
          while (!EOF && this.isCurrentLineEmpty()) {
            EOF = !this.moveToNextLine();
          }
        } else {
          while (!EOF && this.isCurrentLineBlank()) {
            EOF = !this.moveToNextLine();
          }
        }
        if (EOF) {
          return false;
        }
        ret = false;
        if (this.getCurrentLineIndentation() > currentIndentation) {
          ret = true;
        }
        this.moveToPreviousLine();
        return ret;
      };
      Parser2.prototype.isCurrentLineEmpty = function() {
        var trimmedLine;
        trimmedLine = Utils.trim(this.currentLine, " ");
        return trimmedLine.length === 0 || trimmedLine.charAt(0) === "#";
      };
      Parser2.prototype.isCurrentLineBlank = function() {
        return "" === Utils.trim(this.currentLine, " ");
      };
      Parser2.prototype.isCurrentLineComment = function() {
        var ltrimmedLine;
        ltrimmedLine = Utils.ltrim(this.currentLine, " ");
        return ltrimmedLine.charAt(0) === "#";
      };
      Parser2.prototype.cleanup = function(value) {
        var count, i, indent, j, l, len, len1, line, lines, ref, ref1, ref2, smallestIndent, trimmedValue;
        if (value.indexOf("\r") !== -1) {
          value = value.split("\r\n").join("\n").split("\r").join("\n");
        }
        count = 0;
        ref = this.PATTERN_YAML_HEADER.replaceAll(value, ""), value = ref[0], count = ref[1];
        this.offset += count;
        ref1 = this.PATTERN_LEADING_COMMENTS.replaceAll(value, "", 1), trimmedValue = ref1[0], count = ref1[1];
        if (count === 1) {
          this.offset += Utils.subStrCount(value, "\n") - Utils.subStrCount(trimmedValue, "\n");
          value = trimmedValue;
        }
        ref2 = this.PATTERN_DOCUMENT_MARKER_START.replaceAll(value, "", 1), trimmedValue = ref2[0], count = ref2[1];
        if (count === 1) {
          this.offset += Utils.subStrCount(value, "\n") - Utils.subStrCount(trimmedValue, "\n");
          value = trimmedValue;
          value = this.PATTERN_DOCUMENT_MARKER_END.replace(value, "");
        }
        lines = value.split("\n");
        smallestIndent = -1;
        for (j = 0, len = lines.length; j < len; j++) {
          line = lines[j];
          if (Utils.trim(line, " ").length === 0) {
            continue;
          }
          indent = line.length - Utils.ltrim(line).length;
          if (smallestIndent === -1 || indent < smallestIndent) {
            smallestIndent = indent;
          }
        }
        if (smallestIndent > 0) {
          for (i = l = 0, len1 = lines.length; l < len1; i = ++l) {
            line = lines[i];
            lines[i] = line.slice(smallestIndent);
          }
          value = lines.join("\n");
        }
        return value;
      };
      Parser2.prototype.isNextLineUnIndentedCollection = function(currentIndentation) {
        var notEOF, ret;
        if (currentIndentation == null) {
          currentIndentation = null;
        }
        if (currentIndentation == null) {
          currentIndentation = this.getCurrentLineIndentation();
        }
        notEOF = this.moveToNextLine();
        while (notEOF && this.isCurrentLineEmpty()) {
          notEOF = this.moveToNextLine();
        }
        if (false === notEOF) {
          return false;
        }
        ret = false;
        if (this.getCurrentLineIndentation() === currentIndentation && this.isStringUnIndentedCollectionItem(this.currentLine)) {
          ret = true;
        }
        this.moveToPreviousLine();
        return ret;
      };
      Parser2.prototype.isStringUnIndentedCollectionItem = function() {
        return this.currentLine === "-" || this.currentLine.slice(0, 2) === "- ";
      };
      return Parser2;
    }();
    module2.exports = Parser;
  }
});

// ../../node_modules/yamljs/lib/Dumper.js
var require_Dumper = __commonJS({
  "../../node_modules/yamljs/lib/Dumper.js"(exports2, module2) {
    var Dumper;
    var Inline;
    var Utils;
    Utils = require_Utils();
    Inline = require_Inline();
    Dumper = function() {
      function Dumper2() {
      }
      Dumper2.indentation = 4;
      Dumper2.prototype.dump = function(input, inline, indent, exceptionOnInvalidType, objectEncoder) {
        var i, key, len, output3, prefix, value, willBeInlined;
        if (inline == null) {
          inline = 0;
        }
        if (indent == null) {
          indent = 0;
        }
        if (exceptionOnInvalidType == null) {
          exceptionOnInvalidType = false;
        }
        if (objectEncoder == null) {
          objectEncoder = null;
        }
        output3 = "";
        prefix = indent ? Utils.strRepeat(" ", indent) : "";
        if (inline <= 0 || typeof input !== "object" || input instanceof Date || Utils.isEmpty(input)) {
          output3 += prefix + Inline.dump(input, exceptionOnInvalidType, objectEncoder);
        } else {
          if (input instanceof Array) {
            for (i = 0, len = input.length; i < len; i++) {
              value = input[i];
              willBeInlined = inline - 1 <= 0 || typeof value !== "object" || Utils.isEmpty(value);
              output3 += prefix + "-" + (willBeInlined ? " " : "\n") + this.dump(value, inline - 1, willBeInlined ? 0 : indent + this.indentation, exceptionOnInvalidType, objectEncoder) + (willBeInlined ? "\n" : "");
            }
          } else {
            for (key in input) {
              value = input[key];
              willBeInlined = inline - 1 <= 0 || typeof value !== "object" || Utils.isEmpty(value);
              output3 += prefix + Inline.dump(key, exceptionOnInvalidType, objectEncoder) + ":" + (willBeInlined ? " " : "\n") + this.dump(value, inline - 1, willBeInlined ? 0 : indent + this.indentation, exceptionOnInvalidType, objectEncoder) + (willBeInlined ? "\n" : "");
            }
          }
        }
        return output3;
      };
      return Dumper2;
    }();
    module2.exports = Dumper;
  }
});

// ../../node_modules/yamljs/lib/Yaml.js
var require_Yaml = __commonJS({
  "../../node_modules/yamljs/lib/Yaml.js"(exports2, module2) {
    var Dumper;
    var Parser;
    var Utils;
    var Yaml;
    Parser = require_Parser();
    Dumper = require_Dumper();
    Utils = require_Utils();
    Yaml = function() {
      function Yaml2() {
      }
      Yaml2.parse = function(input, exceptionOnInvalidType, objectDecoder) {
        if (exceptionOnInvalidType == null) {
          exceptionOnInvalidType = false;
        }
        if (objectDecoder == null) {
          objectDecoder = null;
        }
        return new Parser().parse(input, exceptionOnInvalidType, objectDecoder);
      };
      Yaml2.parseFile = function(path, callback, exceptionOnInvalidType, objectDecoder) {
        var input;
        if (callback == null) {
          callback = null;
        }
        if (exceptionOnInvalidType == null) {
          exceptionOnInvalidType = false;
        }
        if (objectDecoder == null) {
          objectDecoder = null;
        }
        if (callback != null) {
          return Utils.getStringFromFile(path, function(_this) {
            return function(input2) {
              var result2;
              result2 = null;
              if (input2 != null) {
                result2 = _this.parse(input2, exceptionOnInvalidType, objectDecoder);
              }
              callback(result2);
            };
          }(this));
        } else {
          input = Utils.getStringFromFile(path);
          if (input != null) {
            return this.parse(input, exceptionOnInvalidType, objectDecoder);
          }
          return null;
        }
      };
      Yaml2.dump = function(input, inline, indent, exceptionOnInvalidType, objectEncoder) {
        var yaml;
        if (inline == null) {
          inline = 2;
        }
        if (indent == null) {
          indent = 4;
        }
        if (exceptionOnInvalidType == null) {
          exceptionOnInvalidType = false;
        }
        if (objectEncoder == null) {
          objectEncoder = null;
        }
        yaml = new Dumper();
        yaml.indentation = indent;
        return yaml.dump(input, inline, 0, exceptionOnInvalidType, objectEncoder);
      };
      Yaml2.stringify = function(input, inline, indent, exceptionOnInvalidType, objectEncoder) {
        return this.dump(input, inline, indent, exceptionOnInvalidType, objectEncoder);
      };
      Yaml2.load = function(path, callback, exceptionOnInvalidType, objectDecoder) {
        return this.parseFile(path, callback, exceptionOnInvalidType, objectDecoder);
      };
      return Yaml2;
    }();
    if (typeof window !== "undefined" && window !== null) {
      window.YAML = Yaml;
    }
    if (typeof window === "undefined" || window === null) {
      exports2.YAML = Yaml;
    }
    module2.exports = Yaml;
  }
});

// ../lib/ux-cds/dist/utils/file.js
var require_file3 = __commonJS({
  "../lib/ux-cds/dist/utils/file.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fileExists = exports2.readFile = void 0;
    var fs_1 = require("fs");
    async function readFile2(path) {
      const data2 = await fs_1.promises.readFile(path);
      return Buffer.from(data2).toString("utf8");
    }
    exports2.readFile = readFile2;
    async function fileExists(path) {
      try {
        await fs_1.promises.access(path);
        return true;
      } catch {
        return false;
      }
    }
    exports2.fileExists = fileExists;
  }
});

// ../lib/ux-cds/dist/utils/capProject.js
var require_capProject = __commonJS({
  "../lib/ux-cds/dist/utils/capProject.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toReferenceUri = exports2.toAbsoluteUri = exports2.isCapJavaProject = exports2.isCapNodeJsProject = exports2.isCapProject = exports2.CAP_DB_FOLDER = exports2.CAP_APPS_FOLDER = exports2.CAP_SERVICES_FOLDER = void 0;
    var path_1 = require("path");
    var file_1 = require_file3();
    exports2.CAP_SERVICES_FOLDER = "srv";
    exports2.CAP_APPS_FOLDER = "app";
    exports2.CAP_DB_FOLDER = "db";
    var packageJsonFileName = "package.json";
    async function parsePackageJson(projectRoot) {
      let packageJson;
      const packageJsonPath = path_1.join(projectRoot, packageJsonFileName);
      if (await file_1.fileExists(packageJsonPath)) {
        try {
          packageJson = JSON.parse(await file_1.readFile(packageJsonPath));
        } catch (error3) {
        }
      }
      return packageJson;
    }
    async function isCapProject(projectRoot, packageJson) {
      return await isCapNodeJsProject(projectRoot, packageJson) || await isCapJavaProject(projectRoot);
    }
    exports2.isCapProject = isCapProject;
    async function isCapNodeJsProject(projectRoot, packageJson) {
      var _a2;
      if (!packageJson) {
        packageJson = await parsePackageJson(projectRoot);
      }
      return !!((packageJson == null ? void 0 : packageJson.cds) || ((_a2 = packageJson == null ? void 0 : packageJson.dependencies) == null ? void 0 : _a2["@sap/cds"]));
    }
    exports2.isCapNodeJsProject = isCapNodeJsProject;
    async function isCapJavaProject(projectRoot) {
      return file_1.fileExists(path_1.join(projectRoot, exports2.CAP_SERVICES_FOLDER, "src", "main", "resources", "application.yaml"));
    }
    exports2.isCapJavaProject = isCapJavaProject;
    var toAbsoluteUri = (project, relativeUri) => path_1.join(project.root, relativeUri);
    exports2.toAbsoluteUri = toAbsoluteUri;
    var toReferenceUri = async (project, relativeUriFrom, relativeUriTo) => {
      let relativeUri = "";
      const indexNodeModules = relativeUriTo.lastIndexOf("node_modules");
      if (indexNodeModules >= 0) {
        const indexLastDot = relativeUriTo.lastIndexOf(".");
        if (indexLastDot > indexNodeModules + 13) {
          relativeUri = relativeUriTo.slice(indexNodeModules + 13, indexLastDot);
        } else {
          relativeUri = relativeUriTo.slice(indexNodeModules + 13);
        }
      } else if (relativeUriTo.startsWith("../") || relativeUriTo.startsWith("..\\")) {
        const result2 = await getPackageNameInFolder(project.root, relativeUriTo);
        if (result2.packageName) {
          relativeUri = result2.packageName + relativeUriTo.slice(result2.packageFolder.length);
        }
      }
      if (!relativeUri) {
        const fromDir = path_1.dirname(exports2.toAbsoluteUri(project, relativeUriFrom));
        relativeUri = path_1.relative(fromDir, exports2.toAbsoluteUri(project, relativeUriTo));
        if (!relativeUri.startsWith(".")) {
          relativeUri = "./" + relativeUri;
        }
      }
      const fileExtension = relativeUri.lastIndexOf(".") > 0 ? relativeUri.slice(relativeUri.lastIndexOf(".") + 1) : "";
      if (["CDS", "JSON"].includes(fileExtension.toUpperCase())) {
        relativeUri = relativeUri.slice(0, relativeUri.length - fileExtension.length - 1);
      }
      return relativeUri.split(path_1.sep).join("/");
    };
    exports2.toReferenceUri = toReferenceUri;
    async function getPackageNameInFolder(baseUri, relativeUri) {
      const refUriParts = relativeUri.split(path_1.sep);
      const result2 = { packageName: "", packageFolder: relativeUri };
      for (let i = refUriParts.length - 1; i >= 0 && !result2.packageName; i--) {
        const currentFolder = refUriParts.slice(0, i).join(path_1.sep);
        result2.packageName = await readPackageNameForFolder(baseUri, currentFolder);
        if (result2.packageName) {
          result2.packageFolder = currentFolder;
        }
      }
      return result2;
    }
    async function readPackageNameForFolder(baseUri, relativeUri) {
      let packageName = "";
      try {
        const path = path_1.normalize(baseUri + "/" + relativeUri + "/package.json");
        const content = await file_1.readFile(path);
        if (content) {
          const parsed = JSON.parse(content);
          packageName = parsed.name;
        }
      } catch (e) {
        packageName = "";
      }
      return packageName;
    }
  }
});

// ../lib/project-access/core/dist/project/webapp.js
var require_webapp2 = __commonJS({
  "../lib/project-access/core/dist/project/webapp.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getUi5CustomWebappPath = void 0;
    var file_1 = require_file2();
    var path_1 = require("path");
    var project_spec_1 = require_dist3();
    var yaml = __importStar(require_Yaml());
    async function getUi5CustomWebappPath(root) {
      var _a2, _b, _c, _d, _e;
      let webappPath = project_spec_1.DirName.Webapp;
      try {
        const yamlContent = await file_1.readFile(path_1.join(root, project_spec_1.FileName.Ui5Yaml));
        webappPath = (_e = (_d = (_c = (_b = (_a2 = yaml.parse(yamlContent)) == null ? void 0 : _a2.resources) == null ? void 0 : _b.configuration) == null ? void 0 : _c.paths) == null ? void 0 : _d.webapp) != null ? _e : project_spec_1.DirName.Webapp;
      } catch {
        webappPath = project_spec_1.DirName.Webapp;
      }
      return webappPath;
    }
    exports2.getUi5CustomWebappPath = getUi5CustomWebappPath;
  }
});

// ../lib/ui5-info/core/dist/commandRunner.js
var require_commandRunner = __commonJS({
  "../lib/ui5-info/core/dist/commandRunner.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CommandRunner = void 0;
    var child_process_1 = require("child_process");
    var CommandRunner = class {
      run(cmd, args = []) {
        return new Promise((resolve, reject) => {
          const stack = [];
          const spawnedCmd = child_process_1.spawn(cmd, args, {});
          spawnedCmd.stdout.setEncoding("utf8");
          let response;
          spawnedCmd.stdout.on("data", (data2) => {
            response = data2.toString();
          });
          spawnedCmd.stderr.on("data", (data2) => {
            stack.push(data2.toString());
          });
          spawnedCmd.on("close", (errorCode) => {
            if (errorCode !== 0) {
              reject(`Command failed, \`${cmd} ${args.join(" ")}\`, ${stack.join(", ")}`);
            }
            resolve(response);
          });
        });
      }
    };
    exports2.CommandRunner = CommandRunner;
  }
});

// ../../node_modules/semver-compare/index.js
var require_semver_compare = __commonJS({
  "../../node_modules/semver-compare/index.js"(exports2, module2) {
    module2.exports = function cmp(a, b) {
      var pa = a.split(".");
      var pb = b.split(".");
      for (var i = 0; i < 3; i++) {
        var na = Number(pa[i]);
        var nb = Number(pb[i]);
        if (na > nb)
          return 1;
        if (nb > na)
          return -1;
        if (!isNaN(na) && isNaN(nb))
          return 1;
        if (isNaN(na) && !isNaN(nb))
          return -1;
      }
      return 0;
    };
  }
});

// ../lib/ui5-info/core/node_modules/semver/internal/constants.js
var require_constants2 = __commonJS({
  "../lib/ui5-info/core/node_modules/semver/internal/constants.js"(exports2, module2) {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    module2.exports = {
      SEMVER_SPEC_VERSION,
      MAX_LENGTH,
      MAX_SAFE_INTEGER,
      MAX_SAFE_COMPONENT_LENGTH
    };
  }
});

// ../lib/ui5-info/core/node_modules/semver/internal/debug.js
var require_debug2 = __commonJS({
  "../lib/ui5-info/core/node_modules/semver/internal/debug.js"(exports2, module2) {
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug;
  }
});

// ../lib/ui5-info/core/node_modules/semver/internal/re.js
var require_re = __commonJS({
  "../lib/ui5-info/core/node_modules/semver/internal/re.js"(exports2, module2) {
    var { MAX_SAFE_COMPONENT_LENGTH } = require_constants2();
    var debug = require_debug2();
    exports2 = module2.exports = {};
    var re = exports2.re = [];
    var src = exports2.src = [];
    var t = exports2.t = {};
    var R = 0;
    var createToken = (name, value, isGlobal) => {
      const index = R++;
      debug(index, value);
      t[name] = index;
      src[index] = value;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+");
    createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*");
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+");
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports2.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports2.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports2.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0.0.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
  }
});

// ../lib/ui5-info/core/node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "../lib/ui5-info/core/node_modules/semver/internal/parse-options.js"(exports2, module2) {
    var opts = ["includePrerelease", "loose", "rtl"];
    var parseOptions = (options2) => !options2 ? {} : typeof options2 !== "object" ? { loose: true } : opts.filter((k) => options2[k]).reduce((options3, k) => {
      options3[k] = true;
      return options3;
    }, {});
    module2.exports = parseOptions;
  }
});

// ../lib/ui5-info/core/node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "../lib/ui5-info/core/node_modules/semver/internal/identifiers.js"(exports2, module2) {
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// ../lib/ui5-info/core/node_modules/semver/classes/semver.js
var require_semver4 = __commonJS({
  "../lib/ui5-info/core/node_modules/semver/classes/semver.js"(exports2, module2) {
    var debug = require_debug2();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants2();
    var { re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class {
      constructor(version, options2) {
        options2 = parseOptions(options2);
        if (version instanceof SemVer) {
          if (version.loose === !!options2.loose && version.includePrerelease === !!options2.includePrerelease) {
            return version;
          } else {
            version = version.version;
          }
        } else if (typeof version !== "string") {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        if (version.length > MAX_LENGTH) {
          throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
        }
        debug("SemVer", version, options2);
        this.options = options2;
        this.loose = !!options2.loose;
        this.includePrerelease = !!options2.includePrerelease;
        const m = version.trim().match(options2.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      inc(release, identifier) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier);
            this.inc("pre", identifier);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier);
            }
            this.inc("pre", identifier);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre":
            if (this.prerelease.length === 0) {
              this.prerelease = [0];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                this.prerelease.push(0);
              }
            }
            if (identifier) {
              if (this.prerelease[0] === identifier) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = [identifier, 0];
                }
              } else {
                this.prerelease = [identifier, 0];
              }
            }
            break;
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.format();
        this.raw = this.version;
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// ../lib/ui5-info/core/node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "../lib/ui5-info/core/node_modules/semver/functions/parse.js"(exports2, module2) {
    var { MAX_LENGTH } = require_constants2();
    var { re, t } = require_re();
    var SemVer = require_semver4();
    var parseOptions = require_parse_options();
    var parse2 = (version, options2) => {
      options2 = parseOptions(options2);
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      if (version.length > MAX_LENGTH) {
        return null;
      }
      const r = options2.loose ? re[t.LOOSE] : re[t.FULL];
      if (!r.test(version)) {
        return null;
      }
      try {
        return new SemVer(version, options2);
      } catch (er) {
        return null;
      }
    };
    module2.exports = parse2;
  }
});

// ../lib/ui5-info/core/node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "../lib/ui5-info/core/node_modules/semver/functions/valid.js"(exports2, module2) {
    var parse2 = require_parse();
    var valid = (version, options2) => {
      const v = parse2(version, options2);
      return v ? v.version : null;
    };
    module2.exports = valid;
  }
});

// ../lib/ui5-info/core/node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "../lib/ui5-info/core/node_modules/semver/functions/clean.js"(exports2, module2) {
    var parse2 = require_parse();
    var clean = (version, options2) => {
      const s = parse2(version.trim().replace(/^[=v]+/, ""), options2);
      return s ? s.version : null;
    };
    module2.exports = clean;
  }
});

// ../lib/ui5-info/core/node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "../lib/ui5-info/core/node_modules/semver/functions/inc.js"(exports2, module2) {
    var SemVer = require_semver4();
    var inc = (version, release, options2, identifier) => {
      if (typeof options2 === "string") {
        identifier = options2;
        options2 = void 0;
      }
      try {
        return new SemVer(version, options2).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  }
});

// ../lib/ui5-info/core/node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "../lib/ui5-info/core/node_modules/semver/functions/compare.js"(exports2, module2) {
    var SemVer = require_semver4();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module2.exports = compare;
  }
});

// ../lib/ui5-info/core/node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "../lib/ui5-info/core/node_modules/semver/functions/eq.js"(exports2, module2) {
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module2.exports = eq;
  }
});

// ../lib/ui5-info/core/node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "../lib/ui5-info/core/node_modules/semver/functions/diff.js"(exports2, module2) {
    var parse2 = require_parse();
    var eq = require_eq();
    var diff = (version1, version2) => {
      if (eq(version1, version2)) {
        return null;
      } else {
        const v1 = parse2(version1);
        const v2 = parse2(version2);
        const hasPre = v1.prerelease.length || v2.prerelease.length;
        const prefix = hasPre ? "pre" : "";
        const defaultResult = hasPre ? "prerelease" : "";
        for (const key in v1) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    };
    module2.exports = diff;
  }
});

// ../lib/ui5-info/core/node_modules/semver/functions/major.js
var require_major = __commonJS({
  "../lib/ui5-info/core/node_modules/semver/functions/major.js"(exports2, module2) {
    var SemVer = require_semver4();
    var major = (a, loose) => new SemVer(a, loose).major;
    module2.exports = major;
  }
});

// ../lib/ui5-info/core/node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "../lib/ui5-info/core/node_modules/semver/functions/minor.js"(exports2, module2) {
    var SemVer = require_semver4();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module2.exports = minor;
  }
});

// ../lib/ui5-info/core/node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "../lib/ui5-info/core/node_modules/semver/functions/patch.js"(exports2, module2) {
    var SemVer = require_semver4();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module2.exports = patch;
  }
});

// ../lib/ui5-info/core/node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "../lib/ui5-info/core/node_modules/semver/functions/prerelease.js"(exports2, module2) {
    var parse2 = require_parse();
    var prerelease = (version, options2) => {
      const parsed = parse2(version, options2);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  }
});

// ../lib/ui5-info/core/node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "../lib/ui5-info/core/node_modules/semver/functions/rcompare.js"(exports2, module2) {
    var compare = require_compare();
    var rcompare = (a, b, loose) => compare(b, a, loose);
    module2.exports = rcompare;
  }
});

// ../lib/ui5-info/core/node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "../lib/ui5-info/core/node_modules/semver/functions/compare-loose.js"(exports2, module2) {
    var compare = require_compare();
    var compareLoose = (a, b) => compare(a, b, true);
    module2.exports = compareLoose;
  }
});

// ../lib/ui5-info/core/node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "../lib/ui5-info/core/node_modules/semver/functions/compare-build.js"(exports2, module2) {
    var SemVer = require_semver4();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  }
});

// ../lib/ui5-info/core/node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "../lib/ui5-info/core/node_modules/semver/functions/sort.js"(exports2, module2) {
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module2.exports = sort;
  }
});

// ../lib/ui5-info/core/node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "../lib/ui5-info/core/node_modules/semver/functions/rsort.js"(exports2, module2) {
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module2.exports = rsort;
  }
});

// ../lib/ui5-info/core/node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "../lib/ui5-info/core/node_modules/semver/functions/gt.js"(exports2, module2) {
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module2.exports = gt;
  }
});

// ../lib/ui5-info/core/node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "../lib/ui5-info/core/node_modules/semver/functions/lt.js"(exports2, module2) {
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module2.exports = lt;
  }
});

// ../lib/ui5-info/core/node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "../lib/ui5-info/core/node_modules/semver/functions/neq.js"(exports2, module2) {
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module2.exports = neq;
  }
});

// ../lib/ui5-info/core/node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "../lib/ui5-info/core/node_modules/semver/functions/gte.js"(exports2, module2) {
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module2.exports = gte;
  }
});

// ../lib/ui5-info/core/node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "../lib/ui5-info/core/node_modules/semver/functions/lte.js"(exports2, module2) {
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module2.exports = lte;
  }
});

// ../lib/ui5-info/core/node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "../lib/ui5-info/core/node_modules/semver/functions/cmp.js"(exports2, module2) {
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  }
});

// ../lib/ui5-info/core/node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "../lib/ui5-info/core/node_modules/semver/functions/coerce.js"(exports2, module2) {
    var SemVer = require_semver4();
    var parse2 = require_parse();
    var { re, t } = require_re();
    var coerce = (version, options2) => {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version === "number") {
        version = String(version);
      }
      if (typeof version !== "string") {
        return null;
      }
      options2 = options2 || {};
      let match = null;
      if (!options2.rtl) {
        match = version.match(re[t.COERCE]);
      } else {
        let next;
        while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        re[t.COERCERTL].lastIndex = -1;
      }
      if (match === null)
        return null;
      return parse2(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options2);
    };
    module2.exports = coerce;
  }
});

// ../../node_modules/yallist/iterator.js
var require_iterator = __commonJS({
  "../../node_modules/yallist/iterator.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  }
});

// ../../node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "../../node_modules/yallist/yallist.js"(exports2, module2) {
    "use strict";
    module2.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self2 = this;
      if (!(self2 instanceof Yallist)) {
        self2 = new Yallist();
      }
      self2.tail = null;
      self2.head = null;
      self2.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self2.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self2.push(arguments[i]);
        }
      }
      return self2;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i = 0; walker && i < deleteCount; i++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i = 0; i < nodes.length; i++) {
        walker = insert(this, walker, nodes[i]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self2, node, value) {
      var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
      if (inserted.next === null) {
        self2.tail = inserted;
      }
      if (inserted.prev === null) {
        self2.head = inserted;
      }
      self2.length++;
      return inserted;
    }
    function push(self2, item) {
      self2.tail = new Node(item, self2.tail, null, self2);
      if (!self2.head) {
        self2.head = self2.tail;
      }
      self2.length++;
    }
    function unshift(self2, item) {
      self2.head = new Node(item, null, self2.head, self2);
      if (!self2.tail) {
        self2.tail = self2.head;
      }
      self2.length++;
    }
    function Node(value, prev, next, list) {
      if (!(this instanceof Node)) {
        return new Node(value, prev, next, list);
      }
      this.list = list;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator()(Yallist);
    } catch (er) {
    }
  }
});

// ../../node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "../../node_modules/lru-cache/index.js"(exports2, module2) {
    "use strict";
    var Yallist = require_yallist();
    var MAX = Symbol("max");
    var LENGTH = Symbol("length");
    var LENGTH_CALCULATOR = Symbol("lengthCalculator");
    var ALLOW_STALE = Symbol("allowStale");
    var MAX_AGE = Symbol("maxAge");
    var DISPOSE = Symbol("dispose");
    var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
    var LRU_LIST = Symbol("lruList");
    var CACHE = Symbol("cache");
    var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
    var naiveLength = () => 1;
    var LRUCache = class {
      constructor(options2) {
        if (typeof options2 === "number")
          options2 = { max: options2 };
        if (!options2)
          options2 = {};
        if (options2.max && (typeof options2.max !== "number" || options2.max < 0))
          throw new TypeError("max must be a non-negative number");
        const max = this[MAX] = options2.max || Infinity;
        const lc = options2.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options2.stale || false;
        if (options2.maxAge && typeof options2.maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options2.maxAge || 0;
        this[DISPOSE] = options2.dispose;
        this[NO_DISPOSE_ON_SET] = options2.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options2.updateAgeOnGet || false;
        this.reset();
      }
      set max(mL) {
        if (typeof mL !== "number" || mL < 0)
          throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim(this);
      }
      get max() {
        return this[MAX];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA !== "number")
          throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      set lengthCalculator(lC) {
        if (typeof lC !== "function")
          lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach((hit) => {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          });
        }
        trim(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail; walker !== null; ) {
          const prev = walker.prev;
          forEachStep(this, fn, walker, thisp);
          walker = prev;
        }
      }
      forEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head; walker !== null; ) {
          const next = walker.next;
          forEachStep(this, fn, walker, thisp);
          walker = next;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map((k) => k.key);
      }
      values() {
        return this[LRU_LIST].toArray().map((k) => k.value);
      }
      reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
          this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
        }
        this[CACHE] = /* @__PURE__ */ new Map();
        this[LRU_LIST] = new Yallist();
        this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        }).toArray().filter((h) => h);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value, key);
        if (this[CACHE].has(key)) {
          if (len > this[MAX]) {
            del(this, this[CACHE].get(key));
            return false;
          }
          const node = this[CACHE].get(key);
          const item = node.value;
          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET])
              this[DISPOSE](key, item.value);
          }
          item.now = now;
          item.maxAge = maxAge;
          item.value = value;
          this[LENGTH] += len - item.length;
          item.length = len;
          this.get(key);
          trim(this);
          return true;
        }
        const hit = new Entry(key, value, len, now, maxAge);
        if (hit.length > this[MAX]) {
          if (this[DISPOSE])
            this[DISPOSE](key, value);
          return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim(this);
        return true;
      }
      has(key) {
        if (!this[CACHE].has(key))
          return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
      }
      get(key) {
        return get3(this, key, true);
      }
      peek(key) {
        return get3(this, key, false);
      }
      pop() {
        const node = this[LRU_LIST].tail;
        if (!node)
          return null;
        del(this, node);
        return node.value;
      }
      del(key) {
        del(this, this[CACHE].get(key));
      }
      load(arr) {
        this.reset();
        const now = Date.now();
        for (let l = arr.length - 1; l >= 0; l--) {
          const hit = arr[l];
          const expiresAt = hit.e || 0;
          if (expiresAt === 0)
            this.set(hit.k, hit.v);
          else {
            const maxAge = expiresAt - now;
            if (maxAge > 0) {
              this.set(hit.k, hit.v, maxAge);
            }
          }
        }
      }
      prune() {
        this[CACHE].forEach((value, key) => get3(this, key, false));
      }
    };
    var get3 = (self2, key, doUse) => {
      const node = self2[CACHE].get(key);
      if (node) {
        const hit = node.value;
        if (isStale(self2, hit)) {
          del(self2, node);
          if (!self2[ALLOW_STALE])
            return void 0;
        } else {
          if (doUse) {
            if (self2[UPDATE_AGE_ON_GET])
              node.value.now = Date.now();
            self2[LRU_LIST].unshiftNode(node);
          }
        }
        return hit.value;
      }
    };
    var isStale = (self2, hit) => {
      if (!hit || !hit.maxAge && !self2[MAX_AGE])
        return false;
      const diff = Date.now() - hit.now;
      return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
    };
    var trim = (self2) => {
      if (self2[LENGTH] > self2[MAX]) {
        for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
          const prev = walker.prev;
          del(self2, walker);
          walker = prev;
        }
      }
    };
    var del = (self2, node) => {
      if (node) {
        const hit = node.value;
        if (self2[DISPOSE])
          self2[DISPOSE](hit.key, hit.value);
        self2[LENGTH] -= hit.length;
        self2[CACHE].delete(hit.key);
        self2[LRU_LIST].removeNode(node);
      }
    };
    var Entry = class {
      constructor(key, value, length, now, maxAge) {
        this.key = key;
        this.value = value;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
      }
    };
    var forEachStep = (self2, fn, node, thisp) => {
      let hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE])
          hit = void 0;
      }
      if (hit)
        fn.call(thisp, hit.value, hit.key, self2);
    };
    module2.exports = LRUCache;
  }
});

// ../lib/ui5-info/core/node_modules/semver/classes/range.js
var require_range = __commonJS({
  "../lib/ui5-info/core/node_modules/semver/classes/range.js"(exports2, module2) {
    var Range = class {
      constructor(range, options2) {
        options2 = parseOptions(options2);
        if (range instanceof Range) {
          if (range.loose === !!options2.loose && range.includePrerelease === !!options2.includePrerelease) {
            return range;
          } else {
            return new Range(range.raw, options2);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.format();
          return this;
        }
        this.options = options2;
        this.loose = !!options2.loose;
        this.includePrerelease = !!options2.includePrerelease;
        this.raw = range;
        this.set = range.split(/\s*\|\|\s*/).map((range2) => this.parseRange(range2.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${range}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0)
            this.set = [first];
          else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.format();
      }
      format() {
        this.range = this.set.map((comps) => {
          return comps.join(" ").trim();
        }).join("||").trim();
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        range = range.trim();
        const memoOpts = Object.keys(this.options).join(",");
        const memoKey = `parseRange:${memoOpts}:${range}`;
        const cached = cache.get(memoKey);
        if (cached)
          return cached;
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range, re[t.COMPARATORTRIM]);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        range = range.split(/\s+/).join(" ");
        const compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options)).filter(this.options.loose ? (comp) => !!comp.match(compRe) : () => true).map((comp) => new Comparator(comp, this.options));
        const l = rangeList.length;
        const rangeMap = /* @__PURE__ */ new Map();
        for (const comp of rangeList) {
          if (isNullSet(comp))
            return [comp];
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has(""))
          rangeMap.delete("");
        const result2 = [...rangeMap.values()];
        cache.set(memoKey, result2);
        return result2;
      }
      intersects(range, options2) {
        if (!(range instanceof Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options2) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options2) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options2);
              });
            });
          });
        });
      }
      test(version) {
        if (!version) {
          return false;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range;
    var LRU = require_lru_cache();
    var cache = new LRU({ max: 1e3 });
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug2();
    var SemVer = require_semver4();
    var {
      re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options2) => {
      let result2 = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result2 && remainingComparators.length) {
        result2 = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options2);
        });
        testComparator = remainingComparators.pop();
      }
      return result2;
    };
    var parseComparator = (comp, options2) => {
      debug("comp", comp, options2);
      comp = replaceCarets(comp, options2);
      debug("caret", comp);
      comp = replaceTildes(comp, options2);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options2);
      debug("xrange", comp);
      comp = replaceStars(comp, options2);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options2) => comp.trim().split(/\s+/).map((comp2) => {
      return replaceTilde(comp2, options2);
    }).join(" ");
    var replaceTilde = (comp, options2) => {
      const r = options2.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_45, M, m, p, pr) => {
        debug("tilde", comp, _45, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options2) => comp.trim().split(/\s+/).map((comp2) => {
      return replaceCaret(comp2, options2);
    }).join(" ");
    var replaceCaret = (comp, options2) => {
      debug("caret", comp, options2);
      const r = options2.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options2.includePrerelease ? "-0" : "";
      return comp.replace(r, (_45, M, m, p, pr) => {
        debug("caret", comp, _45, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options2) => {
      debug("replaceXRanges", comp, options2);
      return comp.split(/\s+/).map((comp2) => {
        return replaceXRange(comp2, options2);
      }).join(" ");
    };
    var replaceXRange = (comp, options2) => {
      comp = comp.trim();
      const r = options2.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options2.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<")
            pr = "-0";
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options2) => {
      debug("replaceStars", comp, options2);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options2) => {
      debug("replaceGTE0", comp, options2);
      return comp.trim().replace(re[options2.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version, options2) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options2.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// ../lib/ui5-info/core/node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "../lib/ui5-info/core/node_modules/semver/classes/comparator.js"(exports2, module2) {
    var ANY = Symbol("SemVer ANY");
    var Comparator = class {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options2) {
        options2 = parseOptions(options2);
        if (comp instanceof Comparator) {
          if (comp.loose === !!options2.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        debug("comparator", comp, options2);
        this.options = options2;
        this.loose = !!options2.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version) {
        debug("Comparator.test", version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
          return true;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version, this.operator, this.semver, this.options);
      }
      intersects(comp, options2) {
        if (!(comp instanceof Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (!options2 || typeof options2 !== "object") {
          options2 = {
            loose: !!options2,
            includePrerelease: false
          };
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options2).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options2).test(comp.semver);
        }
        const sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
        const sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
        const sameSemVer = this.semver.version === comp.semver.version;
        const differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
        const oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options2) && (this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<");
        const oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options2) && (this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">");
        return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug2();
    var SemVer = require_semver4();
    var Range = require_range();
  }
});

// ../lib/ui5-info/core/node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "../lib/ui5-info/core/node_modules/semver/functions/satisfies.js"(exports2, module2) {
    var Range = require_range();
    var satisfies = (version, range, options2) => {
      try {
        range = new Range(range, options2);
      } catch (er) {
        return false;
      }
      return range.test(version);
    };
    module2.exports = satisfies;
  }
});

// ../lib/ui5-info/core/node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "../lib/ui5-info/core/node_modules/semver/ranges/to-comparators.js"(exports2, module2) {
    var Range = require_range();
    var toComparators = (range, options2) => new Range(range, options2).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  }
});

// ../lib/ui5-info/core/node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "../lib/ui5-info/core/node_modules/semver/ranges/max-satisfying.js"(exports2, module2) {
    var SemVer = require_semver4();
    var Range = require_range();
    var maxSatisfying = (versions, range, options2) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options2);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options2);
          }
        }
      });
      return max;
    };
    module2.exports = maxSatisfying;
  }
});

// ../lib/ui5-info/core/node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "../lib/ui5-info/core/node_modules/semver/ranges/min-satisfying.js"(exports2, module2) {
    var SemVer = require_semver4();
    var Range = require_range();
    var minSatisfying = (versions, range, options2) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options2);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options2);
          }
        }
      });
      return min;
    };
    module2.exports = minSatisfying;
  }
});

// ../lib/ui5-info/core/node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "../lib/ui5-info/core/node_modules/semver/ranges/min-version.js"(exports2, module2) {
    var SemVer = require_semver4();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin)))
          minver = setMin;
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  }
});

// ../lib/ui5-info/core/node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "../lib/ui5-info/core/node_modules/semver/ranges/valid.js"(exports2, module2) {
    var Range = require_range();
    var validRange = (range, options2) => {
      try {
        return new Range(range, options2).range || "*";
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange;
  }
});

// ../lib/ui5-info/core/node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "../lib/ui5-info/core/node_modules/semver/ranges/outside.js"(exports2, module2) {
    var SemVer = require_semver4();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version, range, hilo, options2) => {
      version = new SemVer(version, options2);
      range = new Range(range, options2);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options2)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options2)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options2)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  }
});

// ../lib/ui5-info/core/node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "../lib/ui5-info/core/node_modules/semver/ranges/gtr.js"(exports2, module2) {
    var outside = require_outside();
    var gtr = (version, range, options2) => outside(version, range, ">", options2);
    module2.exports = gtr;
  }
});

// ../lib/ui5-info/core/node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "../lib/ui5-info/core/node_modules/semver/ranges/ltr.js"(exports2, module2) {
    var outside = require_outside();
    var ltr = (version, range, options2) => outside(version, range, "<", options2);
    module2.exports = ltr;
  }
});

// ../lib/ui5-info/core/node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "../lib/ui5-info/core/node_modules/semver/ranges/intersects.js"(exports2, module2) {
    var Range = require_range();
    var intersects = (r1, r2, options2) => {
      r1 = new Range(r1, options2);
      r2 = new Range(r2, options2);
      return r1.intersects(r2);
    };
    module2.exports = intersects;
  }
});

// ../lib/ui5-info/core/node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "../lib/ui5-info/core/node_modules/semver/ranges/simplify.js"(exports2, module2) {
    var satisfies = require_satisfies();
    var compare = require_compare();
    module2.exports = (versions, range, options2) => {
      const set = [];
      let min = null;
      let prev = null;
      const v = versions.sort((a, b) => compare(a, b, options2));
      for (const version of v) {
        const included = satisfies(version, range, options2);
        if (included) {
          prev = version;
          if (!min)
            min = version;
        } else {
          if (prev) {
            set.push([min, prev]);
          }
          prev = null;
          min = null;
        }
      }
      if (min)
        set.push([min, null]);
      const ranges = [];
      for (const [min2, max] of set) {
        if (min2 === max)
          ranges.push(min2);
        else if (!max && min2 === v[0])
          ranges.push("*");
        else if (!max)
          ranges.push(`>=${min2}`);
        else if (min2 === v[0])
          ranges.push(`<=${max}`);
        else
          ranges.push(`${min2} - ${max}`);
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// ../lib/ui5-info/core/node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "../lib/ui5-info/core/node_modules/semver/ranges/subset.js"(exports2, module2) {
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options2 = {}) => {
      if (sub === dom)
        return true;
      sub = new Range(sub, options2);
      dom = new Range(dom, options2);
      let sawNonNull = false;
      OUTER:
        for (const simpleSub of sub.set) {
          for (const simpleDom of dom.set) {
            const isSub = simpleSubset(simpleSub, simpleDom, options2);
            sawNonNull = sawNonNull || isSub !== null;
            if (isSub)
              continue OUTER;
          }
          if (sawNonNull)
            return false;
        }
      return true;
    };
    var simpleSubset = (sub, dom, options2) => {
      if (sub === dom)
        return true;
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY)
          return true;
        else if (options2.includePrerelease)
          sub = [new Comparator(">=0.0.0-0")];
        else
          sub = [new Comparator(">=0.0.0")];
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options2.includePrerelease)
          return true;
        else
          dom = [new Comparator(">=0.0.0")];
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=")
          gt = higherGT(gt, c, options2);
        else if (c.operator === "<" || c.operator === "<=")
          lt = lowerLT(lt, c, options2);
        else
          eqSet.add(c.semver);
      }
      if (eqSet.size > 1)
        return null;
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options2);
        if (gtltComp > 0)
          return null;
        else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<="))
          return null;
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options2))
          return null;
        if (lt && !satisfies(eq, String(lt), options2))
          return null;
        for (const c of dom) {
          if (!satisfies(eq, String(c), options2))
            return false;
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options2.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options2.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options2);
            if (higher === c && higher !== gt)
              return false;
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options2))
            return false;
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options2);
            if (lower === c && lower !== lt)
              return false;
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options2))
            return false;
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0)
          return false;
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0)
        return false;
      if (lt && hasDomGT && !gt && gtltComp !== 0)
        return false;
      if (needDomGTPre || needDomLTPre)
        return false;
      return true;
    };
    var higherGT = (a, b, options2) => {
      if (!a)
        return b;
      const comp = compare(a.semver, b.semver, options2);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options2) => {
      if (!a)
        return b;
      const comp = compare(a.semver, b.semver, options2);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module2.exports = subset;
  }
});

// ../lib/ui5-info/core/node_modules/semver/index.js
var require_semver5 = __commonJS({
  "../lib/ui5-info/core/node_modules/semver/index.js"(exports2, module2) {
    var internalRe = require_re();
    module2.exports = {
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: require_constants2().SEMVER_SPEC_VERSION,
      SemVer: require_semver4(),
      compareIdentifiers: require_identifiers().compareIdentifiers,
      rcompareIdentifiers: require_identifiers().rcompareIdentifiers,
      parse: require_parse(),
      valid: require_valid(),
      clean: require_clean(),
      inc: require_inc(),
      diff: require_diff(),
      major: require_major(),
      minor: require_minor(),
      patch: require_patch(),
      prerelease: require_prerelease(),
      compare: require_compare(),
      rcompare: require_rcompare(),
      compareLoose: require_compare_loose(),
      compareBuild: require_compare_build(),
      sort: require_sort(),
      rsort: require_rsort(),
      gt: require_gt(),
      lt: require_lt(),
      eq: require_eq(),
      neq: require_neq(),
      gte: require_gte(),
      lte: require_lte(),
      cmp: require_cmp(),
      coerce: require_coerce(),
      Comparator: require_comparator(),
      Range: require_range(),
      satisfies: require_satisfies(),
      toComparators: require_to_comparators(),
      maxSatisfying: require_max_satisfying(),
      minSatisfying: require_min_satisfying(),
      minVersion: require_min_version(),
      validRange: require_valid2(),
      outside: require_outside(),
      gtr: require_gtr(),
      ltr: require_ltr(),
      intersects: require_intersects(),
      simplifyRange: require_simplify(),
      subset: require_subset()
    };
  }
});

// ../lib/store/dist/contants.js
var require_contants = __commonJS({
  "../lib/store/dist/contants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Entity = exports2.ServiceName = void 0;
    var ServiceName;
    (function(ServiceName2) {
      ServiceName2["OldSystemService"] = "fiori/system/info";
      ServiceName2["OldRefreshTokenService"] = "fiori/system/refreshToken";
      ServiceName2["ApiHub"] = "fiori/system/apiHub";
    })(ServiceName = exports2.ServiceName || (exports2.ServiceName = {}));
    var Entity;
    (function(Entity2) {
      Entity2["BackendSystem"] = "system";
    })(Entity = exports2.Entity || (exports2.Entity = {}));
  }
});

// ../../node_modules/i18next-fs-backend/cjs/utils.js
var require_utils2 = __commonJS({
  "../../node_modules/i18next-fs-backend/cjs/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.defaults = defaults;
    exports2.debounce = debounce;
    exports2.setPath = setPath3;
    exports2.pushPath = pushPath3;
    exports2.getPath = getPath3;
    var arr = [];
    var each = arr.forEach;
    var slice = arr.slice;
    function defaults(obj) {
      each.call(slice.call(arguments, 1), function(source) {
        if (source) {
          for (var prop in source) {
            if (obj[prop] === void 0)
              obj[prop] = source[prop];
          }
        }
      });
      return obj;
    }
    function debounce(func, wait, immediate) {
      var timeout;
      return function() {
        var context = this;
        var args = arguments;
        var later = function later2() {
          timeout = null;
          if (!immediate)
            func.apply(context, args);
        };
        var callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (callNow)
          func.apply(context, args);
      };
    }
    function getLastOfPath3(object, path, Empty) {
      function cleanKey(key2) {
        return key2 && key2.indexOf("###") > -1 ? key2.replace(/###/g, ".") : key2;
      }
      var stack = typeof path !== "string" ? [].concat(path) : path.split(".");
      while (stack.length > 1) {
        if (!object)
          return {};
        var key = cleanKey(stack.shift());
        if (!object[key] && Empty)
          object[key] = new Empty();
        object = object[key];
      }
      if (!object)
        return {};
      return {
        obj: object,
        k: cleanKey(stack.shift())
      };
    }
    function setPath3(object, path, newValue) {
      var _getLastOfPath = getLastOfPath3(object, path, Object), obj = _getLastOfPath.obj, k = _getLastOfPath.k;
      obj[k] = newValue;
    }
    function pushPath3(object, path, newValue, concat) {
      var _getLastOfPath2 = getLastOfPath3(object, path, Object), obj = _getLastOfPath2.obj, k = _getLastOfPath2.k;
      obj[k] = obj[k] || [];
      if (concat)
        obj[k] = obj[k].concat(newValue);
      if (!concat)
        obj[k].push(newValue);
    }
    function getPath3(object, path) {
      var _getLastOfPath3 = getLastOfPath3(object, path), obj = _getLastOfPath3.obj, k = _getLastOfPath3.k;
      if (!obj)
        return void 0;
      return obj[k];
    }
  }
});

// ../../node_modules/i18next-fs-backend/cjs/formats/json5.js
var require_json5 = __commonJS({
  "../../node_modules/i18next-fs-backend/cjs/formats/json5.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it;
      if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i = 0;
          var F = function F2() {
          };
          return { s: F, n: function n() {
            if (i >= o.length)
              return { done: true };
            return { done: false, value: o[i++] };
          }, e: function e(_e) {
            throw _e;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true, didErr = false, err;
      return { s: function s() {
        it = o[Symbol.iterator]();
      }, n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      }, e: function e(_e2) {
        didErr = true;
        err = _e2;
      }, f: function f() {
        try {
          if (!normalCompletion && it.return != null)
            it.return();
        } finally {
          if (didErr)
            throw err;
        }
      } };
    }
    function _unsupportedIterableToArray2(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray2(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray2(o, minLen);
    }
    function _arrayLikeToArray2(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    function _typeof3(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof3 = function _typeof4(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof3 = function _typeof4(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof3(obj);
    }
    var Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
    var ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
    var ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;
    var unicode = {
      Space_Separator,
      ID_Start,
      ID_Continue
    };
    var util = {
      isSpaceSeparator: function isSpaceSeparator(c2) {
        return typeof c2 === "string" && unicode.Space_Separator.test(c2);
      },
      isIdStartChar: function isIdStartChar(c2) {
        return typeof c2 === "string" && (c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 === "$" || c2 === "_" || unicode.ID_Start.test(c2));
      },
      isIdContinueChar: function isIdContinueChar(c2) {
        return typeof c2 === "string" && (c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 >= "0" && c2 <= "9" || c2 === "$" || c2 === "_" || c2 === "\u200C" || c2 === "\u200D" || unicode.ID_Continue.test(c2));
      },
      isDigit: function isDigit(c2) {
        return typeof c2 === "string" && /[0-9]/.test(c2);
      },
      isHexDigit: function isHexDigit(c2) {
        return typeof c2 === "string" && /[0-9A-Fa-f]/.test(c2);
      }
    };
    var source;
    var parseState;
    var stack;
    var pos;
    var line;
    var column;
    var token2;
    var key;
    var root;
    var parse2 = function parse3(text, reviver) {
      source = String(text);
      parseState = "start";
      stack = [];
      pos = 0;
      line = 1;
      column = 0;
      token2 = void 0;
      key = void 0;
      root = void 0;
      do {
        token2 = lex();
        parseStates[parseState]();
      } while (token2.type !== "eof");
      if (typeof reviver === "function") {
        return internalize({
          "": root
        }, "", reviver);
      }
      return root;
    };
    function internalize(holder, name, reviver) {
      var value = holder[name];
      if (value != null && _typeof3(value) === "object") {
        for (var _key in value) {
          var replacement = internalize(value, _key, reviver);
          if (replacement === void 0) {
            delete value[_key];
          } else {
            value[_key] = replacement;
          }
        }
      }
      return reviver.call(holder, name, value);
    }
    var lexState;
    var buffer;
    var doubleQuote;
    var _sign;
    var c;
    function lex() {
      lexState = "default";
      buffer = "";
      doubleQuote = false;
      _sign = 1;
      for (; ; ) {
        c = peek();
        var _token = lexStates[lexState]();
        if (_token) {
          return _token;
        }
      }
    }
    function peek() {
      if (source[pos]) {
        return String.fromCodePoint(source.codePointAt(pos));
      }
    }
    function read() {
      var c2 = peek();
      if (c2 === "\n") {
        line++;
        column = 0;
      } else if (c2) {
        column += c2.length;
      } else {
        column++;
      }
      if (c2) {
        pos += c2.length;
      }
      return c2;
    }
    var lexStates = {
      default: function _default() {
        switch (c) {
          case "	":
          case "\v":
          case "\f":
          case " ":
          case "\xA0":
          case "\uFEFF":
          case "\n":
          case "\r":
          case "\u2028":
          case "\u2029":
            read();
            return;
          case "/":
            read();
            lexState = "comment";
            return;
          case void 0:
            read();
            return newToken("eof");
        }
        if (util.isSpaceSeparator(c)) {
          read();
          return;
        }
        return lexStates[parseState]();
      },
      comment: function comment() {
        switch (c) {
          case "*":
            read();
            lexState = "multiLineComment";
            return;
          case "/":
            read();
            lexState = "singleLineComment";
            return;
        }
        throw invalidChar(read());
      },
      multiLineComment: function multiLineComment() {
        switch (c) {
          case "*":
            read();
            lexState = "multiLineCommentAsterisk";
            return;
          case void 0:
            throw invalidChar(read());
        }
        read();
      },
      multiLineCommentAsterisk: function multiLineCommentAsterisk() {
        switch (c) {
          case "*":
            read();
            return;
          case "/":
            read();
            lexState = "default";
            return;
          case void 0:
            throw invalidChar(read());
        }
        read();
        lexState = "multiLineComment";
      },
      singleLineComment: function singleLineComment() {
        switch (c) {
          case "\n":
          case "\r":
          case "\u2028":
          case "\u2029":
            read();
            lexState = "default";
            return;
          case void 0:
            read();
            return newToken("eof");
        }
        read();
      },
      value: function value() {
        switch (c) {
          case "{":
          case "[":
            return newToken("punctuator", read());
          case "n":
            read();
            literal2("ull");
            return newToken("null", null);
          case "t":
            read();
            literal2("rue");
            return newToken("boolean", true);
          case "f":
            read();
            literal2("alse");
            return newToken("boolean", false);
          case "-":
          case "+":
            if (read() === "-") {
              _sign = -1;
            }
            lexState = "sign";
            return;
          case ".":
            buffer = read();
            lexState = "decimalPointLeading";
            return;
          case "0":
            buffer = read();
            lexState = "zero";
            return;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            buffer = read();
            lexState = "decimalInteger";
            return;
          case "I":
            read();
            literal2("nfinity");
            return newToken("numeric", Infinity);
          case "N":
            read();
            literal2("aN");
            return newToken("numeric", NaN);
          case '"':
          case "'":
            doubleQuote = read() === '"';
            buffer = "";
            lexState = "string";
            return;
        }
        throw invalidChar(read());
      },
      identifierNameStartEscape: function identifierNameStartEscape() {
        if (c !== "u") {
          throw invalidChar(read());
        }
        read();
        var u = unicodeEscape();
        switch (u) {
          case "$":
          case "_":
            break;
          default:
            if (!util.isIdStartChar(u)) {
              throw invalidIdentifier();
            }
            break;
        }
        buffer += u;
        lexState = "identifierName";
      },
      identifierName: function identifierName() {
        switch (c) {
          case "$":
          case "_":
          case "\u200C":
          case "\u200D":
            buffer += read();
            return;
          case "\\":
            read();
            lexState = "identifierNameEscape";
            return;
        }
        if (util.isIdContinueChar(c)) {
          buffer += read();
          return;
        }
        return newToken("identifier", buffer);
      },
      identifierNameEscape: function identifierNameEscape() {
        if (c !== "u") {
          throw invalidChar(read());
        }
        read();
        var u = unicodeEscape();
        switch (u) {
          case "$":
          case "_":
          case "\u200C":
          case "\u200D":
            break;
          default:
            if (!util.isIdContinueChar(u)) {
              throw invalidIdentifier();
            }
            break;
        }
        buffer += u;
        lexState = "identifierName";
      },
      sign: function sign() {
        switch (c) {
          case ".":
            buffer = read();
            lexState = "decimalPointLeading";
            return;
          case "0":
            buffer = read();
            lexState = "zero";
            return;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            buffer = read();
            lexState = "decimalInteger";
            return;
          case "I":
            read();
            literal2("nfinity");
            return newToken("numeric", _sign * Infinity);
          case "N":
            read();
            literal2("aN");
            return newToken("numeric", NaN);
        }
        throw invalidChar(read());
      },
      zero: function zero() {
        switch (c) {
          case ".":
            buffer += read();
            lexState = "decimalPoint";
            return;
          case "e":
          case "E":
            buffer += read();
            lexState = "decimalExponent";
            return;
          case "x":
          case "X":
            buffer += read();
            lexState = "hexadecimal";
            return;
        }
        return newToken("numeric", _sign * 0);
      },
      decimalInteger: function decimalInteger() {
        switch (c) {
          case ".":
            buffer += read();
            lexState = "decimalPoint";
            return;
          case "e":
          case "E":
            buffer += read();
            lexState = "decimalExponent";
            return;
        }
        if (util.isDigit(c)) {
          buffer += read();
          return;
        }
        return newToken("numeric", _sign * Number(buffer));
      },
      decimalPointLeading: function decimalPointLeading() {
        if (util.isDigit(c)) {
          buffer += read();
          lexState = "decimalFraction";
          return;
        }
        throw invalidChar(read());
      },
      decimalPoint: function decimalPoint() {
        switch (c) {
          case "e":
          case "E":
            buffer += read();
            lexState = "decimalExponent";
            return;
        }
        if (util.isDigit(c)) {
          buffer += read();
          lexState = "decimalFraction";
          return;
        }
        return newToken("numeric", _sign * Number(buffer));
      },
      decimalFraction: function decimalFraction() {
        switch (c) {
          case "e":
          case "E":
            buffer += read();
            lexState = "decimalExponent";
            return;
        }
        if (util.isDigit(c)) {
          buffer += read();
          return;
        }
        return newToken("numeric", _sign * Number(buffer));
      },
      decimalExponent: function decimalExponent() {
        switch (c) {
          case "+":
          case "-":
            buffer += read();
            lexState = "decimalExponentSign";
            return;
        }
        if (util.isDigit(c)) {
          buffer += read();
          lexState = "decimalExponentInteger";
          return;
        }
        throw invalidChar(read());
      },
      decimalExponentSign: function decimalExponentSign() {
        if (util.isDigit(c)) {
          buffer += read();
          lexState = "decimalExponentInteger";
          return;
        }
        throw invalidChar(read());
      },
      decimalExponentInteger: function decimalExponentInteger() {
        if (util.isDigit(c)) {
          buffer += read();
          return;
        }
        return newToken("numeric", _sign * Number(buffer));
      },
      hexadecimal: function hexadecimal() {
        if (util.isHexDigit(c)) {
          buffer += read();
          lexState = "hexadecimalInteger";
          return;
        }
        throw invalidChar(read());
      },
      hexadecimalInteger: function hexadecimalInteger() {
        if (util.isHexDigit(c)) {
          buffer += read();
          return;
        }
        return newToken("numeric", _sign * Number(buffer));
      },
      string: function string() {
        switch (c) {
          case "\\":
            read();
            buffer += escape4();
            return;
          case '"':
            if (doubleQuote) {
              read();
              return newToken("string", buffer);
            }
            buffer += read();
            return;
          case "'":
            if (!doubleQuote) {
              read();
              return newToken("string", buffer);
            }
            buffer += read();
            return;
          case "\n":
          case "\r":
            throw invalidChar(read());
          case "\u2028":
          case "\u2029":
            separatorChar(c);
            break;
          case void 0:
            throw invalidChar(read());
        }
        buffer += read();
      },
      start: function start() {
        switch (c) {
          case "{":
          case "[":
            return newToken("punctuator", read());
        }
        lexState = "value";
      },
      beforePropertyName: function beforePropertyName() {
        switch (c) {
          case "$":
          case "_":
            buffer = read();
            lexState = "identifierName";
            return;
          case "\\":
            read();
            lexState = "identifierNameStartEscape";
            return;
          case "}":
            return newToken("punctuator", read());
          case '"':
          case "'":
            doubleQuote = read() === '"';
            lexState = "string";
            return;
        }
        if (util.isIdStartChar(c)) {
          buffer += read();
          lexState = "identifierName";
          return;
        }
        throw invalidChar(read());
      },
      afterPropertyName: function afterPropertyName() {
        if (c === ":") {
          return newToken("punctuator", read());
        }
        throw invalidChar(read());
      },
      beforePropertyValue: function beforePropertyValue() {
        lexState = "value";
      },
      afterPropertyValue: function afterPropertyValue() {
        switch (c) {
          case ",":
          case "}":
            return newToken("punctuator", read());
        }
        throw invalidChar(read());
      },
      beforeArrayValue: function beforeArrayValue() {
        if (c === "]") {
          return newToken("punctuator", read());
        }
        lexState = "value";
      },
      afterArrayValue: function afterArrayValue() {
        switch (c) {
          case ",":
          case "]":
            return newToken("punctuator", read());
        }
        throw invalidChar(read());
      },
      end: function end() {
        throw invalidChar(read());
      }
    };
    function newToken(type, value) {
      return {
        type,
        value,
        line,
        column
      };
    }
    function literal2(s) {
      var _iterator = _createForOfIteratorHelper(s), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var _c = _step.value;
          var p = peek();
          if (p !== _c) {
            throw invalidChar(read());
          }
          read();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    function escape4() {
      var c2 = peek();
      switch (c2) {
        case "b":
          read();
          return "\b";
        case "f":
          read();
          return "\f";
        case "n":
          read();
          return "\n";
        case "r":
          read();
          return "\r";
        case "t":
          read();
          return "	";
        case "v":
          read();
          return "\v";
        case "0":
          read();
          if (util.isDigit(peek())) {
            throw invalidChar(read());
          }
          return "\0";
        case "x":
          read();
          return hexEscape();
        case "u":
          read();
          return unicodeEscape();
        case "\n":
        case "\u2028":
        case "\u2029":
          read();
          return "";
        case "\r":
          read();
          if (peek() === "\n") {
            read();
          }
          return "";
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          throw invalidChar(read());
        case void 0:
          throw invalidChar(read());
      }
      return read();
    }
    function hexEscape() {
      var buffer2 = "";
      var c2 = peek();
      if (!util.isHexDigit(c2)) {
        throw invalidChar(read());
      }
      buffer2 += read();
      c2 = peek();
      if (!util.isHexDigit(c2)) {
        throw invalidChar(read());
      }
      buffer2 += read();
      return String.fromCodePoint(parseInt(buffer2, 16));
    }
    function unicodeEscape() {
      var buffer2 = "";
      var count = 4;
      while (count-- > 0) {
        var _c2 = peek();
        if (!util.isHexDigit(_c2)) {
          throw invalidChar(read());
        }
        buffer2 += read();
      }
      return String.fromCodePoint(parseInt(buffer2, 16));
    }
    var parseStates = {
      start: function start() {
        if (token2.type === "eof") {
          throw invalidEOF();
        }
        push();
      },
      beforePropertyName: function beforePropertyName() {
        switch (token2.type) {
          case "identifier":
          case "string":
            key = token2.value;
            parseState = "afterPropertyName";
            return;
          case "punctuator":
            pop();
            return;
          case "eof":
            throw invalidEOF();
        }
      },
      afterPropertyName: function afterPropertyName() {
        if (token2.type === "eof") {
          throw invalidEOF();
        }
        parseState = "beforePropertyValue";
      },
      beforePropertyValue: function beforePropertyValue() {
        if (token2.type === "eof") {
          throw invalidEOF();
        }
        push();
      },
      beforeArrayValue: function beforeArrayValue() {
        if (token2.type === "eof") {
          throw invalidEOF();
        }
        if (token2.type === "punctuator" && token2.value === "]") {
          pop();
          return;
        }
        push();
      },
      afterPropertyValue: function afterPropertyValue() {
        if (token2.type === "eof") {
          throw invalidEOF();
        }
        switch (token2.value) {
          case ",":
            parseState = "beforePropertyName";
            return;
          case "}":
            pop();
        }
      },
      afterArrayValue: function afterArrayValue() {
        if (token2.type === "eof") {
          throw invalidEOF();
        }
        switch (token2.value) {
          case ",":
            parseState = "beforeArrayValue";
            return;
          case "]":
            pop();
        }
      },
      end: function end() {
      }
    };
    function push() {
      var value;
      switch (token2.type) {
        case "punctuator":
          switch (token2.value) {
            case "{":
              value = {};
              break;
            case "[":
              value = [];
              break;
          }
          break;
        case "null":
        case "boolean":
        case "numeric":
        case "string":
          value = token2.value;
          break;
      }
      if (root === void 0) {
        root = value;
      } else {
        var parent = stack[stack.length - 1];
        if (Array.isArray(parent)) {
          parent.push(value);
        } else {
          parent[key] = value;
        }
      }
      if (value !== null && _typeof3(value) === "object") {
        stack.push(value);
        if (Array.isArray(value)) {
          parseState = "beforeArrayValue";
        } else {
          parseState = "beforePropertyName";
        }
      } else {
        var current = stack[stack.length - 1];
        if (current == null) {
          parseState = "end";
        } else if (Array.isArray(current)) {
          parseState = "afterArrayValue";
        } else {
          parseState = "afterPropertyValue";
        }
      }
    }
    function pop() {
      stack.pop();
      var current = stack[stack.length - 1];
      if (current == null) {
        parseState = "end";
      } else if (Array.isArray(current)) {
        parseState = "afterArrayValue";
      } else {
        parseState = "afterPropertyValue";
      }
    }
    function invalidChar(c2) {
      if (c2 === void 0) {
        return syntaxError("JSON5: invalid end of input at ".concat(line, ":").concat(column));
      }
      return syntaxError("JSON5: invalid character '".concat(formatChar(c2), "' at ").concat(line, ":").concat(column));
    }
    function invalidEOF() {
      return syntaxError("JSON5: invalid end of input at ".concat(line, ":").concat(column));
    }
    function invalidIdentifier() {
      column -= 5;
      return syntaxError("JSON5: invalid identifier character at ".concat(line, ":").concat(column));
    }
    function separatorChar(c2) {
      console.warn("JSON5: '".concat(formatChar(c2), "' in strings is not valid ECMAScript; consider escaping"));
    }
    function formatChar(c2) {
      var replacements = {
        "'": "\\'",
        '"': '\\"',
        "\\": "\\\\",
        "\b": "\\b",
        "\f": "\\f",
        "\n": "\\n",
        "\r": "\\r",
        "	": "\\t",
        "\v": "\\v",
        "\0": "\\0",
        "\u2028": "\\u2028",
        "\u2029": "\\u2029"
      };
      if (replacements[c2]) {
        return replacements[c2];
      }
      if (c2 < " ") {
        var hexString = c2.charCodeAt(0).toString(16);
        return "\\x" + ("00" + hexString).substring(hexString.length);
      }
      return c2;
    }
    function syntaxError(message) {
      var err = new SyntaxError(message);
      err.lineNumber = line;
      err.columnNumber = column;
      return err;
    }
    var stringify = function stringify2(value, replacer, space) {
      var stack2 = [];
      var indent = "";
      var propertyList;
      var replacerFunc;
      var gap = "";
      var quote;
      if (replacer != null && _typeof3(replacer) === "object" && !Array.isArray(replacer)) {
        space = replacer.space;
        quote = replacer.quote;
        replacer = replacer.replacer;
      }
      if (typeof replacer === "function") {
        replacerFunc = replacer;
      } else if (Array.isArray(replacer)) {
        propertyList = [];
        var _iterator2 = _createForOfIteratorHelper(replacer), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var v = _step2.value;
            var item = void 0;
            if (typeof v === "string") {
              item = v;
            } else if (typeof v === "number" || v instanceof String || v instanceof Number) {
              item = String(v);
            }
            if (item !== void 0 && propertyList.indexOf(item) < 0) {
              propertyList.push(item);
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
      if (space instanceof Number) {
        space = Number(space);
      } else if (space instanceof String) {
        space = String(space);
      }
      if (typeof space === "number") {
        if (space > 0) {
          space = Math.min(10, Math.floor(space));
          gap = "          ".substr(0, space);
        }
      } else if (typeof space === "string") {
        gap = space.substr(0, 10);
      }
      return serializeProperty("", {
        "": value
      });
      function serializeProperty(key2, holder) {
        var value2 = holder[key2];
        if (value2 != null) {
          if (typeof value2.toJSON5 === "function") {
            value2 = value2.toJSON5(key2);
          } else if (typeof value2.toJSON === "function") {
            value2 = value2.toJSON(key2);
          }
        }
        if (replacerFunc) {
          value2 = replacerFunc.call(holder, key2, value2);
        }
        if (value2 instanceof Number) {
          value2 = Number(value2);
        } else if (value2 instanceof String) {
          value2 = String(value2);
        } else if (value2 instanceof Boolean) {
          value2 = value2.valueOf();
        }
        switch (value2) {
          case null:
            return "null";
          case true:
            return "true";
          case false:
            return "false";
        }
        if (typeof value2 === "string") {
          return quoteString(value2, false);
        }
        if (typeof value2 === "number") {
          return String(value2);
        }
        if (_typeof3(value2) === "object") {
          return Array.isArray(value2) ? serializeArray(value2) : serializeObject(value2);
        }
        return void 0;
      }
      function quoteString(value2) {
        var quotes = {
          "'": 0.1,
          '"': 0.2
        };
        var replacements = {
          "'": "\\'",
          '"': '\\"',
          "\\": "\\\\",
          "\b": "\\b",
          "\f": "\\f",
          "\n": "\\n",
          "\r": "\\r",
          "	": "\\t",
          "\v": "\\v",
          "\0": "\\0",
          "\u2028": "\\u2028",
          "\u2029": "\\u2029"
        };
        var product = "";
        for (var i = 0; i < value2.length; i++) {
          var _c3 = value2[i];
          switch (_c3) {
            case "'":
            case '"':
              quotes[_c3]++;
              product += _c3;
              continue;
            case "\0":
              if (util.isDigit(value2[i + 1])) {
                product += "\\x00";
                continue;
              }
          }
          if (replacements[_c3]) {
            product += replacements[_c3];
            continue;
          }
          if (_c3 < " ") {
            var hexString = _c3.charCodeAt(0).toString(16);
            product += "\\x" + ("00" + hexString).substring(hexString.length);
            continue;
          }
          product += _c3;
        }
        var quoteChar = quote || Object.keys(quotes).reduce(function(a, b) {
          return quotes[a] < quotes[b] ? a : b;
        });
        product = product.replace(new RegExp(quoteChar, "g"), replacements[quoteChar]);
        return quoteChar + product + quoteChar;
      }
      function serializeObject(value2) {
        if (stack2.indexOf(value2) >= 0) {
          throw TypeError("Converting circular structure to JSON5");
        }
        stack2.push(value2);
        var stepback = indent;
        indent = indent + gap;
        var keys = propertyList || Object.keys(value2);
        var partial = [];
        var _iterator3 = _createForOfIteratorHelper(keys), _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
            var _key2 = _step3.value;
            var propertyString = serializeProperty(_key2, value2);
            if (propertyString !== void 0) {
              var member = serializeKey(_key2) + ":";
              if (gap !== "") {
                member += " ";
              }
              member += propertyString;
              partial.push(member);
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
        var final;
        if (partial.length === 0) {
          final = "{}";
        } else {
          var properties;
          if (gap === "") {
            properties = partial.join(",");
            final = "{" + properties + "}";
          } else {
            var separator = ",\n" + indent;
            properties = partial.join(separator);
            final = "{\n" + indent + properties + ",\n" + stepback + "}";
          }
        }
        stack2.pop();
        indent = stepback;
        return final;
      }
      function serializeKey(key2) {
        if (key2.length === 0) {
          return quoteString(key2, true);
        }
        var firstChar = String.fromCodePoint(key2.codePointAt(0));
        if (!util.isIdStartChar(firstChar)) {
          return quoteString(key2, true);
        }
        for (var i = firstChar.length; i < key2.length; i++) {
          if (!util.isIdContinueChar(String.fromCodePoint(key2.codePointAt(i)))) {
            return quoteString(key2, true);
          }
        }
        return key2;
      }
      function serializeArray(value2) {
        if (stack2.indexOf(value2) >= 0) {
          throw TypeError("Converting circular structure to JSON5");
        }
        stack2.push(value2);
        var stepback = indent;
        indent = indent + gap;
        var partial = [];
        for (var i = 0; i < value2.length; i++) {
          var propertyString = serializeProperty(String(i), value2);
          partial.push(propertyString !== void 0 ? propertyString : "null");
        }
        var final;
        if (partial.length === 0) {
          final = "[]";
        } else {
          if (gap === "") {
            var properties = partial.join(",");
            final = "[" + properties + "]";
          } else {
            var separator = ",\n" + indent;
            var _properties = partial.join(separator);
            final = "[\n" + indent + _properties + ",\n" + stepback + "]";
          }
        }
        stack2.pop();
        indent = stepback;
        return final;
      }
    };
    var JSON5 = {
      parse: parse2,
      stringify
    };
    var lib = JSON5;
    var _default2 = lib;
    exports2.default = _default2;
    module2.exports = exports2.default;
  }
});

// ../../node_modules/i18next-fs-backend/cjs/formats/yaml.js
var require_yaml = __commonJS({
  "../../node_modules/i18next-fs-backend/cjs/formats/yaml.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.safeLoadAll = exports2.safeLoad = exports2.safeDump = exports2.loadAll = exports2.load = exports2.dump = exports2.YAMLException = exports2.Type = exports2.Schema = exports2.JSON_SCHEMA = exports2.FAILSAFE_SCHEMA = exports2.DEFAULT_SCHEMA = exports2.CORE_SCHEMA = exports2.default = void 0;
    function _typeof3(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof3 = function _typeof4(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof3 = function _typeof4(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof3(obj);
    }
    function isNothing(subject) {
      return typeof subject === "undefined" || subject === null;
    }
    function isObject(subject) {
      return _typeof3(subject) === "object" && subject !== null;
    }
    function toArray(sequence) {
      if (Array.isArray(sequence))
        return sequence;
      else if (isNothing(sequence))
        return [];
      return [sequence];
    }
    function extend(target, source) {
      var index, length, key, sourceKeys;
      if (source) {
        sourceKeys = Object.keys(source);
        for (index = 0, length = sourceKeys.length; index < length; index += 1) {
          key = sourceKeys[index];
          target[key] = source[key];
        }
      }
      return target;
    }
    function repeat(string, count) {
      var result2 = "", cycle;
      for (cycle = 0; cycle < count; cycle += 1) {
        result2 += string;
      }
      return result2;
    }
    function isNegativeZero(number) {
      return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
    }
    var isNothing_1 = isNothing;
    var isObject_1 = isObject;
    var toArray_1 = toArray;
    var repeat_1 = repeat;
    var isNegativeZero_1 = isNegativeZero;
    var extend_1 = extend;
    var common = {
      isNothing: isNothing_1,
      isObject: isObject_1,
      toArray: toArray_1,
      repeat: repeat_1,
      isNegativeZero: isNegativeZero_1,
      extend: extend_1
    };
    function formatError(exception2, compact) {
      var where = "", message = exception2.reason || "(unknown reason)";
      if (!exception2.mark)
        return message;
      if (exception2.mark.name) {
        where += 'in "' + exception2.mark.name + '" ';
      }
      where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
      if (!compact && exception2.mark.snippet) {
        where += "\n\n" + exception2.mark.snippet;
      }
      return message + " " + where;
    }
    function YAMLException(reason, mark) {
      Error.call(this);
      this.name = "YAMLException";
      this.reason = reason;
      this.mark = mark;
      this.message = formatError(this, false);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack || "";
      }
    }
    YAMLException.prototype = Object.create(Error.prototype);
    YAMLException.prototype.constructor = YAMLException;
    YAMLException.prototype.toString = function toString(compact) {
      return this.name + ": " + formatError(this, compact);
    };
    var exception = YAMLException;
    function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
      var head = "";
      var tail = "";
      var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
      if (position - lineStart > maxHalfLength) {
        head = " ... ";
        lineStart = position - maxHalfLength + head.length;
      }
      if (lineEnd - position > maxHalfLength) {
        tail = " ...";
        lineEnd = position + maxHalfLength - tail.length;
      }
      return {
        str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
        pos: position - lineStart + head.length
      };
    }
    function padStart(string, max) {
      return common.repeat(" ", max - string.length) + string;
    }
    function makeSnippet(mark, options2) {
      options2 = Object.create(options2 || null);
      if (!mark.buffer)
        return null;
      if (!options2.maxLength)
        options2.maxLength = 79;
      if (typeof options2.indent !== "number")
        options2.indent = 1;
      if (typeof options2.linesBefore !== "number")
        options2.linesBefore = 3;
      if (typeof options2.linesAfter !== "number")
        options2.linesAfter = 2;
      var re = /\r?\n|\r|\0/g;
      var lineStarts = [0];
      var lineEnds = [];
      var match;
      var foundLineNo = -1;
      while (match = re.exec(mark.buffer)) {
        lineEnds.push(match.index);
        lineStarts.push(match.index + match[0].length);
        if (mark.position <= match.index && foundLineNo < 0) {
          foundLineNo = lineStarts.length - 2;
        }
      }
      if (foundLineNo < 0)
        foundLineNo = lineStarts.length - 1;
      var result2 = "", i2, line;
      var lineNoLength = Math.min(mark.line + options2.linesAfter, lineEnds.length).toString().length;
      var maxLineLength = options2.maxLength - (options2.indent + lineNoLength + 3);
      for (i2 = 1; i2 <= options2.linesBefore; i2++) {
        if (foundLineNo - i2 < 0)
          break;
        line = getLine(mark.buffer, lineStarts[foundLineNo - i2], lineEnds[foundLineNo - i2], mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i2]), maxLineLength);
        result2 = common.repeat(" ", options2.indent) + padStart((mark.line - i2 + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result2;
      }
      line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
      result2 += common.repeat(" ", options2.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
      result2 += common.repeat("-", options2.indent + lineNoLength + 3 + line.pos) + "^\n";
      for (i2 = 1; i2 <= options2.linesAfter; i2++) {
        if (foundLineNo + i2 >= lineEnds.length)
          break;
        line = getLine(mark.buffer, lineStarts[foundLineNo + i2], lineEnds[foundLineNo + i2], mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i2]), maxLineLength);
        result2 += common.repeat(" ", options2.indent) + padStart((mark.line + i2 + 1).toString(), lineNoLength) + " | " + line.str + "\n";
      }
      return result2.replace(/\n$/, "");
    }
    var snippet = makeSnippet;
    var TYPE_CONSTRUCTOR_OPTIONS = ["kind", "multi", "resolve", "construct", "instanceOf", "predicate", "represent", "representName", "defaultStyle", "styleAliases"];
    var YAML_NODE_KINDS = ["scalar", "sequence", "mapping"];
    function compileStyleAliases(map2) {
      var result2 = {};
      if (map2 !== null) {
        Object.keys(map2).forEach(function(style) {
          map2[style].forEach(function(alias) {
            result2[String(alias)] = style;
          });
        });
      }
      return result2;
    }
    function Type(tag, options2) {
      options2 = options2 || {};
      Object.keys(options2).forEach(function(name) {
        if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
          throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
        }
      });
      this.tag = tag;
      this.kind = options2["kind"] || null;
      this.resolve = options2["resolve"] || function() {
        return true;
      };
      this.construct = options2["construct"] || function(data2) {
        return data2;
      };
      this.instanceOf = options2["instanceOf"] || null;
      this.predicate = options2["predicate"] || null;
      this.represent = options2["represent"] || null;
      this.representName = options2["representName"] || null;
      this.defaultStyle = options2["defaultStyle"] || null;
      this.multi = options2["multi"] || false;
      this.styleAliases = compileStyleAliases(options2["styleAliases"] || null);
      if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
        throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
      }
    }
    var type = Type;
    function compileList(schema2, name, result2) {
      var exclude = [];
      schema2[name].forEach(function(currentType) {
        result2.forEach(function(previousType, previousIndex) {
          if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
            exclude.push(previousIndex);
          }
        });
        result2.push(currentType);
      });
      return result2.filter(function(type2, index) {
        return exclude.indexOf(index) === -1;
      });
    }
    function compileMap() {
      var result2 = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {},
        multi: {
          scalar: [],
          sequence: [],
          mapping: [],
          fallback: []
        }
      }, index, length;
      function collectType(type2) {
        if (type2.multi) {
          result2.multi[type2.kind].push(type2);
          result2.multi["fallback"].push(type2);
        } else {
          result2[type2.kind][type2.tag] = result2["fallback"][type2.tag] = type2;
        }
      }
      for (index = 0, length = arguments.length; index < length; index += 1) {
        arguments[index].forEach(collectType);
      }
      return result2;
    }
    function Schema(definition) {
      return this.extend(definition);
    }
    Schema.prototype.extend = function extend2(definition) {
      var implicit = [];
      var explicit = [];
      if (definition instanceof type) {
        explicit.push(definition);
      } else if (Array.isArray(definition)) {
        explicit = explicit.concat(definition);
      } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
        if (definition.implicit)
          implicit = implicit.concat(definition.implicit);
        if (definition.explicit)
          explicit = explicit.concat(definition.explicit);
      } else {
        throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
      }
      implicit.forEach(function(type$1) {
        if (!(type$1 instanceof type)) {
          throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
        }
        if (type$1.loadKind && type$1.loadKind !== "scalar") {
          throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
        }
        if (type$1.multi) {
          throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
        }
      });
      explicit.forEach(function(type$1) {
        if (!(type$1 instanceof type)) {
          throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
        }
      });
      var result2 = Object.create(Schema.prototype);
      result2.implicit = (this.implicit || []).concat(implicit);
      result2.explicit = (this.explicit || []).concat(explicit);
      result2.compiledImplicit = compileList(result2, "implicit", []);
      result2.compiledExplicit = compileList(result2, "explicit", []);
      result2.compiledTypeMap = compileMap(result2.compiledImplicit, result2.compiledExplicit);
      return result2;
    };
    var schema = Schema;
    var str = new type("tag:yaml.org,2002:str", {
      kind: "scalar",
      construct: function construct(data2) {
        return data2 !== null ? data2 : "";
      }
    });
    var seq = new type("tag:yaml.org,2002:seq", {
      kind: "sequence",
      construct: function construct(data2) {
        return data2 !== null ? data2 : [];
      }
    });
    var map = new type("tag:yaml.org,2002:map", {
      kind: "mapping",
      construct: function construct(data2) {
        return data2 !== null ? data2 : {};
      }
    });
    var failsafe = new schema({
      explicit: [str, seq, map]
    });
    function resolveYamlNull(data2) {
      if (data2 === null)
        return true;
      var max = data2.length;
      return max === 1 && data2 === "~" || max === 4 && (data2 === "null" || data2 === "Null" || data2 === "NULL");
    }
    function constructYamlNull() {
      return null;
    }
    function isNull(object) {
      return object === null;
    }
    var _null = new type("tag:yaml.org,2002:null", {
      kind: "scalar",
      resolve: resolveYamlNull,
      construct: constructYamlNull,
      predicate: isNull,
      represent: {
        canonical: function canonical() {
          return "~";
        },
        lowercase: function lowercase() {
          return "null";
        },
        uppercase: function uppercase() {
          return "NULL";
        },
        camelcase: function camelcase() {
          return "Null";
        },
        empty: function empty() {
          return "";
        }
      },
      defaultStyle: "lowercase"
    });
    function resolveYamlBoolean(data2) {
      if (data2 === null)
        return false;
      var max = data2.length;
      return max === 4 && (data2 === "true" || data2 === "True" || data2 === "TRUE") || max === 5 && (data2 === "false" || data2 === "False" || data2 === "FALSE");
    }
    function constructYamlBoolean(data2) {
      return data2 === "true" || data2 === "True" || data2 === "TRUE";
    }
    function isBoolean(object) {
      return Object.prototype.toString.call(object) === "[object Boolean]";
    }
    var bool = new type("tag:yaml.org,2002:bool", {
      kind: "scalar",
      resolve: resolveYamlBoolean,
      construct: constructYamlBoolean,
      predicate: isBoolean,
      represent: {
        lowercase: function lowercase(object) {
          return object ? "true" : "false";
        },
        uppercase: function uppercase(object) {
          return object ? "TRUE" : "FALSE";
        },
        camelcase: function camelcase(object) {
          return object ? "True" : "False";
        }
      },
      defaultStyle: "lowercase"
    });
    function isHexCode(c) {
      return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
    }
    function isOctCode(c) {
      return 48 <= c && c <= 55;
    }
    function isDecCode(c) {
      return 48 <= c && c <= 57;
    }
    function resolveYamlInteger(data2) {
      if (data2 === null)
        return false;
      var max = data2.length, index = 0, hasDigits = false, ch;
      if (!max)
        return false;
      ch = data2[index];
      if (ch === "-" || ch === "+") {
        ch = data2[++index];
      }
      if (ch === "0") {
        if (index + 1 === max)
          return true;
        ch = data2[++index];
        if (ch === "b") {
          index++;
          for (; index < max; index++) {
            ch = data2[index];
            if (ch === "_")
              continue;
            if (ch !== "0" && ch !== "1")
              return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        if (ch === "x") {
          index++;
          for (; index < max; index++) {
            ch = data2[index];
            if (ch === "_")
              continue;
            if (!isHexCode(data2.charCodeAt(index)))
              return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        if (ch === "o") {
          index++;
          for (; index < max; index++) {
            ch = data2[index];
            if (ch === "_")
              continue;
            if (!isOctCode(data2.charCodeAt(index)))
              return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
      }
      if (ch === "_")
        return false;
      for (; index < max; index++) {
        ch = data2[index];
        if (ch === "_")
          continue;
        if (!isDecCode(data2.charCodeAt(index))) {
          return false;
        }
        hasDigits = true;
      }
      if (!hasDigits || ch === "_")
        return false;
      return true;
    }
    function constructYamlInteger(data2) {
      var value = data2, sign = 1, ch;
      if (value.indexOf("_") !== -1) {
        value = value.replace(/_/g, "");
      }
      ch = value[0];
      if (ch === "-" || ch === "+") {
        if (ch === "-")
          sign = -1;
        value = value.slice(1);
        ch = value[0];
      }
      if (value === "0")
        return 0;
      if (ch === "0") {
        if (value[1] === "b")
          return sign * parseInt(value.slice(2), 2);
        if (value[1] === "x")
          return sign * parseInt(value.slice(2), 16);
        if (value[1] === "o")
          return sign * parseInt(value.slice(2), 8);
      }
      return sign * parseInt(value, 10);
    }
    function isInteger(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && object % 1 === 0 && !common.isNegativeZero(object);
    }
    var int = new type("tag:yaml.org,2002:int", {
      kind: "scalar",
      resolve: resolveYamlInteger,
      construct: constructYamlInteger,
      predicate: isInteger,
      represent: {
        binary: function binary2(obj) {
          return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
        },
        octal: function octal(obj) {
          return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
        },
        decimal: function decimal(obj) {
          return obj.toString(10);
        },
        hexadecimal: function hexadecimal(obj) {
          return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
        }
      },
      defaultStyle: "decimal",
      styleAliases: {
        binary: [2, "bin"],
        octal: [8, "oct"],
        decimal: [10, "dec"],
        hexadecimal: [16, "hex"]
      }
    });
    var YAML_FLOAT_PATTERN = new RegExp("^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$");
    function resolveYamlFloat(data2) {
      if (data2 === null)
        return false;
      if (!YAML_FLOAT_PATTERN.test(data2) || data2[data2.length - 1] === "_") {
        return false;
      }
      return true;
    }
    function constructYamlFloat(data2) {
      var value, sign;
      value = data2.replace(/_/g, "").toLowerCase();
      sign = value[0] === "-" ? -1 : 1;
      if ("+-".indexOf(value[0]) >= 0) {
        value = value.slice(1);
      }
      if (value === ".inf") {
        return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
      } else if (value === ".nan") {
        return NaN;
      }
      return sign * parseFloat(value, 10);
    }
    var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
    function representYamlFloat(object, style) {
      var res;
      if (isNaN(object)) {
        switch (style) {
          case "lowercase":
            return ".nan";
          case "uppercase":
            return ".NAN";
          case "camelcase":
            return ".NaN";
        }
      } else if (Number.POSITIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return ".inf";
          case "uppercase":
            return ".INF";
          case "camelcase":
            return ".Inf";
        }
      } else if (Number.NEGATIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return "-.inf";
          case "uppercase":
            return "-.INF";
          case "camelcase":
            return "-.Inf";
        }
      } else if (common.isNegativeZero(object)) {
        return "-0.0";
      }
      res = object.toString(10);
      return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
    }
    function isFloat(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
    }
    var float = new type("tag:yaml.org,2002:float", {
      kind: "scalar",
      resolve: resolveYamlFloat,
      construct: constructYamlFloat,
      predicate: isFloat,
      represent: representYamlFloat,
      defaultStyle: "lowercase"
    });
    var json = failsafe.extend({
      implicit: [_null, bool, int, float]
    });
    var core = json;
    var YAML_DATE_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$");
    var YAML_TIMESTAMP_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$");
    function resolveYamlTimestamp(data2) {
      if (data2 === null)
        return false;
      if (YAML_DATE_REGEXP.exec(data2) !== null)
        return true;
      if (YAML_TIMESTAMP_REGEXP.exec(data2) !== null)
        return true;
      return false;
    }
    function constructYamlTimestamp(data2) {
      var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
      match = YAML_DATE_REGEXP.exec(data2);
      if (match === null)
        match = YAML_TIMESTAMP_REGEXP.exec(data2);
      if (match === null)
        throw new Error("Date resolve error");
      year = +match[1];
      month = +match[2] - 1;
      day = +match[3];
      if (!match[4]) {
        return new Date(Date.UTC(year, month, day));
      }
      hour = +match[4];
      minute = +match[5];
      second = +match[6];
      if (match[7]) {
        fraction = match[7].slice(0, 3);
        while (fraction.length < 3) {
          fraction += "0";
        }
        fraction = +fraction;
      }
      if (match[9]) {
        tz_hour = +match[10];
        tz_minute = +(match[11] || 0);
        delta = (tz_hour * 60 + tz_minute) * 6e4;
        if (match[9] === "-")
          delta = -delta;
      }
      date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
      if (delta)
        date.setTime(date.getTime() - delta);
      return date;
    }
    function representYamlTimestamp(object) {
      return object.toISOString();
    }
    var timestamp = new type("tag:yaml.org,2002:timestamp", {
      kind: "scalar",
      resolve: resolveYamlTimestamp,
      construct: constructYamlTimestamp,
      instanceOf: Date,
      represent: representYamlTimestamp
    });
    function resolveYamlMerge(data2) {
      return data2 === "<<" || data2 === null;
    }
    var merge = new type("tag:yaml.org,2002:merge", {
      kind: "scalar",
      resolve: resolveYamlMerge
    });
    var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
    function resolveYamlBinary(data2) {
      if (data2 === null)
        return false;
      var code, idx, bitlen = 0, max = data2.length, map2 = BASE64_MAP;
      for (idx = 0; idx < max; idx++) {
        code = map2.indexOf(data2.charAt(idx));
        if (code > 64)
          continue;
        if (code < 0)
          return false;
        bitlen += 6;
      }
      return bitlen % 8 === 0;
    }
    function constructYamlBinary(data2) {
      var idx, tailbits, input = data2.replace(/[\r\n=]/g, ""), max = input.length, map2 = BASE64_MAP, bits = 0, result2 = [];
      for (idx = 0; idx < max; idx++) {
        if (idx % 4 === 0 && idx) {
          result2.push(bits >> 16 & 255);
          result2.push(bits >> 8 & 255);
          result2.push(bits & 255);
        }
        bits = bits << 6 | map2.indexOf(input.charAt(idx));
      }
      tailbits = max % 4 * 6;
      if (tailbits === 0) {
        result2.push(bits >> 16 & 255);
        result2.push(bits >> 8 & 255);
        result2.push(bits & 255);
      } else if (tailbits === 18) {
        result2.push(bits >> 10 & 255);
        result2.push(bits >> 2 & 255);
      } else if (tailbits === 12) {
        result2.push(bits >> 4 & 255);
      }
      return new Uint8Array(result2);
    }
    function representYamlBinary(object) {
      var result2 = "", bits = 0, idx, tail, max = object.length, map2 = BASE64_MAP;
      for (idx = 0; idx < max; idx++) {
        if (idx % 3 === 0 && idx) {
          result2 += map2[bits >> 18 & 63];
          result2 += map2[bits >> 12 & 63];
          result2 += map2[bits >> 6 & 63];
          result2 += map2[bits & 63];
        }
        bits = (bits << 8) + object[idx];
      }
      tail = max % 3;
      if (tail === 0) {
        result2 += map2[bits >> 18 & 63];
        result2 += map2[bits >> 12 & 63];
        result2 += map2[bits >> 6 & 63];
        result2 += map2[bits & 63];
      } else if (tail === 2) {
        result2 += map2[bits >> 10 & 63];
        result2 += map2[bits >> 4 & 63];
        result2 += map2[bits << 2 & 63];
        result2 += map2[64];
      } else if (tail === 1) {
        result2 += map2[bits >> 2 & 63];
        result2 += map2[bits << 4 & 63];
        result2 += map2[64];
        result2 += map2[64];
      }
      return result2;
    }
    function isBinary(obj) {
      return Object.prototype.toString.call(obj) === "[object Uint8Array]";
    }
    var binary = new type("tag:yaml.org,2002:binary", {
      kind: "scalar",
      resolve: resolveYamlBinary,
      construct: constructYamlBinary,
      predicate: isBinary,
      represent: representYamlBinary
    });
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var _toString = Object.prototype.toString;
    function resolveYamlOmap(data2) {
      if (data2 === null)
        return true;
      var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data2;
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        pairHasKey = false;
        if (_toString.call(pair) !== "[object Object]")
          return false;
        for (pairKey in pair) {
          if (_hasOwnProperty.call(pair, pairKey)) {
            if (!pairHasKey)
              pairHasKey = true;
            else
              return false;
          }
        }
        if (!pairHasKey)
          return false;
        if (objectKeys.indexOf(pairKey) === -1)
          objectKeys.push(pairKey);
        else
          return false;
      }
      return true;
    }
    function constructYamlOmap(data2) {
      return data2 !== null ? data2 : [];
    }
    var omap = new type("tag:yaml.org,2002:omap", {
      kind: "sequence",
      resolve: resolveYamlOmap,
      construct: constructYamlOmap
    });
    var _toString$1 = Object.prototype.toString;
    function resolveYamlPairs(data2) {
      if (data2 === null)
        return true;
      var index, length, pair, keys, result2, object = data2;
      result2 = new Array(object.length);
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        if (_toString$1.call(pair) !== "[object Object]")
          return false;
        keys = Object.keys(pair);
        if (keys.length !== 1)
          return false;
        result2[index] = [keys[0], pair[keys[0]]];
      }
      return true;
    }
    function constructYamlPairs(data2) {
      if (data2 === null)
        return [];
      var index, length, pair, keys, result2, object = data2;
      result2 = new Array(object.length);
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        keys = Object.keys(pair);
        result2[index] = [keys[0], pair[keys[0]]];
      }
      return result2;
    }
    var pairs = new type("tag:yaml.org,2002:pairs", {
      kind: "sequence",
      resolve: resolveYamlPairs,
      construct: constructYamlPairs
    });
    var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
    function resolveYamlSet(data2) {
      if (data2 === null)
        return true;
      var key, object = data2;
      for (key in object) {
        if (_hasOwnProperty$1.call(object, key)) {
          if (object[key] !== null)
            return false;
        }
      }
      return true;
    }
    function constructYamlSet(data2) {
      return data2 !== null ? data2 : {};
    }
    var set = new type("tag:yaml.org,2002:set", {
      kind: "mapping",
      resolve: resolveYamlSet,
      construct: constructYamlSet
    });
    var _default = core.extend({
      implicit: [timestamp, merge],
      explicit: [binary, omap, pairs, set]
    });
    var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
    var CONTEXT_FLOW_IN = 1;
    var CONTEXT_FLOW_OUT = 2;
    var CONTEXT_BLOCK_IN = 3;
    var CONTEXT_BLOCK_OUT = 4;
    var CHOMPING_CLIP = 1;
    var CHOMPING_STRIP = 2;
    var CHOMPING_KEEP = 3;
    var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
    var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
    var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
    var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function is_EOL(c) {
      return c === 10 || c === 13;
    }
    function is_WHITE_SPACE(c) {
      return c === 9 || c === 32;
    }
    function is_WS_OR_EOL(c) {
      return c === 9 || c === 32 || c === 10 || c === 13;
    }
    function is_FLOW_INDICATOR(c) {
      return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
    }
    function fromHexCode(c) {
      var lc;
      if (48 <= c && c <= 57) {
        return c - 48;
      }
      lc = c | 32;
      if (97 <= lc && lc <= 102) {
        return lc - 97 + 10;
      }
      return -1;
    }
    function escapedHexLen(c) {
      if (c === 120) {
        return 2;
      }
      if (c === 117) {
        return 4;
      }
      if (c === 85) {
        return 8;
      }
      return 0;
    }
    function fromDecimalCode(c) {
      if (48 <= c && c <= 57) {
        return c - 48;
      }
      return -1;
    }
    function simpleEscapeSequence(c) {
      return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
    }
    function charFromCodepoint(c) {
      if (c <= 65535) {
        return String.fromCharCode(c);
      }
      return String.fromCharCode((c - 65536 >> 10) + 55296, (c - 65536 & 1023) + 56320);
    }
    var simpleEscapeCheck = new Array(256);
    var simpleEscapeMap = new Array(256);
    for (i = 0; i < 256; i++) {
      simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
      simpleEscapeMap[i] = simpleEscapeSequence(i);
    }
    var i;
    function State(input, options2) {
      this.input = input;
      this.filename = options2["filename"] || null;
      this.schema = options2["schema"] || _default;
      this.onWarning = options2["onWarning"] || null;
      this.legacy = options2["legacy"] || false;
      this.json = options2["json"] || false;
      this.listener = options2["listener"] || null;
      this.implicitTypes = this.schema.compiledImplicit;
      this.typeMap = this.schema.compiledTypeMap;
      this.length = input.length;
      this.position = 0;
      this.line = 0;
      this.lineStart = 0;
      this.lineIndent = 0;
      this.firstTabInLine = -1;
      this.documents = [];
    }
    function generateError(state, message) {
      var mark = {
        name: state.filename,
        buffer: state.input.slice(0, -1),
        position: state.position,
        line: state.line,
        column: state.position - state.lineStart
      };
      mark.snippet = snippet(mark);
      return new exception(message, mark);
    }
    function throwError(state, message) {
      throw generateError(state, message);
    }
    function throwWarning(state, message) {
      if (state.onWarning) {
        state.onWarning.call(null, generateError(state, message));
      }
    }
    var directiveHandlers = {
      YAML: function handleYamlDirective(state, name, args) {
        var match, major, minor;
        if (state.version !== null) {
          throwError(state, "duplication of %YAML directive");
        }
        if (args.length !== 1) {
          throwError(state, "YAML directive accepts exactly one argument");
        }
        match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
        if (match === null) {
          throwError(state, "ill-formed argument of the YAML directive");
        }
        major = parseInt(match[1], 10);
        minor = parseInt(match[2], 10);
        if (major !== 1) {
          throwError(state, "unacceptable YAML version of the document");
        }
        state.version = args[0];
        state.checkLineBreaks = minor < 2;
        if (minor !== 1 && minor !== 2) {
          throwWarning(state, "unsupported YAML version of the document");
        }
      },
      TAG: function handleTagDirective(state, name, args) {
        var handle3, prefix;
        if (args.length !== 2) {
          throwError(state, "TAG directive accepts exactly two arguments");
        }
        handle3 = args[0];
        prefix = args[1];
        if (!PATTERN_TAG_HANDLE.test(handle3)) {
          throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
        }
        if (_hasOwnProperty$2.call(state.tagMap, handle3)) {
          throwError(state, 'there is a previously declared suffix for "' + handle3 + '" tag handle');
        }
        if (!PATTERN_TAG_URI.test(prefix)) {
          throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
        }
        try {
          prefix = decodeURIComponent(prefix);
        } catch (err) {
          throwError(state, "tag prefix is malformed: " + prefix);
        }
        state.tagMap[handle3] = prefix;
      }
    };
    function captureSegment(state, start, end, checkJson) {
      var _position, _length, _character, _result;
      if (start < end) {
        _result = state.input.slice(start, end);
        if (checkJson) {
          for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
            _character = _result.charCodeAt(_position);
            if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
              throwError(state, "expected valid JSON character");
            }
          }
        } else if (PATTERN_NON_PRINTABLE.test(_result)) {
          throwError(state, "the stream contains non-printable characters");
        }
        state.result += _result;
      }
    }
    function mergeMappings(state, destination, source, overridableKeys) {
      var sourceKeys, key, index, quantity;
      if (!common.isObject(source)) {
        throwError(state, "cannot merge mappings; the provided source object is unacceptable");
      }
      sourceKeys = Object.keys(source);
      for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
        key = sourceKeys[index];
        if (!_hasOwnProperty$2.call(destination, key)) {
          destination[key] = source[key];
          overridableKeys[key] = true;
        }
      }
    }
    function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
      var index, quantity;
      if (Array.isArray(keyNode)) {
        keyNode = Array.prototype.slice.call(keyNode);
        for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
          if (Array.isArray(keyNode[index])) {
            throwError(state, "nested arrays are not supported inside keys");
          }
          if (_typeof3(keyNode) === "object" && _class(keyNode[index]) === "[object Object]") {
            keyNode[index] = "[object Object]";
          }
        }
      }
      if (_typeof3(keyNode) === "object" && _class(keyNode) === "[object Object]") {
        keyNode = "[object Object]";
      }
      keyNode = String(keyNode);
      if (_result === null) {
        _result = {};
      }
      if (keyTag === "tag:yaml.org,2002:merge") {
        if (Array.isArray(valueNode)) {
          for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
            mergeMappings(state, _result, valueNode[index], overridableKeys);
          }
        } else {
          mergeMappings(state, _result, valueNode, overridableKeys);
        }
      } else {
        if (!state.json && !_hasOwnProperty$2.call(overridableKeys, keyNode) && _hasOwnProperty$2.call(_result, keyNode)) {
          state.line = startLine || state.line;
          state.lineStart = startLineStart || state.lineStart;
          state.position = startPos || state.position;
          throwError(state, "duplicated mapping key");
        }
        if (keyNode === "__proto__") {
          Object.defineProperty(_result, keyNode, {
            configurable: true,
            enumerable: true,
            writable: true,
            value: valueNode
          });
        } else {
          _result[keyNode] = valueNode;
        }
        delete overridableKeys[keyNode];
      }
      return _result;
    }
    function readLineBreak(state) {
      var ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 10) {
        state.position++;
      } else if (ch === 13) {
        state.position++;
        if (state.input.charCodeAt(state.position) === 10) {
          state.position++;
        }
      } else {
        throwError(state, "a line break is expected");
      }
      state.line += 1;
      state.lineStart = state.position;
      state.firstTabInLine = -1;
    }
    function skipSeparationSpace(state, allowComments, checkIndent) {
      var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        while (is_WHITE_SPACE(ch)) {
          if (ch === 9 && state.firstTabInLine === -1) {
            state.firstTabInLine = state.position;
          }
          ch = state.input.charCodeAt(++state.position);
        }
        if (allowComments && ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 10 && ch !== 13 && ch !== 0);
        }
        if (is_EOL(ch)) {
          readLineBreak(state);
          ch = state.input.charCodeAt(state.position);
          lineBreaks++;
          state.lineIndent = 0;
          while (ch === 32) {
            state.lineIndent++;
            ch = state.input.charCodeAt(++state.position);
          }
        } else {
          break;
        }
      }
      if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
        throwWarning(state, "deficient indentation");
      }
      return lineBreaks;
    }
    function testDocumentSeparator(state) {
      var _position = state.position, ch;
      ch = state.input.charCodeAt(_position);
      if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
        _position += 3;
        ch = state.input.charCodeAt(_position);
        if (ch === 0 || is_WS_OR_EOL(ch)) {
          return true;
        }
      }
      return false;
    }
    function writeFoldedLines(state, count) {
      if (count === 1) {
        state.result += " ";
      } else if (count > 1) {
        state.result += common.repeat("\n", count - 1);
      }
    }
    function readPlainScalar(state, nodeIndent, withinFlowCollection) {
      var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
      ch = state.input.charCodeAt(state.position);
      if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
        return false;
      }
      if (ch === 63 || ch === 45) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          return false;
        }
      }
      state.kind = "scalar";
      state.result = "";
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
      while (ch !== 0) {
        if (ch === 58) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
            break;
          }
        } else if (ch === 35) {
          preceding = state.input.charCodeAt(state.position - 1);
          if (is_WS_OR_EOL(preceding)) {
            break;
          }
        } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
          break;
        } else if (is_EOL(ch)) {
          _line = state.line;
          _lineStart = state.lineStart;
          _lineIndent = state.lineIndent;
          skipSeparationSpace(state, false, -1);
          if (state.lineIndent >= nodeIndent) {
            hasPendingContent = true;
            ch = state.input.charCodeAt(state.position);
            continue;
          } else {
            state.position = captureEnd;
            state.line = _line;
            state.lineStart = _lineStart;
            state.lineIndent = _lineIndent;
            break;
          }
        }
        if (hasPendingContent) {
          captureSegment(state, captureStart, captureEnd, false);
          writeFoldedLines(state, state.line - _line);
          captureStart = captureEnd = state.position;
          hasPendingContent = false;
        }
        if (!is_WHITE_SPACE(ch)) {
          captureEnd = state.position + 1;
        }
        ch = state.input.charCodeAt(++state.position);
      }
      captureSegment(state, captureStart, captureEnd, false);
      if (state.result) {
        return true;
      }
      state.kind = _kind;
      state.result = _result;
      return false;
    }
    function readSingleQuotedScalar(state, nodeIndent) {
      var ch, captureStart, captureEnd;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 39) {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 39) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (ch === 39) {
            captureStart = state.position;
            state.position++;
            captureEnd = state.position;
          } else {
            return true;
          }
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, "unexpected end of the document within a single quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, "unexpected end of the stream within a single quoted scalar");
    }
    function readDoubleQuotedScalar(state, nodeIndent) {
      var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 34) {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 34) {
          captureSegment(state, captureStart, state.position, true);
          state.position++;
          return true;
        } else if (ch === 92) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (is_EOL(ch)) {
            skipSeparationSpace(state, false, nodeIndent);
          } else if (ch < 256 && simpleEscapeCheck[ch]) {
            state.result += simpleEscapeMap[ch];
            state.position++;
          } else if ((tmp = escapedHexLen(ch)) > 0) {
            hexLength = tmp;
            hexResult = 0;
            for (; hexLength > 0; hexLength--) {
              ch = state.input.charCodeAt(++state.position);
              if ((tmp = fromHexCode(ch)) >= 0) {
                hexResult = (hexResult << 4) + tmp;
              } else {
                throwError(state, "expected hexadecimal character");
              }
            }
            state.result += charFromCodepoint(hexResult);
            state.position++;
          } else {
            throwError(state, "unknown escape sequence");
          }
          captureStart = captureEnd = state.position;
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, "unexpected end of the document within a double quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, "unexpected end of the stream within a double quoted scalar");
    }
    function readFlowCollection(state, nodeIndent) {
      var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 91) {
        terminator = 93;
        isMapping = false;
        _result = [];
      } else if (ch === 123) {
        terminator = 125;
        isMapping = true;
        _result = {};
      } else {
        return false;
      }
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(++state.position);
      while (ch !== 0) {
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === terminator) {
          state.position++;
          state.tag = _tag;
          state.anchor = _anchor;
          state.kind = isMapping ? "mapping" : "sequence";
          state.result = _result;
          return true;
        } else if (!readNext) {
          throwError(state, "missed comma between flow collection entries");
        } else if (ch === 44) {
          throwError(state, "expected the node content, but found ','");
        }
        keyTag = keyNode = valueNode = null;
        isPair = isExplicitPair = false;
        if (ch === 63) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following)) {
            isPair = isExplicitPair = true;
            state.position++;
            skipSeparationSpace(state, true, nodeIndent);
          }
        }
        _line = state.line;
        _lineStart = state.lineStart;
        _pos = state.position;
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        keyTag = state.tag;
        keyNode = state.result;
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if ((isExplicitPair || state.line === _line) && ch === 58) {
          isPair = true;
          ch = state.input.charCodeAt(++state.position);
          skipSeparationSpace(state, true, nodeIndent);
          composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
          valueNode = state.result;
        }
        if (isMapping) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
        } else if (isPair) {
          _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
        } else {
          _result.push(keyNode);
        }
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === 44) {
          readNext = true;
          ch = state.input.charCodeAt(++state.position);
        } else {
          readNext = false;
        }
      }
      throwError(state, "unexpected end of the stream within a flow collection");
    }
    function readBlockScalar(state, nodeIndent) {
      var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 124) {
        folding = false;
      } else if (ch === 62) {
        folding = true;
      } else {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      while (ch !== 0) {
        ch = state.input.charCodeAt(++state.position);
        if (ch === 43 || ch === 45) {
          if (CHOMPING_CLIP === chomping) {
            chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
          } else {
            throwError(state, "repeat of a chomping mode identifier");
          }
        } else if ((tmp = fromDecimalCode(ch)) >= 0) {
          if (tmp === 0) {
            throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
          } else if (!detectedIndent) {
            textIndent = nodeIndent + tmp - 1;
            detectedIndent = true;
          } else {
            throwError(state, "repeat of an indentation width identifier");
          }
        } else {
          break;
        }
      }
      if (is_WHITE_SPACE(ch)) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (is_WHITE_SPACE(ch));
        if (ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (!is_EOL(ch) && ch !== 0);
        }
      }
      while (ch !== 0) {
        readLineBreak(state);
        state.lineIndent = 0;
        ch = state.input.charCodeAt(state.position);
        while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
        if (!detectedIndent && state.lineIndent > textIndent) {
          textIndent = state.lineIndent;
        }
        if (is_EOL(ch)) {
          emptyLines++;
          continue;
        }
        if (state.lineIndent < textIndent) {
          if (chomping === CHOMPING_KEEP) {
            state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          } else if (chomping === CHOMPING_CLIP) {
            if (didReadContent) {
              state.result += "\n";
            }
          }
          break;
        }
        if (folding) {
          if (is_WHITE_SPACE(ch)) {
            atMoreIndented = true;
            state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          } else if (atMoreIndented) {
            atMoreIndented = false;
            state.result += common.repeat("\n", emptyLines + 1);
          } else if (emptyLines === 0) {
            if (didReadContent) {
              state.result += " ";
            }
          } else {
            state.result += common.repeat("\n", emptyLines);
          }
        } else {
          state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        }
        didReadContent = true;
        detectedIndent = true;
        emptyLines = 0;
        captureStart = state.position;
        while (!is_EOL(ch) && ch !== 0) {
          ch = state.input.charCodeAt(++state.position);
        }
        captureSegment(state, captureStart, state.position, false);
      }
      return true;
    }
    function readBlockSequence(state, nodeIndent) {
      var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
      if (state.firstTabInLine !== -1)
        return false;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        if (state.firstTabInLine !== -1) {
          state.position = state.firstTabInLine;
          throwError(state, "tab characters must not be used in indentation");
        }
        if (ch !== 45) {
          break;
        }
        following = state.input.charCodeAt(state.position + 1);
        if (!is_WS_OR_EOL(following)) {
          break;
        }
        detected = true;
        state.position++;
        if (skipSeparationSpace(state, true, -1)) {
          if (state.lineIndent <= nodeIndent) {
            _result.push(null);
            ch = state.input.charCodeAt(state.position);
            continue;
          }
        }
        _line = state.line;
        composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
        _result.push(state.result);
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
          throwError(state, "bad indentation of a sequence entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "sequence";
        state.result = _result;
        return true;
      }
      return false;
    }
    function readBlockMapping(state, nodeIndent, flowIndent) {
      var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
      if (state.firstTabInLine !== -1)
        return false;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        if (!atExplicitKey && state.firstTabInLine !== -1) {
          state.position = state.firstTabInLine;
          throwError(state, "tab characters must not be used in indentation");
        }
        following = state.input.charCodeAt(state.position + 1);
        _line = state.line;
        if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
          if (ch === 63) {
            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
              keyTag = keyNode = valueNode = null;
            }
            detected = true;
            atExplicitKey = true;
            allowCompact = true;
          } else if (atExplicitKey) {
            atExplicitKey = false;
            allowCompact = true;
          } else {
            throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
          }
          state.position += 1;
          ch = following;
        } else {
          _keyLine = state.line;
          _keyLineStart = state.lineStart;
          _keyPos = state.position;
          if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
            break;
          }
          if (state.line === _line) {
            ch = state.input.charCodeAt(state.position);
            while (is_WHITE_SPACE(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            if (ch === 58) {
              ch = state.input.charCodeAt(++state.position);
              if (!is_WS_OR_EOL(ch)) {
                throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
              }
              if (atExplicitKey) {
                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
                keyTag = keyNode = valueNode = null;
              }
              detected = true;
              atExplicitKey = false;
              allowCompact = false;
              keyTag = state.tag;
              keyNode = state.result;
            } else if (detected) {
              throwError(state, "can not read an implicit mapping pair; a colon is missed");
            } else {
              state.tag = _tag;
              state.anchor = _anchor;
              return true;
            }
          } else if (detected) {
            throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true;
          }
        }
        if (state.line === _line || state.lineIndent > nodeIndent) {
          if (atExplicitKey) {
            _keyLine = state.line;
            _keyLineStart = state.lineStart;
            _keyPos = state.position;
          }
          if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
            if (atExplicitKey) {
              keyNode = state.result;
            } else {
              valueNode = state.result;
            }
          }
          if (!atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          skipSeparationSpace(state, true, -1);
          ch = state.input.charCodeAt(state.position);
        }
        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
          throwError(state, "bad indentation of a mapping entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "mapping";
        state.result = _result;
      }
      return detected;
    }
    function readTagProperty(state) {
      var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 33)
        return false;
      if (state.tag !== null) {
        throwError(state, "duplication of a tag property");
      }
      ch = state.input.charCodeAt(++state.position);
      if (ch === 60) {
        isVerbatim = true;
        ch = state.input.charCodeAt(++state.position);
      } else if (ch === 33) {
        isNamed = true;
        tagHandle = "!!";
        ch = state.input.charCodeAt(++state.position);
      } else {
        tagHandle = "!";
      }
      _position = state.position;
      if (isVerbatim) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && ch !== 62);
        if (state.position < state.length) {
          tagName = state.input.slice(_position, state.position);
          ch = state.input.charCodeAt(++state.position);
        } else {
          throwError(state, "unexpected end of the stream within a verbatim tag");
        }
      } else {
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          if (ch === 33) {
            if (!isNamed) {
              tagHandle = state.input.slice(_position - 1, state.position + 1);
              if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                throwError(state, "named tag handle cannot contain such characters");
              }
              isNamed = true;
              _position = state.position + 1;
            } else {
              throwError(state, "tag suffix cannot contain exclamation marks");
            }
          }
          ch = state.input.charCodeAt(++state.position);
        }
        tagName = state.input.slice(_position, state.position);
        if (PATTERN_FLOW_INDICATORS.test(tagName)) {
          throwError(state, "tag suffix cannot contain flow indicator characters");
        }
      }
      if (tagName && !PATTERN_TAG_URI.test(tagName)) {
        throwError(state, "tag name cannot contain such characters: " + tagName);
      }
      try {
        tagName = decodeURIComponent(tagName);
      } catch (err) {
        throwError(state, "tag name is malformed: " + tagName);
      }
      if (isVerbatim) {
        state.tag = tagName;
      } else if (_hasOwnProperty$2.call(state.tagMap, tagHandle)) {
        state.tag = state.tagMap[tagHandle] + tagName;
      } else if (tagHandle === "!") {
        state.tag = "!" + tagName;
      } else if (tagHandle === "!!") {
        state.tag = "tag:yaml.org,2002:" + tagName;
      } else {
        throwError(state, 'undeclared tag handle "' + tagHandle + '"');
      }
      return true;
    }
    function readAnchorProperty(state) {
      var _position, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 38)
        return false;
      if (state.anchor !== null) {
        throwError(state, "duplication of an anchor property");
      }
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, "name of an anchor node must contain at least one character");
      }
      state.anchor = state.input.slice(_position, state.position);
      return true;
    }
    function readAlias(state) {
      var _position, alias, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 42)
        return false;
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, "name of an alias node must contain at least one character");
      }
      alias = state.input.slice(_position, state.position);
      if (!_hasOwnProperty$2.call(state.anchorMap, alias)) {
        throwError(state, 'unidentified alias "' + alias + '"');
      }
      state.result = state.anchorMap[alias];
      skipSeparationSpace(state, true, -1);
      return true;
    }
    function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
      var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
      if (state.listener !== null) {
        state.listener("open", state);
      }
      state.tag = null;
      state.anchor = null;
      state.kind = null;
      state.result = null;
      allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
      if (allowToSeek) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        }
      }
      if (indentStatus === 1) {
        while (readTagProperty(state) || readAnchorProperty(state)) {
          if (skipSeparationSpace(state, true, -1)) {
            atNewLine = true;
            allowBlockCollections = allowBlockStyles;
            if (state.lineIndent > parentIndent) {
              indentStatus = 1;
            } else if (state.lineIndent === parentIndent) {
              indentStatus = 0;
            } else if (state.lineIndent < parentIndent) {
              indentStatus = -1;
            }
          } else {
            allowBlockCollections = false;
          }
        }
      }
      if (allowBlockCollections) {
        allowBlockCollections = atNewLine || allowCompact;
      }
      if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
        if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
          flowIndent = parentIndent;
        } else {
          flowIndent = parentIndent + 1;
        }
        blockIndent = state.position - state.lineStart;
        if (indentStatus === 1) {
          if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
            hasContent = true;
          } else {
            if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
              hasContent = true;
            } else if (readAlias(state)) {
              hasContent = true;
              if (state.tag !== null || state.anchor !== null) {
                throwError(state, "alias node should not have any properties");
              }
            } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
              hasContent = true;
              if (state.tag === null) {
                state.tag = "?";
              }
            }
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
          }
        } else if (indentStatus === 0) {
          hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
        }
      }
      if (state.tag === null) {
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      } else if (state.tag === "?") {
        if (state.result !== null && state.kind !== "scalar") {
          throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
        }
        for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
          type2 = state.implicitTypes[typeIndex];
          if (type2.resolve(state.result)) {
            state.result = type2.construct(state.result);
            state.tag = type2.tag;
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
            break;
          }
        }
      } else if (state.tag !== "!") {
        if (_hasOwnProperty$2.call(state.typeMap[state.kind || "fallback"], state.tag)) {
          type2 = state.typeMap[state.kind || "fallback"][state.tag];
        } else {
          type2 = null;
          typeList = state.typeMap.multi[state.kind || "fallback"];
          for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
            if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
              type2 = typeList[typeIndex];
              break;
            }
          }
        }
        if (!type2) {
          throwError(state, "unknown tag !<" + state.tag + ">");
        }
        if (state.result !== null && type2.kind !== state.kind) {
          throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
        }
        if (!type2.resolve(state.result, state.tag)) {
          throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
        } else {
          state.result = type2.construct(state.result, state.tag);
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
        }
      }
      if (state.listener !== null) {
        state.listener("close", state);
      }
      return state.tag !== null || state.anchor !== null || hasContent;
    }
    function readDocument(state) {
      var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
      state.version = null;
      state.checkLineBreaks = state.legacy;
      state.tagMap = /* @__PURE__ */ Object.create(null);
      state.anchorMap = /* @__PURE__ */ Object.create(null);
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if (state.lineIndent > 0 || ch !== 37) {
          break;
        }
        hasDirectives = true;
        ch = state.input.charCodeAt(++state.position);
        _position = state.position;
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        directiveName = state.input.slice(_position, state.position);
        directiveArgs = [];
        if (directiveName.length < 1) {
          throwError(state, "directive name must not be less than one character in length");
        }
        while (ch !== 0) {
          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (ch === 35) {
            do {
              ch = state.input.charCodeAt(++state.position);
            } while (ch !== 0 && !is_EOL(ch));
            break;
          }
          if (is_EOL(ch))
            break;
          _position = state.position;
          while (ch !== 0 && !is_WS_OR_EOL(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          directiveArgs.push(state.input.slice(_position, state.position));
        }
        if (ch !== 0)
          readLineBreak(state);
        if (_hasOwnProperty$2.call(directiveHandlers, directiveName)) {
          directiveHandlers[directiveName](state, directiveName, directiveArgs);
        } else {
          throwWarning(state, 'unknown document directive "' + directiveName + '"');
        }
      }
      skipSeparationSpace(state, true, -1);
      if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      } else if (hasDirectives) {
        throwError(state, "directives end mark is expected");
      }
      composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
      skipSeparationSpace(state, true, -1);
      if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
        throwWarning(state, "non-ASCII line breaks are interpreted as content");
      }
      state.documents.push(state.result);
      if (state.position === state.lineStart && testDocumentSeparator(state)) {
        if (state.input.charCodeAt(state.position) === 46) {
          state.position += 3;
          skipSeparationSpace(state, true, -1);
        }
        return;
      }
      if (state.position < state.length - 1) {
        throwError(state, "end of the stream or a document separator is expected");
      } else {
        return;
      }
    }
    function loadDocuments(input, options2) {
      input = String(input);
      options2 = options2 || {};
      if (input.length !== 0) {
        if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
          input += "\n";
        }
        if (input.charCodeAt(0) === 65279) {
          input = input.slice(1);
        }
      }
      var state = new State(input, options2);
      var nullpos = input.indexOf("\0");
      if (nullpos !== -1) {
        state.position = nullpos;
        throwError(state, "null byte is not allowed in input");
      }
      state.input += "\0";
      while (state.input.charCodeAt(state.position) === 32) {
        state.lineIndent += 1;
        state.position += 1;
      }
      while (state.position < state.length - 1) {
        readDocument(state);
      }
      return state.documents;
    }
    function loadAll(input, iterator, options2) {
      if (iterator !== null && _typeof3(iterator) === "object" && typeof options2 === "undefined") {
        options2 = iterator;
        iterator = null;
      }
      var documents = loadDocuments(input, options2);
      if (typeof iterator !== "function") {
        return documents;
      }
      for (var index = 0, length = documents.length; index < length; index += 1) {
        iterator(documents[index]);
      }
    }
    function load(input, options2) {
      var documents = loadDocuments(input, options2);
      if (documents.length === 0) {
        return void 0;
      } else if (documents.length === 1) {
        return documents[0];
      }
      throw new exception("expected a single document in the stream, but found more");
    }
    var loadAll_1 = loadAll;
    var load_1 = load;
    var loader = {
      loadAll: loadAll_1,
      load: load_1
    };
    var _toString$2 = Object.prototype.toString;
    var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
    var CHAR_BOM = 65279;
    var CHAR_TAB = 9;
    var CHAR_LINE_FEED = 10;
    var CHAR_CARRIAGE_RETURN = 13;
    var CHAR_SPACE = 32;
    var CHAR_EXCLAMATION = 33;
    var CHAR_DOUBLE_QUOTE = 34;
    var CHAR_SHARP = 35;
    var CHAR_PERCENT = 37;
    var CHAR_AMPERSAND = 38;
    var CHAR_SINGLE_QUOTE = 39;
    var CHAR_ASTERISK = 42;
    var CHAR_COMMA = 44;
    var CHAR_MINUS = 45;
    var CHAR_COLON = 58;
    var CHAR_EQUALS = 61;
    var CHAR_GREATER_THAN = 62;
    var CHAR_QUESTION = 63;
    var CHAR_COMMERCIAL_AT = 64;
    var CHAR_LEFT_SQUARE_BRACKET = 91;
    var CHAR_RIGHT_SQUARE_BRACKET = 93;
    var CHAR_GRAVE_ACCENT = 96;
    var CHAR_LEFT_CURLY_BRACKET = 123;
    var CHAR_VERTICAL_LINE = 124;
    var CHAR_RIGHT_CURLY_BRACKET = 125;
    var ESCAPE_SEQUENCES = {};
    ESCAPE_SEQUENCES[0] = "\\0";
    ESCAPE_SEQUENCES[7] = "\\a";
    ESCAPE_SEQUENCES[8] = "\\b";
    ESCAPE_SEQUENCES[9] = "\\t";
    ESCAPE_SEQUENCES[10] = "\\n";
    ESCAPE_SEQUENCES[11] = "\\v";
    ESCAPE_SEQUENCES[12] = "\\f";
    ESCAPE_SEQUENCES[13] = "\\r";
    ESCAPE_SEQUENCES[27] = "\\e";
    ESCAPE_SEQUENCES[34] = '\\"';
    ESCAPE_SEQUENCES[92] = "\\\\";
    ESCAPE_SEQUENCES[133] = "\\N";
    ESCAPE_SEQUENCES[160] = "\\_";
    ESCAPE_SEQUENCES[8232] = "\\L";
    ESCAPE_SEQUENCES[8233] = "\\P";
    var DEPRECATED_BOOLEANS_SYNTAX = ["y", "Y", "yes", "Yes", "YES", "on", "On", "ON", "n", "N", "no", "No", "NO", "off", "Off", "OFF"];
    var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
    function compileStyleMap(schema2, map2) {
      var result2, keys, index, length, tag, style, type2;
      if (map2 === null)
        return {};
      result2 = {};
      keys = Object.keys(map2);
      for (index = 0, length = keys.length; index < length; index += 1) {
        tag = keys[index];
        style = String(map2[tag]);
        if (tag.slice(0, 2) === "!!") {
          tag = "tag:yaml.org,2002:" + tag.slice(2);
        }
        type2 = schema2.compiledTypeMap["fallback"][tag];
        if (type2 && _hasOwnProperty$3.call(type2.styleAliases, style)) {
          style = type2.styleAliases[style];
        }
        result2[tag] = style;
      }
      return result2;
    }
    function encodeHex(character) {
      var string, handle3, length;
      string = character.toString(16).toUpperCase();
      if (character <= 255) {
        handle3 = "x";
        length = 2;
      } else if (character <= 65535) {
        handle3 = "u";
        length = 4;
      } else if (character <= 4294967295) {
        handle3 = "U";
        length = 8;
      } else {
        throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
      }
      return "\\" + handle3 + common.repeat("0", length - string.length) + string;
    }
    var QUOTING_TYPE_SINGLE = 1;
    var QUOTING_TYPE_DOUBLE = 2;
    function State$1(options2) {
      this.schema = options2["schema"] || _default;
      this.indent = Math.max(1, options2["indent"] || 2);
      this.noArrayIndent = options2["noArrayIndent"] || false;
      this.skipInvalid = options2["skipInvalid"] || false;
      this.flowLevel = common.isNothing(options2["flowLevel"]) ? -1 : options2["flowLevel"];
      this.styleMap = compileStyleMap(this.schema, options2["styles"] || null);
      this.sortKeys = options2["sortKeys"] || false;
      this.lineWidth = options2["lineWidth"] || 80;
      this.noRefs = options2["noRefs"] || false;
      this.noCompatMode = options2["noCompatMode"] || false;
      this.condenseFlow = options2["condenseFlow"] || false;
      this.quotingType = options2["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
      this.forceQuotes = options2["forceQuotes"] || false;
      this.replacer = typeof options2["replacer"] === "function" ? options2["replacer"] : null;
      this.implicitTypes = this.schema.compiledImplicit;
      this.explicitTypes = this.schema.compiledExplicit;
      this.tag = null;
      this.result = "";
      this.duplicates = [];
      this.usedDuplicates = null;
    }
    function indentString(string, spaces) {
      var ind = common.repeat(" ", spaces), position = 0, next = -1, result2 = "", line, length = string.length;
      while (position < length) {
        next = string.indexOf("\n", position);
        if (next === -1) {
          line = string.slice(position);
          position = length;
        } else {
          line = string.slice(position, next + 1);
          position = next + 1;
        }
        if (line.length && line !== "\n")
          result2 += ind;
        result2 += line;
      }
      return result2;
    }
    function generateNextLine(state, level) {
      return "\n" + common.repeat(" ", state.indent * level);
    }
    function testImplicitResolving(state, str2) {
      var index, length, type2;
      for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
        type2 = state.implicitTypes[index];
        if (type2.resolve(str2)) {
          return true;
        }
      }
      return false;
    }
    function isWhitespace(c) {
      return c === CHAR_SPACE || c === CHAR_TAB;
    }
    function isPrintable(c) {
      return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
    }
    function isNsCharOrWhitespace(c) {
      return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
    }
    function isPlainSafe(c, prev, inblock) {
      var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
      var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
      return (inblock ? cIsNsCharOrWhitespace : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar;
    }
    function isPlainSafeFirst(c) {
      return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
    }
    function isPlainSafeLast(c) {
      return !isWhitespace(c) && c !== CHAR_COLON;
    }
    function codePointAt(string, pos) {
      var first = string.charCodeAt(pos), second;
      if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
        second = string.charCodeAt(pos + 1);
        if (second >= 56320 && second <= 57343) {
          return (first - 55296) * 1024 + second - 56320 + 65536;
        }
      }
      return first;
    }
    function needIndentIndicator(string) {
      var leadingSpaceRe = /^\n* /;
      return leadingSpaceRe.test(string);
    }
    var STYLE_PLAIN = 1;
    var STYLE_SINGLE = 2;
    var STYLE_LITERAL = 3;
    var STYLE_FOLDED = 4;
    var STYLE_DOUBLE = 5;
    function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
      var i2;
      var char = 0;
      var prevChar = null;
      var hasLineBreak = false;
      var hasFoldableLine = false;
      var shouldTrackWidth = lineWidth !== -1;
      var previousLineBreak = -1;
      var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
      if (singleLineOnly || forceQuotes) {
        for (i2 = 0; i2 < string.length; char >= 65536 ? i2 += 2 : i2++) {
          char = codePointAt(string, i2);
          if (!isPrintable(char)) {
            return STYLE_DOUBLE;
          }
          plain = plain && isPlainSafe(char, prevChar, inblock);
          prevChar = char;
        }
      } else {
        for (i2 = 0; i2 < string.length; char >= 65536 ? i2 += 2 : i2++) {
          char = codePointAt(string, i2);
          if (char === CHAR_LINE_FEED) {
            hasLineBreak = true;
            if (shouldTrackWidth) {
              hasFoldableLine = hasFoldableLine || i2 - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
              previousLineBreak = i2;
            }
          } else if (!isPrintable(char)) {
            return STYLE_DOUBLE;
          }
          plain = plain && isPlainSafe(char, prevChar, inblock);
          prevChar = char;
        }
        hasFoldableLine = hasFoldableLine || shouldTrackWidth && i2 - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
      }
      if (!hasLineBreak && !hasFoldableLine) {
        if (plain && !forceQuotes && !testAmbiguousType(string)) {
          return STYLE_PLAIN;
        }
        return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
      }
      if (indentPerLevel > 9 && needIndentIndicator(string)) {
        return STYLE_DOUBLE;
      }
      if (!forceQuotes) {
        return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
      }
      return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
    }
    function writeScalar(state, string, level, iskey, inblock) {
      state.dump = function() {
        if (string.length === 0) {
          return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
        }
        if (!state.noCompatMode) {
          if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
            return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
          }
        }
        var indent = state.indent * Math.max(1, level);
        var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
        var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
        function testAmbiguity(string2) {
          return testImplicitResolving(state, string2);
        }
        switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {
          case STYLE_PLAIN:
            return string;
          case STYLE_SINGLE:
            return "'" + string.replace(/'/g, "''") + "'";
          case STYLE_LITERAL:
            return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
          case STYLE_FOLDED:
            return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
          case STYLE_DOUBLE:
            return '"' + escapeString(string) + '"';
          default:
            throw new exception("impossible error: invalid scalar style");
        }
      }();
    }
    function blockHeader(string, indentPerLevel) {
      var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
      var clip = string[string.length - 1] === "\n";
      var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
      var chomp = keep ? "+" : clip ? "" : "-";
      return indentIndicator + chomp + "\n";
    }
    function dropEndingNewline(string) {
      return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
    }
    function foldString(string, width) {
      var lineRe = /(\n+)([^\n]*)/g;
      var result2 = function() {
        var nextLF = string.indexOf("\n");
        nextLF = nextLF !== -1 ? nextLF : string.length;
        lineRe.lastIndex = nextLF;
        return foldLine(string.slice(0, nextLF), width);
      }();
      var prevMoreIndented = string[0] === "\n" || string[0] === " ";
      var moreIndented;
      var match;
      while (match = lineRe.exec(string)) {
        var prefix = match[1], line = match[2];
        moreIndented = line[0] === " ";
        result2 += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
        prevMoreIndented = moreIndented;
      }
      return result2;
    }
    function foldLine(line, width) {
      if (line === "" || line[0] === " ")
        return line;
      var breakRe = / [^ ]/g;
      var match;
      var start = 0, end, curr = 0, next = 0;
      var result2 = "";
      while (match = breakRe.exec(line)) {
        next = match.index;
        if (next - start > width) {
          end = curr > start ? curr : next;
          result2 += "\n" + line.slice(start, end);
          start = end + 1;
        }
        curr = next;
      }
      result2 += "\n";
      if (line.length - start > width && curr > start) {
        result2 += line.slice(start, curr) + "\n" + line.slice(curr + 1);
      } else {
        result2 += line.slice(start);
      }
      return result2.slice(1);
    }
    function escapeString(string) {
      var result2 = "";
      var char = 0;
      var escapeSeq;
      for (var i2 = 0; i2 < string.length; char >= 65536 ? i2 += 2 : i2++) {
        char = codePointAt(string, i2);
        escapeSeq = ESCAPE_SEQUENCES[char];
        if (!escapeSeq && isPrintable(char)) {
          result2 += string[i2];
          if (char >= 65536)
            result2 += string[i2 + 1];
        } else {
          result2 += escapeSeq || encodeHex(char);
        }
      }
      return result2;
    }
    function writeFlowSequence(state, level, object) {
      var _result = "", _tag = state.tag, index, length, value;
      for (index = 0, length = object.length; index < length; index += 1) {
        value = object[index];
        if (state.replacer) {
          value = state.replacer.call(object, String(index), value);
        }
        if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
          if (_result !== "")
            _result += "," + (!state.condenseFlow ? " " : "");
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = "[" + _result + "]";
    }
    function writeBlockSequence(state, level, object, compact) {
      var _result = "", _tag = state.tag, index, length, value;
      for (index = 0, length = object.length; index < length; index += 1) {
        value = object[index];
        if (state.replacer) {
          value = state.replacer.call(object, String(index), value);
        }
        if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
          if (!compact || _result !== "") {
            _result += generateNextLine(state, level);
          }
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            _result += "-";
          } else {
            _result += "- ";
          }
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = _result || "[]";
    }
    function writeFlowMapping(state, level, object) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
      for (index = 0, length = objectKeyList.length; index < length; index += 1) {
        pairBuffer = "";
        if (_result !== "")
          pairBuffer += ", ";
        if (state.condenseFlow)
          pairBuffer += '"';
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (state.replacer) {
          objectValue = state.replacer.call(object, objectKey, objectValue);
        }
        if (!writeNode(state, level, objectKey, false, false)) {
          continue;
        }
        if (state.dump.length > 1024)
          pairBuffer += "? ";
        pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
        if (!writeNode(state, level, objectValue, false, false)) {
          continue;
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = "{" + _result + "}";
    }
    function writeBlockMapping(state, level, object, compact) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
      if (state.sortKeys === true) {
        objectKeyList.sort();
      } else if (typeof state.sortKeys === "function") {
        objectKeyList.sort(state.sortKeys);
      } else if (state.sortKeys) {
        throw new exception("sortKeys must be a boolean or a function");
      }
      for (index = 0, length = objectKeyList.length; index < length; index += 1) {
        pairBuffer = "";
        if (!compact || _result !== "") {
          pairBuffer += generateNextLine(state, level);
        }
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (state.replacer) {
          objectValue = state.replacer.call(object, objectKey, objectValue);
        }
        if (!writeNode(state, level + 1, objectKey, true, true, true)) {
          continue;
        }
        explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
        if (explicitPair) {
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            pairBuffer += "?";
          } else {
            pairBuffer += "? ";
          }
        }
        pairBuffer += state.dump;
        if (explicitPair) {
          pairBuffer += generateNextLine(state, level);
        }
        if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
          continue;
        }
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += ":";
        } else {
          pairBuffer += ": ";
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = _result || "{}";
    }
    function detectType(state, object, explicit) {
      var _result, typeList, index, length, type2, style;
      typeList = explicit ? state.explicitTypes : state.implicitTypes;
      for (index = 0, length = typeList.length; index < length; index += 1) {
        type2 = typeList[index];
        if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || _typeof3(object) === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
          if (explicit) {
            if (type2.multi && type2.representName) {
              state.tag = type2.representName(object);
            } else {
              state.tag = type2.tag;
            }
          } else {
            state.tag = "?";
          }
          if (type2.represent) {
            style = state.styleMap[type2.tag] || type2.defaultStyle;
            if (_toString$2.call(type2.represent) === "[object Function]") {
              _result = type2.represent(object, style);
            } else if (_hasOwnProperty$3.call(type2.represent, style)) {
              _result = type2.represent[style](object, style);
            } else {
              throw new exception("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
            }
            state.dump = _result;
          }
          return true;
        }
      }
      return false;
    }
    function writeNode(state, level, object, block, compact, iskey, isblockseq) {
      state.tag = null;
      state.dump = object;
      if (!detectType(state, object, false)) {
        detectType(state, object, true);
      }
      var type2 = _toString$2.call(state.dump);
      var inblock = block;
      var tagStr;
      if (block) {
        block = state.flowLevel < 0 || state.flowLevel > level;
      }
      var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
      if (objectOrArray) {
        duplicateIndex = state.duplicates.indexOf(object);
        duplicate = duplicateIndex !== -1;
      }
      if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
        compact = false;
      }
      if (duplicate && state.usedDuplicates[duplicateIndex]) {
        state.dump = "*ref_" + duplicateIndex;
      } else {
        if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
          state.usedDuplicates[duplicateIndex] = true;
        }
        if (type2 === "[object Object]") {
          if (block && Object.keys(state.dump).length !== 0) {
            writeBlockMapping(state, level, state.dump, compact);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowMapping(state, level, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type2 === "[object Array]") {
          if (block && state.dump.length !== 0) {
            if (state.noArrayIndent && !isblockseq && level > 0) {
              writeBlockSequence(state, level - 1, state.dump, compact);
            } else {
              writeBlockSequence(state, level, state.dump, compact);
            }
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowSequence(state, level, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type2 === "[object String]") {
          if (state.tag !== "?") {
            writeScalar(state, state.dump, level, iskey, inblock);
          }
        } else if (type2 === "[object Undefined]") {
          return false;
        } else {
          if (state.skipInvalid)
            return false;
          throw new exception("unacceptable kind of an object to dump " + type2);
        }
        if (state.tag !== null && state.tag !== "?") {
          tagStr = encodeURI(state.tag[0] === "!" ? state.tag.slice(1) : state.tag).replace(/!/g, "%21");
          if (state.tag[0] === "!") {
            tagStr = "!" + tagStr;
          } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
            tagStr = "!!" + tagStr.slice(18);
          } else {
            tagStr = "!<" + tagStr + ">";
          }
          state.dump = tagStr + " " + state.dump;
        }
      }
      return true;
    }
    function getDuplicateReferences(object, state) {
      var objects = [], duplicatesIndexes = [], index, length;
      inspectNode(object, objects, duplicatesIndexes);
      for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
        state.duplicates.push(objects[duplicatesIndexes[index]]);
      }
      state.usedDuplicates = new Array(length);
    }
    function inspectNode(object, objects, duplicatesIndexes) {
      var objectKeyList, index, length;
      if (object !== null && _typeof3(object) === "object") {
        index = objects.indexOf(object);
        if (index !== -1) {
          if (duplicatesIndexes.indexOf(index) === -1) {
            duplicatesIndexes.push(index);
          }
        } else {
          objects.push(object);
          if (Array.isArray(object)) {
            for (index = 0, length = object.length; index < length; index += 1) {
              inspectNode(object[index], objects, duplicatesIndexes);
            }
          } else {
            objectKeyList = Object.keys(object);
            for (index = 0, length = objectKeyList.length; index < length; index += 1) {
              inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
            }
          }
        }
      }
    }
    function dump(input, options2) {
      options2 = options2 || {};
      var state = new State$1(options2);
      if (!state.noRefs)
        getDuplicateReferences(input, state);
      var value = input;
      if (state.replacer) {
        value = state.replacer.call({
          "": value
        }, "", value);
      }
      if (writeNode(state, 0, value, true, true))
        return state.dump + "\n";
      return "";
    }
    var dump_1 = dump;
    var dumper = {
      dump: dump_1
    };
    function renamed(from, to) {
      return function() {
        throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
      };
    }
    var Type$1 = type;
    exports2.Type = Type$1;
    var Schema$1 = schema;
    exports2.Schema = Schema$1;
    var FAILSAFE_SCHEMA = failsafe;
    exports2.FAILSAFE_SCHEMA = FAILSAFE_SCHEMA;
    var JSON_SCHEMA = json;
    exports2.JSON_SCHEMA = JSON_SCHEMA;
    var CORE_SCHEMA = core;
    exports2.CORE_SCHEMA = CORE_SCHEMA;
    var DEFAULT_SCHEMA = _default;
    exports2.DEFAULT_SCHEMA = DEFAULT_SCHEMA;
    var load$1 = loader.load;
    exports2.load = load$1;
    var loadAll$1 = loader.loadAll;
    exports2.loadAll = loadAll$1;
    var dump$1 = dumper.dump;
    exports2.dump = dump$1;
    var YAMLException$1 = exception;
    exports2.YAMLException = YAMLException$1;
    var safeLoad = renamed("safeLoad", "load");
    exports2.safeLoad = safeLoad;
    var safeLoadAll = renamed("safeLoadAll", "loadAll");
    exports2.safeLoadAll = safeLoadAll;
    var safeDump = renamed("safeDump", "dump");
    exports2.safeDump = safeDump;
    var jsYaml = {
      Type: Type$1,
      Schema: Schema$1,
      FAILSAFE_SCHEMA,
      JSON_SCHEMA,
      CORE_SCHEMA,
      DEFAULT_SCHEMA,
      load: load$1,
      loadAll: loadAll$1,
      dump: dump$1,
      YAMLException: YAMLException$1,
      safeLoad,
      safeLoadAll,
      safeDump
    };
    var _default2 = jsYaml;
    exports2.default = _default2;
  }
});

// ../../node_modules/i18next-fs-backend/cjs/fs.js
var require_fs = __commonJS({
  "../../node_modules/i18next-fs-backend/cjs/fs.js"(exports2, module2) {
    if (typeof require !== "undefined") {
      f = require("fs");
      if (f.default)
        f = f.default;
      exports2.default = f;
      module2.exports = exports2.default;
    }
    var f;
  }
});

// ../../node_modules/i18next-fs-backend/cjs/extname.js
var require_extname = __commonJS({
  "../../node_modules/i18next-fs-backend/cjs/extname.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = function _default2(filename) {
      if (filename.indexOf(".") < 0)
        return void 0;
      return ".".concat(filename.split(".").pop());
    };
    exports2.default = _default;
    module2.exports = exports2.default;
  }
});

// ../../node_modules/i18next-fs-backend/cjs/readFile.js
var require_readFile = __commonJS({
  "../../node_modules/i18next-fs-backend/cjs/readFile.js"(exports, module) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof3(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof3(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.readFileSync = readFileSync;
    exports.readFile = readFile;
    var _json = _interopRequireDefault(require_json5());
    var _yaml = _interopRequireDefault(require_yaml());
    var fsMod = _interopRequireWildcard(require_fs());
    var _extname = _interopRequireDefault(require_extname());
    function _getRequireWildcardCache() {
      if (typeof WeakMap !== "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      _getRequireWildcardCache = function _getRequireWildcardCache2() {
        return cache;
      };
      return cache;
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache();
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var isDeno = typeof Deno !== "undefined";
    var YAML = typeof _yaml.default !== "undefined" && _yaml.default.load ? _yaml.default : void 0;
    var fs = fsMod ? fsMod.default || fsMod : void 0;
    var readFileInNodeSync = function readFileInNodeSync2(filename) {
      var data2 = fs.readFileSync(filename, "utf8");
      var stat;
      try {
        stat = fs.statSync(filename);
      } catch (e) {
      }
      return {
        data: data2,
        stat
      };
    };
    var readFileInNode = function readFileInNode2(filename) {
      return new Promise(function(resolve, reject) {
        fs.readFile(filename, "utf8", function(err, data2) {
          if (err)
            return reject(err);
          fs.stat(filename, function(err2, stat) {
            if (err2)
              return resolve({
                data: data2
              });
            return resolve({
              data: data2,
              stat
            });
          });
        });
      });
    };
    var readFileInDenoSync = function readFileInDenoSync2(filename) {
      var decoder = new TextDecoder("utf-8");
      var d = Deno.readFileSync(filename);
      var data2 = decoder.decode(d);
      var stat;
      try {
        stat = Deno.statSync(filename);
      } catch (e) {
      }
      return {
        data: data2,
        stat
      };
    };
    var readFileInDeno = function readFileInDeno2(filename) {
      return new Promise(function(resolve, reject) {
        var decoder = new TextDecoder("utf-8");
        Deno.readFile(filename).then(function(d) {
          var data2 = decoder.decode(d);
          Deno.stat(filename).then(function(stat) {
            return resolve({
              data: data2,
              stat
            });
          }).catch(function() {
            return resolve({
              data: data2
            });
          });
        }).catch(reject);
      });
    };
    var parseData = function parseData(extension, data, options) {
      data = data.replace(/^\uFEFF/, "");
      var result = {};
      switch (extension) {
        case ".js":
        case ".ts":
          if (typeof module === "undefined") {
            if (data.indexOf("exports") > -1) {
              data = "(".concat(data.substring(data.indexOf("=") + 1).replace(/;/, ""), ")");
            } else if (data.indexOf("export default ") > -1) {
              data = "(".concat(data.substring(data.indexOf("export default ") + 15).replace(/;/, ""), ")");
            }
          }
          result = eval(data);
          break;
        case ".json5":
          result = _json.default.parse(data);
          break;
        case ".yml":
        case ".yaml":
          result = YAML.load(data);
          break;
        default:
          result = options.parse(data);
      }
      return result;
    };
    function readFileSync(filename, options2) {
      var ext = (0, _extname.default)(filename);
      if ([".js", ".ts"].indexOf(ext) > -1 && typeof require !== "undefined") {
        return !filename.startsWith("/") && typeof process !== "undefined" && process.cwd ? require("".concat(process.cwd(), "/").concat(filename)) : require(filename);
      }
      var data2, stat;
      if (isDeno) {
        var ret = readFileInDenoSync(filename);
        data2 = ret.data;
        stat = ret.stat;
      } else {
        var _ret = readFileInNodeSync(filename);
        data2 = _ret.data;
        stat = _ret.stat;
      }
      return {
        data: parseData(ext, data2, options2),
        stat
      };
    }
    function readFile(filename) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        parse: JSON.parse
      };
      var ext = (0, _extname.default)(filename);
      if ([".js", ".ts"].indexOf(ext) > -1 && typeof require !== "undefined") {
        return new Promise(function(resolve, reject) {
          try {
            resolve({
              data: !filename.startsWith("/") && typeof process !== "undefined" && process.cwd ? require("".concat(process.cwd(), "/").concat(filename)) : require(filename)
            });
          } catch (err) {
            reject(err);
          }
        });
      }
      var fn = isDeno ? readFileInDeno : readFileInNode;
      return new Promise(function(resolve, reject) {
        fn(filename).then(function(_ref) {
          var data2 = _ref.data, stat = _ref.stat;
          try {
            var ret = parseData(ext, data2, options2);
            resolve({
              data: ret,
              stat
            });
          } catch (err) {
            err.message = "error parsing " + filename + ": " + err.message;
            reject(err);
          }
        }).catch(reject);
      });
    }
  }
});

// ../../node_modules/i18next-fs-backend/cjs/writeFile.js
var require_writeFile = __commonJS({
  "../../node_modules/i18next-fs-backend/cjs/writeFile.js"(exports2, module2) {
    "use strict";
    function _typeof3(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof3 = function _typeof4(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof3 = function _typeof4(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof3(obj);
    }
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.writeFileSync = writeFileSync;
    exports2.writeFile = writeFile;
    exports2.removeFileSync = removeFileSync;
    exports2.removeFile = removeFile;
    var _json2 = _interopRequireDefault2(require_json5());
    var _yaml2 = _interopRequireDefault2(require_yaml());
    var fsMod2 = _interopRequireWildcard2(require_fs());
    var _extname2 = _interopRequireDefault2(require_extname());
    function _getRequireWildcardCache2() {
      if (typeof WeakMap !== "function")
        return null;
      var cache = /* @__PURE__ */ new WeakMap();
      _getRequireWildcardCache2 = function _getRequireWildcardCache3() {
        return cache;
      };
      return cache;
    }
    function _interopRequireWildcard2(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof3(obj) !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache2();
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var isDeno2 = typeof Deno !== "undefined";
    var YAML3 = typeof _yaml2.default !== "undefined" && _yaml2.default.load ? _yaml2.default : void 0;
    var fs2 = fsMod2 ? fsMod2.default || fsMod2 : void 0;
    function dirname(path) {
      if (path.length === 0)
        return ".";
      var code = path.charCodeAt(0);
      var hasRoot = code === 47;
      var end = -1;
      var matchedSlash = true;
      for (var i = path.length - 1; i >= 1; --i) {
        code = path.charCodeAt(i);
        if (code === 47) {
          if (!matchedSlash) {
            end = i;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end === -1)
        return hasRoot ? "/" : ".";
      if (hasRoot && end === 1)
        return "//";
      return path.slice(0, end);
    }
    var writeFileInNodeSync = function writeFileInNodeSync2(filename, payload) {
      try {
        fs2.mkdirSync(dirname(filename), {
          recursive: true
        });
      } catch (err) {
      }
      return fs2.writeFileSync(filename, payload, "utf8");
    };
    var writeFileInNode = function writeFileInNode2(filename, payload) {
      return new Promise(function(resolve, reject) {
        fs2.mkdir(dirname(filename), {
          recursive: true
        }, function() {
          fs2.writeFile(filename, payload, "utf8", function(err, data2) {
            return err ? reject(err) : resolve(data2);
          });
        });
      });
    };
    var removeFileInNodeSync = function removeFileInNodeSync2(filename) {
      return fs2.unlinkSync(filename);
    };
    var removeFileInNode = function removeFileInNode2(filename) {
      return new Promise(function(resolve, reject) {
        return fs2.unlink(filename, function(err) {
          return err ? reject(err) : resolve();
        });
      });
    };
    var writeFileInDenoSync = function writeFileInDenoSync2(filename, payload) {
      var encoder = new TextEncoder();
      var data2 = encoder.encode(payload);
      try {
        Deno.mkdirSync(dirname(filename), {
          recursive: true
        });
      } catch (err) {
      }
      Deno.writeFileSync(filename, data2);
    };
    var writeFileInDeno = function writeFileInDeno2(filename, payload) {
      var encoder = new TextEncoder();
      var data2 = encoder.encode(payload);
      return new Promise(function(resolve, reject) {
        Deno.mkdir(dirname(filename), {
          recursive: true
        }).then(function() {
          Deno.writeFile(filename, data2).then(resolve, reject);
        }).catch(function() {
          Deno.writeFile(filename, data2).then(resolve, reject);
        });
      });
    };
    var removeFileInDenoSync = function removeFileInDenoSync2(filename) {
      Deno.removeSync(filename);
    };
    var removeFileInDeno = function removeFileInDeno2(filename) {
      return Deno.remove(filename);
    };
    var stringifyData = function stringifyData2(extension2, data2, options2) {
      var result2 = "";
      switch (extension2) {
        case ".js":
        case ".ts":
          if (typeof module2 === "undefined") {
            result2 = "export default ".concat(options2.stringify(data2, null, options2.ident));
          } else {
            result2 = "module.exports = ".concat(options2.stringify(data2, null, options2.ident));
          }
          break;
        case ".json5":
          result2 = _json2.default.stringify(data2, null, options2.ident);
          break;
        case ".yml":
        case ".yaml":
          result2 = YAML3.dump(data2, {
            ident: options2.indent
          });
          break;
        default:
          result2 = options2.stringify(data2, null, options2.ident);
      }
      return result2;
    };
    function writeFileSync(filename, payload, options2) {
      var ext = (0, _extname2.default)(filename);
      var data2;
      try {
        data2 = stringifyData(ext, payload, options2);
      } catch (err) {
        err.message = "error stringifying " + filename + ": " + err.message;
        throw err;
      }
      if (isDeno2) {
        return writeFileInDenoSync(filename, data2);
      } else {
        return writeFileInNodeSync(filename, data2);
      }
    }
    function writeFile(filename, payload) {
      var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
        stringify: JSON.stringify,
        ident: 2
      };
      var ext = (0, _extname2.default)(filename);
      var data2;
      try {
        data2 = stringifyData(ext, payload, options2);
      } catch (err) {
        err.message = "error stringifying " + filename + ": " + err.message;
        throw err;
      }
      var fn = isDeno2 ? writeFileInDeno : writeFileInNode;
      return fn(filename, data2);
    }
    function removeFileSync(filename) {
      if (isDeno2) {
        return removeFileInDenoSync(filename);
      } else {
        return removeFileInNodeSync(filename);
      }
    }
    function removeFile(filename) {
      var fn = isDeno2 ? removeFileInDeno : removeFileInNode;
      return fn(filename);
    }
  }
});

// ../../node_modules/i18next-fs-backend/cjs/index.js
var require_cjs = __commonJS({
  "../../node_modules/i18next-fs-backend/cjs/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _utils = require_utils2();
    var _readFile = require_readFile();
    var _writeFile2 = require_writeFile();
    function _classCallCheck2(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties2(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass2(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties2(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties2(Constructor, staticProps);
      return Constructor;
    }
    var getDefaults = function getDefaults2() {
      return {
        loadPath: "/locales/{{lng}}/{{ns}}.json",
        addPath: "/locales/{{lng}}/{{ns}}.missing.json",
        ident: 2,
        parse: JSON.parse,
        stringify: JSON.stringify
      };
    };
    var Backend = function() {
      function Backend2(services) {
        var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var allOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        _classCallCheck2(this, Backend2);
        this.services = services;
        this.options = options2;
        this.allOptions = allOptions;
        this.type = "backend";
        this.init(services, options2, allOptions);
      }
      _createClass2(Backend2, [{
        key: "init",
        value: function init(services) {
          var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var allOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          this.services = services;
          this.options = (0, _utils.defaults)(options2, this.options || {}, getDefaults());
          this.allOptions = allOptions;
          this.queuedWrites = {};
          this.debouncedWrite = (0, _utils.debounce)(this.write, 250);
        }
      }, {
        key: "read",
        value: function read(language, namespace, callback) {
          var _this = this;
          var loadPath = this.options.loadPath;
          if (typeof this.options.loadPath === "function") {
            loadPath = this.options.loadPath(language, namespace);
          }
          var filename = this.services.interpolator.interpolate(loadPath, {
            lng: language,
            ns: namespace
          });
          if (this.allOptions.initImmediate === false) {
            try {
              var _readFileSync = (0, _readFile.readFileSync)(filename, this.options), data2 = _readFileSync.data, stat = _readFileSync.stat;
              if (this.options.expirationTime && stat && stat.mtime && stat.mtime.getTime() + this.options.expirationTime < Date.now()) {
                this.removeFile(language, namespace);
                return callback(new Error("File expired!"), false);
              }
              callback(null, data2);
            } catch (err) {
              callback(err, false);
            }
            return;
          }
          (0, _readFile.readFile)(filename, this.options).then(function(_ref) {
            var data3 = _ref.data, stat2 = _ref.stat;
            if (_this.options.expirationTime && stat2 && stat2.mtime && stat2.mtime.getTime() + _this.options.expirationTime < Date.now()) {
              _this.removeFile(language, namespace);
              return callback(new Error("File expired!"), false);
            }
            callback(null, data3);
          }).catch(function(err) {
            return callback(err, false);
          });
        }
      }, {
        key: "create",
        value: function create(languages, namespace, key, fallbackValue, callback) {
          var _this2 = this;
          if (!callback)
            callback = function callback2() {
            };
          if (typeof languages === "string")
            languages = [languages];
          var todo = languages.length;
          var done = function done2() {
            if (!--todo)
              callback();
          };
          languages.forEach(function(lng) {
            _this2.queue.call(_this2, lng, namespace, key, fallbackValue, done);
          });
        }
      }, {
        key: "save",
        value: function save(language, namespace, data2, callback) {
          var _this3 = this;
          if (!callback)
            callback = function callback2() {
            };
          var keys = Object.keys(data2);
          var todo = keys.length;
          var done = function done2() {
            if (!--todo)
              callback();
          };
          keys.forEach(function(key) {
            _this3.queue.call(_this3, language, namespace, key, data2[key], done);
          });
        }
      }, {
        key: "removeFile",
        value: function removeFile(language, namespace) {
          var addPath = this.options.addPath;
          if (typeof this.options.addPath === "function") {
            addPath = this.options.addPath(language, namespace);
          }
          var filename = this.services.interpolator.interpolate(addPath, {
            lng: language,
            ns: namespace
          });
          (0, _writeFile2.removeFile)(filename, this.options).then(function() {
          }).catch(function() {
          });
        }
      }, {
        key: "write",
        value: function write() {
          for (var lng in this.queuedWrites) {
            var namespaces = this.queuedWrites[lng];
            if (lng !== "locks") {
              for (var ns in namespaces) {
                this.writeFile(lng, ns);
              }
            }
          }
        }
      }, {
        key: "writeFile",
        value: function writeFile(lng, namespace) {
          var _this4 = this;
          var lock = (0, _utils.getPath)(this.queuedWrites, ["locks", lng, namespace]);
          if (lock)
            return;
          var addPath = this.options.addPath;
          if (typeof this.options.addPath === "function") {
            addPath = this.options.addPath(lng, namespace);
          }
          var filename = this.services.interpolator.interpolate(addPath, {
            lng,
            ns: namespace
          });
          var missings = (0, _utils.getPath)(this.queuedWrites, [lng, namespace]);
          (0, _utils.setPath)(this.queuedWrites, [lng, namespace], []);
          if (missings.length) {
            (0, _utils.setPath)(this.queuedWrites, ["locks", lng, namespace], true);
            var proceed = function proceed2(_ref2) {
              var data2 = _ref2.data;
              missings.forEach(function(missing) {
                var path = _this4.allOptions.keySeparator === false ? [missing.key] : missing.key.split(_this4.allOptions.keySeparator || ".");
                (0, _utils.setPath)(data2, path, missing.fallbackValue);
              });
              var proceedWrite = function proceedWrite2() {
                (0, _utils.setPath)(_this4.queuedWrites, ["locks", lng, namespace], false);
                missings.forEach(function(missing) {
                  if (missing.callback)
                    missing.callback();
                });
                _this4.debouncedWrite();
              };
              (0, _writeFile2.writeFile)(filename, data2, _this4.options).then(proceedWrite).catch(proceedWrite);
            };
            (0, _readFile.readFile)(filename, this.options).then(proceed).catch(function() {
              return proceed({
                data: {}
              });
            });
          }
        }
      }, {
        key: "queue",
        value: function queue(lng, namespace, key, fallbackValue, callback) {
          (0, _utils.pushPath)(this.queuedWrites, [lng, namespace], {
            key,
            fallbackValue: fallbackValue || "",
            callback
          });
          this.debouncedWrite();
        }
      }]);
      return Backend2;
    }();
    Backend.type = "backend";
    var _default = Backend;
    exports2.default = _default;
    module2.exports = exports2.default;
  }
});

// ../lib/store/dist/i18n.js
var require_i18n3 = __commonJS({
  "../lib/store/dist/i18n.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.text = exports2.initI18n = void 0;
    var i18next_1 = __importDefault((init_i18next(), __toCommonJS(i18next_exports)));
    var i18next_fs_backend_1 = __importDefault(require_cjs());
    var path_1 = __importDefault(require("path"));
    var i18nInstance = i18next_1.default.createInstance();
    async function initI18n() {
      await i18nInstance.use(i18next_fs_backend_1.default).init({
        initImmediate: false,
        fallbackLng: "en",
        fallbackNS: "default",
        interpolation: { escapeValue: false },
        ns: "ux-store",
        defaultNS: "ux-store",
        backend: {
          loadPath: path_1.default.join(__dirname, "./translations/{{lng}}.{{ns}}.json")
        }
      });
    }
    exports2.initI18n = initI18n;
    function text(key, options2) {
      return i18nInstance.t(key, options2);
    }
    exports2.text = text;
  }
});

// ../lib/store/node_modules/debug/src/common.js
var require_common2 = __commonJS({
  "../lib/store/node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format2];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => enableOverride === null ? createDebug.enabled(namespace) : enableOverride,
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// ../lib/store/node_modules/debug/src/browser.js
var require_browser2 = __commonJS({
  "../lib/store/node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error3) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error3) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error3) {
      }
    }
    module2.exports = require_common2()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error3) {
        return "[UnexpectedJSONParseError]: " + error3.message;
      }
    };
  }
});

// ../lib/store/node_modules/debug/src/node.js
var require_node2 = __commonJS({
  "../lib/store/node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2.init = init;
    exports2.log = log4;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(() => {
    }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error3) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_45, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return new Date().toISOString() + " ";
    }
    function log4(...args) {
      return process.stderr.write(util.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common2()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// ../lib/store/node_modules/debug/src/index.js
var require_src3 = __commonJS({
  "../lib/store/node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser2();
    } else {
      module2.exports = require_node2();
    }
  }
});

// ../lib/store/dist/utils/index.js
var require_utils3 = __commonJS({
  "../lib/store/dist/utils/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getExtendedLogger = exports2.pick = exports2.enableDebugLogger = exports2.newDebugLogger = exports2.MIGRATION_NAMESPACE = exports2.STORE_NAMESPACE = void 0;
    var debug_1 = require_src3();
    exports2.STORE_NAMESPACE = "ft:store";
    exports2.MIGRATION_NAMESPACE = exports2.STORE_NAMESPACE + ":migrate";
    var newDebugLogger = (namespace = exports2.STORE_NAMESPACE) => debug_1.debug(namespace);
    exports2.newDebugLogger = newDebugLogger;
    var enableDebugLogger = (namespace) => debug_1.debug.enable(namespace);
    exports2.enableDebugLogger = enableDebugLogger;
    var pick = (target, ...props) => {
      return target && (props == null ? void 0 : props.length) > 0 && props.reduce((o, k) => {
        o[k] = target[k];
        return o;
      }, {}) || void 0;
    };
    exports2.pick = pick;
    function getExtendedLogger(l) {
      return {
        ...l,
        debug: exports2.newDebugLogger()
      };
    }
    exports2.getExtendedLogger = getExtendedLogger;
  }
});

// ../../node_modules/pluralize/pluralize.js
var require_pluralize = __commonJS({
  "../../node_modules/pluralize/pluralize.js"(exports2, module2) {
    (function(root, pluralize) {
      if (typeof require === "function" && typeof exports2 === "object" && typeof module2 === "object") {
        module2.exports = pluralize();
      } else if (typeof define === "function" && define.amd) {
        define(function() {
          return pluralize();
        });
      } else {
        root.pluralize = pluralize();
      }
    })(exports2, function() {
      var pluralRules = [];
      var singularRules = [];
      var uncountables = {};
      var irregularPlurals = {};
      var irregularSingles = {};
      function sanitizeRule(rule) {
        if (typeof rule === "string") {
          return new RegExp("^" + rule + "$", "i");
        }
        return rule;
      }
      function restoreCase(word2, token2) {
        if (word2 === token2)
          return token2;
        if (word2 === word2.toLowerCase())
          return token2.toLowerCase();
        if (word2 === word2.toUpperCase())
          return token2.toUpperCase();
        if (word2[0] === word2[0].toUpperCase()) {
          return token2.charAt(0).toUpperCase() + token2.substr(1).toLowerCase();
        }
        return token2.toLowerCase();
      }
      function interpolate(str, args) {
        return str.replace(/\$(\d{1,2})/g, function(match, index) {
          return args[index] || "";
        });
      }
      function replace(word2, rule) {
        return word2.replace(rule[0], function(match, index) {
          var result2 = interpolate(rule[1], arguments);
          if (match === "") {
            return restoreCase(word2[index - 1], result2);
          }
          return restoreCase(match, result2);
        });
      }
      function sanitizeWord(token2, word2, rules) {
        if (!token2.length || uncountables.hasOwnProperty(token2)) {
          return word2;
        }
        var len = rules.length;
        while (len--) {
          var rule = rules[len];
          if (rule[0].test(word2))
            return replace(word2, rule);
        }
        return word2;
      }
      function replaceWord(replaceMap, keepMap, rules) {
        return function(word2) {
          var token2 = word2.toLowerCase();
          if (keepMap.hasOwnProperty(token2)) {
            return restoreCase(word2, token2);
          }
          if (replaceMap.hasOwnProperty(token2)) {
            return restoreCase(word2, replaceMap[token2]);
          }
          return sanitizeWord(token2, word2, rules);
        };
      }
      function checkWord(replaceMap, keepMap, rules, bool) {
        return function(word2) {
          var token2 = word2.toLowerCase();
          if (keepMap.hasOwnProperty(token2))
            return true;
          if (replaceMap.hasOwnProperty(token2))
            return false;
          return sanitizeWord(token2, token2, rules) === token2;
        };
      }
      function pluralize(word2, count, inclusive) {
        var pluralized = count === 1 ? pluralize.singular(word2) : pluralize.plural(word2);
        return (inclusive ? count + " " : "") + pluralized;
      }
      pluralize.plural = replaceWord(irregularSingles, irregularPlurals, pluralRules);
      pluralize.isPlural = checkWord(irregularSingles, irregularPlurals, pluralRules);
      pluralize.singular = replaceWord(irregularPlurals, irregularSingles, singularRules);
      pluralize.isSingular = checkWord(irregularPlurals, irregularSingles, singularRules);
      pluralize.addPluralRule = function(rule, replacement) {
        pluralRules.push([sanitizeRule(rule), replacement]);
      };
      pluralize.addSingularRule = function(rule, replacement) {
        singularRules.push([sanitizeRule(rule), replacement]);
      };
      pluralize.addUncountableRule = function(word2) {
        if (typeof word2 === "string") {
          uncountables[word2.toLowerCase()] = true;
          return;
        }
        pluralize.addPluralRule(word2, "$0");
        pluralize.addSingularRule(word2, "$0");
      };
      pluralize.addIrregularRule = function(single, plural) {
        plural = plural.toLowerCase();
        single = single.toLowerCase();
        irregularSingles[single] = plural;
        irregularPlurals[plural] = single;
      };
      [
        ["I", "we"],
        ["me", "us"],
        ["he", "they"],
        ["she", "they"],
        ["them", "them"],
        ["myself", "ourselves"],
        ["yourself", "yourselves"],
        ["itself", "themselves"],
        ["herself", "themselves"],
        ["himself", "themselves"],
        ["themself", "themselves"],
        ["is", "are"],
        ["was", "were"],
        ["has", "have"],
        ["this", "these"],
        ["that", "those"],
        ["echo", "echoes"],
        ["dingo", "dingoes"],
        ["volcano", "volcanoes"],
        ["tornado", "tornadoes"],
        ["torpedo", "torpedoes"],
        ["genus", "genera"],
        ["viscus", "viscera"],
        ["stigma", "stigmata"],
        ["stoma", "stomata"],
        ["dogma", "dogmata"],
        ["lemma", "lemmata"],
        ["schema", "schemata"],
        ["anathema", "anathemata"],
        ["ox", "oxen"],
        ["axe", "axes"],
        ["die", "dice"],
        ["yes", "yeses"],
        ["foot", "feet"],
        ["eave", "eaves"],
        ["goose", "geese"],
        ["tooth", "teeth"],
        ["quiz", "quizzes"],
        ["human", "humans"],
        ["proof", "proofs"],
        ["carve", "carves"],
        ["valve", "valves"],
        ["looey", "looies"],
        ["thief", "thieves"],
        ["groove", "grooves"],
        ["pickaxe", "pickaxes"],
        ["passerby", "passersby"]
      ].forEach(function(rule) {
        return pluralize.addIrregularRule(rule[0], rule[1]);
      });
      [
        [/s?$/i, "s"],
        [/[^\u0000-\u007F]$/i, "$0"],
        [/([^aeiou]ese)$/i, "$1"],
        [/(ax|test)is$/i, "$1es"],
        [/(alias|[^aou]us|t[lm]as|gas|ris)$/i, "$1es"],
        [/(e[mn]u)s?$/i, "$1s"],
        [/([^l]ias|[aeiou]las|[ejzr]as|[iu]am)$/i, "$1"],
        [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1i"],
        [/(alumn|alg|vertebr)(?:a|ae)$/i, "$1ae"],
        [/(seraph|cherub)(?:im)?$/i, "$1im"],
        [/(her|at|gr)o$/i, "$1oes"],
        [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|automat|quor)(?:a|um)$/i, "$1a"],
        [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)(?:a|on)$/i, "$1a"],
        [/sis$/i, "ses"],
        [/(?:(kni|wi|li)fe|(ar|l|ea|eo|oa|hoo)f)$/i, "$1$2ves"],
        [/([^aeiouy]|qu)y$/i, "$1ies"],
        [/([^ch][ieo][ln])ey$/i, "$1ies"],
        [/(x|ch|ss|sh|zz)$/i, "$1es"],
        [/(matr|cod|mur|sil|vert|ind|append)(?:ix|ex)$/i, "$1ices"],
        [/\b((?:tit)?m|l)(?:ice|ouse)$/i, "$1ice"],
        [/(pe)(?:rson|ople)$/i, "$1ople"],
        [/(child)(?:ren)?$/i, "$1ren"],
        [/eaux$/i, "$0"],
        [/m[ae]n$/i, "men"],
        ["thou", "you"]
      ].forEach(function(rule) {
        return pluralize.addPluralRule(rule[0], rule[1]);
      });
      [
        [/s$/i, ""],
        [/(ss)$/i, "$1"],
        [/(wi|kni|(?:after|half|high|low|mid|non|night|[^\w]|^)li)ves$/i, "$1fe"],
        [/(ar|(?:wo|[ae])l|[eo][ao])ves$/i, "$1f"],
        [/ies$/i, "y"],
        [/\b([pl]|zomb|(?:neck|cross)?t|coll|faer|food|gen|goon|group|lass|talk|goal|cut)ies$/i, "$1ie"],
        [/\b(mon|smil)ies$/i, "$1ey"],
        [/\b((?:tit)?m|l)ice$/i, "$1ouse"],
        [/(seraph|cherub)im$/i, "$1"],
        [/(x|ch|ss|sh|zz|tto|go|cho|alias|[^aou]us|t[lm]as|gas|(?:her|at|gr)o|[aeiou]ris)(?:es)?$/i, "$1"],
        [/(analy|diagno|parenthe|progno|synop|the|empha|cri|ne)(?:sis|ses)$/i, "$1sis"],
        [/(movie|twelve|abuse|e[mn]u)s$/i, "$1"],
        [/(test)(?:is|es)$/i, "$1is"],
        [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1us"],
        [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|quor)a$/i, "$1um"],
        [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)a$/i, "$1on"],
        [/(alumn|alg|vertebr)ae$/i, "$1a"],
        [/(cod|mur|sil|vert|ind)ices$/i, "$1ex"],
        [/(matr|append)ices$/i, "$1ix"],
        [/(pe)(rson|ople)$/i, "$1rson"],
        [/(child)ren$/i, "$1"],
        [/(eau)x?$/i, "$1"],
        [/men$/i, "man"]
      ].forEach(function(rule) {
        return pluralize.addSingularRule(rule[0], rule[1]);
      });
      [
        "adulthood",
        "advice",
        "agenda",
        "aid",
        "aircraft",
        "alcohol",
        "ammo",
        "analytics",
        "anime",
        "athletics",
        "audio",
        "bison",
        "blood",
        "bream",
        "buffalo",
        "butter",
        "carp",
        "cash",
        "chassis",
        "chess",
        "clothing",
        "cod",
        "commerce",
        "cooperation",
        "corps",
        "debris",
        "diabetes",
        "digestion",
        "elk",
        "energy",
        "equipment",
        "excretion",
        "expertise",
        "firmware",
        "flounder",
        "fun",
        "gallows",
        "garbage",
        "graffiti",
        "hardware",
        "headquarters",
        "health",
        "herpes",
        "highjinks",
        "homework",
        "housework",
        "information",
        "jeans",
        "justice",
        "kudos",
        "labour",
        "literature",
        "machinery",
        "mackerel",
        "mail",
        "media",
        "mews",
        "moose",
        "music",
        "mud",
        "manga",
        "news",
        "only",
        "personnel",
        "pike",
        "plankton",
        "pliers",
        "police",
        "pollution",
        "premises",
        "rain",
        "research",
        "rice",
        "salmon",
        "scissors",
        "series",
        "sewage",
        "shambles",
        "shrimp",
        "software",
        "species",
        "staff",
        "swine",
        "tennis",
        "traffic",
        "transportation",
        "trout",
        "tuna",
        "wealth",
        "welfare",
        "whiting",
        "wildebeest",
        "wildlife",
        "you",
        /pok[e]mon$/i,
        /[^aeiou]ese$/i,
        /deer$/i,
        /fish$/i,
        /measles$/i,
        /o[iu]s$/i,
        /pox$/i,
        /sheep$/i
      ].forEach(pluralize.addUncountableRule);
      return pluralize;
    });
  }
});

// ../lib/store/dist/data-access/filesystem.js
var require_filesystem = __commonJS({
  "../lib/store/dist/data-access/filesystem.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getFilesystemWatcherFor = exports2.FilesystemStore = exports2.basedir = void 0;
    var path_1 = __importStar(require("path"));
    var fs_1 = require("fs");
    var pluralize_1 = require_pluralize();
    var ux_common_utils_1 = require_dist();
    exports2.basedir = ux_common_utils_1.getFioriToolsDirectory;
    var FilesystemStore = class {
      constructor(logger) {
        this.logger = logger;
      }
      async read({ entityName, id }) {
        const name = toPersistenceName(entityName);
        if (!name) {
          this.logger.debug("read: Entity Type is falsy - " + entityName);
          return Promise.resolve(void 0);
        }
        const { entities, error: error3 } = this._readAll(name);
        if (error3) {
          if (error3.code === "ENOENT") {
            return Promise.resolve(void 0);
          } else {
            throw error3;
          }
        }
        if (!entities) {
          this.logger.debug(`read: After parsing, entities is falsy. Entity: ${name}, parsed value: ${entities}`);
          return void 0;
        }
        return Promise.resolve(entities[id]);
      }
      async getAll({ entityName }) {
        const name = toPersistenceName(entityName);
        if (!name) {
          this.logger.debug("read: Entity Type is falsy - " + entityName);
          return Promise.resolve([]);
        }
        const { entities, error: error3 } = this._readAll(name);
        if (error3) {
          if (error3.code === "ENOENT") {
            return Promise.resolve([]);
          } else {
            throw error3;
          }
        }
        if (!entities) {
          this.logger.debug(`read: After parsing, entities is falsy. Entity: ${name}, parsed value: ${entities}`);
          return Promise.resolve([]);
        }
        return Promise.resolve(Object.values(entities));
      }
      async readAll({ entityName }) {
        const name = toPersistenceName(entityName);
        if (!name) {
          this.logger.debug("read: Entity Type is falsy - " + entityName);
          return Promise.resolve({});
        }
        const { entities, error: error3 } = this._readAll(name);
        if (error3) {
          if (error3.code === "ENOENT") {
            return Promise.resolve({});
          } else {
            throw error3;
          }
        }
        if (!entities) {
          this.logger.debug(`read: After parsing, entities is falsy. Entity: ${name}, parsed value: ${entities}`);
          return Promise.resolve({});
        }
        return Promise.resolve(entities);
      }
      async write({ entityName, id, entity }) {
        const name = toPersistenceName(entityName);
        if (!name) {
          this.logger.debug("write: Entity is falsy - " + name);
          return Promise.resolve(void 0);
        }
        const { entities = {}, error: error3 } = this._readAll(name);
        if (error3 && error3.code !== "ENOENT") {
          throw error3;
        }
        entities[id] = entity;
        this.writeToFile(name, entities);
        return Promise.resolve(entity);
      }
      async del({ entityName, id }) {
        const name = toPersistenceName(entityName);
        if (!name) {
          this.logger.debug("delete: Entity is falsy - " + name);
          return Promise.resolve(false);
        }
        const { entities = {}, error: error3 } = this._readAll(name);
        if (error3) {
          if (error3.code !== "ENOENT") {
            throw error3;
          }
        }
        const exists = !!entities[id];
        if (exists) {
          this.logger.debug(`delete: entity found  for id - ${id}. Deleting`);
          delete entities[id];
          this.writeToFile(name, entities);
          return Promise.resolve(true);
        } else {
          this.logger.debug("delete: entity not found");
          return Promise.resolve(false);
        }
      }
      _readAll(entityName) {
        var _a2, _b;
        let rawContents;
        try {
          rawContents = (_a2 = fs_1.readFileSync(path_1.join(exports2.basedir(), `${entityName}.json`))) == null ? void 0 : _a2.toString().trim();
        } catch (e) {
          this.logger.debug(e.message);
          return { error: e };
        }
        if (!rawContents) {
          return { entities: void 0 };
        }
        let entities = void 0;
        try {
          entities = (_b = JSON.parse(rawContents)) == null ? void 0 : _b[entityName];
        } catch (e) {
          return { error: e };
        }
        return { entities };
      }
      writeToFile(entityName, entities) {
        const base = exports2.basedir();
        const data2 = JSON.stringify({ [entityName]: entities }, null, 2);
        const filename = getEntityFileName(entityName);
        try {
          fs_1.writeFileSync(path_1.default.join(base, filename), data2);
        } catch (e) {
          if (e.code === "ENOENT") {
            this.logger.debug(`Base directory [${base}] does not exist, trying to create it`);
            fs_1.mkdirSync(base, { recursive: true });
            fs_1.writeFileSync(path_1.default.join(base, filename), data2);
          } else {
            throw e;
          }
        }
      }
    };
    exports2.FilesystemStore = FilesystemStore;
    function toPersistenceName(s) {
      const t = s == null ? void 0 : s.trim().toLowerCase();
      return t && pluralize_1.plural(t);
    }
    function getEntityFileName(entityName) {
      return toPersistenceName(entityName) + ".json";
    }
    function getFilesystemWatcherFor(entityName, callback) {
      const watchPath = path_1.default.join(exports2.basedir(), getEntityFileName(entityName));
      if (fs_1.existsSync(watchPath)) {
        return fs_1.watch(watchPath, void 0, () => {
          callback(entityName);
        });
      } else {
        console.warn(`File Not Found: ${watchPath}`);
      }
    }
    exports2.getFilesystemWatcherFor = getFilesystemWatcherFor;
  }
});

// ../lib/store/dist/secure-store/dummy-store.js
var require_dummy_store = __commonJS({
  "../lib/store/dist/secure-store/dummy-store.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DummyStore = void 0;
    var DummyStore = class {
      constructor(log4) {
        this.log = log4;
      }
      async save(service, key, value) {
        this.log.warn(`Dummy store. Trying to save for service: ${service}, key: ${key}, value type: ${typeof value}`);
        return Promise.resolve(true);
      }
      async retrieve(service, key) {
        this.log.warn(`Dummy store. Trying to retrieve for service: ${service}, key: ${key}`);
        return Promise.resolve(null);
      }
      async delete(service, key) {
        this.log.warn(`Dummy store. Trying to delete for service: ${service}, key: ${key}`);
        return Promise.resolve(true);
      }
      async getAll(service) {
        this.log.warn(`Dummy store. Trying to get all values for service: [${service}]`);
        return Promise.resolve({});
      }
    };
    exports2.DummyStore = DummyStore;
  }
});

// ../lib/store/dist/secure-store/keytar-store.js
var require_keytar_store = __commonJS({
  "../lib/store/dist/secure-store/keytar-store.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KeytarStore = void 0;
    var KeytarStore = class {
      constructor(log4, keytar) {
        this.log = log4;
        this.keytar = keytar;
      }
      async save(service, key, value) {
        try {
          const serialized = JSON.stringify(value);
          await this.keytar.setPassword(service, key, serialized);
          return true;
        } catch (e) {
          this.log.error(`Error saving to secure store. Service: [${service}], key: [${key}]`);
          this.log.error(e);
          return false;
        }
      }
      async retrieve(service, key) {
        try {
          const serializedValue = await this.keytar.getPassword(service, key);
          return JSON.parse(serializedValue);
        } catch (e) {
          this.log.error(`Error retrieving from secure store. Service: [${service}], key: [${key}]`);
          this.log.error(e);
          return null;
        }
      }
      async delete(service, key) {
        try {
          return await this.keytar.deletePassword(service, key);
        } catch (e) {
          this.log.error(`Error deleting from secure store. Service: [${service}], key: [${key}]`);
          this.log.error(e);
          return false;
        }
      }
      async getAll(service) {
        try {
          return (await this.keytar.findCredentials(service)).reduce((result2, entry) => {
            try {
              result2[entry.account] = JSON.parse(entry.password);
            } catch (e) {
              this.log.error(`Error parsing credentials for [${entry.account}]`);
            }
            return result2;
          }, {});
        } catch (e) {
          this.log.error(`Error getting values for service: [${service}]`);
          this.log.error(e);
          return {};
        }
      }
    };
    exports2.KeytarStore = KeytarStore;
  }
});

// ../lib/store/dist/secure-store/types.js
var require_types = __commonJS({
  "../lib/store/dist/secure-store/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../lib/store/dist/secure-store/index.js
var require_secure_store = __commonJS({
  "../lib/store/dist/secure-store/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getSecureStore = void 0;
    var ux_common_utils_1 = require_dist();
    var dummy_store_1 = require_dummy_store();
    var keytar_store_1 = require_keytar_store();
    function getKeytar(log4) {
      var _a2, _b;
      try {
        return require("keytar");
      } catch (e) {
        log4.warn(e);
        log4.warn(`Could not "require('keytar')". Trying VSCode's copy`);
        let vscode;
        try {
          vscode = require("vscode");
        } catch (e2) {
          log4.warn(e2);
          log4.warn("Could not get hold of vscode");
          return null;
        }
        try {
          return require(`${(_a2 = vscode == null ? void 0 : vscode.env) == null ? void 0 : _a2.appRoot}/node_modules.asar/keytar`);
        } catch (e2) {
          log4.warn(e2);
          log4.warn("Could not get keytar from vscode node_modules.asar");
        }
        try {
          return require(`${(_b = vscode == null ? void 0 : vscode.env) == null ? void 0 : _b.appRoot}/node_modules/keytar`);
        } catch (e2) {
          log4.warn(e2);
          log4.warn("Could not get keytar from vscode node_modules");
        }
        return null;
      }
    }
    var getSecureStore = (log4) => {
      if (ux_common_utils_1.isAppStudio() || process.env.UX_TOOLS_DISABLE_KEYSTORE) {
        return new dummy_store_1.DummyStore(log4);
      } else {
        const keytar = getKeytar(log4);
        return keytar ? new keytar_store_1.KeytarStore(log4, keytar) : new dummy_store_1.DummyStore(log4);
      }
    };
    exports2.getSecureStore = getSecureStore;
    __exportStar(require_types(), exports2);
  }
});

// ../../node_modules/reflect-metadata/Reflect.js
var require_Reflect = __commonJS({
  "../../node_modules/reflect-metadata/Reflect.js"() {
    var Reflect2;
    (function(Reflect3) {
      (function(factory) {
        var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : Function("return this;")();
        var exporter = makeExporter(Reflect3);
        if (typeof root.Reflect === "undefined") {
          root.Reflect = Reflect3;
        } else {
          exporter = makeExporter(root.Reflect, exporter);
        }
        factory(exporter);
        function makeExporter(target, previous) {
          return function(key, value) {
            if (typeof target[key] !== "function") {
              Object.defineProperty(target, key, { configurable: true, writable: true, value });
            }
            if (previous)
              previous(key, value);
          };
        }
      })(function(exporter) {
        var hasOwn = Object.prototype.hasOwnProperty;
        var supportsSymbol = typeof Symbol === "function";
        var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
        var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
        var supportsCreate = typeof Object.create === "function";
        var supportsProto = { __proto__: [] } instanceof Array;
        var downLevel = !supportsCreate && !supportsProto;
        var HashMap = {
          create: supportsCreate ? function() {
            return MakeDictionary(/* @__PURE__ */ Object.create(null));
          } : supportsProto ? function() {
            return MakeDictionary({ __proto__: null });
          } : function() {
            return MakeDictionary({});
          },
          has: downLevel ? function(map, key) {
            return hasOwn.call(map, key);
          } : function(map, key) {
            return key in map;
          },
          get: downLevel ? function(map, key) {
            return hasOwn.call(map, key) ? map[key] : void 0;
          } : function(map, key) {
            return map[key];
          }
        };
        var functionPrototype = Object.getPrototypeOf(Function);
        var usePolyfill = typeof process === "object" && process.env && process.env["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
        var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
        var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
        var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
        var Metadata = new _WeakMap();
        function decorate(decorators, target, propertyKey, attributes) {
          if (!IsUndefined(propertyKey)) {
            if (!IsArray(decorators))
              throw new TypeError();
            if (!IsObject(target))
              throw new TypeError();
            if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
              throw new TypeError();
            if (IsNull(attributes))
              attributes = void 0;
            propertyKey = ToPropertyKey(propertyKey);
            return DecorateProperty(decorators, target, propertyKey, attributes);
          } else {
            if (!IsArray(decorators))
              throw new TypeError();
            if (!IsConstructor(target))
              throw new TypeError();
            return DecorateConstructor(decorators, target);
          }
        }
        exporter("decorate", decorate);
        function metadata(metadataKey, metadataValue) {
          function decorator(target, propertyKey) {
            if (!IsObject(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
              throw new TypeError();
            OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
          }
          return decorator;
        }
        exporter("metadata", metadata);
        function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        exporter("defineMetadata", defineMetadata);
        function hasMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryHasMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasMetadata", hasMetadata);
        function hasOwnMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasOwnMetadata", hasOwnMetadata);
        function getMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryGetMetadata(metadataKey, target, propertyKey);
        }
        exporter("getMetadata", getMetadata);
        function getOwnMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("getOwnMetadata", getOwnMetadata);
        function getMetadataKeys(target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryMetadataKeys(target, propertyKey);
        }
        exporter("getMetadataKeys", getMetadataKeys);
        function getOwnMetadataKeys(target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryOwnMetadataKeys(target, propertyKey);
        }
        exporter("getOwnMetadataKeys", getOwnMetadataKeys);
        function deleteMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          var metadataMap = GetOrCreateMetadataMap(target, propertyKey, false);
          if (IsUndefined(metadataMap))
            return false;
          if (!metadataMap.delete(metadataKey))
            return false;
          if (metadataMap.size > 0)
            return true;
          var targetMetadata = Metadata.get(target);
          targetMetadata.delete(propertyKey);
          if (targetMetadata.size > 0)
            return true;
          Metadata.delete(target);
          return true;
        }
        exporter("deleteMetadata", deleteMetadata);
        function DecorateConstructor(decorators, target) {
          for (var i = decorators.length - 1; i >= 0; --i) {
            var decorator = decorators[i];
            var decorated = decorator(target);
            if (!IsUndefined(decorated) && !IsNull(decorated)) {
              if (!IsConstructor(decorated))
                throw new TypeError();
              target = decorated;
            }
          }
          return target;
        }
        function DecorateProperty(decorators, target, propertyKey, descriptor) {
          for (var i = decorators.length - 1; i >= 0; --i) {
            var decorator = decorators[i];
            var decorated = decorator(target, propertyKey, descriptor);
            if (!IsUndefined(decorated) && !IsNull(decorated)) {
              if (!IsObject(decorated))
                throw new TypeError();
              descriptor = decorated;
            }
          }
          return descriptor;
        }
        function GetOrCreateMetadataMap(O, P, Create) {
          var targetMetadata = Metadata.get(O);
          if (IsUndefined(targetMetadata)) {
            if (!Create)
              return void 0;
            targetMetadata = new _Map();
            Metadata.set(O, targetMetadata);
          }
          var metadataMap = targetMetadata.get(P);
          if (IsUndefined(metadataMap)) {
            if (!Create)
              return void 0;
            metadataMap = new _Map();
            targetMetadata.set(P, metadataMap);
          }
          return metadataMap;
        }
        function OrdinaryHasMetadata(MetadataKey, O, P) {
          var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
          if (hasOwn2)
            return true;
          var parent = OrdinaryGetPrototypeOf(O);
          if (!IsNull(parent))
            return OrdinaryHasMetadata(MetadataKey, parent, P);
          return false;
        }
        function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
          var metadataMap = GetOrCreateMetadataMap(O, P, false);
          if (IsUndefined(metadataMap))
            return false;
          return ToBoolean(metadataMap.has(MetadataKey));
        }
        function OrdinaryGetMetadata(MetadataKey, O, P) {
          var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
          if (hasOwn2)
            return OrdinaryGetOwnMetadata(MetadataKey, O, P);
          var parent = OrdinaryGetPrototypeOf(O);
          if (!IsNull(parent))
            return OrdinaryGetMetadata(MetadataKey, parent, P);
          return void 0;
        }
        function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
          var metadataMap = GetOrCreateMetadataMap(O, P, false);
          if (IsUndefined(metadataMap))
            return void 0;
          return metadataMap.get(MetadataKey);
        }
        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
          var metadataMap = GetOrCreateMetadataMap(O, P, true);
          metadataMap.set(MetadataKey, MetadataValue);
        }
        function OrdinaryMetadataKeys(O, P) {
          var ownKeys = OrdinaryOwnMetadataKeys(O, P);
          var parent = OrdinaryGetPrototypeOf(O);
          if (parent === null)
            return ownKeys;
          var parentKeys = OrdinaryMetadataKeys(parent, P);
          if (parentKeys.length <= 0)
            return ownKeys;
          if (ownKeys.length <= 0)
            return parentKeys;
          var set = new _Set();
          var keys = [];
          for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
            var key = ownKeys_1[_i];
            var hasKey = set.has(key);
            if (!hasKey) {
              set.add(key);
              keys.push(key);
            }
          }
          for (var _a2 = 0, parentKeys_1 = parentKeys; _a2 < parentKeys_1.length; _a2++) {
            var key = parentKeys_1[_a2];
            var hasKey = set.has(key);
            if (!hasKey) {
              set.add(key);
              keys.push(key);
            }
          }
          return keys;
        }
        function OrdinaryOwnMetadataKeys(O, P) {
          var keys = [];
          var metadataMap = GetOrCreateMetadataMap(O, P, false);
          if (IsUndefined(metadataMap))
            return keys;
          var keysObj = metadataMap.keys();
          var iterator = GetIterator(keysObj);
          var k = 0;
          while (true) {
            var next = IteratorStep(iterator);
            if (!next) {
              keys.length = k;
              return keys;
            }
            var nextValue = IteratorValue(next);
            try {
              keys[k] = nextValue;
            } catch (e) {
              try {
                IteratorClose(iterator);
              } finally {
                throw e;
              }
            }
            k++;
          }
        }
        function Type(x) {
          if (x === null)
            return 1;
          switch (typeof x) {
            case "undefined":
              return 0;
            case "boolean":
              return 2;
            case "string":
              return 3;
            case "symbol":
              return 4;
            case "number":
              return 5;
            case "object":
              return x === null ? 1 : 6;
            default:
              return 6;
          }
        }
        function IsUndefined(x) {
          return x === void 0;
        }
        function IsNull(x) {
          return x === null;
        }
        function IsSymbol(x) {
          return typeof x === "symbol";
        }
        function IsObject(x) {
          return typeof x === "object" ? x !== null : typeof x === "function";
        }
        function ToPrimitive(input, PreferredType) {
          switch (Type(input)) {
            case 0:
              return input;
            case 1:
              return input;
            case 2:
              return input;
            case 3:
              return input;
            case 4:
              return input;
            case 5:
              return input;
          }
          var hint = PreferredType === 3 ? "string" : PreferredType === 5 ? "number" : "default";
          var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
          if (exoticToPrim !== void 0) {
            var result2 = exoticToPrim.call(input, hint);
            if (IsObject(result2))
              throw new TypeError();
            return result2;
          }
          return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
        }
        function OrdinaryToPrimitive(O, hint) {
          if (hint === "string") {
            var toString_1 = O.toString;
            if (IsCallable(toString_1)) {
              var result2 = toString_1.call(O);
              if (!IsObject(result2))
                return result2;
            }
            var valueOf = O.valueOf;
            if (IsCallable(valueOf)) {
              var result2 = valueOf.call(O);
              if (!IsObject(result2))
                return result2;
            }
          } else {
            var valueOf = O.valueOf;
            if (IsCallable(valueOf)) {
              var result2 = valueOf.call(O);
              if (!IsObject(result2))
                return result2;
            }
            var toString_2 = O.toString;
            if (IsCallable(toString_2)) {
              var result2 = toString_2.call(O);
              if (!IsObject(result2))
                return result2;
            }
          }
          throw new TypeError();
        }
        function ToBoolean(argument) {
          return !!argument;
        }
        function ToString(argument) {
          return "" + argument;
        }
        function ToPropertyKey(argument) {
          var key = ToPrimitive(argument, 3);
          if (IsSymbol(key))
            return key;
          return ToString(key);
        }
        function IsArray(argument) {
          return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : Object.prototype.toString.call(argument) === "[object Array]";
        }
        function IsCallable(argument) {
          return typeof argument === "function";
        }
        function IsConstructor(argument) {
          return typeof argument === "function";
        }
        function IsPropertyKey(argument) {
          switch (Type(argument)) {
            case 3:
              return true;
            case 4:
              return true;
            default:
              return false;
          }
        }
        function GetMethod(V, P) {
          var func = V[P];
          if (func === void 0 || func === null)
            return void 0;
          if (!IsCallable(func))
            throw new TypeError();
          return func;
        }
        function GetIterator(obj) {
          var method = GetMethod(obj, iteratorSymbol);
          if (!IsCallable(method))
            throw new TypeError();
          var iterator = method.call(obj);
          if (!IsObject(iterator))
            throw new TypeError();
          return iterator;
        }
        function IteratorValue(iterResult) {
          return iterResult.value;
        }
        function IteratorStep(iterator) {
          var result2 = iterator.next();
          return result2.done ? false : result2;
        }
        function IteratorClose(iterator) {
          var f = iterator["return"];
          if (f)
            f.call(iterator);
        }
        function OrdinaryGetPrototypeOf(O) {
          var proto = Object.getPrototypeOf(O);
          if (typeof O !== "function" || O === functionPrototype)
            return proto;
          if (proto !== functionPrototype)
            return proto;
          var prototype = O.prototype;
          var prototypeProto = prototype && Object.getPrototypeOf(prototype);
          if (prototypeProto == null || prototypeProto === Object.prototype)
            return proto;
          var constructor = prototypeProto.constructor;
          if (typeof constructor !== "function")
            return proto;
          if (constructor === O)
            return proto;
          return constructor;
        }
        function CreateMapPolyfill() {
          var cacheSentinel = {};
          var arraySentinel = [];
          var MapIterator = function() {
            function MapIterator2(keys, values, selector) {
              this._index = 0;
              this._keys = keys;
              this._values = values;
              this._selector = selector;
            }
            MapIterator2.prototype["@@iterator"] = function() {
              return this;
            };
            MapIterator2.prototype[iteratorSymbol] = function() {
              return this;
            };
            MapIterator2.prototype.next = function() {
              var index = this._index;
              if (index >= 0 && index < this._keys.length) {
                var result2 = this._selector(this._keys[index], this._values[index]);
                if (index + 1 >= this._keys.length) {
                  this._index = -1;
                  this._keys = arraySentinel;
                  this._values = arraySentinel;
                } else {
                  this._index++;
                }
                return { value: result2, done: false };
              }
              return { value: void 0, done: true };
            };
            MapIterator2.prototype.throw = function(error3) {
              if (this._index >= 0) {
                this._index = -1;
                this._keys = arraySentinel;
                this._values = arraySentinel;
              }
              throw error3;
            };
            MapIterator2.prototype.return = function(value) {
              if (this._index >= 0) {
                this._index = -1;
                this._keys = arraySentinel;
                this._values = arraySentinel;
              }
              return { value, done: true };
            };
            return MapIterator2;
          }();
          return function() {
            function Map2() {
              this._keys = [];
              this._values = [];
              this._cacheKey = cacheSentinel;
              this._cacheIndex = -2;
            }
            Object.defineProperty(Map2.prototype, "size", {
              get: function() {
                return this._keys.length;
              },
              enumerable: true,
              configurable: true
            });
            Map2.prototype.has = function(key) {
              return this._find(key, false) >= 0;
            };
            Map2.prototype.get = function(key) {
              var index = this._find(key, false);
              return index >= 0 ? this._values[index] : void 0;
            };
            Map2.prototype.set = function(key, value) {
              var index = this._find(key, true);
              this._values[index] = value;
              return this;
            };
            Map2.prototype.delete = function(key) {
              var index = this._find(key, false);
              if (index >= 0) {
                var size = this._keys.length;
                for (var i = index + 1; i < size; i++) {
                  this._keys[i - 1] = this._keys[i];
                  this._values[i - 1] = this._values[i];
                }
                this._keys.length--;
                this._values.length--;
                if (key === this._cacheKey) {
                  this._cacheKey = cacheSentinel;
                  this._cacheIndex = -2;
                }
                return true;
              }
              return false;
            };
            Map2.prototype.clear = function() {
              this._keys.length = 0;
              this._values.length = 0;
              this._cacheKey = cacheSentinel;
              this._cacheIndex = -2;
            };
            Map2.prototype.keys = function() {
              return new MapIterator(this._keys, this._values, getKey);
            };
            Map2.prototype.values = function() {
              return new MapIterator(this._keys, this._values, getValue);
            };
            Map2.prototype.entries = function() {
              return new MapIterator(this._keys, this._values, getEntry);
            };
            Map2.prototype["@@iterator"] = function() {
              return this.entries();
            };
            Map2.prototype[iteratorSymbol] = function() {
              return this.entries();
            };
            Map2.prototype._find = function(key, insert) {
              if (this._cacheKey !== key) {
                this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
              }
              if (this._cacheIndex < 0 && insert) {
                this._cacheIndex = this._keys.length;
                this._keys.push(key);
                this._values.push(void 0);
              }
              return this._cacheIndex;
            };
            return Map2;
          }();
          function getKey(key, _45) {
            return key;
          }
          function getValue(_45, value) {
            return value;
          }
          function getEntry(key, value) {
            return [key, value];
          }
        }
        function CreateSetPolyfill() {
          return function() {
            function Set2() {
              this._map = new _Map();
            }
            Object.defineProperty(Set2.prototype, "size", {
              get: function() {
                return this._map.size;
              },
              enumerable: true,
              configurable: true
            });
            Set2.prototype.has = function(value) {
              return this._map.has(value);
            };
            Set2.prototype.add = function(value) {
              return this._map.set(value, value), this;
            };
            Set2.prototype.delete = function(value) {
              return this._map.delete(value);
            };
            Set2.prototype.clear = function() {
              this._map.clear();
            };
            Set2.prototype.keys = function() {
              return this._map.keys();
            };
            Set2.prototype.values = function() {
              return this._map.values();
            };
            Set2.prototype.entries = function() {
              return this._map.entries();
            };
            Set2.prototype["@@iterator"] = function() {
              return this.keys();
            };
            Set2.prototype[iteratorSymbol] = function() {
              return this.keys();
            };
            return Set2;
          }();
        }
        function CreateWeakMapPolyfill() {
          var UUID_SIZE = 16;
          var keys = HashMap.create();
          var rootKey = CreateUniqueKey();
          return function() {
            function WeakMap2() {
              this._key = CreateUniqueKey();
            }
            WeakMap2.prototype.has = function(target) {
              var table = GetOrCreateWeakMapTable(target, false);
              return table !== void 0 ? HashMap.has(table, this._key) : false;
            };
            WeakMap2.prototype.get = function(target) {
              var table = GetOrCreateWeakMapTable(target, false);
              return table !== void 0 ? HashMap.get(table, this._key) : void 0;
            };
            WeakMap2.prototype.set = function(target, value) {
              var table = GetOrCreateWeakMapTable(target, true);
              table[this._key] = value;
              return this;
            };
            WeakMap2.prototype.delete = function(target) {
              var table = GetOrCreateWeakMapTable(target, false);
              return table !== void 0 ? delete table[this._key] : false;
            };
            WeakMap2.prototype.clear = function() {
              this._key = CreateUniqueKey();
            };
            return WeakMap2;
          }();
          function CreateUniqueKey() {
            var key;
            do
              key = "@@WeakMap@@" + CreateUUID();
            while (HashMap.has(keys, key));
            keys[key] = true;
            return key;
          }
          function GetOrCreateWeakMapTable(target, create) {
            if (!hasOwn.call(target, rootKey)) {
              if (!create)
                return void 0;
              Object.defineProperty(target, rootKey, { value: HashMap.create() });
            }
            return target[rootKey];
          }
          function FillRandomBytes(buffer, size) {
            for (var i = 0; i < size; ++i)
              buffer[i] = Math.random() * 255 | 0;
            return buffer;
          }
          function GenRandomBytes(size) {
            if (typeof Uint8Array === "function") {
              if (typeof crypto !== "undefined")
                return crypto.getRandomValues(new Uint8Array(size));
              if (typeof msCrypto !== "undefined")
                return msCrypto.getRandomValues(new Uint8Array(size));
              return FillRandomBytes(new Uint8Array(size), size);
            }
            return FillRandomBytes(new Array(size), size);
          }
          function CreateUUID() {
            var data2 = GenRandomBytes(UUID_SIZE);
            data2[6] = data2[6] & 79 | 64;
            data2[8] = data2[8] & 191 | 128;
            var result2 = "";
            for (var offset = 0; offset < UUID_SIZE; ++offset) {
              var byte = data2[offset];
              if (offset === 4 || offset === 6 || offset === 8)
                result2 += "-";
              if (byte < 16)
                result2 += "0";
              result2 += byte.toString(16).toLowerCase();
            }
            return result2;
          }
        }
        function MakeDictionary(obj) {
          obj.__ = void 0;
          delete obj.__;
          return obj;
        }
      });
    })(Reflect2 || (Reflect2 = {}));
  }
});

// ../lib/store/dist/decorators/index.js
var require_decorators = __commonJS({
  "../lib/store/dist/decorators/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getSensitiveDataProperties = exports2.sensitiveData = exports2.getSerializableProperties = exports2.serializable = void 0;
    require_Reflect();
    var SERIALIZABLE = Symbol("serializable");
    function serializable(target, key) {
      const serializableProperties = Reflect.getOwnMetadata(SERIALIZABLE, target.constructor) || /* @__PURE__ */ new Set();
      Reflect.defineMetadata(SERIALIZABLE, serializableProperties.add(key), target.constructor);
    }
    exports2.serializable = serializable;
    function getSerializableProperties(target) {
      const props = Reflect.getOwnMetadata(SERIALIZABLE, target.constructor);
      return props && Array.from(props.values()) || [];
    }
    exports2.getSerializableProperties = getSerializableProperties;
    var SENSITIVE = Symbol("sensitive");
    function sensitiveData(target, key) {
      const sensitiveProperties = Reflect.getOwnMetadata(SENSITIVE, target.constructor) || /* @__PURE__ */ new Set();
      Reflect.defineMetadata(SENSITIVE, sensitiveProperties.add(key), target.constructor);
    }
    exports2.sensitiveData = sensitiveData;
    function getSensitiveDataProperties(target) {
      const props = Reflect.getOwnMetadata(SENSITIVE, target.constructor);
      return props && Array.from(props.values()) || [];
    }
    exports2.getSensitiveDataProperties = getSensitiveDataProperties;
  }
});

// ../lib/store/dist/data-access/hybrid.js
var require_hybrid = __commonJS({
  "../lib/store/dist/data-access/hybrid.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HybridStore = void 0;
    var filesystem_1 = require_filesystem();
    var utils_1 = require_utils3();
    var secure_store_1 = require_secure_store();
    var decorators_1 = require_decorators();
    function getFullyQualifiedServiceName(name) {
      return "fiori/v2/" + name;
    }
    var HybridStore = class {
      constructor(logger) {
        this.logger = logger;
        this.filesystem = new filesystem_1.FilesystemStore(this.logger);
        this.secureStore = secure_store_1.getSecureStore(this.logger);
      }
      async read({ entityName, id }) {
        const serialized = await this.filesystem.read({ entityName, id });
        if (!serialized) {
          this.logger.debug(`hybrid/read - id: [${id}], nothing on the filesystem`);
        } else {
          this.logger.debug("hybrid/read - id: [%s], filesystem: %O", id, serialized);
        }
        const sensitiveData = await this.secureStore.retrieve(getFullyQualifiedServiceName(entityName), id);
        if (!sensitiveData) {
          this.logger.debug(`hybrid/read - id: [${id}], nothing in the secure store`);
        } else {
          this.logger.debug(`hybrid/read - id: [${id}]. Found sensitive data in secure store`);
        }
        if (serialized || sensitiveData) {
          return { ...serialized, ...sensitiveData };
        } else {
          return void 0;
        }
      }
      async getAll({ entityName }) {
        return Object.values(await this.readAll({ entityName }));
      }
      async readAll({ entityName }) {
        const result2 = {};
        const entitiesFs = await this.filesystem.readAll({ entityName }) || {};
        const entitiesInSecureStore = await this.secureStore.getAll(getFullyQualifiedServiceName(entityName)) || {};
        for (const key of /* @__PURE__ */ new Set([...Object.keys(entitiesFs), ...Object.keys(entitiesInSecureStore)])) {
          const entity = { ...entitiesFs[key], ...entitiesInSecureStore[key] };
          result2[key] = entity;
        }
        return result2;
      }
      async write({ entityName, id, entity }) {
        const serializableProps = decorators_1.getSerializableProperties(entity);
        const sensitiveProps = decorators_1.getSensitiveDataProperties(entity);
        if (serializableProps.length > 0 && sensitiveProps.length > 0) {
          for (let i = 0; i < serializableProps.length; i = i + 1) {
            if (sensitiveProps.indexOf(serializableProps[i]) !== -1) {
              this.logger.debug(`hybrid/write - [${serializableProps[i]}] is also marked as sensitive. Not writing to filesystem`);
              serializableProps.splice(i, 1);
            }
          }
        }
        const serializable = utils_1.pick(entity, ...serializableProps);
        if (serializable) {
          this.logger.debug("hybrid/write - writing serializable properties: %O", serializable);
          await this.filesystem.write({ entityName, id, entity: serializable });
        } else {
          this.logger.debug("hybrid/write - no serializable properties found in %O", serializable);
        }
        const sensitiveData = utils_1.pick(entity, ...sensitiveProps);
        if (sensitiveData) {
          this.logger.debug(`hybrid/write - writing sensitive properties to secure store. ID: [${id}]`);
          await this.secureStore.save(getFullyQualifiedServiceName(entityName), id, sensitiveData);
        } else {
          this.logger.debug("hybrid/write - no sensitive properties found in %O", entity);
        }
        return entity;
      }
      async del({ entityName, id }) {
        const deletedinFs = await this.filesystem.del({ entityName, id });
        this.logger.debug(`hybrid/del - delete result for id [${id}] on the filesystem: ${deletedinFs}`);
        const deletedInSecureStore = await this.secureStore.delete(getFullyQualifiedServiceName(entityName), id);
        this.logger.debug(`hybrid/del - delete result for id [${id}] in the secure store: ${deletedInSecureStore}`);
        return deletedinFs || deletedInSecureStore;
      }
    };
    exports2.HybridStore = HybridStore;
  }
});

// ../lib/store/dist/entities/backend-system.js
var require_backend_system = __commonJS({
  "../lib/store/dist/entities/backend-system.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BackendSystem = exports2.BackendSystemKey = exports2.AuthenticationType = void 0;
    var decorators_1 = require_decorators();
    var AuthenticationType;
    (function(AuthenticationType2) {
      AuthenticationType2["Basic"] = "basic";
      AuthenticationType2["ReentranceTicket"] = "reentranceTicket";
      AuthenticationType2["OAuth2RefreshToken"] = "oauth2";
      AuthenticationType2["OAuth2ClientCredential"] = "oauth2ClientCredential";
    })(AuthenticationType = exports2.AuthenticationType || (exports2.AuthenticationType = {}));
    var BackendSystemKey = class {
      constructor({ url, client }) {
        this.url = url.trim().replace(/\/$/, "");
        this.client = client == null ? void 0 : client.trim();
      }
      static from(system) {
        return new BackendSystemKey({ url: system.url, client: system.client });
      }
      getId() {
        return this.url + `${this.client ? "/" + this.client : ""}`;
      }
    };
    exports2.BackendSystemKey = BackendSystemKey;
    var BackendSystem = class {
      constructor({ name, url, client, serviceKeys, refreshToken, username, password, userDisplayName, authenticationType, csrfToken, cookieString }) {
        this.name = name;
        this.url = url;
        this.client = client;
        this.serviceKeys = serviceKeys;
        this.refreshToken = refreshToken;
        this.username = username;
        this.password = password;
        this.userDisplayName = userDisplayName;
        this.authenticationType = authenticationType;
        this.csrfToken = csrfToken;
        this.cookieString = cookieString;
      }
    };
    __decorate([
      decorators_1.serializable
    ], BackendSystem.prototype, "name", void 0);
    __decorate([
      decorators_1.serializable
    ], BackendSystem.prototype, "url", void 0);
    __decorate([
      decorators_1.serializable
    ], BackendSystem.prototype, "client", void 0);
    __decorate([
      decorators_1.serializable
    ], BackendSystem.prototype, "userDisplayName", void 0);
    __decorate([
      decorators_1.sensitiveData
    ], BackendSystem.prototype, "serviceKeys", void 0);
    __decorate([
      decorators_1.sensitiveData
    ], BackendSystem.prototype, "refreshToken", void 0);
    __decorate([
      decorators_1.sensitiveData
    ], BackendSystem.prototype, "username", void 0);
    __decorate([
      decorators_1.sensitiveData
    ], BackendSystem.prototype, "password", void 0);
    __decorate([
      decorators_1.sensitiveData
    ], BackendSystem.prototype, "authenticationType", void 0);
    __decorate([
      decorators_1.sensitiveData
    ], BackendSystem.prototype, "csrfToken", void 0);
    __decorate([
      decorators_1.sensitiveData
    ], BackendSystem.prototype, "cookieString", void 0);
    exports2.BackendSystem = BackendSystem;
  }
});

// ../lib/store/dist/data-provider/constants.js
var require_constants3 = __commonJS({
  "../lib/store/dist/data-provider/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Entities = void 0;
    var Entities;
    (function(Entities2) {
      Entities2["BackendSystem"] = "system";
      Entities2["SystemMigrationStatus"] = "systemMigrationStatus";
    })(Entities = exports2.Entities || (exports2.Entities = {}));
  }
});

// ../lib/store/dist/data-provider/backend-system.js
var require_backend_system2 = __commonJS({
  "../lib/store/dist/data-provider/backend-system.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SystemDataProvider = void 0;
    var hybrid_1 = require_hybrid();
    var backend_system_1 = require_backend_system();
    var constants_1 = require_constants3();
    var SystemDataProvider = class {
      constructor(logger) {
        this.entityName = constants_1.Entities.BackendSystem;
        this.logger = logger;
        this.dataAccessor = new hybrid_1.HybridStore(this.logger);
      }
      async read(key) {
        return this.dataAccessor.read({ entityName: this.entityName, id: key.getId() });
      }
      async write(entity) {
        let e;
        if (!(entity instanceof backend_system_1.BackendSystem)) {
          e = new backend_system_1.BackendSystem({ ...entity });
        } else {
          e = entity;
        }
        return this.dataAccessor.write({
          entityName: this.entityName,
          id: backend_system_1.BackendSystemKey.from(entity).getId(),
          entity: e
        });
      }
      async delete(entity) {
        return this.dataAccessor.del({
          entityName: this.entityName,
          id: backend_system_1.BackendSystemKey.from(entity).getId()
        });
      }
      async getAll() {
        var _a2;
        const systems = await this.dataAccessor.readAll({ entityName: this.entityName });
        for (const id of Object.keys(systems)) {
          const system = systems[id];
          if (!((_a2 = system == null ? void 0 : system.url) == null ? void 0 : _a2.trim())) {
            this.logger.warn(`Filtering system with ID [${id}] as it seems corrupt. Run repair`);
            delete systems[id];
          }
        }
        return Object.values(systems);
      }
    };
    exports2.SystemDataProvider = SystemDataProvider;
  }
});

// ../lib/store/dist/entities/system-migration-status.js
var require_system_migration_status = __commonJS({
  "../lib/store/dist/entities/system-migration-status.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SystemMigrationStatusKey = exports2.SystemMigrationStatus = void 0;
    var decorators_1 = require_decorators();
    var SystemMigrationStatus = class {
      constructor({ authTypeMigrated, migrationDone, migrationLogs }) {
        this.migrationDone = migrationDone;
        this.authTypeMigrated = authTypeMigrated;
        this.migrationLogs = migrationLogs;
      }
    };
    __decorate([
      decorators_1.serializable
    ], SystemMigrationStatus.prototype, "migrationDone", void 0);
    __decorate([
      decorators_1.serializable
    ], SystemMigrationStatus.prototype, "authTypeMigrated", void 0);
    __decorate([
      decorators_1.serializable
    ], SystemMigrationStatus.prototype, "migrationLogs", void 0);
    exports2.SystemMigrationStatus = SystemMigrationStatus;
    var SystemMigrationStatusKey = class {
      getId() {
        return "systemMigration";
      }
    };
    exports2.SystemMigrationStatusKey = SystemMigrationStatusKey;
  }
});

// ../lib/store/dist/data-provider/system-migration.js
var require_system_migration = __commonJS({
  "../lib/store/dist/data-provider/system-migration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SystemMigrationStatusDataProvider = void 0;
    var filesystem_1 = require_filesystem();
    var system_migration_status_1 = require_system_migration_status();
    var constants_1 = require_constants3();
    var SystemMigrationStatusDataProvider = class {
      constructor(logger) {
        this.entityName = constants_1.Entities.SystemMigrationStatus;
        this.logger = logger;
        this.dataAccessor = new filesystem_1.FilesystemStore(this.logger);
      }
      read(key) {
        return this.dataAccessor.read({ entityName: this.entityName, id: key.getId() });
      }
      write(entity) {
        return this.dataAccessor.write({
          entityName: this.entityName,
          id: new system_migration_status_1.SystemMigrationStatusKey().getId(),
          entity
        });
      }
      delete(_entity) {
        return this.dataAccessor.del({
          entityName: this.entityName,
          id: new system_migration_status_1.SystemMigrationStatusKey().getId()
        });
      }
      getAll() {
        return this.dataAccessor.getAll({ entityName: this.entityName });
      }
    };
    exports2.SystemMigrationStatusDataProvider = SystemMigrationStatusDataProvider;
  }
});

// ../lib/store/dist/services/system-migration.js
var require_system_migration2 = __commonJS({
  "../lib/store/dist/services/system-migration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.migrate = void 0;
    var contants_1 = require_contants();
    var system_migration_1 = require_system_migration();
    var backend_system_1 = require_backend_system();
    var system_migration_status_1 = require_system_migration_status();
    var i18n_1 = require_i18n3();
    var secure_store_1 = require_secure_store();
    var utils_1 = require_utils3();
    var Migration = class {
      constructor({ logger, secureStore, systemMigrationStatus, systemDataProvider }) {
        this.cache = {};
        this.logger = logger;
        this.secureStore = secureStore;
        this.systemMigrationStatus = systemMigrationStatus;
        this.systemDataProvider = systemDataProvider;
      }
      async run() {
        let dirty = false;
        let migrationDone = this.systemMigrationStatus.migrationDone;
        if (!this.systemMigrationStatus.migrationDone) {
          this.logger.info(new Date(Date.now()).toString());
          await this.migrateFromPureSecureStore();
          await this.migrateRefreshTokens();
          migrationDone = dirty = true;
        }
        let authTypeMigrated = this.systemMigrationStatus.authTypeMigrated;
        if (!this.systemMigrationStatus.authTypeMigrated) {
          await this.migrateAuthType();
          authTypeMigrated = dirty = true;
        }
        return {
          migrationStatus: { ...this.systemMigrationStatus, migrationDone, authTypeMigrated },
          dirty
        };
      }
      async migrateFromPureSecureStore() {
        const systemsToMigrate = await this.secureStore.getAll(contants_1.ServiceName.OldSystemService);
        const existingSystems = await this.getExistingSystems();
        for (const systemId of Object.keys(systemsToMigrate)) {
          if (!existingSystems[systemId]) {
            const oldSystem = systemsToMigrate[systemId];
            this.logger.debug(`Migrating sytem ID: [${systemId}]`);
            const refreshToken = await this.getRefreshTokenFromOldStore(oldSystem);
            if (refreshToken) {
              this.logger.info(i18n_1.text("info.foundRefreshToken", { systemId }));
            }
            await this.saveBackendSystem(new backend_system_1.BackendSystem({ ...oldSystem, refreshToken }));
            await this.secureStore.delete(contants_1.ServiceName.OldSystemService, systemId);
            if (refreshToken) {
              await this.deleteOldRefreshToken(oldSystem, systemId);
              this.logger.info(i18n_1.text("info.deletingRefreshTokenFromOldStore", { systemId }));
            }
          } else {
            this.logger.info(i18n_1.text("error.systemAlreadyExistsInHybridStore", { systemId }));
          }
        }
      }
      async migrateRefreshTokens() {
        const existingSystems = await this.getExistingSystems();
        for (const systemId of Object.keys(existingSystems)) {
          const existingSystem = existingSystems[systemId];
          const refreshToken = await this.getRefreshTokenFromOldStore(existingSystem);
          if (refreshToken) {
            this.logger.info(i18n_1.text("info.foundRefreshToken", { systemId }));
            await this.updateRefreshTokenInStoredSystem(existingSystem, refreshToken, systemId);
            await this.deleteOldRefreshToken(existingSystem, systemId);
          }
        }
      }
      async migrateAuthType() {
        const existingSystems = await this.getExistingSystems();
        for (const systemId of Object.keys(existingSystems)) {
          const existingSystem = existingSystems[systemId];
          if (!existingSystem.authenticationType) {
            this.logger.info(i18n_1.text("info.tryingToUpdateAuthType", { systemId }));
            const authenticationType = this.guessAuthType(existingSystem);
            if (authenticationType) {
              this.logger.info(i18n_1.text("info.authTypeDetermined", { authenticationType, systemId }));
              await this.saveBackendSystem(new backend_system_1.BackendSystem({ ...existingSystem, authenticationType }));
            } else {
              this.logger.info(i18n_1.text("info.authTypeNotDetermined", { systemId }));
            }
          }
        }
      }
      guessAuthType(sys) {
        if (sys.serviceKeys) {
          return backend_system_1.AuthenticationType.OAuth2RefreshToken;
        } else if (sys.username) {
          return backend_system_1.AuthenticationType.Basic;
        } else {
          return void 0;
        }
      }
      async getRefreshTokenFromOldStore(system) {
        var _a2;
        try {
          const host = (_a2 = new URL(system.url)) == null ? void 0 : _a2.host;
          return host ? await this.secureStore.retrieve(contants_1.ServiceName.OldRefreshTokenService, host) : void 0;
        } catch {
          return void 0;
        }
      }
      async deleteOldRefreshToken(system, systemId) {
        var _a2;
        this.logger.info(i18n_1.text("info.deletingRefreshTokenFromOldStore", { systemId }));
        try {
          const host = (_a2 = new URL(system.url)) == null ? void 0 : _a2.host;
          await this.secureStore.delete(contants_1.ServiceName.OldRefreshTokenService, host);
        } catch (e) {
          this.logger.info(i18n_1.text("error.couldNotDeleteRefreshToken", { url: system.url }));
          this.logger.info(e.message);
        }
      }
      async updateRefreshTokenInStoredSystem(system, refreshToken, systemId) {
        if (system.refreshToken !== refreshToken) {
          this.logger.info(i18n_1.text("info.updatingRefreshTokenInNewStore", { systemId }));
          await this.saveBackendSystem(new backend_system_1.BackendSystem({ ...system, refreshToken }));
        }
      }
      async saveBackendSystem(backendSystem) {
        this.cache.existingSystems = void 0;
        return this.systemDataProvider.write(backendSystem);
      }
      async getExistingSystems() {
        if (!this.cache.existingSystems) {
          this.cache.existingSystems = (await this.systemDataProvider.getAll()).reduce((systems, sys) => {
            systems[new backend_system_1.BackendSystemKey(sys).getId()] = sys;
            return systems;
          }, {});
        }
        return this.cache.existingSystems;
      }
    };
    async function migrate(logger, systemDataProvider) {
      try {
        const systemMigrationStatusDataProvider = new system_migration_1.SystemMigrationStatusDataProvider(logger);
        const systemMigrationStatus = await systemMigrationStatusDataProvider.read(new system_migration_status_1.SystemMigrationStatusKey()) || { migrationDone: false, authTypeMigrated: false, migrationLogs: [] };
        const migrationLogger = createLogInterceptor(logger, systemMigrationStatus.migrationLogs);
        const secureStore = secure_store_1.getSecureStore(migrationLogger);
        const migration = new Migration({
          logger: migrationLogger,
          systemMigrationStatus,
          secureStore,
          systemDataProvider
        });
        const { migrationStatus: updatedStatus, dirty } = await migration.run();
        if (dirty) {
          await systemMigrationStatusDataProvider.write(new system_migration_status_1.SystemMigrationStatus({
            ...updatedStatus,
            migrationLogs: updatedStatus.migrationLogs.slice(-200)
          }));
        }
      } catch (e) {
        logger.warn(i18n_1.text("error.systemMigrationFailed"));
        logger.debug(e.message);
      }
    }
    exports2.migrate = migrate;
    function addBeforeHook(hookFn, fn) {
      return function(arg) {
        hookFn(arg);
        fn(arg);
      };
    }
    function createLogInterceptor(logger, migrationLogs) {
      const migrationLogger = getMigrationLogger(migrationLogs);
      return {
        info: addBeforeHook(migrationLogger, logger.info),
        warn: addBeforeHook(migrationLogger, logger.warn),
        error: addBeforeHook(migrationLogger, logger.error),
        debug: migrationLogger
      };
    }
    function getMigrationLogger(migrationLogs) {
      const migrationLogger = utils_1.newDebugLogger(utils_1.MIGRATION_NAMESPACE);
      migrationLogger.log = (args) => {
        migrationLogs.push(args == null ? void 0 : args.toString());
      };
      utils_1.enableDebugLogger(utils_1.MIGRATION_NAMESPACE);
      return migrationLogger;
    }
  }
});

// ../lib/store/dist/services/backend-system.js
var require_backend_system3 = __commonJS({
  "../lib/store/dist/services/backend-system.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getInstance = exports2.SystemService = void 0;
    var utils_1 = require_utils3();
    var backend_system_1 = require_backend_system2();
    var backend_system_2 = require_backend_system();
    var system_migration_1 = require_system_migration2();
    var i18n_1 = require_i18n3();
    var SystemService = class {
      constructor(logger) {
        this.migrationDone = false;
        this.logger = utils_1.getExtendedLogger(logger);
        this.dataProvider = new backend_system_1.SystemDataProvider(this.logger);
      }
      async partialUpdate(key, entity) {
        this.validatePartialUpdateInput(entity);
        const existingSystem = await this.readOrThrow(key);
        const updatedEntity = this.mergeProperties(entity, existingSystem);
        return this.write(updatedEntity);
      }
      mergeProperties(update, existingSystem) {
        const patch = { ...update };
        delete patch.url;
        delete patch.client;
        const updatedEntity = { ...existingSystem, ...patch };
        return new backend_system_2.BackendSystem({ ...updatedEntity });
      }
      async readOrThrow(key) {
        const existingSystem = await this.read(key);
        if (!existingSystem) {
          throw new Error(i18n_1.text("error.systemDoesNotExist", { system: key }));
        }
        return existingSystem;
      }
      validatePartialUpdateInput(entity) {
        if (!entity || !Object.keys(entity).length) {
          throw new Error(i18n_1.text("error.noPropertiesSpecified"));
        }
      }
      async ensureMigrationDone() {
        if (!this.migrationDone) {
          await system_migration_1.migrate(this.logger, this.dataProvider);
          this.migrationDone = true;
        }
      }
      async read(key) {
        await this.ensureMigrationDone();
        return this.dataProvider.read(key);
      }
      async write(entity) {
        await this.ensureMigrationDone();
        return this.dataProvider.write(entity);
      }
      async delete(entity) {
        await this.ensureMigrationDone();
        return this.dataProvider.delete(entity);
      }
      async getAll() {
        await this.ensureMigrationDone();
        return this.dataProvider.getAll();
      }
    };
    exports2.SystemService = SystemService;
    function getInstance(logger) {
      return new SystemService(logger);
    }
    exports2.getInstance = getInstance;
  }
});

// ../lib/store/dist/services/index.js
var require_services = __commonJS({
  "../lib/store/dist/services/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SystemService = void 0;
    var backend_system_1 = require_backend_system3();
    Object.defineProperty(exports2, "SystemService", { enumerable: true, get: function() {
      return backend_system_1.SystemService;
    } });
  }
});

// ../lib/store/dist/data-access/index.js
var require_data_access = __commonJS({
  "../lib/store/dist/data-access/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getFilesystemWatcherFor = void 0;
    var filesystem_1 = require_filesystem();
    Object.defineProperty(exports2, "getFilesystemWatcherFor", { enumerable: true, get: function() {
      return filesystem_1.getFilesystemWatcherFor;
    } });
  }
});

// ../lib/store/dist/index.js
var require_dist4 = __commonJS({
  "../lib/store/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Entity = exports2.getFilesystemWatcherFor = exports2.getService = void 0;
    var contants_1 = require_contants();
    Object.defineProperty(exports2, "Entity", { enumerable: true, get: function() {
      return contants_1.Entity;
    } });
    var i18n_1 = require_i18n3();
    var backend_system_1 = require_backend_system3();
    var services = {
      system: backend_system_1.getInstance
    };
    async function getService({ logger = console, entityName }) {
      await i18n_1.initI18n();
      const factory = services[entityName];
      if (factory) {
        return factory(logger);
      } else {
        throw new Error(i18n_1.text("error.unsupportedEntity", { entityName }));
      }
    }
    exports2.getService = getService;
    __exportStar(require_services(), exports2);
    __exportStar(require_secure_store(), exports2);
    __exportStar(require_backend_system(), exports2);
    var data_access_1 = require_data_access();
    Object.defineProperty(exports2, "getFilesystemWatcherFor", { enumerable: true, get: function() {
      return data_access_1.getFilesystemWatcherFor;
    } });
  }
});

// ../lib/odata-client/dist/config.js
var require_config = __commonJS({
  "../lib/odata-client/dist/config.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hasHTML5DynamicDestinationAttrib = exports2.hasFullUrlDestAttribute = exports2.hasDestinationAttrib = exports2.destinationPropertyId = exports2.DestinationAttributeProperty = exports2.DestinationProperties = exports2.AuthenticationType = exports2.ServiceName = void 0;
    var ServiceName;
    (function(ServiceName2) {
      ServiceName2["SystemInfo"] = "fiori/system/info";
      ServiceName2["RefreshToken"] = "fiori/system/refreshToken";
      ServiceName2["ApiHub"] = "fiori/system/apiHub";
    })(ServiceName = exports2.ServiceName || (exports2.ServiceName = {}));
    var ux_store_1 = require_dist4();
    Object.defineProperty(exports2, "AuthenticationType", { enumerable: true, get: function() {
      return ux_store_1.AuthenticationType;
    } });
    var DestinationProperties;
    (function(DestinationProperties2) {
      DestinationProperties2["WebIDEUsage"] = "WebIDEUsage";
      DestinationProperties2["WebIDEEnabled"] = "WebIDEEnabled";
      DestinationProperties2["WebIDESystem"] = "WebIDESystem";
      DestinationProperties2["SapClient"] = "sap-client";
      DestinationProperties2["WebIDEAdditionalData"] = "WebIDEAdditionalData";
      DestinationProperties2["HTML5ForwardAuthToken"] = "HTML5.ForwardAuthToken";
      DestinationProperties2["HTML5Timeout"] = "HTML5.Timeout";
      DestinationProperties2["HTML5PreserveHostHeader"] = "HTML5.PreserveHostHeader";
      DestinationProperties2["HTML5DynamicDestination"] = "HTML5.DynamicDestination";
      DestinationProperties2["HTML5SetXForwardedHeaders"] = "HTML5.SetXForwardedHeaders";
      DestinationProperties2["TrustAll"] = "TrustAll";
    })(DestinationProperties = exports2.DestinationProperties || (exports2.DestinationProperties = {}));
    exports2.DestinationAttributeProperty = {
      ODATA_GENERIC: "odata_gen",
      FULL_URL: "full_url",
      ODATA_ABAP: "odata_abap",
      DEV_ABAP: "dev_abap",
      ABAP_CLOUD: "abap_cloud"
    };
    exports2.destinationPropertyId = Object.keys(exports2.DestinationAttributeProperty);
    function hasDestinationAttrib(destinationProperty, destinationAttributeProperty, destinationAttribs = {}) {
      var _a2, _b;
      return (_b = destinationAttribs && ((_a2 = destinationAttribs[destinationProperty]) == null ? void 0 : _a2.includes(destinationAttributeProperty))) != null ? _b : false;
    }
    exports2.hasDestinationAttrib = hasDestinationAttrib;
    function hasFullUrlDestAttribute(destinationAttribs) {
      var _a2, _b;
      return (_b = destinationAttribs && ((_a2 = destinationAttribs["WebIDEAdditionalData"]) == null ? void 0 : _a2.includes(exports2.DestinationAttributeProperty.FULL_URL))) != null ? _b : false;
    }
    exports2.hasFullUrlDestAttribute = hasFullUrlDestAttribute;
    function hasHTML5DynamicDestinationAttrib(destinationAttribs) {
      var _a2;
      return (_a2 = destinationAttribs && destinationAttribs["HTML5.DynamicDestination"] === "true") != null ? _a2 : false;
    }
    exports2.hasHTML5DynamicDestinationAttrib = hasHTML5DynamicDestinationAttrib;
  }
});

// ../lib/odata-client/dist/connection/cookies.js
var require_cookies2 = __commonJS({
  "../lib/odata-client/dist/connection/cookies.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Cookies = void 0;
    var Cookies = class {
      constructor() {
        this.cookies = {};
      }
      setCookie(response) {
        var _a2;
        if ((_a2 = response == null ? void 0 : response.headers) == null ? void 0 : _a2["set-cookie"]) {
          response.headers["set-cookie"].forEach((cookieString) => this.addCookie(cookieString));
        }
        return this;
      }
      addCookie(cookieString) {
        const cookie = cookieString.split(";");
        const [, key, value] = cookie[0].match(/(.*?)=(.*)/);
        if (cookieString.indexOf("Max-Age=0") >= 0) {
          delete this.cookies[key];
        } else {
          if (key && value) {
            this.cookies[key] = value;
          }
        }
        return this;
      }
      toString() {
        const cookies = [];
        Object.keys(this.cookies).forEach((key) => {
          cookies.push(`${key}=${this.cookies[key]}`);
        });
        return cookies.join("; ");
      }
    };
    exports2.Cookies = Cookies;
  }
});

// ../../node_modules/is-docker/index.js
var require_is_docker = __commonJS({
  "../../node_modules/is-docker/index.js"(exports2, module2) {
    "use strict";
    var fs2 = require("fs");
    var isDocker;
    function hasDockerEnv() {
      try {
        fs2.statSync("/.dockerenv");
        return true;
      } catch (_45) {
        return false;
      }
    }
    function hasDockerCGroup() {
      try {
        return fs2.readFileSync("/proc/self/cgroup", "utf8").includes("docker");
      } catch (_45) {
        return false;
      }
    }
    module2.exports = () => {
      if (isDocker === void 0) {
        isDocker = hasDockerEnv() || hasDockerCGroup();
      }
      return isDocker;
    };
  }
});

// ../../node_modules/is-wsl/index.js
var require_is_wsl = __commonJS({
  "../../node_modules/is-wsl/index.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var fs2 = require("fs");
    var isDocker = require_is_docker();
    var isWsl = () => {
      if (process.platform !== "linux") {
        return false;
      }
      if (os.release().toLowerCase().includes("microsoft")) {
        if (isDocker()) {
          return false;
        }
        return true;
      }
      try {
        return fs2.readFileSync("/proc/version", "utf8").toLowerCase().includes("microsoft") ? !isDocker() : false;
      } catch (_45) {
        return false;
      }
    };
    if (process.env.__IS_WSL_TEST__) {
      module2.exports = isWsl;
    } else {
      module2.exports = isWsl();
    }
  }
});

// ../../node_modules/open/index.js
var require_open = __commonJS({
  "../../node_modules/open/index.js"(exports2, module2) {
    "use strict";
    var { promisify } = require("util");
    var path = require("path");
    var childProcess = require("child_process");
    var fs2 = require("fs");
    var isWsl = require_is_wsl();
    var isDocker = require_is_docker();
    var pAccess = promisify(fs2.access);
    var pReadFile = promisify(fs2.readFile);
    var localXdgOpenPath = path.join(__dirname, "xdg-open");
    var getWslDrivesMountPoint = (() => {
      const defaultMountPoint = "/mnt/";
      let mountPoint;
      return async function() {
        if (mountPoint) {
          return mountPoint;
        }
        const configFilePath = "/etc/wsl.conf";
        let isConfigFileExists = false;
        try {
          await pAccess(configFilePath, fs2.constants.F_OK);
          isConfigFileExists = true;
        } catch (_45) {
        }
        if (!isConfigFileExists) {
          return defaultMountPoint;
        }
        const configContent = await pReadFile(configFilePath, { encoding: "utf8" });
        const configMountPoint = /root\s*=\s*(.*)/g.exec(configContent);
        if (!configMountPoint) {
          return defaultMountPoint;
        }
        mountPoint = configMountPoint[1].trim();
        mountPoint = mountPoint.endsWith("/") ? mountPoint : mountPoint + "/";
        return mountPoint;
      };
    })();
    module2.exports = async (target, options2) => {
      if (typeof target !== "string") {
        throw new TypeError("Expected a `target`");
      }
      options2 = {
        wait: false,
        background: false,
        allowNonzeroExitCode: false,
        ...options2
      };
      let command;
      let { app } = options2;
      let appArguments = [];
      const cliArguments = [];
      const childProcessOptions = {};
      if (Array.isArray(app)) {
        appArguments = app.slice(1);
        app = app[0];
      }
      if (process.platform === "darwin") {
        command = "open";
        if (options2.wait) {
          cliArguments.push("--wait-apps");
        }
        if (options2.background) {
          cliArguments.push("--background");
        }
        if (app) {
          cliArguments.push("-a", app);
        }
      } else if (process.platform === "win32" || isWsl && !isDocker()) {
        const mountPoint = await getWslDrivesMountPoint();
        command = isWsl ? `${mountPoint}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe` : `${process.env.SYSTEMROOT}\\System32\\WindowsPowerShell\\v1.0\\powershell`;
        cliArguments.push("-NoProfile", "-NonInteractive", "\u2013ExecutionPolicy", "Bypass", "-EncodedCommand");
        if (!isWsl) {
          childProcessOptions.windowsVerbatimArguments = true;
        }
        const encodedArguments = ["Start"];
        if (options2.wait) {
          encodedArguments.push("-Wait");
        }
        if (app) {
          encodedArguments.push(`"\`"${app}\`""`, "-ArgumentList");
          appArguments.unshift(target);
        } else {
          encodedArguments.push(`"${target}"`);
        }
        if (appArguments.length > 0) {
          appArguments = appArguments.map((arg) => `"\`"${arg}\`""`);
          encodedArguments.push(appArguments.join(","));
        }
        target = Buffer.from(encodedArguments.join(" "), "utf16le").toString("base64");
      } else {
        if (app) {
          command = app;
        } else {
          const isBundled = !__dirname || __dirname === "/";
          let exeLocalXdgOpen = false;
          try {
            await pAccess(localXdgOpenPath, fs2.constants.X_OK);
            exeLocalXdgOpen = true;
          } catch (_45) {
          }
          const useSystemXdgOpen = process.versions.electron || process.platform === "android" || isBundled || !exeLocalXdgOpen;
          command = useSystemXdgOpen ? "xdg-open" : localXdgOpenPath;
        }
        if (appArguments.length > 0) {
          cliArguments.push(...appArguments);
        }
        if (!options2.wait) {
          childProcessOptions.stdio = "ignore";
          childProcessOptions.detached = true;
        }
      }
      cliArguments.push(target);
      if (process.platform === "darwin" && appArguments.length > 0) {
        cliArguments.push("--args", ...appArguments);
      }
      const subprocess = childProcess.spawn(command, cliArguments, childProcessOptions);
      if (options2.wait) {
        return new Promise((resolve, reject) => {
          subprocess.once("error", reject);
          subprocess.once("close", (exitCode) => {
            if (options2.allowNonzeroExitCode && exitCode > 0) {
              reject(new Error(`Exited with code ${exitCode}`));
              return;
            }
            resolve(subprocess);
          });
        });
      }
      subprocess.unref();
      return subprocess;
    };
  }
});

// ../lib/odata-client/dist/connection/common.js
var require_common3 = __commonJS({
  "../lib/odata-client/dist/connection/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CSRF = void 0;
    var CSRF;
    (function(CSRF2) {
      CSRF2["requestHeaderName"] = "X-Csrf-Token";
      CSRF2["requestHeaderValue"] = "Fetch";
      CSRF2["responseHeaderName"] = "x-csrf-token";
    })(CSRF = exports2.CSRF || (exports2.CSRF = {}));
  }
});

// ../lib/odata-client/dist/static/index.js
var require_static = __commonJS({
  "../lib/odata-client/dist/static/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.redirectSuccessHtml = exports2.globalRootCaPem = void 0;
    exports2.globalRootCaPem = `
-----BEGIN CERTIFICATE-----
MIIGTDCCBDSgAwIBAgIQXQPZPTFhXY9Iizlwx48bmTANBgkqhkiG9w0BAQsFADBO
MQswCQYDVQQGEwJERTERMA8GA1UEBwwIV2FsbGRvcmYxDzANBgNVBAoMBlNBUCBB
RzEbMBkGA1UEAwwSU0FQIEdsb2JhbCBSb290IENBMB4XDTEyMDQyNjE1NDE1NVoX
DTMyMDQyNjE1NDYyN1owTjELMAkGA1UEBhMCREUxETAPBgNVBAcMCFdhbGxkb3Jm
MQ8wDQYDVQQKDAZTQVAgQUcxGzAZBgNVBAMMElNBUCBHbG9iYWwgUm9vdCBDQTCC
AiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAOrxJKFFA1eTrZg1Ux8ax6n/
LQRHZlgLc2FZpfyAgwvkt71wLkPLiTOaRb3Bd1dyydpKcwJLy0dzGkunzNkPRSFz
bKy2IPS0RS45hUCCPzhGnqQM6TcDYWeWpSUvygqujgb/cAG0mSJpvzAD3SMDQ+VJ
Az5Ryq4IrP7LkfCb63LKZxLsHEkEcNKoGPsSsd4LTwuEIyM3ZHcCoA97m6hvgLWV
GLzLIQMEblkswqX29z7JZH+zJopoqZB6eEogE2YpExkw52PufytEslDY3dyVubjp
GlvD4T03F2zm6CYleMwgWbATLVYvk2I9WfqPAP+ln2IU9DZzegSMTWHCE+jizaiq
b5f5s7m8f+cz7ndHSrz8KD/S9iNdWpuSlknHDrh+3lFTX/uWNBRs5mC/cdejcqS1
v6erflyIfqPWWO6PxhIs49NL9Lix3ou6opJo+m8K757T5uP/rQ9KYALIXvl2uFP7
0CqI+VGfossMlSXa1keagraW8qfplz6ffeSJQWO/+zifbfsf0tzUAC72zBuO0qvN
E7rSbqAfpav/o010nKP132gbkb4uOkUfZwCuvZjA8ddsQ4udIBRj0hQlqnPLJOR1
PImrAFC3PW3NgaDEo9QAJBEp5jEJmQghNvEsmzXgABebwLdI9u0VrDz4mSb6TYQC
XTUaSnH3zvwAv8oMx7q7AgMBAAGjggEkMIIBIDAOBgNVHQ8BAf8EBAMCAQYwEgYD
VR0TAQH/BAgwBgEB/wIBATAdBgNVHQ4EFgQUg8dB/Q4mTynBuHmOhnrhv7XXagMw
gdoGA1UdIASB0jCBzzCBzAYKKwYBBAGFNgRkATCBvTAmBggrBgEFBQcCARYaaHR0
cDovL3d3dy5wa2kuY28uc2FwLmNvbS8wgZIGCCsGAQUFBwICMIGFHoGCAEMAZQBy
AHQAaQBmAGkAYwBhAHQAZQAgAFAAbwBsAGkAYwB5ACAAYQBuAGQAIABDAGUAcgB0
AGkAZgBpAGMAYQB0AGkAbwBuACAAUAByAGEAYwB0AGkAYwBlACAAUwB0AGEAdABl
AG0AZQBuAHQAIABvAGYAIABTAEEAUAAgAEEARzANBgkqhkiG9w0BAQsFAAOCAgEA
0HpCIaC36me6ShB3oHDexA2a3UFcU149nZTABPKT+yUCnCQPzvK/6nJUc5I4xPfv
2Q8cIlJjPNRoh9vNSF7OZGRmWQOFFrPWeqX5JA7HQPsRVURjJMeYgZWMpy4t1Tof
lF13u6OY6xV6A5kQZIISFj/dOYLT3+O7wME5SItL+YsNh6BToNU0xAZt71Z8JNdY
VJb2xSPMzn6bNXY8ioGzHlVxfEvzMqebV0KY7BTXR3y/Mh+v/RjXGmvZU6L/gnU7
8mTRPgekYKY8JX2CXTqgfuW6QSnJ+88bHHMhMP7nPwv+YkPcsvCPBSY08ykzFATw
SNoKP1/QFtERVUwrUXt3Cufz9huVysiy23dEyfAglgCCRWA+ZlaaXfieKkUWCJaE
Kw/2Jqz02HDc7uXkFLS1BMYjr3WjShg1a+ulYvrBhNtseRoZT833SStlS/jzZ8Bi
c1dt7UOiIZCGUIODfcZhO8l4mtjh034hdARLF0sUZhkVlosHPml5rlxh+qn8yJiJ
GJ7CUQtNCDBVGksVlwew/+XnesITxrDjUMu+2297at7wjBwCnO93zr1/wsx1e2Um
Xn+IfM6K/pbDar/y6uI9rHlyWu4iJ6cg7DAPJ2CCklw/YHJXhDHGwheO/qSrKtgz
PGHZoN9jcvvvWDLUGtJkEotMgdFpEA2XWR83H4fVFVc=
-----END CERTIFICATE-----
`;
    var redirectSuccessHtml = (logoutUrl, systemId) => `
<html>

<head>
    <meta http-equiv="content-type" content="text/html; charset=windows-1252">
    <title>${systemId ? systemId + ": " : ""}Authentication Successful</title>
    <style>
        body {
            background: #ffffff;
            text-align: center;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .content {
            display: table;
            position: absolute;
            width: 100%;
            height: 80%;
        }

        .valigned {
            display: table-cell;
            vertical-align: middle;
        }

        .lowerCenter {
            display: table-cell;
            vertical-align: bottom;
        }

        .footer {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            z-index: -1;
        }

        .footerLeft {
            float: left;
            margin-left: 20px;
        }

        .footerRight {
            float: right;
            margin-right: 20px;
            position: absolute;
            bottom: 0px;
            right: 0px;
        }

        .centerText {
            font-style: normal;
            font-family: Arial;
            font-size: 26px;
            color: #444444;
            z-index: 1;
        }
        .centerLink {
            font-style: normal;
            font-family: Arial, Helvetica, sans-serif;
            font-size: 18px;
            text-decoration: none;
            color: #224679;
        }

        .errorTextHeader {
            font-style: normal;
            font-family: Arial;
            font-size: 40px;
            color: #444444;
        }

        .bottomText {
            align: center;
            font-style: normal;
            font-family: Arial;
            font-size: 14px;
            color: #444444;
        }

        .biggerBottomText {
            align: center;
            font-style: normal;
            font-family: Arial;
            font-size: 16px;
            color: #444444;
        }

        .detailTable {
            align: bottom;
            vertical-align: middle;
            margin-left: auto;
            margin-right: auto;
            font-style: normal;
            font-family: Arial;
            font-size: 16px;
            color: #444444;
        }
    </style>
</head>

<body>
    <div class="content">
        <div class="valigned">
            <p class="centerText"><span class="errorTextHeader">You can close this tab now.</span></p>
            ${logoutUrl ? '<a class="centerLink" href="' + logoutUrl + '">(Click here to log off the current user)</a>' : ""}
        </div>
    </div>
    <div class="footer">
        <div class="footerLeft"><img width='150' height='80' title='' alt='SAP logo'
                src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAABQCAYAAAGMt7zdAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAFhpJREFUeNpiZEAAJiBmZCAd/IdhmGYWhu0ffzNQAjz5mVigTGa291/JNudXlBQHA5K32P////8DWQHv9LsMnzOVGWTm3mf4+OsfmI0sBwNfslQ4gdRPkDeZkA24/OoHg1DHFTCGaX6SrMjA+vE7mA0SBwEQH4SRDUI2h120+sx/GDh67xOYhokhy8H4QD0cuCKMfcXJl/8lCo7+xwYevf0BpkHyIIzPIFiYYQDp9AP/Vx17jsLHZxBMkE02cc9PQrH2eL4L1jBCN4wZaiMzDlv/gVIAFP/HZRlAADEi0YzUyAGMYFdt//iNgtTPCiT/sMAMIzcHAFM/PzQY4BlcCDkWeabdwcqG8WEYqE8AGs5wg+AAlvphKR6W2mFyM868BecMaOoXBAp/BuK/DGhFD4rLPnz/8x8fQHcRA7zogQLJwmNg+nm/FQM/B4Y6uPyLCdZYXYTTZbDUDsJoqR+rixjQ0hc/MAe8J5D68boI2TA2UP7EkWj/Qw34gc8gEAAIIEY07zJBvcHEQF/wD4r/wnITC5IDQWwO5vWvPzIMAPgbKMqNFKIMLGjRAKyjILn9W6IcXJPFxhcMl979gvN3eorD2e7bX2IVP/TiB0PrecJ+/J4kLwiN2t/QUPuPHJWgqAOVIdzAxPkWpsl79SOGLEMhBm8VHgb+/ptgsUwjQYYOezEUw2FyHwvVwfSRJ98Y5PhYwRhdDQx8KtLA6iCMfIkNbA2FhJpI00UGmBUwR4HE3tTpg9k5WjwMM0++gesLmHcbTMPkwSXPZ0j9/rbeAK+DsOVzUE4SEi898R+G8QGQfPeuJyh8bODjtz9gOWj5gK++wporsUYluUA65zCc/WyqHUkhhCsq/8um7qc4h4F8+WSOE1kOQnfYf6jm30y//1LkqEcLXQWg7RCyHIStgIUVGeQ2tpE9+J9cB8EAQAAx4mgHMVDgOFI9gt6GQnEAclXESMcC/z9SVfQPvSpiBjbufjIMFPDkZ8daPzL/+DUg7vm/ZbbsP7RcCG9LM3//TXcH/V3dpfRv/YR3yDkWucxiZP4BcdQsW2GGGBVuMHvzo+8M4XtfoxgEq5g3P/zGMOXaZ4zKGgQW3/7CsOQO/ub579VtKn+3z3yNrbJmhHVjgM3sz8idT/ROKrhfmaTIwM/OhCGOSx96JxYGfq7vUvm9e9ZLaNfoD3ofAQ6QDc7c+RyM4Qp//AFjZAchiyMDUAsCGSiwMcLVgfCvNe04HYS39bDy/FsUGlfr+1GWCoNi/3UUMb8l98D0uwodMD3dVZzBb9l9SJTdO+34a99cnA5iwNc8BhkIwlM9pRiYfv0FY5gl4Ab+B0hO5WdnBsuhGApVD1f7/ieY//fmCccvs5PO4HMQA1pzmQd92AB9CAEGZh59gcLHpw8mLxAzwwFkB7QTwkSomoEndGBb6DO8LNMWZJgfrwZX+PH7XwZ+TkgkSpSdhHTQuswJZnmQ2l+Pzjm+X5lFVAhhOEqi4OhnWSF2hsfvEAU7qOdIKoD1KsG97yfnHN+tySXaQRgJfWKEMkOYuTjlbStoM+jn0/OO7zbkk+QgDEcx/sPe4vj0/Q8DHydEqUzGQRS5JzPsMYP/zz+Gv19e5b4lw0EY0SeTsu8zVaoOoIOer4hYQI6D0Fug/xn//qPcQV+BDloVRbaDYI6CxdlfXNFHtIO+vcl5thruoL/kOAi9kccM7eGwkDgC9x9p3OAvNHTIdhC2gRBqDAmS3WmAAYAAYsST+LGxhzNA7vCgszGKKka0mGRGGt5iwtH5GcoBgzEYjTSk9g8tJf7H1qpCHvtjYdr87jPDCAP/962Q+t+f9RaaILAOYKGnGnBgDUQ3Z6DA33X9Cv9WdLxFGlX+j6/FwIiOB6qjSk/wewWwy7dt+hukWukvUjbEWWZhFPSwntS1CBkGeV4Woix/+PkPg9W6ZwwffiFqQj1hNobjQVJY1XPPfoAh9jVVgWjPHn7+g8FjywvSA2ktsNe3c9ZbaCD9YUAb/seWshixDKPB2g9sDz/+eos8SE0MaD/5jqH9FOrA6qdcVZzqL7/5yWC9/BHR6vEBvsm3Car5ualL5deeOSQFEjEpiwFbQAn0XMeqFtTHB6m//PonSk/vQ4kmXsfrirAz2ImxMRx5jH8yFN1ebOZ2WgkzVO5/iVX/j609Kj8PzCMrkAh253EBkCNBeJmfNIMg4z8G5p9/wPjLp18M1558hfNBGKQGHVTtfoYhtiVcHkUfNoAsD8IzTr3BUKMHDHh0df9uHHf8WKolCAwoUCj+gDbhfyMFGNGNVbzZUKTu3NvXjYZEB2TX/ucM3Qcg5YeOBCfD/kwNDDWi9ecZPDX4GRZFKmGVAwFsdh598AVuLrZpYBAw6r8KH5P59eCM46dFaRcoSUkkBZZYBaLwkRVgZ9ibr43TochArfEcw616Iwxx8crTcPbLdlPMEbOzbxjy1tzHKkeMnR9//GX49eis44dlmVQNJKICS6LoON4pMNAQzqlqQwZqAtPW8wynCZh59dlXhh1X3jP07HyCKLifnHN8vyqbJoFEVAHP+Ocvw7OJ1nD+7IPPGHZeegfnz0vRoHq7B1dASeUfxRrToDGyt+vyaBpIRKUsakyugoBl7SmGx28hU9CWagIMVx9/AQ+NgYfBptkRZYZM1iHUdtKb2wGvVqccpEcgEZOy/sumHQAztGV5GOrDVcAexcgSQI+nTLvC8AQYGKtKDDDkn7z5wfDk5Td4rJy49g4llrQLjjDMydIhHKt//iFGypaFL6FnIBFKWaBAZJNN2vtu0PTdgIH0bGXkgAQStjFS9OEKiocnqRNIr3Ofro5cjDSqSPdAwpUNYWM6IEf9///rW/t/0JrD//+YGP6jrMClIWD8z8AItPL394tP10RtRurY/mVAXZVA95hkxDFKir7kgtwhXUoG5v5jCZwBCSRCI56MBAKU1qOXuEY0BxQABCDnbGPiKMI4/hy2VbHF3oEGUoRaWzTUQqvYKi8lUioRIaZqDLSiidooUWPsB0Pa2jQxIlXAGotNq1ibmFJiNNE2FkrsBxUuMVYjLEZrscLdQSkv5a5SetzerTdz3b293ZnZO3p3e+k9yeRgdmZ297czz8zO/GcNMQJKt4nRUB7OPI3eMZ4WK4DQzAXWTCkQfFXCdQ6M5iNBa6ZUhKMM11MtEygjAOHqvVGnbeZRB6cnZEL9eDLB0wvlxjzwr+5Iqzy0BYuEBN4df6A8nl7P4ynrQnk3xE3PEG+w3O4+91Op+aGM4KXmmODyxBEonnNVLymkDH6ZS2G4KcZNzfKCmq3JKFI4dkGrZgX0cnHhs3ieu/L8netBvbhKfLWizWcZxPkj0SozboYda26FHNOCgPjB/3ho6b8kCYFJhsTENSsWquLlu31EUwqJledC4ccRJ94RdG01ysXNbF1eTABFXe0xEMZXeC4r8eC5KXSgKO0m6KhIDfoa3jRPQgvnCIijrTBXnbyAFdfBpKXZQ18PQ+/EbMigLtdmFYN/bswtm/bx0F53qOuGqBm+mr0oJFDIco3zcV55oNnRR24POi3NkCzg4PpkVTm0YHA65wSKCQs1wz0FySFffG3XeZxXDG1lbL2sPK2y6QdrW+5eBDneh6QsSxWcs9z0a/fMCRQTVlt5GjH+SL8db/JDocE8Dnan/wY3f2tTXWDFsoXMG93+gFET1pDDheX9Som/3LqrMjRAOblLb2TPGRTLwcNjd6lvcv/pyQAtQffgNDR0+3Z/1OWnwHdnHAFd6qrbbtSsFXUPpkDDT2PMNEe4KWjo8S/X195ngndL1DWWKh32+ih7Xe41gWLWLGITu98EmbfcQPQF7/0wqoo7XpUZVLlaPgutBcjTHPh5TLMcyUe5eHs4QDFhcaPk9+jfa7Pwfo/qlYu9T1JgBrQHRGkkQccXT2RIecjvbOqyiVCVaXi3fWp7zrJwgGLCqmk/x8zYUpkOEztW4VCYnoibgDy8nGdS5UGijZ0dNlV8eVaSlI8IQRACyt5XsYQCS3YNPG+/+NbqsIFi+izrhBO48zNYtaJl3zzn26MlqmCQvVOmvqFn2/6hAkH+DZ2PZNW5JijI9PnQgqX0DkMqW/DYx9/OCyso9tDBe+KSfX/A+6eGgy4MSYVYNaTfNo2PHf1VrQpAEiRavjsWL8CQWKA2tf4l1ahIgNKEhUJjlw1LhZAcKBj7e+dqOLxZrb1CciCxzF3HBolA5roRhhu5DD1nHUjIYh+rXxsRUEHBEsPr7QN4q1nWrtPQ/gu9q0f6rUezjar4xpNWqSzHNFkyXrUm9EEwepilH/RhUBf2rIsYKOa7Yeo285RWZqTNQhqtaFvPgAOaOq3410dAsI8250cUFNPBg8d3jq9euReebOGISTr6JmFrcVrE4TR1WKCx00I+KHhBfVgYcVBMWGgguHfLCshfnoQ3ZaJNmk0nhsB6dbNmWY4pKqDEWyWKVLygRj4qigooNiyvb3l6rf+DLqi5IXh6mDjOUoIa/rg4aqCYsPY+kxW2k4iqPbQJFgnjzGd87rAsNxlaX1oZRM0SVDXLtj+6oJi9YfOxf0MqqPn4IDF+95cD+HUFBdQLmv+8KP3f+dt40M1QzIOCF1RytEGxR/BjMyDKJLdVLoUXNqRDUqI6eev3VtjdfhanEWtMwPEuC3MJm5RHdS3jM1LNsn7ysC6gWEOH+ekvntLls15MaJ+W6AZKWbMEZW8YS2b5bIOuoGjN0LcEJMQOLMuhUt1BkWBJq7CGGGE19HmpCQK39OsCilazfGtnMVCzhg5vNMoA6QqK5LOkXegCf6VewCplj09Z4/uN+PATKZXRNVjbNtWDX6UsVyrrAkreG4p/6yVmUyrt5GConw7QG5Z8GKGXTFKpZFGKNWJG2h0LAlzWVzt0daSxJO0OSWath/0vQHvnAtPUFcbxr4ibBge4IauCj/meyEx0m8NFo9lDdGbrTJzC5syyIU50btMQM7vFbOiyqWTL1IE6dUF8MB9RAR9xusWo+IAxKD6CKAIFRbAtFIb09t71HKSW9j7O7W0L9N4vOWnpfZ/74zvfPe33/1QS6OPb3t9/Cu5vxhCOJaTb8QJAIlKqEgGbYt0HLIbwlROuQIK5CHAaFwNYxktVJwwHinlvKGVTEuPaRgUEWU58UDknHgawwCUUlCmgdf7wxhfQcjXaaRuVEFyBBPGUI0RtmRc5BrNy3+SCJ10EeblvMinzDWKg5RsK2VKlcQugaKXD/Z4nazFzancss+lz4yOPpRLzxEmiSucCl8piVXreX42miukjm2fRu1IMIEEUIlAg/mHzXCpZZmz6u4eyUjrrgQ1v0wftZR1ogtiLc2gkCd5dlquUodB/zGrRUfvXv2M9utEArt910O5ARTLdwPqZ2OTWKeperJ8jvVfHgmOK+dAoSkcd/FFD5aYhoJzzUZ1fub4nck/KlQsutuA95IkASIoKhg9GBsHgPoGSrhkVTEWpmrtKm7AIMKldnRtBfGx0jAEZlUTrNn082KP3FKWQnr3bAht1jVBhpnzuoVoPrddQx9P5PBTbl46ivjbiml1nexrs0d6C0srseRFJ0SFYm9fbFpVZgZOiuSx9aj+cmSnGssubYd4JYeVqc+JQr1/f2isGWJtv8CJQlK718AaN5eQWoSGPlgKUJLD6bCytnxzRG3I1EV7vcJQdG5VR3iFL1tneHx0Maa+Fu7X/RX/WQub1Bt51GpOG+8yhfH/5Aay99MCzQB1N1bSe2uoToCSBtehkTf2vb6i93skoHTp6B3+q46DgQCj+SJpHid5xy3Ysbm9oWjYSfGk5ZWaIz66WtA/GNuQ9zPlJ03p6m0+BkgSWscVa71wCj93bWGFWVgUU1wqXjkQFet8a/hTER4Xgv5F8PtpWMF5JGAZi6x+wAfzC1jLO5cblZKrRSH/AMdXdDn9IT1gZE2a/NhJbfLwGaxuIn4ey6FqO/ax5eOa3TgHK3eAdtFptCAlU+IaZLDgjiiTLMvdGA25JOXreR1NH2zRzgGSo2rxeT9g8XQ1JudK8hIpmWK8V9QG6LtT+TRyBQROy+DHBsKdIRMzF0KbWwmPTmvcm3+lMoNpNdM2KlJQU4n+j6PBeUL5sNBiSx8DmGf1tT2w9bB1v9UhDHR8/NlTwHIrvteAmeCNt+0L7ZDsWubdgBM+bFBY8XJD0BUWZrKV504wro4faoEJxA+XUHOWVrYSAgc89FrK0i3WwaGKYqG3iovvi5uqlTLiZWsgnXQeF9oRNsyKJ1l1ypG04/TtBOE5C+zx/uxEqjO5V+cJpkBQj0A+hhB5IaF+0yVKer2nc/klRV/BQHgFLe6wKd2LiK/0kHXzmqGDcAAbaP0MFYlYd13PKXyA7Mn8Y0f7T8+5Dib7Z/p7kfDPmDIGpaTfcuyCOoRDJhqyJjeBVoXAJDa6ZOEKINqAafl/YJYGSFLyHafPxPBYSbPhl9mCY8XyoV07u3G0zLNhdhtUy2g0dj0TsAYncjN/QUSLg5qpxREWC0i/Ugjb3cU2a+9+N9+lT4Tmb19RsL3WJoSwVBRpTRmKXBsrtGAuT56DysSDjJoR/dQUmrCuCvQV1Hj25V5/rg2FInqrGx4sb15dYQUSbXeGicPJ1dgXRtokx4diT8mnoeMtQH7679YaDMpPVRN26PK1uzUtDbVAVdpUYyiseKzz5omCdIlRBPXZMX1xdHTWptv6UHla8TjYhi8uLZd1iXbbzwxHE5zNydT6uBn/vh5e9fiN01c0we8s1fLxHLJhaKws0xj2Lu4WH8ghYz67Ic7sAFhqKEiarYeHk/hDcu4fXLqzBdoN01U0dY50BQaKOiSSAZqddg7vrJnrl/JAu1JazNVBpaO04bVD1j8awL6lbAiUJLPUX5z1SWS1hSn/4VjMEurIhjanl0yOJ1+WUXRJ+CsRAPdi/pFsDJempsF0IAykcXfxmgv3zrEu1uCHpOCGLigiCFYQ3rDNtuZhzZBESIprY1Bdq6g8s9QugJIJFQ+TTvTpAhQzJajlKa8nOMFg04apMG1CHPvMroCSBhcQw81a/2KUuZNsZPS5YGjsuzAb9kzDwGfYfF6J1Sqqa4EKpEWJGhNrW99xPftDcHlgZwSHvYbUNqMPL/BIoSTGWp6rXespKqswwfU2BW9teTZ2ENfQ8Yak5dzhl6JBZzbVL7+6as9ufgZLisZiBiX/hN5E2r/DeJDXMiVHj91LtRGEdrM66CTGjQiF1AXkdalRRmHQIcrYvd16HbZ+O9UxvcgyFVJMNqMy5sgDKXY+FXyMTTgv+Eg2BhoYj/BrWUQm9pLIRGpopIv3D7mzIQ9XsmScroIQ8FgOuv1phHgfvwjvW32/BjZRqvwIKlQDfK0+g+MByLAepYl3OMKAYB1D74mQNFBtYXF7KpakUsFxiqOqseAUokcG7q+qIAtYjD1W3VP9HXCbwp0/JCiiSGMv5b9r/u4MQqP/qk/RZ8zKd4GGDSXZA8cXPctPHYgiW8+lIcaWhyxIoIARArop+fNKJXJCxLZetj1c0SMVBJkabU9ZBg6KaLH6IZET+rYDlwfX9GSyp68rC/gcKtRRHC4+EWgAAAABJRU5ErkJggg=='>
        </div>
        <div class="footerRight">
            <p class="bottomText"><span class="biggerBottomText">&copy;</span>2020 SAP SE, All rights reserved.</p>
        </div>
    </div>
</body>

</html>
`;
    exports2.redirectSuccessHtml = redirectSuccessHtml;
  }
});

// ../lib/odata-client/dist/error.js
var require_error = __commonJS({
  "../lib/odata-client/dist/error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UnknownSystemAuthenticationType = exports2.BaseError = void 0;
    var BaseError = class extends Error {
      constructor(message, cause) {
        super(message);
        this.cause = cause;
      }
    };
    exports2.BaseError = BaseError;
    var UnknownSystemAuthenticationType = class extends BaseError {
      constructor(authType, cause) {
        super(`Unknown authenication type: [${authType}]`, cause);
        this.name = this.constructor.name;
      }
    };
    exports2.UnknownSystemAuthenticationType = UnknownSystemAuthenticationType;
  }
});

// ../lib/odata-client/dist/connection/error.js
var require_error2 = __commonJS({
  "../lib/odata-client/dist/connection/error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UAATimeoutError = exports2.TimeoutError = exports2.ConnectionError = void 0;
    var error_1 = require_error();
    var ConnectionError = class extends error_1.BaseError {
      constructor(message, cause) {
        super(message, cause);
        this.name = this.constructor.name;
      }
    };
    exports2.ConnectionError = ConnectionError;
    var TimeoutError = class extends error_1.BaseError {
      constructor(message, cause) {
        super(message, cause);
        this.name = this.constructor.name;
      }
    };
    exports2.TimeoutError = TimeoutError;
    var UAATimeoutError = class extends TimeoutError {
      constructor(message, cause) {
        super(message, cause);
        this.name = this.constructor.name;
      }
    };
    exports2.UAATimeoutError = UAATimeoutError;
  }
});

// ../lib/odata-client/node_modules/qs/lib/utils.js
var require_utils4 = __commonJS({
  "../lib/odata-client/node_modules/qs/lib/utils.js"(exports2, module2) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var hexTable = function() {
      var array = [];
      for (var i = 0; i < 256; ++i) {
        array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
      }
      return array;
    }();
    var compactQueue = function compactQueue2(queue) {
      while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];
        if (isArray(obj)) {
          var compacted = [];
          for (var j = 0; j < obj.length; ++j) {
            if (typeof obj[j] !== "undefined") {
              compacted.push(obj[j]);
            }
          }
          item.obj[item.prop] = compacted;
        }
      }
    };
    var arrayToObject = function arrayToObject2(source, options2) {
      var obj = options2 && options2.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== "undefined") {
          obj[i] = source[i];
        }
      }
      return obj;
    };
    var merge = function merge2(target, source, options2) {
      if (!source) {
        return target;
      }
      if (typeof source !== "object") {
        if (isArray(target)) {
          target.push(source);
        } else if (target && typeof target === "object") {
          if (options2 && (options2.plainObjects || options2.allowPrototypes) || !has.call(Object.prototype, source)) {
            target[source] = true;
          }
        } else {
          return [target, source];
        }
        return target;
      }
      if (!target || typeof target !== "object") {
        return [target].concat(source);
      }
      var mergeTarget = target;
      if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options2);
      }
      if (isArray(target) && isArray(source)) {
        source.forEach(function(item, i) {
          if (has.call(target, i)) {
            var targetItem = target[i];
            if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
              target[i] = merge2(targetItem, item, options2);
            } else {
              target.push(item);
            }
          } else {
            target[i] = item;
          }
        });
        return target;
      }
      return Object.keys(source).reduce(function(acc, key) {
        var value = source[key];
        if (has.call(acc, key)) {
          acc[key] = merge2(acc[key], value, options2);
        } else {
          acc[key] = value;
        }
        return acc;
      }, mergeTarget);
    };
    var assign2 = function assignSingleSource(target, source) {
      return Object.keys(source).reduce(function(acc, key) {
        acc[key] = source[key];
        return acc;
      }, target);
    };
    var decode = function(str, decoder, charset) {
      var strWithoutPlus = str.replace(/\+/g, " ");
      if (charset === "iso-8859-1") {
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
      }
      try {
        return decodeURIComponent(strWithoutPlus);
      } catch (e) {
        return strWithoutPlus;
      }
    };
    var encode = function encode2(str, defaultEncoder, charset) {
      if (str.length === 0) {
        return str;
      }
      var string = typeof str === "string" ? str : String(str);
      if (charset === "iso-8859-1") {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
          return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
        });
      }
      var out = "";
      for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);
        if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122) {
          out += string.charAt(i);
          continue;
        }
        if (c < 128) {
          out = out + hexTable[c];
          continue;
        }
        if (c < 2048) {
          out = out + (hexTable[192 | c >> 6] + hexTable[128 | c & 63]);
          continue;
        }
        if (c < 55296 || c >= 57344) {
          out = out + (hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63]);
          continue;
        }
        i += 1;
        c = 65536 + ((c & 1023) << 10 | string.charCodeAt(i) & 1023);
        out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
      }
      return out;
    };
    var compact = function compact2(value) {
      var queue = [{ obj: { o: value }, prop: "o" }];
      var refs = [];
      for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];
        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
          var key = keys[j];
          var val = obj[key];
          if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
            queue.push({ obj, prop: key });
            refs.push(val);
          }
        }
      }
      compactQueue(queue);
      return value;
    };
    var isRegExp = function isRegExp2(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    };
    var isBuffer = function isBuffer2(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    };
    var combine = function combine2(a, b) {
      return [].concat(a, b);
    };
    module2.exports = {
      arrayToObject,
      assign: assign2,
      combine,
      compact,
      decode,
      encode,
      isBuffer,
      isRegExp,
      merge
    };
  }
});

// ../lib/odata-client/node_modules/qs/lib/formats.js
var require_formats = __commonJS({
  "../lib/odata-client/node_modules/qs/lib/formats.js"(exports2, module2) {
    "use strict";
    var replace = String.prototype.replace;
    var percentTwenties = /%20/g;
    module2.exports = {
      "default": "RFC3986",
      formatters: {
        RFC1738: function(value) {
          return replace.call(value, percentTwenties, "+");
        },
        RFC3986: function(value) {
          return value;
        }
      },
      RFC1738: "RFC1738",
      RFC3986: "RFC3986"
    };
  }
});

// ../lib/odata-client/node_modules/qs/lib/stringify.js
var require_stringify2 = __commonJS({
  "../lib/odata-client/node_modules/qs/lib/stringify.js"(exports2, module2) {
    "use strict";
    var utils = require_utils4();
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var arrayPrefixGenerators = {
      brackets: function brackets(prefix) {
        return prefix + "[]";
      },
      comma: "comma",
      indices: function indices(prefix, key) {
        return prefix + "[" + key + "]";
      },
      repeat: function repeat(prefix) {
        return prefix;
      }
    };
    var isArray = Array.isArray;
    var push = Array.prototype.push;
    var pushToArray = function(arr, valueOrArray) {
      push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
    };
    var toISO = Date.prototype.toISOString;
    var defaults = {
      addQueryPrefix: false,
      allowDots: false,
      charset: "utf-8",
      charsetSentinel: false,
      delimiter: "&",
      encode: true,
      encoder: utils.encode,
      encodeValuesOnly: false,
      formatter: formats.formatters[formats["default"]],
      indices: false,
      serializeDate: function serializeDate(date) {
        return toISO.call(date);
      },
      skipNulls: false,
      strictNullHandling: false
    };
    var stringify = function stringify2(object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly, charset) {
      var obj = object;
      if (typeof filter === "function") {
        obj = filter(prefix, obj);
      } else if (obj instanceof Date) {
        obj = serializeDate(obj);
      } else if (generateArrayPrefix === "comma" && isArray(obj)) {
        obj = obj.join(",");
      }
      if (obj === null) {
        if (strictNullHandling) {
          return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset) : prefix;
        }
        obj = "";
      }
      if (typeof obj === "string" || typeof obj === "number" || typeof obj === "boolean" || utils.isBuffer(obj)) {
        if (encoder) {
          var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset);
          return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder, charset))];
        }
        return [formatter(prefix) + "=" + formatter(String(obj))];
      }
      var values = [];
      if (typeof obj === "undefined") {
        return values;
      }
      var objKeys;
      if (isArray(filter)) {
        objKeys = filter;
      } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
      }
      for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];
        if (skipNulls && obj[key] === null) {
          continue;
        }
        if (isArray(obj)) {
          pushToArray(values, stringify2(obj[key], typeof generateArrayPrefix === "function" ? generateArrayPrefix(prefix, key) : prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly, charset));
        } else {
          pushToArray(values, stringify2(obj[key], prefix + (allowDots ? "." + key : "[" + key + "]"), generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, formatter, encodeValuesOnly, charset));
        }
      }
      return values;
    };
    var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (opts.encoder !== null && opts.encoder !== void 0 && typeof opts.encoder !== "function") {
        throw new TypeError("Encoder has to be a function.");
      }
      var charset = opts.charset || defaults.charset;
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var format2 = formats["default"];
      if (typeof opts.format !== "undefined") {
        if (!has.call(formats.formatters, opts.format)) {
          throw new TypeError("Unknown format option provided.");
        }
        format2 = opts.format;
      }
      var formatter = formats.formatters[format2];
      var filter = defaults.filter;
      if (typeof opts.filter === "function" || isArray(opts.filter)) {
        filter = opts.filter;
      }
      return {
        addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
        encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter,
        formatter,
        serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === "function" ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module2.exports = function(object, opts) {
      var obj = object;
      var options2 = normalizeStringifyOptions(opts);
      var objKeys;
      var filter;
      if (typeof options2.filter === "function") {
        filter = options2.filter;
        obj = filter("", obj);
      } else if (isArray(options2.filter)) {
        filter = options2.filter;
        objKeys = filter;
      }
      var keys = [];
      if (typeof obj !== "object" || obj === null) {
        return "";
      }
      var arrayFormat;
      if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
      } else if (opts && "indices" in opts) {
        arrayFormat = opts.indices ? "indices" : "repeat";
      } else {
        arrayFormat = "indices";
      }
      var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
      if (!objKeys) {
        objKeys = Object.keys(obj);
      }
      if (options2.sort) {
        objKeys.sort(options2.sort);
      }
      for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];
        if (options2.skipNulls && obj[key] === null) {
          continue;
        }
        pushToArray(keys, stringify(obj[key], key, generateArrayPrefix, options2.strictNullHandling, options2.skipNulls, options2.encode ? options2.encoder : null, options2.filter, options2.sort, options2.allowDots, options2.serializeDate, options2.formatter, options2.encodeValuesOnly, options2.charset));
      }
      var joined = keys.join(options2.delimiter);
      var prefix = options2.addQueryPrefix === true ? "?" : "";
      if (options2.charsetSentinel) {
        if (options2.charset === "iso-8859-1") {
          prefix += "utf8=%26%2310003%3B&";
        } else {
          prefix += "utf8=%E2%9C%93&";
        }
      }
      return joined.length > 0 ? prefix + joined : "";
    };
  }
});

// ../lib/odata-client/node_modules/qs/lib/parse.js
var require_parse2 = __commonJS({
  "../lib/odata-client/node_modules/qs/lib/parse.js"(exports2, module2) {
    "use strict";
    var utils = require_utils4();
    var has = Object.prototype.hasOwnProperty;
    var defaults = {
      allowDots: false,
      allowPrototypes: false,
      arrayLimit: 20,
      charset: "utf-8",
      charsetSentinel: false,
      comma: false,
      decoder: utils.decode,
      delimiter: "&",
      depth: 5,
      ignoreQueryPrefix: false,
      interpretNumericEntities: false,
      parameterLimit: 1e3,
      parseArrays: true,
      plainObjects: false,
      strictNullHandling: false
    };
    var interpretNumericEntities = function(str) {
      return str.replace(/&#(\d+);/g, function($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
      });
    };
    var isoSentinel = "utf8=%26%2310003%3B";
    var charsetSentinel = "utf8=%E2%9C%93";
    var parseValues = function parseQueryStringValues(str, options2) {
      var obj = {};
      var cleanStr = options2.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
      var limit = options2.parameterLimit === Infinity ? void 0 : options2.parameterLimit;
      var parts = cleanStr.split(options2.delimiter, limit);
      var skipIndex = -1;
      var i;
      var charset = options2.charset;
      if (options2.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
          if (parts[i].indexOf("utf8=") === 0) {
            if (parts[i] === charsetSentinel) {
              charset = "utf-8";
            } else if (parts[i] === isoSentinel) {
              charset = "iso-8859-1";
            }
            skipIndex = i;
            i = parts.length;
          }
        }
      }
      for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
          continue;
        }
        var part = parts[i];
        var bracketEqualsPos = part.indexOf("]=");
        var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
        var key, val;
        if (pos === -1) {
          key = options2.decoder(part, defaults.decoder, charset);
          val = options2.strictNullHandling ? null : "";
        } else {
          key = options2.decoder(part.slice(0, pos), defaults.decoder, charset);
          val = options2.decoder(part.slice(pos + 1), defaults.decoder, charset);
        }
        if (val && options2.interpretNumericEntities && charset === "iso-8859-1") {
          val = interpretNumericEntities(val);
        }
        if (val && options2.comma && val.indexOf(",") > -1) {
          val = val.split(",");
        }
        if (has.call(obj, key)) {
          obj[key] = utils.combine(obj[key], val);
        } else {
          obj[key] = val;
        }
      }
      return obj;
    };
    var parseObject = function(chain, val, options2) {
      var leaf = val;
      for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];
        if (root === "[]" && options2.parseArrays) {
          obj = [].concat(leaf);
        } else {
          obj = options2.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
          var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
          var index = parseInt(cleanRoot, 10);
          if (!options2.parseArrays && cleanRoot === "") {
            obj = { 0: leaf };
          } else if (!isNaN(index) && root !== cleanRoot && String(index) === cleanRoot && index >= 0 && (options2.parseArrays && index <= options2.arrayLimit)) {
            obj = [];
            obj[index] = leaf;
          } else {
            obj[cleanRoot] = leaf;
          }
        }
        leaf = obj;
      }
      return leaf;
    };
    var parseKeys = function parseQueryStringKeys(givenKey, val, options2) {
      if (!givenKey) {
        return;
      }
      var key = options2.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
      var brackets = /(\[[^[\]]*])/;
      var child = /(\[[^[\]]*])/g;
      var segment = brackets.exec(key);
      var parent = segment ? key.slice(0, segment.index) : key;
      var keys = [];
      if (parent) {
        if (!options2.plainObjects && has.call(Object.prototype, parent)) {
          if (!options2.allowPrototypes) {
            return;
          }
        }
        keys.push(parent);
      }
      var i = 0;
      while ((segment = child.exec(key)) !== null && i < options2.depth) {
        i += 1;
        if (!options2.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
          if (!options2.allowPrototypes) {
            return;
          }
        }
        keys.push(segment[1]);
      }
      if (segment) {
        keys.push("[" + key.slice(segment.index) + "]");
      }
      return parseObject(keys, val, options2);
    };
    var normalizeParseOptions = function normalizeParseOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
        throw new TypeError("Decoder has to be a function.");
      }
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new Error("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
      return {
        allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
        arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
        decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        depth: typeof opts.depth === "number" ? opts.depth : defaults.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module2.exports = function(str, opts) {
      var options2 = normalizeParseOptions(opts);
      if (str === "" || str === null || typeof str === "undefined") {
        return options2.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      }
      var tempObj = typeof str === "string" ? parseValues(str, options2) : str;
      var obj = options2.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var keys = Object.keys(tempObj);
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options2);
        obj = utils.merge(obj, newObj, options2);
      }
      return utils.compact(obj);
    };
  }
});

// ../lib/odata-client/node_modules/qs/lib/index.js
var require_lib = __commonJS({
  "../lib/odata-client/node_modules/qs/lib/index.js"(exports2, module2) {
    "use strict";
    var stringify = require_stringify2();
    var parse2 = require_parse2();
    var formats = require_formats();
    module2.exports = {
      formats,
      parse: parse2,
      stringify
    };
  }
});

// ../lib/odata-client/dist/connection/utils.js
var require_utils5 = __commonJS({
  "../lib/odata-client/dist/connection/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.timeString = exports2.timeoutMs = void 0;
    exports2.timeoutMs = 60 * 1e3;
    var timeString = (ms = exports2.timeoutMs) => {
      const min = ms / 60 / 1e3;
      if (min > 1) {
        return `${min} minutes`;
      } else if (min === 1) {
        return "1 minute";
      } else {
        return `${ms / 1e3} seconds`;
      }
    };
    exports2.timeString = timeString;
  }
});

// ../lib/odata-client/dist/connection/uaaOauth.js
var require_uaaOauth = __commonJS({
  "../lib/odata-client/dist/connection/uaaOauth.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.connectUsingUaaClientCredential = exports2.connectUsingUaa = exports2.defaultUtils = exports2.getServiceInfo = void 0;
    var open = require_open();
    var http_1 = __importDefault(require("http"));
    var axios_1 = __importDefault(require_axios2());
    var express_1 = __importDefault(require("express"));
    var fs_1 = require("fs");
    var _1 = require_connection();
    var common_1 = require_common3();
    var static_1 = require_static();
    var error_1 = require_error2();
    var qs_1 = __importDefault(require_lib());
    var utils_1 = require_utils5();
    var Redirect = class {
      constructor(port) {
        this.port = port;
      }
      url() {
        return `http://localhost:${this.port}${Redirect.path}`;
      }
    };
    Redirect.path = "/oauth/client/redirect";
    function getAuthCode({ uaa, log: log4, timeout = utils_1.timeoutMs }) {
      return new Promise((resolve, reject) => {
        const app = express_1.default();
        const server = http_1.default.createServer(app);
        let redirect;
        const handleTimeout = () => {
          server.close();
          reject(new error_1.UAATimeoutError(`Timeout. Did not get a response within ${utils_1.timeString(timeout)}`));
        };
        const timer = setTimeout(handleTimeout, timeout);
        app.get(Redirect.path, (req, res) => {
          res.set("Content-Type", "text/html");
          res.send(Buffer.from(static_1.redirectSuccessHtml(uaa.logoutUrl, uaa.systemId)));
          log4.info("Got authCode");
          resolve({ authCode: req.query.code + "", redirect });
          if (timer) {
            clearTimeout(timer);
          }
          server.close();
        });
        server.listen();
        redirect = new Redirect(server.address().port);
        const oauthUrl = uaa.getAuthCodeUrl({ redirectUri: redirect.url() });
        open(oauthUrl);
      });
    }
    async function getAccessToken({ uaa, log: log4, postConnectionCallback, refreshToken }) {
      var _a2;
      let response;
      let startFreshLogin = false;
      let newRefreshToken;
      if (refreshToken) {
        log4.info("Refresh token passed in");
        const tokenRequest = uaa.getTokenRequestForRefreshToken(refreshToken);
        try {
          response = await axios_1.default.request(tokenRequest);
          if (response.status === 401 || response.data.error === "invalid_token") {
            startFreshLogin = true;
            log4.warn("Cannot use stored refresh token. Starting fresh request");
          } else {
            if (refreshToken !== response.data.refresh_token) {
              log4.info("New refresh token issued");
              newRefreshToken = response.data.refresh_token;
            }
          }
        } catch (e) {
          startFreshLogin = true;
        }
      }
      if (!refreshToken || startFreshLogin) {
        const { authCode, redirect } = await getAuthCode({ uaa, log: log4 });
        const tokenRequest = uaa.getTokenRequestForAuthCode({
          redirectUri: redirect.url(),
          authCode
        });
        response = await axios_1.default.request(tokenRequest);
        log4.info("Storing refresh token");
        newRefreshToken = response.data.refresh_token;
      }
      if (postConnectionCallback) {
        await runPostConnectionCallback({
          log: log4,
          uaa,
          accessToken: response.data.access_token,
          postConnectionCallback,
          newRefreshToken
        });
      }
      log4.info("Got access token successfully");
      return (_a2 = response == null ? void 0 : response.data) == null ? void 0 : _a2.access_token;
    }
    async function getAccessTokenByUaaClientCredential({ uaa, log: log4 }) {
      try {
        const tokenRequest = uaa.getAccessTokenRequestUsingClientCredential();
        const response = await axios_1.default.request(tokenRequest);
        log4.info("Receiving response from OAuth2 Client Credential grant type");
        return response.data.access_token;
      } catch (e) {
        if (e instanceof error_1.ConnectionError) {
          throw e;
        }
        throw new error_1.ConnectionError(e.message, e);
      }
    }
    async function runPostConnectionCallback({ log: log4, uaa, accessToken, postConnectionCallback: cb, newRefreshToken }) {
      if (cb.sync) {
        try {
          let userDisplayName;
          if (cb.updateUserInfo) {
            userDisplayName = await getUserInfo(uaa, accessToken);
          }
          cb.fn({ user: userDisplayName, refreshToken: newRefreshToken });
        } catch (e) {
          log4.warn(e);
        }
      } else {
        return processCallbackAsync({
          log: log4,
          uaa,
          accessToken,
          updateFunction: cb.fn,
          fetchUserInfo: cb.updateUserInfo,
          newRefreshToken
        });
      }
    }
    async function getUserInfo(uaa, accessToken) {
      var _a2, _b;
      const userInfoResp = await axios_1.default.request(uaa.getUserinfoRequest(accessToken));
      return ((_a2 = userInfoResp == null ? void 0 : userInfoResp.data) == null ? void 0 : _a2.email) || ((_b = userInfoResp == null ? void 0 : userInfoResp.data) == null ? void 0 : _b.name);
    }
    async function processCallbackAsync({ log: log4, uaa, accessToken, updateFunction, newRefreshToken, fetchUserInfo }) {
      if (newRefreshToken) {
        log4.info("Trying to save refreshToken");
        try {
          await updateFunction({ refreshToken: newRefreshToken });
        } catch (e) {
          log4.warn(e.message);
        }
      }
      if (fetchUserInfo) {
        log4.info("Scheduling user info fetch");
        setTimeout(async () => {
          try {
            log4.info("Fetching user info");
            const userDisplayName = await getUserInfo(uaa, accessToken);
            log4.info(`Username: [${userDisplayName}]`);
            if (userDisplayName) {
              log4.info("Trying to update user name in system details");
              await updateFunction({ user: userDisplayName });
            }
          } catch (e) {
            log4.warn(e.message);
          }
        }, 1);
      }
    }
    var Uaa = class {
      constructor(serviceInfo) {
        this.validatePropertyExists(serviceInfo.uaa.clientid, "Client ID missing");
        this.validatePropertyExists(serviceInfo.uaa.clientsecret, "Client Secret missing");
        this.validatePropertyExists(serviceInfo.uaa.url, "UAA URL missing");
        this.serviceInfo = serviceInfo;
      }
      validatePropertyExists(property, errMsg) {
        if (!property) {
          throw Error(errMsg);
        }
      }
      get url() {
        return this.serviceInfo.uaa.url;
      }
      get clientid() {
        return this.serviceInfo.uaa.clientid;
      }
      get clientsecret() {
        return this.serviceInfo.uaa.clientsecret;
      }
      get username() {
        return this.serviceInfo.uaa.username;
      }
      get password() {
        return this.serviceInfo.uaa.password;
      }
      get logoutUrl() {
        return this.url + "/logout.do";
      }
      get systemId() {
        return this.serviceInfo.systemid;
      }
      getAuthCodeUrl({ redirectUri }) {
        return this.url + "/oauth/authorize?" + qs_1.default.stringify({
          response_type: "code",
          redirect_uri: redirectUri,
          client_id: this.clientid
        });
      }
      getTokenRequestForAuthCode({ redirectUri, authCode }) {
        return {
          url: this.url + "/oauth/token",
          auth: { username: this.clientid, password: this.clientsecret },
          method: "POST",
          data: qs_1.default.stringify({
            code: authCode,
            grant_type: "authorization_code",
            redirect_uri: redirectUri,
            response_type: "token"
          }),
          headers: {
            "Content-Type": "application/x-www-form-urlencoded",
            Accept: "application/json"
          }
        };
      }
      getAccessTokenRequestUsingClientCredential() {
        return {
          url: this.url,
          method: "POST",
          data: qs_1.default.stringify({
            grant_type: "password",
            username: this.username,
            password: this.password
          }),
          headers: {
            "Content-Type": "application/x-www-form-urlencoded",
            Accept: "application/json",
            Authorization: `Basic ${Buffer.from(this.clientid + ":" + this.clientsecret).toString("base64")}`
          }
        };
      }
      getTokenRequestForRefreshToken(refreshToken) {
        return {
          url: this.url + "/oauth/token",
          auth: { username: this.clientid, password: this.clientsecret },
          method: "POST",
          data: qs_1.default.stringify({
            grant_type: "refresh_token",
            refresh_token: refreshToken
          }),
          headers: {
            "Content-Type": "application/x-www-form-urlencoded",
            Accept: "application/json"
          }
        };
      }
      getUserinfoRequest(accessToken) {
        return {
          url: this.url + "/userinfo",
          method: "GET",
          headers: {
            authorization: `bearer ${accessToken}`
          }
        };
      }
    };
    async function newConnection(target, accessToken) {
      var _a2;
      const url = `${target.url}${target.service}${target.client ? "?sap-client=" + target.client : ""}`;
      const response = await axios_1.default.get(url, {
        headers: {
          authorization: `bearer ${accessToken}`,
          [common_1.CSRF.requestHeaderName]: common_1.CSRF.requestHeaderValue
        }
      });
      return {
        cookies: new _1.Cookies().setCookie(response),
        xsrfToken: (_a2 = response.headers) == null ? void 0 : _a2[common_1.CSRF.responseHeaderName]
      };
    }
    function getServiceInfo(credentials) {
      try {
        if (credentials.serviceKeysContents) {
          return typeof credentials.serviceKeyContents === "string" ? JSON.parse(credentials.serviceKeysContents) : credentials.serviceKeysContents;
        }
        return JSON.parse(fs_1.readFileSync(credentials.serviceKeys, "utf-8"));
      } catch (e) {
        throw new Error("Error parsing service keys");
      }
    }
    exports2.getServiceInfo = getServiceInfo;
    exports2.defaultUtils = {
      serviceInfo: getServiceInfo,
      connection: newConnection,
      accessToken: getAccessToken,
      accessTokenByUaaClientCredential: getAccessTokenByUaaClientCredential
    };
    async function connectUsingUaa({ target, credentials, log: log4 = console, uaaUtils = exports2.defaultUtils, postConnectionCallback }) {
      try {
        const uaa = new Uaa(credentials.serviceInfo || uaaUtils.serviceInfo(credentials));
        const token2 = await uaaUtils.accessToken({
          uaa,
          log: log4,
          postConnectionCallback,
          refreshToken: credentials.refreshToken
        });
        return await uaaUtils.connection(target, token2);
      } catch (e) {
        log4.error(e.message);
        if (e instanceof error_1.ConnectionError) {
          throw e;
        }
        throw new error_1.ConnectionError(e.message, e);
      }
    }
    exports2.connectUsingUaa = connectUsingUaa;
    async function connectUsingUaaClientCredential({ target, credentials, log: log4 = console, uaaUtils = exports2.defaultUtils }) {
      let accessToken;
      try {
        const uaa = new Uaa(credentials.serviceInfo);
        accessToken = await uaaUtils.accessTokenByUaaClientCredential({
          uaa,
          log: log4
        });
      } catch (e) {
        log4.error(`Failed to obtain OAuth2 access token: ${e.message}`);
        if (e instanceof error_1.ConnectionError) {
          throw e;
        }
        throw new error_1.ConnectionError(e.message, e);
      }
      try {
        return await uaaUtils.connection(target, accessToken);
      } catch (e) {
        log4.error(e.message);
        if (e instanceof error_1.ConnectionError) {
          throw e;
        }
        throw new error_1.ConnectionError(e.message, e);
      }
    }
    exports2.connectUsingUaaClientCredential = connectUsingUaaClientCredential;
  }
});

// ../lib/odata-client/dist/connection/connectWithReentranceTicket.js
var require_connectWithReentranceTicket = __commonJS({
  "../lib/odata-client/dist/connection/connectWithReentranceTicket.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.connectWithReentranceTicket = void 0;
    var axios_1 = __importDefault(require_axios2());
    var common_1 = require_common3();
    var express_1 = __importDefault(require("express"));
    var http_1 = __importDefault(require("http"));
    var https_1 = __importDefault(require("https"));
    var error_1 = require_error2();
    var utils_1 = require_utils5();
    var static_1 = require_static();
    var _1 = require_connection();
    var open = require_open();
    var ABAPSystem = class {
      static uiHostname(hostname) {
        const [first, ...rest] = hostname.split(".");
        return [first.replace("-api", ""), ...rest].join(".");
      }
      static apiHostname(hostname) {
        const [first, ...rest] = hostname.split(".");
        return !first.match(/.*-api$/) ? [first + "-api", ...rest].join(".") : hostname;
      }
      static logoffUrl(hostname) {
        return this.uiHostname(hostname) + "/sap/public/bc/icf/logoff";
      }
    };
    async function connectWithReentranceTicket({ target, ignoreCertError = false, logger = console }) {
      const reentranceTicket = await getReentranceTicket({ backendUrl: target.url, logger });
      const response = await axios_1.default.get(ABAPSystem.apiHostname(target.url) + target.service + "/", {
        params: {},
        headers: {
          MYSAPSSO2: reentranceTicket,
          [common_1.CSRF.requestHeaderName]: common_1.CSRF.requestHeaderValue
        },
        httpsAgent: new https_1.default.Agent({
          rejectUnauthorized: !ignoreCertError
        })
      });
      return {
        cookies: new _1.Cookies().setCookie(response),
        xsrfToken: response.headers[common_1.CSRF.responseHeaderName]
      };
    }
    exports2.connectWithReentranceTicket = connectWithReentranceTicket;
    var ADT_REENTRANCE_ENDPOINT = "/sap/bc/adt/core/http/reentranceticket";
    async function getReentranceTicket({ backendUrl, logger, timeout = utils_1.timeoutMs }) {
      return new Promise((resolve, reject) => {
        const app = express_1.default();
        const server = http_1.default.createServer(app);
        const handleTimeout = () => {
          server.close();
          reject(new error_1.TimeoutError(`Timeout. Did not get a response within ${utils_1.timeString(timeout)}`));
        };
        class Redirect {
          static url(port) {
            return "http://localhost:" + port + Redirect.path;
          }
        }
        Redirect.path = "/redirect";
        const timer = setTimeout(handleTimeout, timeout);
        app.get(Redirect.path, (req, res) => {
          var _a2;
          const reentranceTicket = (_a2 = req.query["reentrance-ticket"]) == null ? void 0 : _a2.toString();
          logger.info("Got reentrance ticket: " + reentranceTicket);
          res.set("Content-Type", "text/html");
          res.send(Buffer.from(static_1.redirectSuccessHtml(ABAPSystem.logoffUrl(backendUrl))));
          if (timer) {
            clearTimeout(timer);
          }
          server.close();
          resolve(reentranceTicket);
        });
        server.listen();
        const redirectPort = server.address().port;
        const url = `${ABAPSystem.uiHostname(backendUrl)}${ADT_REENTRANCE_ENDPOINT}?redirect-url=${Redirect.url(redirectPort)}`;
        open(url);
      });
    }
  }
});

// ../../node_modules/detect-content-type/lib/index.js
var require_lib2 = __commonJS({
  "../../node_modules/detect-content-type/lib/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = detectContentType;
    function detectContentType(content) {
      const data2 = content.slice(0, 512);
      let firstNonWS = 0;
      while (firstNonWS < data2.length && isWS(data2[firstNonWS])) {
        firstNonWS++;
      }
      for (let sig of sniffSignatures) {
        let ct = sig.match(data2, firstNonWS);
        if (ct != "") {
          return ct;
        }
      }
      return "application/octet-stream";
    }
    function isWS(b) {
      switch (b) {
        case "	".charCodeAt(0):
        case "\n".charCodeAt(0):
        case ",0x0c".charCodeAt(0):
        case "\r".charCodeAt(0):
        case " ".charCodeAt(0):
          return true;
      }
      return false;
    }
    var exactSig = class {
      constructor(sig, ct) {
        Object.assign(this, { sig, ct });
      }
      match(data2) {
        if (Buffer.compare(this.sig, data2.slice(0, this.sig.length)) == 0) {
          return this.ct;
        }
        return "";
      }
    };
    var maskedSig = class {
      constructor(mask, pat, skipWS, ct) {
        Object.assign(this, { mask, pat, skipWS, ct });
      }
      match(data2, firstNonWS) {
        if (this.skipWS) {
          data2 = data2.slice(firstNonWS);
        }
        if (this.pat.length != this.mask.length) {
          return "";
        }
        if (data2.length < this.mask.length) {
          return "";
        }
        for (let i = 0; i < this.mask.length; i++) {
          let db = data2[i] & this.mask[i];
          if (db != this.pat[i]) {
            return "";
          }
        }
        return this.ct;
      }
    };
    var htmlSig = class {
      constructor(h) {
        this.h = Buffer.from(h);
      }
      match(data2, firstNonWS) {
        data2 = data2.slice(firstNonWS);
        if (data2.length < this.h.length + 1) {
          return "";
        }
        for (let i = 0; i < this.h.length; i++) {
          let b = this.h[i];
          let db2 = data2[i];
          if ("A".charCodeAt(0) <= b && b <= "Z".charCodeAt(0)) {
            db2 &= 223;
          }
          if (b != db2) {
            return "";
          }
        }
        let db = String.fromCharCode(data2[this.h.length]);
        if (db != " " && db != ">") {
          return "";
        }
        return "text/html; charset=utf-8";
      }
    };
    var mp4ftype = Buffer.from("ftyp");
    var mp4 = Buffer.from("mp4");
    var mp4Sig = class {
      match(data2) {
        if (data2.length < 12) {
          return "";
        }
        let boxSize = data2.readUInt32BE(0);
        if (boxSize % 4 != 0 || data2.length < boxSize) {
          return "";
        }
        if (Buffer.compare(data2.slice(4, 8), mp4ftype) != 0) {
          return "";
        }
        for (let st = 8; st < boxSize; st += 4) {
          if (st == 12) {
            continue;
          }
          if (Buffer.compare(data2.slice(st, st + 3), mp4) == 0) {
            return "video/mp4";
          }
        }
        return "";
      }
    };
    var textSig = class {
      match(data2, firstNonWS) {
        for (let b of data2.slice(firstNonWS)) {
          if (b <= 8 || b == 11 || 14 <= b && b <= 26 || 28 <= b && b <= 31) {
            return "";
          }
        }
        return "text/plain; charset=utf-8";
      }
    };
    var sniffSignatures = [
      new htmlSig("<!DOCTYPE HTML"),
      new htmlSig("<HTML"),
      new htmlSig("<HEAD"),
      new htmlSig("<SCRIPT"),
      new htmlSig("<IFRAME"),
      new htmlSig("<H1"),
      new htmlSig("<DIV"),
      new htmlSig("<FONT"),
      new htmlSig("<TABLE"),
      new htmlSig("<A"),
      new htmlSig("<STYLE"),
      new htmlSig("<TITLE"),
      new htmlSig("<B"),
      new htmlSig("<BODY"),
      new htmlSig("<BR"),
      new htmlSig("<P"),
      new htmlSig("<!--"),
      new maskedSig(Buffer.from([255, 255, 255, 255, 255]), Buffer.from("<?xml"), true, "text/xml; charset=utf-8"),
      new exactSig(Buffer.from("%PDF-"), "application/pdf"),
      new exactSig(Buffer.from("%!PS-Adobe-"), "application/postscript"),
      new maskedSig(Buffer.from([255, 255, 0, 0]), Buffer.from([254, 255, 0, 0]), false, "text/plain; charset=utf-16be"),
      new maskedSig(Buffer.from([255, 255, 0, 0]), Buffer.from([255, 254, 0, 0]), false, "text/plain; charset=utf-16le"),
      new maskedSig(Buffer.from([255, 255, 255, 0]), Buffer.from([239, 187, 191, 0]), false, "text/plain; charset=utf-8"),
      new exactSig(Buffer.from("GIF87a"), "image/gif"),
      new exactSig(Buffer.from("GIF89a"), "image/gif"),
      new exactSig(Buffer.from([137, 80, 78, 71, 13, 10, 26, 10]), "image/png"),
      new exactSig(Buffer.from([255, 216, 255]), "image/jpeg"),
      new exactSig(Buffer.from("BM"), "image/bmp"),
      new maskedSig(Buffer.from([255, 255, 255, 255, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255]), Buffer.from("RIFF\0\0\0\0WEBPVP"), false, "image/webp"),
      new exactSig(Buffer.from([0, 0, 1, 0]), "image/vnd.microsoft.icon"),
      new maskedSig(Buffer.from([255, 255, 255, 255, 0, 0, 0, 0, 255, 255, 255, 255]), Buffer.from("RIFF\0\0\0\0WAVE"), false, "audio/wave"),
      new maskedSig(Buffer.from([255, 255, 255, 255, 0, 0, 0, 0, 255, 255, 255, 255]), Buffer.from("FORM\0\0\0\0AIFF"), false, "audio/aiff"),
      new maskedSig(Buffer.from([255, 255, 255, 255]), Buffer.from(".snd"), false, "audio/basic"),
      new maskedSig(Buffer.from([255, 255, 255, 255, 255]), Buffer.from("OggS\0"), false, "application/ogg"),
      new maskedSig(Buffer.from([255, 255, 255, 255, 255, 255, 255, 255]), Buffer.concat([Buffer.from("MThd"), Buffer.from([0, 0, 0, 6])]), false, "audio/midi"),
      new maskedSig(Buffer.from([255, 255, 255]), Buffer.from("ID3"), false, "audio/mpeg"),
      new maskedSig(Buffer.from([255, 255, 255, 255, 0, 0, 0, 0, 255, 255, 255, 255]), Buffer.from("RIFF\0\0\0\0AVI "), false, "video/avi"),
      new exactSig(Buffer.from([26, 69, 223, 163]), "video/webm"),
      new exactSig(Buffer.from([82, 97, 114, 32, 26, 7, 0]), "application/x-rar-compressed"),
      new exactSig(Buffer.from([80, 75, 3, 4]), "application/zip"),
      new exactSig(Buffer.from([31, 139, 8]), "application/x-gzip"),
      new mp4Sig(),
      new textSig()
    ];
    module2.exports = exports2["default"];
  }
});

// ../../node_modules/@sap/cf-tools/out/src/types.js
var require_types2 = __commonJS({
  "../../node_modules/@sap/cf-tools/out/src/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.eServiceTypes = exports2.eOrderDirection = exports2.eOperation = exports2.eFilters = exports2.CF_CMD_EXIT_CODE = exports2.DEFAULT_TARGET = exports2.CF_PAGE_SIZE = exports2.NEW_LINE = exports2.OK = void 0;
    exports2.OK = "OK";
    exports2.NEW_LINE = "\n";
    exports2.CF_PAGE_SIZE = 99 * 3;
    exports2.DEFAULT_TARGET = "Default (no targets)";
    var CF_CMD_EXIT_CODE;
    (function(CF_CMD_EXIT_CODE2) {
      CF_CMD_EXIT_CODE2[CF_CMD_EXIT_CODE2["OK"] = 0] = "OK";
      CF_CMD_EXIT_CODE2[CF_CMD_EXIT_CODE2["ERROR"] = -1] = "ERROR";
      CF_CMD_EXIT_CODE2[CF_CMD_EXIT_CODE2["CANCEL_REQ"] = -2] = "CANCEL_REQ";
      CF_CMD_EXIT_CODE2[CF_CMD_EXIT_CODE2["CANCELED"] = -3] = "CANCELED";
    })(CF_CMD_EXIT_CODE = exports2.CF_CMD_EXIT_CODE || (exports2.CF_CMD_EXIT_CODE = {}));
    var eFilters;
    (function(eFilters2) {
      eFilters2["type"] = "type";
      eFilters2["names"] = "names";
      eFilters2["guids"] = "guids";
      eFilters2["app_guids"] = "app_guids";
      eFilters2["app_names"] = "app_names";
      eFilters2["space_guids"] = "space_guids";
      eFilters2["available"] = "available";
      eFilters2["broker_catalog_ids"] = "broker_catalog_ids";
      eFilters2["service_broker_guids"] = "service_broker_guids";
      eFilters2["service_broker_names"] = "service_broker_names";
      eFilters2["service_plan_guids"] = "service_plan_guids";
      eFilters2["organization_guids"] = "organization_guids";
      eFilters2["service_plan_names"] = "service_plan_names";
      eFilters2["service_plan"] = "service_plan";
      eFilters2["service_instance_guids"] = "service_instance_guids";
      eFilters2["service_instance_names"] = "service_instance_names";
      eFilters2["service_offering_guids"] = "service_offering_guids";
      eFilters2["service_offering_names"] = "service_offering_names";
      eFilters2["label_selector"] = "label_selector";
      eFilters2["page"] = "page";
      eFilters2["per_page"] = "per_page";
      eFilters2["oder_by"] = "order_by";
      eFilters2["created_ats"] = "created_ats";
      eFilters2["updated_ats"] = "updated_ats";
      eFilters2["status"] = "status";
      eFilters2["include"] = "include";
    })(eFilters = exports2.eFilters || (exports2.eFilters = {}));
    var eOperation;
    (function(eOperation2) {
      eOperation2["gte"] = "gte";
      eOperation2["lte"] = "lte";
      eOperation2["lt"] = "lt";
      eOperation2["gt"] = "gt";
      eOperation2["not"] = "not";
      eOperation2["fields"] = "fields";
    })(eOperation = exports2.eOperation || (exports2.eOperation = {}));
    var eOrderDirection;
    (function(eOrderDirection2) {
      eOrderDirection2[eOrderDirection2["asc"] = 0] = "asc";
      eOrderDirection2[eOrderDirection2["desc"] = 1] = "desc";
    })(eOrderDirection = exports2.eOrderDirection || (exports2.eOrderDirection = {}));
    var eServiceTypes;
    (function(eServiceTypes2) {
      eServiceTypes2["managed"] = "managed";
      eServiceTypes2["user_provided"] = "user-provided";
    })(eServiceTypes = exports2.eServiceTypes || (exports2.eServiceTypes = {}));
  }
});

// ../../node_modules/esprima/dist/esprima.js
var require_esprima = __commonJS({
  "../../node_modules/esprima/dist/esprima.js"(exports2, module2) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports2 === "object" && typeof module2 === "object")
        module2.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else if (typeof exports2 === "object")
        exports2["esprima"] = factory();
      else
        root["esprima"] = factory();
    })(exports2, function() {
      return function(modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
          if (installedModules[moduleId])
            return installedModules[moduleId].exports;
          var module3 = installedModules[moduleId] = {
            exports: {},
            id: moduleId,
            loaded: false
          };
          modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__);
          module3.loaded = true;
          return module3.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.p = "";
        return __webpack_require__(0);
      }([
        function(module3, exports3, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports3, "__esModule", { value: true });
          var comment_handler_1 = __webpack_require__(1);
          var jsx_parser_1 = __webpack_require__(3);
          var parser_1 = __webpack_require__(8);
          var tokenizer_1 = __webpack_require__(15);
          function parse2(code, options2, delegate) {
            var commentHandler = null;
            var proxyDelegate = function(node, metadata) {
              if (delegate) {
                delegate(node, metadata);
              }
              if (commentHandler) {
                commentHandler.visit(node, metadata);
              }
            };
            var parserDelegate = typeof delegate === "function" ? proxyDelegate : null;
            var collectComment = false;
            if (options2) {
              collectComment = typeof options2.comment === "boolean" && options2.comment;
              var attachComment = typeof options2.attachComment === "boolean" && options2.attachComment;
              if (collectComment || attachComment) {
                commentHandler = new comment_handler_1.CommentHandler();
                commentHandler.attach = attachComment;
                options2.comment = true;
                parserDelegate = proxyDelegate;
              }
            }
            var isModule = false;
            if (options2 && typeof options2.sourceType === "string") {
              isModule = options2.sourceType === "module";
            }
            var parser;
            if (options2 && typeof options2.jsx === "boolean" && options2.jsx) {
              parser = new jsx_parser_1.JSXParser(code, options2, parserDelegate);
            } else {
              parser = new parser_1.Parser(code, options2, parserDelegate);
            }
            var program = isModule ? parser.parseModule() : parser.parseScript();
            var ast = program;
            if (collectComment && commentHandler) {
              ast.comments = commentHandler.comments;
            }
            if (parser.config.tokens) {
              ast.tokens = parser.tokens;
            }
            if (parser.config.tolerant) {
              ast.errors = parser.errorHandler.errors;
            }
            return ast;
          }
          exports3.parse = parse2;
          function parseModule(code, options2, delegate) {
            var parsingOptions = options2 || {};
            parsingOptions.sourceType = "module";
            return parse2(code, parsingOptions, delegate);
          }
          exports3.parseModule = parseModule;
          function parseScript(code, options2, delegate) {
            var parsingOptions = options2 || {};
            parsingOptions.sourceType = "script";
            return parse2(code, parsingOptions, delegate);
          }
          exports3.parseScript = parseScript;
          function tokenize(code, options2, delegate) {
            var tokenizer = new tokenizer_1.Tokenizer(code, options2);
            var tokens;
            tokens = [];
            try {
              while (true) {
                var token2 = tokenizer.getNextToken();
                if (!token2) {
                  break;
                }
                if (delegate) {
                  token2 = delegate(token2);
                }
                tokens.push(token2);
              }
            } catch (e) {
              tokenizer.errorHandler.tolerate(e);
            }
            if (tokenizer.errorHandler.tolerant) {
              tokens.errors = tokenizer.errors();
            }
            return tokens;
          }
          exports3.tokenize = tokenize;
          var syntax_1 = __webpack_require__(2);
          exports3.Syntax = syntax_1.Syntax;
          exports3.version = "4.0.1";
        },
        function(module3, exports3, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports3, "__esModule", { value: true });
          var syntax_1 = __webpack_require__(2);
          var CommentHandler = function() {
            function CommentHandler2() {
              this.attach = false;
              this.comments = [];
              this.stack = [];
              this.leading = [];
              this.trailing = [];
            }
            CommentHandler2.prototype.insertInnerComments = function(node, metadata) {
              if (node.type === syntax_1.Syntax.BlockStatement && node.body.length === 0) {
                var innerComments = [];
                for (var i = this.leading.length - 1; i >= 0; --i) {
                  var entry = this.leading[i];
                  if (metadata.end.offset >= entry.start) {
                    innerComments.unshift(entry.comment);
                    this.leading.splice(i, 1);
                    this.trailing.splice(i, 1);
                  }
                }
                if (innerComments.length) {
                  node.innerComments = innerComments;
                }
              }
            };
            CommentHandler2.prototype.findTrailingComments = function(metadata) {
              var trailingComments = [];
              if (this.trailing.length > 0) {
                for (var i = this.trailing.length - 1; i >= 0; --i) {
                  var entry_1 = this.trailing[i];
                  if (entry_1.start >= metadata.end.offset) {
                    trailingComments.unshift(entry_1.comment);
                  }
                }
                this.trailing.length = 0;
                return trailingComments;
              }
              var entry = this.stack[this.stack.length - 1];
              if (entry && entry.node.trailingComments) {
                var firstComment = entry.node.trailingComments[0];
                if (firstComment && firstComment.range[0] >= metadata.end.offset) {
                  trailingComments = entry.node.trailingComments;
                  delete entry.node.trailingComments;
                }
              }
              return trailingComments;
            };
            CommentHandler2.prototype.findLeadingComments = function(metadata) {
              var leadingComments = [];
              var target;
              while (this.stack.length > 0) {
                var entry = this.stack[this.stack.length - 1];
                if (entry && entry.start >= metadata.start.offset) {
                  target = entry.node;
                  this.stack.pop();
                } else {
                  break;
                }
              }
              if (target) {
                var count = target.leadingComments ? target.leadingComments.length : 0;
                for (var i = count - 1; i >= 0; --i) {
                  var comment = target.leadingComments[i];
                  if (comment.range[1] <= metadata.start.offset) {
                    leadingComments.unshift(comment);
                    target.leadingComments.splice(i, 1);
                  }
                }
                if (target.leadingComments && target.leadingComments.length === 0) {
                  delete target.leadingComments;
                }
                return leadingComments;
              }
              for (var i = this.leading.length - 1; i >= 0; --i) {
                var entry = this.leading[i];
                if (entry.start <= metadata.start.offset) {
                  leadingComments.unshift(entry.comment);
                  this.leading.splice(i, 1);
                }
              }
              return leadingComments;
            };
            CommentHandler2.prototype.visitNode = function(node, metadata) {
              if (node.type === syntax_1.Syntax.Program && node.body.length > 0) {
                return;
              }
              this.insertInnerComments(node, metadata);
              var trailingComments = this.findTrailingComments(metadata);
              var leadingComments = this.findLeadingComments(metadata);
              if (leadingComments.length > 0) {
                node.leadingComments = leadingComments;
              }
              if (trailingComments.length > 0) {
                node.trailingComments = trailingComments;
              }
              this.stack.push({
                node,
                start: metadata.start.offset
              });
            };
            CommentHandler2.prototype.visitComment = function(node, metadata) {
              var type = node.type[0] === "L" ? "Line" : "Block";
              var comment = {
                type,
                value: node.value
              };
              if (node.range) {
                comment.range = node.range;
              }
              if (node.loc) {
                comment.loc = node.loc;
              }
              this.comments.push(comment);
              if (this.attach) {
                var entry = {
                  comment: {
                    type,
                    value: node.value,
                    range: [metadata.start.offset, metadata.end.offset]
                  },
                  start: metadata.start.offset
                };
                if (node.loc) {
                  entry.comment.loc = node.loc;
                }
                node.type = type;
                this.leading.push(entry);
                this.trailing.push(entry);
              }
            };
            CommentHandler2.prototype.visit = function(node, metadata) {
              if (node.type === "LineComment") {
                this.visitComment(node, metadata);
              } else if (node.type === "BlockComment") {
                this.visitComment(node, metadata);
              } else if (this.attach) {
                this.visitNode(node, metadata);
              }
            };
            return CommentHandler2;
          }();
          exports3.CommentHandler = CommentHandler;
        },
        function(module3, exports3) {
          "use strict";
          Object.defineProperty(exports3, "__esModule", { value: true });
          exports3.Syntax = {
            AssignmentExpression: "AssignmentExpression",
            AssignmentPattern: "AssignmentPattern",
            ArrayExpression: "ArrayExpression",
            ArrayPattern: "ArrayPattern",
            ArrowFunctionExpression: "ArrowFunctionExpression",
            AwaitExpression: "AwaitExpression",
            BlockStatement: "BlockStatement",
            BinaryExpression: "BinaryExpression",
            BreakStatement: "BreakStatement",
            CallExpression: "CallExpression",
            CatchClause: "CatchClause",
            ClassBody: "ClassBody",
            ClassDeclaration: "ClassDeclaration",
            ClassExpression: "ClassExpression",
            ConditionalExpression: "ConditionalExpression",
            ContinueStatement: "ContinueStatement",
            DoWhileStatement: "DoWhileStatement",
            DebuggerStatement: "DebuggerStatement",
            EmptyStatement: "EmptyStatement",
            ExportAllDeclaration: "ExportAllDeclaration",
            ExportDefaultDeclaration: "ExportDefaultDeclaration",
            ExportNamedDeclaration: "ExportNamedDeclaration",
            ExportSpecifier: "ExportSpecifier",
            ExpressionStatement: "ExpressionStatement",
            ForStatement: "ForStatement",
            ForOfStatement: "ForOfStatement",
            ForInStatement: "ForInStatement",
            FunctionDeclaration: "FunctionDeclaration",
            FunctionExpression: "FunctionExpression",
            Identifier: "Identifier",
            IfStatement: "IfStatement",
            ImportDeclaration: "ImportDeclaration",
            ImportDefaultSpecifier: "ImportDefaultSpecifier",
            ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
            ImportSpecifier: "ImportSpecifier",
            Literal: "Literal",
            LabeledStatement: "LabeledStatement",
            LogicalExpression: "LogicalExpression",
            MemberExpression: "MemberExpression",
            MetaProperty: "MetaProperty",
            MethodDefinition: "MethodDefinition",
            NewExpression: "NewExpression",
            ObjectExpression: "ObjectExpression",
            ObjectPattern: "ObjectPattern",
            Program: "Program",
            Property: "Property",
            RestElement: "RestElement",
            ReturnStatement: "ReturnStatement",
            SequenceExpression: "SequenceExpression",
            SpreadElement: "SpreadElement",
            Super: "Super",
            SwitchCase: "SwitchCase",
            SwitchStatement: "SwitchStatement",
            TaggedTemplateExpression: "TaggedTemplateExpression",
            TemplateElement: "TemplateElement",
            TemplateLiteral: "TemplateLiteral",
            ThisExpression: "ThisExpression",
            ThrowStatement: "ThrowStatement",
            TryStatement: "TryStatement",
            UnaryExpression: "UnaryExpression",
            UpdateExpression: "UpdateExpression",
            VariableDeclaration: "VariableDeclaration",
            VariableDeclarator: "VariableDeclarator",
            WhileStatement: "WhileStatement",
            WithStatement: "WithStatement",
            YieldExpression: "YieldExpression"
          };
        },
        function(module3, exports3, __webpack_require__) {
          "use strict";
          var __extends2 = this && this.__extends || function() {
            var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
              d.__proto__ = b;
            } || function(d, b) {
              for (var p in b)
                if (b.hasOwnProperty(p))
                  d[p] = b[p];
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          Object.defineProperty(exports3, "__esModule", { value: true });
          var character_1 = __webpack_require__(4);
          var JSXNode = __webpack_require__(5);
          var jsx_syntax_1 = __webpack_require__(6);
          var Node = __webpack_require__(7);
          var parser_1 = __webpack_require__(8);
          var token_1 = __webpack_require__(13);
          var xhtml_entities_1 = __webpack_require__(14);
          token_1.TokenName[100] = "JSXIdentifier";
          token_1.TokenName[101] = "JSXText";
          function getQualifiedElementName(elementName) {
            var qualifiedName;
            switch (elementName.type) {
              case jsx_syntax_1.JSXSyntax.JSXIdentifier:
                var id = elementName;
                qualifiedName = id.name;
                break;
              case jsx_syntax_1.JSXSyntax.JSXNamespacedName:
                var ns = elementName;
                qualifiedName = getQualifiedElementName(ns.namespace) + ":" + getQualifiedElementName(ns.name);
                break;
              case jsx_syntax_1.JSXSyntax.JSXMemberExpression:
                var expr = elementName;
                qualifiedName = getQualifiedElementName(expr.object) + "." + getQualifiedElementName(expr.property);
                break;
              default:
                break;
            }
            return qualifiedName;
          }
          var JSXParser = function(_super) {
            __extends2(JSXParser2, _super);
            function JSXParser2(code, options2, delegate) {
              return _super.call(this, code, options2, delegate) || this;
            }
            JSXParser2.prototype.parsePrimaryExpression = function() {
              return this.match("<") ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);
            };
            JSXParser2.prototype.startJSX = function() {
              this.scanner.index = this.startMarker.index;
              this.scanner.lineNumber = this.startMarker.line;
              this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
            };
            JSXParser2.prototype.finishJSX = function() {
              this.nextToken();
            };
            JSXParser2.prototype.reenterJSX = function() {
              this.startJSX();
              this.expectJSX("}");
              if (this.config.tokens) {
                this.tokens.pop();
              }
            };
            JSXParser2.prototype.createJSXNode = function() {
              this.collectComments();
              return {
                index: this.scanner.index,
                line: this.scanner.lineNumber,
                column: this.scanner.index - this.scanner.lineStart
              };
            };
            JSXParser2.prototype.createJSXChildNode = function() {
              return {
                index: this.scanner.index,
                line: this.scanner.lineNumber,
                column: this.scanner.index - this.scanner.lineStart
              };
            };
            JSXParser2.prototype.scanXHTMLEntity = function(quote) {
              var result2 = "&";
              var valid = true;
              var terminated = false;
              var numeric = false;
              var hex = false;
              while (!this.scanner.eof() && valid && !terminated) {
                var ch = this.scanner.source[this.scanner.index];
                if (ch === quote) {
                  break;
                }
                terminated = ch === ";";
                result2 += ch;
                ++this.scanner.index;
                if (!terminated) {
                  switch (result2.length) {
                    case 2:
                      numeric = ch === "#";
                      break;
                    case 3:
                      if (numeric) {
                        hex = ch === "x";
                        valid = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0));
                        numeric = numeric && !hex;
                      }
                      break;
                    default:
                      valid = valid && !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0)));
                      valid = valid && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));
                      break;
                  }
                }
              }
              if (valid && terminated && result2.length > 2) {
                var str = result2.substr(1, result2.length - 2);
                if (numeric && str.length > 1) {
                  result2 = String.fromCharCode(parseInt(str.substr(1), 10));
                } else if (hex && str.length > 2) {
                  result2 = String.fromCharCode(parseInt("0" + str.substr(1), 16));
                } else if (!numeric && !hex && xhtml_entities_1.XHTMLEntities[str]) {
                  result2 = xhtml_entities_1.XHTMLEntities[str];
                }
              }
              return result2;
            };
            JSXParser2.prototype.lexJSX = function() {
              var cp = this.scanner.source.charCodeAt(this.scanner.index);
              if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {
                var value = this.scanner.source[this.scanner.index++];
                return {
                  type: 7,
                  value,
                  lineNumber: this.scanner.lineNumber,
                  lineStart: this.scanner.lineStart,
                  start: this.scanner.index - 1,
                  end: this.scanner.index
                };
              }
              if (cp === 34 || cp === 39) {
                var start = this.scanner.index;
                var quote = this.scanner.source[this.scanner.index++];
                var str = "";
                while (!this.scanner.eof()) {
                  var ch = this.scanner.source[this.scanner.index++];
                  if (ch === quote) {
                    break;
                  } else if (ch === "&") {
                    str += this.scanXHTMLEntity(quote);
                  } else {
                    str += ch;
                  }
                }
                return {
                  type: 8,
                  value: str,
                  lineNumber: this.scanner.lineNumber,
                  lineStart: this.scanner.lineStart,
                  start,
                  end: this.scanner.index
                };
              }
              if (cp === 46) {
                var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);
                var n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);
                var value = n1 === 46 && n2 === 46 ? "..." : ".";
                var start = this.scanner.index;
                this.scanner.index += value.length;
                return {
                  type: 7,
                  value,
                  lineNumber: this.scanner.lineNumber,
                  lineStart: this.scanner.lineStart,
                  start,
                  end: this.scanner.index
                };
              }
              if (cp === 96) {
                return {
                  type: 10,
                  value: "",
                  lineNumber: this.scanner.lineNumber,
                  lineStart: this.scanner.lineStart,
                  start: this.scanner.index,
                  end: this.scanner.index
                };
              }
              if (character_1.Character.isIdentifierStart(cp) && cp !== 92) {
                var start = this.scanner.index;
                ++this.scanner.index;
                while (!this.scanner.eof()) {
                  var ch = this.scanner.source.charCodeAt(this.scanner.index);
                  if (character_1.Character.isIdentifierPart(ch) && ch !== 92) {
                    ++this.scanner.index;
                  } else if (ch === 45) {
                    ++this.scanner.index;
                  } else {
                    break;
                  }
                }
                var id = this.scanner.source.slice(start, this.scanner.index);
                return {
                  type: 100,
                  value: id,
                  lineNumber: this.scanner.lineNumber,
                  lineStart: this.scanner.lineStart,
                  start,
                  end: this.scanner.index
                };
              }
              return this.scanner.lex();
            };
            JSXParser2.prototype.nextJSXToken = function() {
              this.collectComments();
              this.startMarker.index = this.scanner.index;
              this.startMarker.line = this.scanner.lineNumber;
              this.startMarker.column = this.scanner.index - this.scanner.lineStart;
              var token2 = this.lexJSX();
              this.lastMarker.index = this.scanner.index;
              this.lastMarker.line = this.scanner.lineNumber;
              this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
              if (this.config.tokens) {
                this.tokens.push(this.convertToken(token2));
              }
              return token2;
            };
            JSXParser2.prototype.nextJSXText = function() {
              this.startMarker.index = this.scanner.index;
              this.startMarker.line = this.scanner.lineNumber;
              this.startMarker.column = this.scanner.index - this.scanner.lineStart;
              var start = this.scanner.index;
              var text = "";
              while (!this.scanner.eof()) {
                var ch = this.scanner.source[this.scanner.index];
                if (ch === "{" || ch === "<") {
                  break;
                }
                ++this.scanner.index;
                text += ch;
                if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                  ++this.scanner.lineNumber;
                  if (ch === "\r" && this.scanner.source[this.scanner.index] === "\n") {
                    ++this.scanner.index;
                  }
                  this.scanner.lineStart = this.scanner.index;
                }
              }
              this.lastMarker.index = this.scanner.index;
              this.lastMarker.line = this.scanner.lineNumber;
              this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
              var token2 = {
                type: 101,
                value: text,
                lineNumber: this.scanner.lineNumber,
                lineStart: this.scanner.lineStart,
                start,
                end: this.scanner.index
              };
              if (text.length > 0 && this.config.tokens) {
                this.tokens.push(this.convertToken(token2));
              }
              return token2;
            };
            JSXParser2.prototype.peekJSXToken = function() {
              var state = this.scanner.saveState();
              this.scanner.scanComments();
              var next = this.lexJSX();
              this.scanner.restoreState(state);
              return next;
            };
            JSXParser2.prototype.expectJSX = function(value) {
              var token2 = this.nextJSXToken();
              if (token2.type !== 7 || token2.value !== value) {
                this.throwUnexpectedToken(token2);
              }
            };
            JSXParser2.prototype.matchJSX = function(value) {
              var next = this.peekJSXToken();
              return next.type === 7 && next.value === value;
            };
            JSXParser2.prototype.parseJSXIdentifier = function() {
              var node = this.createJSXNode();
              var token2 = this.nextJSXToken();
              if (token2.type !== 100) {
                this.throwUnexpectedToken(token2);
              }
              return this.finalize(node, new JSXNode.JSXIdentifier(token2.value));
            };
            JSXParser2.prototype.parseJSXElementName = function() {
              var node = this.createJSXNode();
              var elementName = this.parseJSXIdentifier();
              if (this.matchJSX(":")) {
                var namespace = elementName;
                this.expectJSX(":");
                var name_1 = this.parseJSXIdentifier();
                elementName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_1));
              } else if (this.matchJSX(".")) {
                while (this.matchJSX(".")) {
                  var object = elementName;
                  this.expectJSX(".");
                  var property = this.parseJSXIdentifier();
                  elementName = this.finalize(node, new JSXNode.JSXMemberExpression(object, property));
                }
              }
              return elementName;
            };
            JSXParser2.prototype.parseJSXAttributeName = function() {
              var node = this.createJSXNode();
              var attributeName;
              var identifier = this.parseJSXIdentifier();
              if (this.matchJSX(":")) {
                var namespace = identifier;
                this.expectJSX(":");
                var name_2 = this.parseJSXIdentifier();
                attributeName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_2));
              } else {
                attributeName = identifier;
              }
              return attributeName;
            };
            JSXParser2.prototype.parseJSXStringLiteralAttribute = function() {
              var node = this.createJSXNode();
              var token2 = this.nextJSXToken();
              if (token2.type !== 8) {
                this.throwUnexpectedToken(token2);
              }
              var raw = this.getTokenRaw(token2);
              return this.finalize(node, new Node.Literal(token2.value, raw));
            };
            JSXParser2.prototype.parseJSXExpressionAttribute = function() {
              var node = this.createJSXNode();
              this.expectJSX("{");
              this.finishJSX();
              if (this.match("}")) {
                this.tolerateError("JSX attributes must only be assigned a non-empty expression");
              }
              var expression = this.parseAssignmentExpression();
              this.reenterJSX();
              return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
            };
            JSXParser2.prototype.parseJSXAttributeValue = function() {
              return this.matchJSX("{") ? this.parseJSXExpressionAttribute() : this.matchJSX("<") ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
            };
            JSXParser2.prototype.parseJSXNameValueAttribute = function() {
              var node = this.createJSXNode();
              var name = this.parseJSXAttributeName();
              var value = null;
              if (this.matchJSX("=")) {
                this.expectJSX("=");
                value = this.parseJSXAttributeValue();
              }
              return this.finalize(node, new JSXNode.JSXAttribute(name, value));
            };
            JSXParser2.prototype.parseJSXSpreadAttribute = function() {
              var node = this.createJSXNode();
              this.expectJSX("{");
              this.expectJSX("...");
              this.finishJSX();
              var argument = this.parseAssignmentExpression();
              this.reenterJSX();
              return this.finalize(node, new JSXNode.JSXSpreadAttribute(argument));
            };
            JSXParser2.prototype.parseJSXAttributes = function() {
              var attributes = [];
              while (!this.matchJSX("/") && !this.matchJSX(">")) {
                var attribute = this.matchJSX("{") ? this.parseJSXSpreadAttribute() : this.parseJSXNameValueAttribute();
                attributes.push(attribute);
              }
              return attributes;
            };
            JSXParser2.prototype.parseJSXOpeningElement = function() {
              var node = this.createJSXNode();
              this.expectJSX("<");
              var name = this.parseJSXElementName();
              var attributes = this.parseJSXAttributes();
              var selfClosing = this.matchJSX("/");
              if (selfClosing) {
                this.expectJSX("/");
              }
              this.expectJSX(">");
              return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
            };
            JSXParser2.prototype.parseJSXBoundaryElement = function() {
              var node = this.createJSXNode();
              this.expectJSX("<");
              if (this.matchJSX("/")) {
                this.expectJSX("/");
                var name_3 = this.parseJSXElementName();
                this.expectJSX(">");
                return this.finalize(node, new JSXNode.JSXClosingElement(name_3));
              }
              var name = this.parseJSXElementName();
              var attributes = this.parseJSXAttributes();
              var selfClosing = this.matchJSX("/");
              if (selfClosing) {
                this.expectJSX("/");
              }
              this.expectJSX(">");
              return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
            };
            JSXParser2.prototype.parseJSXEmptyExpression = function() {
              var node = this.createJSXChildNode();
              this.collectComments();
              this.lastMarker.index = this.scanner.index;
              this.lastMarker.line = this.scanner.lineNumber;
              this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
              return this.finalize(node, new JSXNode.JSXEmptyExpression());
            };
            JSXParser2.prototype.parseJSXExpressionContainer = function() {
              var node = this.createJSXNode();
              this.expectJSX("{");
              var expression;
              if (this.matchJSX("}")) {
                expression = this.parseJSXEmptyExpression();
                this.expectJSX("}");
              } else {
                this.finishJSX();
                expression = this.parseAssignmentExpression();
                this.reenterJSX();
              }
              return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
            };
            JSXParser2.prototype.parseJSXChildren = function() {
              var children = [];
              while (!this.scanner.eof()) {
                var node = this.createJSXChildNode();
                var token2 = this.nextJSXText();
                if (token2.start < token2.end) {
                  var raw = this.getTokenRaw(token2);
                  var child = this.finalize(node, new JSXNode.JSXText(token2.value, raw));
                  children.push(child);
                }
                if (this.scanner.source[this.scanner.index] === "{") {
                  var container = this.parseJSXExpressionContainer();
                  children.push(container);
                } else {
                  break;
                }
              }
              return children;
            };
            JSXParser2.prototype.parseComplexJSXElement = function(el) {
              var stack = [];
              while (!this.scanner.eof()) {
                el.children = el.children.concat(this.parseJSXChildren());
                var node = this.createJSXChildNode();
                var element = this.parseJSXBoundaryElement();
                if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {
                  var opening = element;
                  if (opening.selfClosing) {
                    var child = this.finalize(node, new JSXNode.JSXElement(opening, [], null));
                    el.children.push(child);
                  } else {
                    stack.push(el);
                    el = { node, opening, closing: null, children: [] };
                  }
                }
                if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {
                  el.closing = element;
                  var open_1 = getQualifiedElementName(el.opening.name);
                  var close_1 = getQualifiedElementName(el.closing.name);
                  if (open_1 !== close_1) {
                    this.tolerateError("Expected corresponding JSX closing tag for %0", open_1);
                  }
                  if (stack.length > 0) {
                    var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));
                    el = stack[stack.length - 1];
                    el.children.push(child);
                    stack.pop();
                  } else {
                    break;
                  }
                }
              }
              return el;
            };
            JSXParser2.prototype.parseJSXElement = function() {
              var node = this.createJSXNode();
              var opening = this.parseJSXOpeningElement();
              var children = [];
              var closing = null;
              if (!opening.selfClosing) {
                var el = this.parseComplexJSXElement({ node, opening, closing, children });
                children = el.children;
                closing = el.closing;
              }
              return this.finalize(node, new JSXNode.JSXElement(opening, children, closing));
            };
            JSXParser2.prototype.parseJSXRoot = function() {
              if (this.config.tokens) {
                this.tokens.pop();
              }
              this.startJSX();
              var element = this.parseJSXElement();
              this.finishJSX();
              return element;
            };
            JSXParser2.prototype.isStartOfExpression = function() {
              return _super.prototype.isStartOfExpression.call(this) || this.match("<");
            };
            return JSXParser2;
          }(parser_1.Parser);
          exports3.JSXParser = JSXParser;
        },
        function(module3, exports3) {
          "use strict";
          Object.defineProperty(exports3, "__esModule", { value: true });
          var Regex = {
            NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
            NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
          };
          exports3.Character = {
            fromCodePoint: function(cp) {
              return cp < 65536 ? String.fromCharCode(cp) : String.fromCharCode(55296 + (cp - 65536 >> 10)) + String.fromCharCode(56320 + (cp - 65536 & 1023));
            },
            isWhiteSpace: function(cp) {
              return cp === 32 || cp === 9 || cp === 11 || cp === 12 || cp === 160 || cp >= 5760 && [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(cp) >= 0;
            },
            isLineTerminator: function(cp) {
              return cp === 10 || cp === 13 || cp === 8232 || cp === 8233;
            },
            isIdentifierStart: function(cp) {
              return cp === 36 || cp === 95 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp === 92 || cp >= 128 && Regex.NonAsciiIdentifierStart.test(exports3.Character.fromCodePoint(cp));
            },
            isIdentifierPart: function(cp) {
              return cp === 36 || cp === 95 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp >= 48 && cp <= 57 || cp === 92 || cp >= 128 && Regex.NonAsciiIdentifierPart.test(exports3.Character.fromCodePoint(cp));
            },
            isDecimalDigit: function(cp) {
              return cp >= 48 && cp <= 57;
            },
            isHexDigit: function(cp) {
              return cp >= 48 && cp <= 57 || cp >= 65 && cp <= 70 || cp >= 97 && cp <= 102;
            },
            isOctalDigit: function(cp) {
              return cp >= 48 && cp <= 55;
            }
          };
        },
        function(module3, exports3, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports3, "__esModule", { value: true });
          var jsx_syntax_1 = __webpack_require__(6);
          var JSXClosingElement = function() {
            function JSXClosingElement2(name) {
              this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement;
              this.name = name;
            }
            return JSXClosingElement2;
          }();
          exports3.JSXClosingElement = JSXClosingElement;
          var JSXElement = function() {
            function JSXElement2(openingElement, children, closingElement) {
              this.type = jsx_syntax_1.JSXSyntax.JSXElement;
              this.openingElement = openingElement;
              this.children = children;
              this.closingElement = closingElement;
            }
            return JSXElement2;
          }();
          exports3.JSXElement = JSXElement;
          var JSXEmptyExpression = function() {
            function JSXEmptyExpression2() {
              this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;
            }
            return JSXEmptyExpression2;
          }();
          exports3.JSXEmptyExpression = JSXEmptyExpression;
          var JSXExpressionContainer = function() {
            function JSXExpressionContainer2(expression) {
              this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer;
              this.expression = expression;
            }
            return JSXExpressionContainer2;
          }();
          exports3.JSXExpressionContainer = JSXExpressionContainer;
          var JSXIdentifier = function() {
            function JSXIdentifier2(name) {
              this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier;
              this.name = name;
            }
            return JSXIdentifier2;
          }();
          exports3.JSXIdentifier = JSXIdentifier;
          var JSXMemberExpression = function() {
            function JSXMemberExpression2(object, property) {
              this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression;
              this.object = object;
              this.property = property;
            }
            return JSXMemberExpression2;
          }();
          exports3.JSXMemberExpression = JSXMemberExpression;
          var JSXAttribute = function() {
            function JSXAttribute2(name, value) {
              this.type = jsx_syntax_1.JSXSyntax.JSXAttribute;
              this.name = name;
              this.value = value;
            }
            return JSXAttribute2;
          }();
          exports3.JSXAttribute = JSXAttribute;
          var JSXNamespacedName = function() {
            function JSXNamespacedName2(namespace, name) {
              this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName;
              this.namespace = namespace;
              this.name = name;
            }
            return JSXNamespacedName2;
          }();
          exports3.JSXNamespacedName = JSXNamespacedName;
          var JSXOpeningElement = function() {
            function JSXOpeningElement2(name, selfClosing, attributes) {
              this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement;
              this.name = name;
              this.selfClosing = selfClosing;
              this.attributes = attributes;
            }
            return JSXOpeningElement2;
          }();
          exports3.JSXOpeningElement = JSXOpeningElement;
          var JSXSpreadAttribute = function() {
            function JSXSpreadAttribute2(argument) {
              this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute;
              this.argument = argument;
            }
            return JSXSpreadAttribute2;
          }();
          exports3.JSXSpreadAttribute = JSXSpreadAttribute;
          var JSXText = function() {
            function JSXText2(value, raw) {
              this.type = jsx_syntax_1.JSXSyntax.JSXText;
              this.value = value;
              this.raw = raw;
            }
            return JSXText2;
          }();
          exports3.JSXText = JSXText;
        },
        function(module3, exports3) {
          "use strict";
          Object.defineProperty(exports3, "__esModule", { value: true });
          exports3.JSXSyntax = {
            JSXAttribute: "JSXAttribute",
            JSXClosingElement: "JSXClosingElement",
            JSXElement: "JSXElement",
            JSXEmptyExpression: "JSXEmptyExpression",
            JSXExpressionContainer: "JSXExpressionContainer",
            JSXIdentifier: "JSXIdentifier",
            JSXMemberExpression: "JSXMemberExpression",
            JSXNamespacedName: "JSXNamespacedName",
            JSXOpeningElement: "JSXOpeningElement",
            JSXSpreadAttribute: "JSXSpreadAttribute",
            JSXText: "JSXText"
          };
        },
        function(module3, exports3, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports3, "__esModule", { value: true });
          var syntax_1 = __webpack_require__(2);
          var ArrayExpression = function() {
            function ArrayExpression2(elements) {
              this.type = syntax_1.Syntax.ArrayExpression;
              this.elements = elements;
            }
            return ArrayExpression2;
          }();
          exports3.ArrayExpression = ArrayExpression;
          var ArrayPattern = function() {
            function ArrayPattern2(elements) {
              this.type = syntax_1.Syntax.ArrayPattern;
              this.elements = elements;
            }
            return ArrayPattern2;
          }();
          exports3.ArrayPattern = ArrayPattern;
          var ArrowFunctionExpression = function() {
            function ArrowFunctionExpression2(params, body, expression) {
              this.type = syntax_1.Syntax.ArrowFunctionExpression;
              this.id = null;
              this.params = params;
              this.body = body;
              this.generator = false;
              this.expression = expression;
              this.async = false;
            }
            return ArrowFunctionExpression2;
          }();
          exports3.ArrowFunctionExpression = ArrowFunctionExpression;
          var AssignmentExpression = function() {
            function AssignmentExpression2(operator, left, right) {
              this.type = syntax_1.Syntax.AssignmentExpression;
              this.operator = operator;
              this.left = left;
              this.right = right;
            }
            return AssignmentExpression2;
          }();
          exports3.AssignmentExpression = AssignmentExpression;
          var AssignmentPattern = function() {
            function AssignmentPattern2(left, right) {
              this.type = syntax_1.Syntax.AssignmentPattern;
              this.left = left;
              this.right = right;
            }
            return AssignmentPattern2;
          }();
          exports3.AssignmentPattern = AssignmentPattern;
          var AsyncArrowFunctionExpression = function() {
            function AsyncArrowFunctionExpression2(params, body, expression) {
              this.type = syntax_1.Syntax.ArrowFunctionExpression;
              this.id = null;
              this.params = params;
              this.body = body;
              this.generator = false;
              this.expression = expression;
              this.async = true;
            }
            return AsyncArrowFunctionExpression2;
          }();
          exports3.AsyncArrowFunctionExpression = AsyncArrowFunctionExpression;
          var AsyncFunctionDeclaration = function() {
            function AsyncFunctionDeclaration2(id, params, body) {
              this.type = syntax_1.Syntax.FunctionDeclaration;
              this.id = id;
              this.params = params;
              this.body = body;
              this.generator = false;
              this.expression = false;
              this.async = true;
            }
            return AsyncFunctionDeclaration2;
          }();
          exports3.AsyncFunctionDeclaration = AsyncFunctionDeclaration;
          var AsyncFunctionExpression = function() {
            function AsyncFunctionExpression2(id, params, body) {
              this.type = syntax_1.Syntax.FunctionExpression;
              this.id = id;
              this.params = params;
              this.body = body;
              this.generator = false;
              this.expression = false;
              this.async = true;
            }
            return AsyncFunctionExpression2;
          }();
          exports3.AsyncFunctionExpression = AsyncFunctionExpression;
          var AwaitExpression = function() {
            function AwaitExpression2(argument) {
              this.type = syntax_1.Syntax.AwaitExpression;
              this.argument = argument;
            }
            return AwaitExpression2;
          }();
          exports3.AwaitExpression = AwaitExpression;
          var BinaryExpression = function() {
            function BinaryExpression2(operator, left, right) {
              var logical = operator === "||" || operator === "&&";
              this.type = logical ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression;
              this.operator = operator;
              this.left = left;
              this.right = right;
            }
            return BinaryExpression2;
          }();
          exports3.BinaryExpression = BinaryExpression;
          var BlockStatement = function() {
            function BlockStatement2(body) {
              this.type = syntax_1.Syntax.BlockStatement;
              this.body = body;
            }
            return BlockStatement2;
          }();
          exports3.BlockStatement = BlockStatement;
          var BreakStatement = function() {
            function BreakStatement2(label) {
              this.type = syntax_1.Syntax.BreakStatement;
              this.label = label;
            }
            return BreakStatement2;
          }();
          exports3.BreakStatement = BreakStatement;
          var CallExpression = function() {
            function CallExpression2(callee, args) {
              this.type = syntax_1.Syntax.CallExpression;
              this.callee = callee;
              this.arguments = args;
            }
            return CallExpression2;
          }();
          exports3.CallExpression = CallExpression;
          var CatchClause = function() {
            function CatchClause2(param, body) {
              this.type = syntax_1.Syntax.CatchClause;
              this.param = param;
              this.body = body;
            }
            return CatchClause2;
          }();
          exports3.CatchClause = CatchClause;
          var ClassBody = function() {
            function ClassBody2(body) {
              this.type = syntax_1.Syntax.ClassBody;
              this.body = body;
            }
            return ClassBody2;
          }();
          exports3.ClassBody = ClassBody;
          var ClassDeclaration = function() {
            function ClassDeclaration2(id, superClass, body) {
              this.type = syntax_1.Syntax.ClassDeclaration;
              this.id = id;
              this.superClass = superClass;
              this.body = body;
            }
            return ClassDeclaration2;
          }();
          exports3.ClassDeclaration = ClassDeclaration;
          var ClassExpression = function() {
            function ClassExpression2(id, superClass, body) {
              this.type = syntax_1.Syntax.ClassExpression;
              this.id = id;
              this.superClass = superClass;
              this.body = body;
            }
            return ClassExpression2;
          }();
          exports3.ClassExpression = ClassExpression;
          var ComputedMemberExpression = function() {
            function ComputedMemberExpression2(object, property) {
              this.type = syntax_1.Syntax.MemberExpression;
              this.computed = true;
              this.object = object;
              this.property = property;
            }
            return ComputedMemberExpression2;
          }();
          exports3.ComputedMemberExpression = ComputedMemberExpression;
          var ConditionalExpression = function() {
            function ConditionalExpression2(test, consequent, alternate) {
              this.type = syntax_1.Syntax.ConditionalExpression;
              this.test = test;
              this.consequent = consequent;
              this.alternate = alternate;
            }
            return ConditionalExpression2;
          }();
          exports3.ConditionalExpression = ConditionalExpression;
          var ContinueStatement = function() {
            function ContinueStatement2(label) {
              this.type = syntax_1.Syntax.ContinueStatement;
              this.label = label;
            }
            return ContinueStatement2;
          }();
          exports3.ContinueStatement = ContinueStatement;
          var DebuggerStatement = function() {
            function DebuggerStatement2() {
              this.type = syntax_1.Syntax.DebuggerStatement;
            }
            return DebuggerStatement2;
          }();
          exports3.DebuggerStatement = DebuggerStatement;
          var Directive = function() {
            function Directive2(expression, directive) {
              this.type = syntax_1.Syntax.ExpressionStatement;
              this.expression = expression;
              this.directive = directive;
            }
            return Directive2;
          }();
          exports3.Directive = Directive;
          var DoWhileStatement = function() {
            function DoWhileStatement2(body, test) {
              this.type = syntax_1.Syntax.DoWhileStatement;
              this.body = body;
              this.test = test;
            }
            return DoWhileStatement2;
          }();
          exports3.DoWhileStatement = DoWhileStatement;
          var EmptyStatement = function() {
            function EmptyStatement2() {
              this.type = syntax_1.Syntax.EmptyStatement;
            }
            return EmptyStatement2;
          }();
          exports3.EmptyStatement = EmptyStatement;
          var ExportAllDeclaration = function() {
            function ExportAllDeclaration2(source) {
              this.type = syntax_1.Syntax.ExportAllDeclaration;
              this.source = source;
            }
            return ExportAllDeclaration2;
          }();
          exports3.ExportAllDeclaration = ExportAllDeclaration;
          var ExportDefaultDeclaration = function() {
            function ExportDefaultDeclaration2(declaration) {
              this.type = syntax_1.Syntax.ExportDefaultDeclaration;
              this.declaration = declaration;
            }
            return ExportDefaultDeclaration2;
          }();
          exports3.ExportDefaultDeclaration = ExportDefaultDeclaration;
          var ExportNamedDeclaration = function() {
            function ExportNamedDeclaration2(declaration, specifiers, source) {
              this.type = syntax_1.Syntax.ExportNamedDeclaration;
              this.declaration = declaration;
              this.specifiers = specifiers;
              this.source = source;
            }
            return ExportNamedDeclaration2;
          }();
          exports3.ExportNamedDeclaration = ExportNamedDeclaration;
          var ExportSpecifier = function() {
            function ExportSpecifier2(local, exported) {
              this.type = syntax_1.Syntax.ExportSpecifier;
              this.exported = exported;
              this.local = local;
            }
            return ExportSpecifier2;
          }();
          exports3.ExportSpecifier = ExportSpecifier;
          var ExpressionStatement = function() {
            function ExpressionStatement2(expression) {
              this.type = syntax_1.Syntax.ExpressionStatement;
              this.expression = expression;
            }
            return ExpressionStatement2;
          }();
          exports3.ExpressionStatement = ExpressionStatement;
          var ForInStatement = function() {
            function ForInStatement2(left, right, body) {
              this.type = syntax_1.Syntax.ForInStatement;
              this.left = left;
              this.right = right;
              this.body = body;
              this.each = false;
            }
            return ForInStatement2;
          }();
          exports3.ForInStatement = ForInStatement;
          var ForOfStatement = function() {
            function ForOfStatement2(left, right, body) {
              this.type = syntax_1.Syntax.ForOfStatement;
              this.left = left;
              this.right = right;
              this.body = body;
            }
            return ForOfStatement2;
          }();
          exports3.ForOfStatement = ForOfStatement;
          var ForStatement = function() {
            function ForStatement2(init, test, update, body) {
              this.type = syntax_1.Syntax.ForStatement;
              this.init = init;
              this.test = test;
              this.update = update;
              this.body = body;
            }
            return ForStatement2;
          }();
          exports3.ForStatement = ForStatement;
          var FunctionDeclaration = function() {
            function FunctionDeclaration2(id, params, body, generator) {
              this.type = syntax_1.Syntax.FunctionDeclaration;
              this.id = id;
              this.params = params;
              this.body = body;
              this.generator = generator;
              this.expression = false;
              this.async = false;
            }
            return FunctionDeclaration2;
          }();
          exports3.FunctionDeclaration = FunctionDeclaration;
          var FunctionExpression = function() {
            function FunctionExpression2(id, params, body, generator) {
              this.type = syntax_1.Syntax.FunctionExpression;
              this.id = id;
              this.params = params;
              this.body = body;
              this.generator = generator;
              this.expression = false;
              this.async = false;
            }
            return FunctionExpression2;
          }();
          exports3.FunctionExpression = FunctionExpression;
          var Identifier = function() {
            function Identifier2(name) {
              this.type = syntax_1.Syntax.Identifier;
              this.name = name;
            }
            return Identifier2;
          }();
          exports3.Identifier = Identifier;
          var IfStatement = function() {
            function IfStatement2(test, consequent, alternate) {
              this.type = syntax_1.Syntax.IfStatement;
              this.test = test;
              this.consequent = consequent;
              this.alternate = alternate;
            }
            return IfStatement2;
          }();
          exports3.IfStatement = IfStatement;
          var ImportDeclaration = function() {
            function ImportDeclaration2(specifiers, source) {
              this.type = syntax_1.Syntax.ImportDeclaration;
              this.specifiers = specifiers;
              this.source = source;
            }
            return ImportDeclaration2;
          }();
          exports3.ImportDeclaration = ImportDeclaration;
          var ImportDefaultSpecifier = function() {
            function ImportDefaultSpecifier2(local) {
              this.type = syntax_1.Syntax.ImportDefaultSpecifier;
              this.local = local;
            }
            return ImportDefaultSpecifier2;
          }();
          exports3.ImportDefaultSpecifier = ImportDefaultSpecifier;
          var ImportNamespaceSpecifier = function() {
            function ImportNamespaceSpecifier2(local) {
              this.type = syntax_1.Syntax.ImportNamespaceSpecifier;
              this.local = local;
            }
            return ImportNamespaceSpecifier2;
          }();
          exports3.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
          var ImportSpecifier = function() {
            function ImportSpecifier2(local, imported) {
              this.type = syntax_1.Syntax.ImportSpecifier;
              this.local = local;
              this.imported = imported;
            }
            return ImportSpecifier2;
          }();
          exports3.ImportSpecifier = ImportSpecifier;
          var LabeledStatement = function() {
            function LabeledStatement2(label, body) {
              this.type = syntax_1.Syntax.LabeledStatement;
              this.label = label;
              this.body = body;
            }
            return LabeledStatement2;
          }();
          exports3.LabeledStatement = LabeledStatement;
          var Literal = function() {
            function Literal2(value, raw) {
              this.type = syntax_1.Syntax.Literal;
              this.value = value;
              this.raw = raw;
            }
            return Literal2;
          }();
          exports3.Literal = Literal;
          var MetaProperty = function() {
            function MetaProperty2(meta, property) {
              this.type = syntax_1.Syntax.MetaProperty;
              this.meta = meta;
              this.property = property;
            }
            return MetaProperty2;
          }();
          exports3.MetaProperty = MetaProperty;
          var MethodDefinition = function() {
            function MethodDefinition2(key, computed, value, kind, isStatic) {
              this.type = syntax_1.Syntax.MethodDefinition;
              this.key = key;
              this.computed = computed;
              this.value = value;
              this.kind = kind;
              this.static = isStatic;
            }
            return MethodDefinition2;
          }();
          exports3.MethodDefinition = MethodDefinition;
          var Module = function() {
            function Module2(body) {
              this.type = syntax_1.Syntax.Program;
              this.body = body;
              this.sourceType = "module";
            }
            return Module2;
          }();
          exports3.Module = Module;
          var NewExpression = function() {
            function NewExpression2(callee, args) {
              this.type = syntax_1.Syntax.NewExpression;
              this.callee = callee;
              this.arguments = args;
            }
            return NewExpression2;
          }();
          exports3.NewExpression = NewExpression;
          var ObjectExpression = function() {
            function ObjectExpression2(properties) {
              this.type = syntax_1.Syntax.ObjectExpression;
              this.properties = properties;
            }
            return ObjectExpression2;
          }();
          exports3.ObjectExpression = ObjectExpression;
          var ObjectPattern = function() {
            function ObjectPattern2(properties) {
              this.type = syntax_1.Syntax.ObjectPattern;
              this.properties = properties;
            }
            return ObjectPattern2;
          }();
          exports3.ObjectPattern = ObjectPattern;
          var Property = function() {
            function Property2(kind, key, computed, value, method, shorthand) {
              this.type = syntax_1.Syntax.Property;
              this.key = key;
              this.computed = computed;
              this.value = value;
              this.kind = kind;
              this.method = method;
              this.shorthand = shorthand;
            }
            return Property2;
          }();
          exports3.Property = Property;
          var RegexLiteral = function() {
            function RegexLiteral2(value, raw, pattern, flags) {
              this.type = syntax_1.Syntax.Literal;
              this.value = value;
              this.raw = raw;
              this.regex = { pattern, flags };
            }
            return RegexLiteral2;
          }();
          exports3.RegexLiteral = RegexLiteral;
          var RestElement = function() {
            function RestElement2(argument) {
              this.type = syntax_1.Syntax.RestElement;
              this.argument = argument;
            }
            return RestElement2;
          }();
          exports3.RestElement = RestElement;
          var ReturnStatement = function() {
            function ReturnStatement2(argument) {
              this.type = syntax_1.Syntax.ReturnStatement;
              this.argument = argument;
            }
            return ReturnStatement2;
          }();
          exports3.ReturnStatement = ReturnStatement;
          var Script = function() {
            function Script2(body) {
              this.type = syntax_1.Syntax.Program;
              this.body = body;
              this.sourceType = "script";
            }
            return Script2;
          }();
          exports3.Script = Script;
          var SequenceExpression = function() {
            function SequenceExpression2(expressions) {
              this.type = syntax_1.Syntax.SequenceExpression;
              this.expressions = expressions;
            }
            return SequenceExpression2;
          }();
          exports3.SequenceExpression = SequenceExpression;
          var SpreadElement = function() {
            function SpreadElement2(argument) {
              this.type = syntax_1.Syntax.SpreadElement;
              this.argument = argument;
            }
            return SpreadElement2;
          }();
          exports3.SpreadElement = SpreadElement;
          var StaticMemberExpression = function() {
            function StaticMemberExpression2(object, property) {
              this.type = syntax_1.Syntax.MemberExpression;
              this.computed = false;
              this.object = object;
              this.property = property;
            }
            return StaticMemberExpression2;
          }();
          exports3.StaticMemberExpression = StaticMemberExpression;
          var Super = function() {
            function Super2() {
              this.type = syntax_1.Syntax.Super;
            }
            return Super2;
          }();
          exports3.Super = Super;
          var SwitchCase = function() {
            function SwitchCase2(test, consequent) {
              this.type = syntax_1.Syntax.SwitchCase;
              this.test = test;
              this.consequent = consequent;
            }
            return SwitchCase2;
          }();
          exports3.SwitchCase = SwitchCase;
          var SwitchStatement = function() {
            function SwitchStatement2(discriminant, cases) {
              this.type = syntax_1.Syntax.SwitchStatement;
              this.discriminant = discriminant;
              this.cases = cases;
            }
            return SwitchStatement2;
          }();
          exports3.SwitchStatement = SwitchStatement;
          var TaggedTemplateExpression = function() {
            function TaggedTemplateExpression2(tag, quasi) {
              this.type = syntax_1.Syntax.TaggedTemplateExpression;
              this.tag = tag;
              this.quasi = quasi;
            }
            return TaggedTemplateExpression2;
          }();
          exports3.TaggedTemplateExpression = TaggedTemplateExpression;
          var TemplateElement = function() {
            function TemplateElement2(value, tail) {
              this.type = syntax_1.Syntax.TemplateElement;
              this.value = value;
              this.tail = tail;
            }
            return TemplateElement2;
          }();
          exports3.TemplateElement = TemplateElement;
          var TemplateLiteral = function() {
            function TemplateLiteral2(quasis, expressions) {
              this.type = syntax_1.Syntax.TemplateLiteral;
              this.quasis = quasis;
              this.expressions = expressions;
            }
            return TemplateLiteral2;
          }();
          exports3.TemplateLiteral = TemplateLiteral;
          var ThisExpression = function() {
            function ThisExpression2() {
              this.type = syntax_1.Syntax.ThisExpression;
            }
            return ThisExpression2;
          }();
          exports3.ThisExpression = ThisExpression;
          var ThrowStatement = function() {
            function ThrowStatement2(argument) {
              this.type = syntax_1.Syntax.ThrowStatement;
              this.argument = argument;
            }
            return ThrowStatement2;
          }();
          exports3.ThrowStatement = ThrowStatement;
          var TryStatement = function() {
            function TryStatement2(block, handler, finalizer) {
              this.type = syntax_1.Syntax.TryStatement;
              this.block = block;
              this.handler = handler;
              this.finalizer = finalizer;
            }
            return TryStatement2;
          }();
          exports3.TryStatement = TryStatement;
          var UnaryExpression = function() {
            function UnaryExpression2(operator, argument) {
              this.type = syntax_1.Syntax.UnaryExpression;
              this.operator = operator;
              this.argument = argument;
              this.prefix = true;
            }
            return UnaryExpression2;
          }();
          exports3.UnaryExpression = UnaryExpression;
          var UpdateExpression = function() {
            function UpdateExpression2(operator, argument, prefix) {
              this.type = syntax_1.Syntax.UpdateExpression;
              this.operator = operator;
              this.argument = argument;
              this.prefix = prefix;
            }
            return UpdateExpression2;
          }();
          exports3.UpdateExpression = UpdateExpression;
          var VariableDeclaration = function() {
            function VariableDeclaration2(declarations, kind) {
              this.type = syntax_1.Syntax.VariableDeclaration;
              this.declarations = declarations;
              this.kind = kind;
            }
            return VariableDeclaration2;
          }();
          exports3.VariableDeclaration = VariableDeclaration;
          var VariableDeclarator = function() {
            function VariableDeclarator2(id, init) {
              this.type = syntax_1.Syntax.VariableDeclarator;
              this.id = id;
              this.init = init;
            }
            return VariableDeclarator2;
          }();
          exports3.VariableDeclarator = VariableDeclarator;
          var WhileStatement = function() {
            function WhileStatement2(test, body) {
              this.type = syntax_1.Syntax.WhileStatement;
              this.test = test;
              this.body = body;
            }
            return WhileStatement2;
          }();
          exports3.WhileStatement = WhileStatement;
          var WithStatement = function() {
            function WithStatement2(object, body) {
              this.type = syntax_1.Syntax.WithStatement;
              this.object = object;
              this.body = body;
            }
            return WithStatement2;
          }();
          exports3.WithStatement = WithStatement;
          var YieldExpression = function() {
            function YieldExpression2(argument, delegate) {
              this.type = syntax_1.Syntax.YieldExpression;
              this.argument = argument;
              this.delegate = delegate;
            }
            return YieldExpression2;
          }();
          exports3.YieldExpression = YieldExpression;
        },
        function(module3, exports3, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports3, "__esModule", { value: true });
          var assert_1 = __webpack_require__(9);
          var error_handler_1 = __webpack_require__(10);
          var messages_1 = __webpack_require__(11);
          var Node = __webpack_require__(7);
          var scanner_1 = __webpack_require__(12);
          var syntax_1 = __webpack_require__(2);
          var token_1 = __webpack_require__(13);
          var ArrowParameterPlaceHolder = "ArrowParameterPlaceHolder";
          var Parser = function() {
            function Parser2(code, options2, delegate) {
              if (options2 === void 0) {
                options2 = {};
              }
              this.config = {
                range: typeof options2.range === "boolean" && options2.range,
                loc: typeof options2.loc === "boolean" && options2.loc,
                source: null,
                tokens: typeof options2.tokens === "boolean" && options2.tokens,
                comment: typeof options2.comment === "boolean" && options2.comment,
                tolerant: typeof options2.tolerant === "boolean" && options2.tolerant
              };
              if (this.config.loc && options2.source && options2.source !== null) {
                this.config.source = String(options2.source);
              }
              this.delegate = delegate;
              this.errorHandler = new error_handler_1.ErrorHandler();
              this.errorHandler.tolerant = this.config.tolerant;
              this.scanner = new scanner_1.Scanner(code, this.errorHandler);
              this.scanner.trackComment = this.config.comment;
              this.operatorPrecedence = {
                ")": 0,
                ";": 0,
                ",": 0,
                "=": 0,
                "]": 0,
                "||": 1,
                "&&": 2,
                "|": 3,
                "^": 4,
                "&": 5,
                "==": 6,
                "!=": 6,
                "===": 6,
                "!==": 6,
                "<": 7,
                ">": 7,
                "<=": 7,
                ">=": 7,
                "<<": 8,
                ">>": 8,
                ">>>": 8,
                "+": 9,
                "-": 9,
                "*": 11,
                "/": 11,
                "%": 11
              };
              this.lookahead = {
                type: 2,
                value: "",
                lineNumber: this.scanner.lineNumber,
                lineStart: 0,
                start: 0,
                end: 0
              };
              this.hasLineTerminator = false;
              this.context = {
                isModule: false,
                await: false,
                allowIn: true,
                allowStrictDirective: true,
                allowYield: true,
                firstCoverInitializedNameError: null,
                isAssignmentTarget: false,
                isBindingElement: false,
                inFunctionBody: false,
                inIteration: false,
                inSwitch: false,
                labelSet: {},
                strict: false
              };
              this.tokens = [];
              this.startMarker = {
                index: 0,
                line: this.scanner.lineNumber,
                column: 0
              };
              this.lastMarker = {
                index: 0,
                line: this.scanner.lineNumber,
                column: 0
              };
              this.nextToken();
              this.lastMarker = {
                index: this.scanner.index,
                line: this.scanner.lineNumber,
                column: this.scanner.index - this.scanner.lineStart
              };
            }
            Parser2.prototype.throwError = function(messageFormat) {
              var values = [];
              for (var _i = 1; _i < arguments.length; _i++) {
                values[_i - 1] = arguments[_i];
              }
              var args = Array.prototype.slice.call(arguments, 1);
              var msg = messageFormat.replace(/%(\d)/g, function(whole, idx) {
                assert_1.assert(idx < args.length, "Message reference must be in range");
                return args[idx];
              });
              var index = this.lastMarker.index;
              var line = this.lastMarker.line;
              var column = this.lastMarker.column + 1;
              throw this.errorHandler.createError(index, line, column, msg);
            };
            Parser2.prototype.tolerateError = function(messageFormat) {
              var values = [];
              for (var _i = 1; _i < arguments.length; _i++) {
                values[_i - 1] = arguments[_i];
              }
              var args = Array.prototype.slice.call(arguments, 1);
              var msg = messageFormat.replace(/%(\d)/g, function(whole, idx) {
                assert_1.assert(idx < args.length, "Message reference must be in range");
                return args[idx];
              });
              var index = this.lastMarker.index;
              var line = this.scanner.lineNumber;
              var column = this.lastMarker.column + 1;
              this.errorHandler.tolerateError(index, line, column, msg);
            };
            Parser2.prototype.unexpectedTokenError = function(token2, message) {
              var msg = message || messages_1.Messages.UnexpectedToken;
              var value;
              if (token2) {
                if (!message) {
                  msg = token2.type === 2 ? messages_1.Messages.UnexpectedEOS : token2.type === 3 ? messages_1.Messages.UnexpectedIdentifier : token2.type === 6 ? messages_1.Messages.UnexpectedNumber : token2.type === 8 ? messages_1.Messages.UnexpectedString : token2.type === 10 ? messages_1.Messages.UnexpectedTemplate : messages_1.Messages.UnexpectedToken;
                  if (token2.type === 4) {
                    if (this.scanner.isFutureReservedWord(token2.value)) {
                      msg = messages_1.Messages.UnexpectedReserved;
                    } else if (this.context.strict && this.scanner.isStrictModeReservedWord(token2.value)) {
                      msg = messages_1.Messages.StrictReservedWord;
                    }
                  }
                }
                value = token2.value;
              } else {
                value = "ILLEGAL";
              }
              msg = msg.replace("%0", value);
              if (token2 && typeof token2.lineNumber === "number") {
                var index = token2.start;
                var line = token2.lineNumber;
                var lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column;
                var column = token2.start - lastMarkerLineStart + 1;
                return this.errorHandler.createError(index, line, column, msg);
              } else {
                var index = this.lastMarker.index;
                var line = this.lastMarker.line;
                var column = this.lastMarker.column + 1;
                return this.errorHandler.createError(index, line, column, msg);
              }
            };
            Parser2.prototype.throwUnexpectedToken = function(token2, message) {
              throw this.unexpectedTokenError(token2, message);
            };
            Parser2.prototype.tolerateUnexpectedToken = function(token2, message) {
              this.errorHandler.tolerate(this.unexpectedTokenError(token2, message));
            };
            Parser2.prototype.collectComments = function() {
              if (!this.config.comment) {
                this.scanner.scanComments();
              } else {
                var comments = this.scanner.scanComments();
                if (comments.length > 0 && this.delegate) {
                  for (var i = 0; i < comments.length; ++i) {
                    var e = comments[i];
                    var node = void 0;
                    node = {
                      type: e.multiLine ? "BlockComment" : "LineComment",
                      value: this.scanner.source.slice(e.slice[0], e.slice[1])
                    };
                    if (this.config.range) {
                      node.range = e.range;
                    }
                    if (this.config.loc) {
                      node.loc = e.loc;
                    }
                    var metadata = {
                      start: {
                        line: e.loc.start.line,
                        column: e.loc.start.column,
                        offset: e.range[0]
                      },
                      end: {
                        line: e.loc.end.line,
                        column: e.loc.end.column,
                        offset: e.range[1]
                      }
                    };
                    this.delegate(node, metadata);
                  }
                }
              }
            };
            Parser2.prototype.getTokenRaw = function(token2) {
              return this.scanner.source.slice(token2.start, token2.end);
            };
            Parser2.prototype.convertToken = function(token2) {
              var t = {
                type: token_1.TokenName[token2.type],
                value: this.getTokenRaw(token2)
              };
              if (this.config.range) {
                t.range = [token2.start, token2.end];
              }
              if (this.config.loc) {
                t.loc = {
                  start: {
                    line: this.startMarker.line,
                    column: this.startMarker.column
                  },
                  end: {
                    line: this.scanner.lineNumber,
                    column: this.scanner.index - this.scanner.lineStart
                  }
                };
              }
              if (token2.type === 9) {
                var pattern = token2.pattern;
                var flags = token2.flags;
                t.regex = { pattern, flags };
              }
              return t;
            };
            Parser2.prototype.nextToken = function() {
              var token2 = this.lookahead;
              this.lastMarker.index = this.scanner.index;
              this.lastMarker.line = this.scanner.lineNumber;
              this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
              this.collectComments();
              if (this.scanner.index !== this.startMarker.index) {
                this.startMarker.index = this.scanner.index;
                this.startMarker.line = this.scanner.lineNumber;
                this.startMarker.column = this.scanner.index - this.scanner.lineStart;
              }
              var next = this.scanner.lex();
              this.hasLineTerminator = token2.lineNumber !== next.lineNumber;
              if (next && this.context.strict && next.type === 3) {
                if (this.scanner.isStrictModeReservedWord(next.value)) {
                  next.type = 4;
                }
              }
              this.lookahead = next;
              if (this.config.tokens && next.type !== 2) {
                this.tokens.push(this.convertToken(next));
              }
              return token2;
            };
            Parser2.prototype.nextRegexToken = function() {
              this.collectComments();
              var token2 = this.scanner.scanRegExp();
              if (this.config.tokens) {
                this.tokens.pop();
                this.tokens.push(this.convertToken(token2));
              }
              this.lookahead = token2;
              this.nextToken();
              return token2;
            };
            Parser2.prototype.createNode = function() {
              return {
                index: this.startMarker.index,
                line: this.startMarker.line,
                column: this.startMarker.column
              };
            };
            Parser2.prototype.startNode = function(token2, lastLineStart) {
              if (lastLineStart === void 0) {
                lastLineStart = 0;
              }
              var column = token2.start - token2.lineStart;
              var line = token2.lineNumber;
              if (column < 0) {
                column += lastLineStart;
                line--;
              }
              return {
                index: token2.start,
                line,
                column
              };
            };
            Parser2.prototype.finalize = function(marker, node) {
              if (this.config.range) {
                node.range = [marker.index, this.lastMarker.index];
              }
              if (this.config.loc) {
                node.loc = {
                  start: {
                    line: marker.line,
                    column: marker.column
                  },
                  end: {
                    line: this.lastMarker.line,
                    column: this.lastMarker.column
                  }
                };
                if (this.config.source) {
                  node.loc.source = this.config.source;
                }
              }
              if (this.delegate) {
                var metadata = {
                  start: {
                    line: marker.line,
                    column: marker.column,
                    offset: marker.index
                  },
                  end: {
                    line: this.lastMarker.line,
                    column: this.lastMarker.column,
                    offset: this.lastMarker.index
                  }
                };
                this.delegate(node, metadata);
              }
              return node;
            };
            Parser2.prototype.expect = function(value) {
              var token2 = this.nextToken();
              if (token2.type !== 7 || token2.value !== value) {
                this.throwUnexpectedToken(token2);
              }
            };
            Parser2.prototype.expectCommaSeparator = function() {
              if (this.config.tolerant) {
                var token2 = this.lookahead;
                if (token2.type === 7 && token2.value === ",") {
                  this.nextToken();
                } else if (token2.type === 7 && token2.value === ";") {
                  this.nextToken();
                  this.tolerateUnexpectedToken(token2);
                } else {
                  this.tolerateUnexpectedToken(token2, messages_1.Messages.UnexpectedToken);
                }
              } else {
                this.expect(",");
              }
            };
            Parser2.prototype.expectKeyword = function(keyword) {
              var token2 = this.nextToken();
              if (token2.type !== 4 || token2.value !== keyword) {
                this.throwUnexpectedToken(token2);
              }
            };
            Parser2.prototype.match = function(value) {
              return this.lookahead.type === 7 && this.lookahead.value === value;
            };
            Parser2.prototype.matchKeyword = function(keyword) {
              return this.lookahead.type === 4 && this.lookahead.value === keyword;
            };
            Parser2.prototype.matchContextualKeyword = function(keyword) {
              return this.lookahead.type === 3 && this.lookahead.value === keyword;
            };
            Parser2.prototype.matchAssign = function() {
              if (this.lookahead.type !== 7) {
                return false;
              }
              var op = this.lookahead.value;
              return op === "=" || op === "*=" || op === "**=" || op === "/=" || op === "%=" || op === "+=" || op === "-=" || op === "<<=" || op === ">>=" || op === ">>>=" || op === "&=" || op === "^=" || op === "|=";
            };
            Parser2.prototype.isolateCoverGrammar = function(parseFunction) {
              var previousIsBindingElement = this.context.isBindingElement;
              var previousIsAssignmentTarget = this.context.isAssignmentTarget;
              var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
              this.context.isBindingElement = true;
              this.context.isAssignmentTarget = true;
              this.context.firstCoverInitializedNameError = null;
              var result2 = parseFunction.call(this);
              if (this.context.firstCoverInitializedNameError !== null) {
                this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
              }
              this.context.isBindingElement = previousIsBindingElement;
              this.context.isAssignmentTarget = previousIsAssignmentTarget;
              this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;
              return result2;
            };
            Parser2.prototype.inheritCoverGrammar = function(parseFunction) {
              var previousIsBindingElement = this.context.isBindingElement;
              var previousIsAssignmentTarget = this.context.isAssignmentTarget;
              var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
              this.context.isBindingElement = true;
              this.context.isAssignmentTarget = true;
              this.context.firstCoverInitializedNameError = null;
              var result2 = parseFunction.call(this);
              this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;
              this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;
              this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;
              return result2;
            };
            Parser2.prototype.consumeSemicolon = function() {
              if (this.match(";")) {
                this.nextToken();
              } else if (!this.hasLineTerminator) {
                if (this.lookahead.type !== 2 && !this.match("}")) {
                  this.throwUnexpectedToken(this.lookahead);
                }
                this.lastMarker.index = this.startMarker.index;
                this.lastMarker.line = this.startMarker.line;
                this.lastMarker.column = this.startMarker.column;
              }
            };
            Parser2.prototype.parsePrimaryExpression = function() {
              var node = this.createNode();
              var expr;
              var token2, raw;
              switch (this.lookahead.type) {
                case 3:
                  if ((this.context.isModule || this.context.await) && this.lookahead.value === "await") {
                    this.tolerateUnexpectedToken(this.lookahead);
                  }
                  expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node, new Node.Identifier(this.nextToken().value));
                  break;
                case 6:
                case 8:
                  if (this.context.strict && this.lookahead.octal) {
                    this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral);
                  }
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                  token2 = this.nextToken();
                  raw = this.getTokenRaw(token2);
                  expr = this.finalize(node, new Node.Literal(token2.value, raw));
                  break;
                case 1:
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                  token2 = this.nextToken();
                  raw = this.getTokenRaw(token2);
                  expr = this.finalize(node, new Node.Literal(token2.value === "true", raw));
                  break;
                case 5:
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                  token2 = this.nextToken();
                  raw = this.getTokenRaw(token2);
                  expr = this.finalize(node, new Node.Literal(null, raw));
                  break;
                case 10:
                  expr = this.parseTemplateLiteral();
                  break;
                case 7:
                  switch (this.lookahead.value) {
                    case "(":
                      this.context.isBindingElement = false;
                      expr = this.inheritCoverGrammar(this.parseGroupExpression);
                      break;
                    case "[":
                      expr = this.inheritCoverGrammar(this.parseArrayInitializer);
                      break;
                    case "{":
                      expr = this.inheritCoverGrammar(this.parseObjectInitializer);
                      break;
                    case "/":
                    case "/=":
                      this.context.isAssignmentTarget = false;
                      this.context.isBindingElement = false;
                      this.scanner.index = this.startMarker.index;
                      token2 = this.nextRegexToken();
                      raw = this.getTokenRaw(token2);
                      expr = this.finalize(node, new Node.RegexLiteral(token2.regex, raw, token2.pattern, token2.flags));
                      break;
                    default:
                      expr = this.throwUnexpectedToken(this.nextToken());
                  }
                  break;
                case 4:
                  if (!this.context.strict && this.context.allowYield && this.matchKeyword("yield")) {
                    expr = this.parseIdentifierName();
                  } else if (!this.context.strict && this.matchKeyword("let")) {
                    expr = this.finalize(node, new Node.Identifier(this.nextToken().value));
                  } else {
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                    if (this.matchKeyword("function")) {
                      expr = this.parseFunctionExpression();
                    } else if (this.matchKeyword("this")) {
                      this.nextToken();
                      expr = this.finalize(node, new Node.ThisExpression());
                    } else if (this.matchKeyword("class")) {
                      expr = this.parseClassExpression();
                    } else {
                      expr = this.throwUnexpectedToken(this.nextToken());
                    }
                  }
                  break;
                default:
                  expr = this.throwUnexpectedToken(this.nextToken());
              }
              return expr;
            };
            Parser2.prototype.parseSpreadElement = function() {
              var node = this.createNode();
              this.expect("...");
              var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
              return this.finalize(node, new Node.SpreadElement(arg));
            };
            Parser2.prototype.parseArrayInitializer = function() {
              var node = this.createNode();
              var elements = [];
              this.expect("[");
              while (!this.match("]")) {
                if (this.match(",")) {
                  this.nextToken();
                  elements.push(null);
                } else if (this.match("...")) {
                  var element = this.parseSpreadElement();
                  if (!this.match("]")) {
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                    this.expect(",");
                  }
                  elements.push(element);
                } else {
                  elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
                  if (!this.match("]")) {
                    this.expect(",");
                  }
                }
              }
              this.expect("]");
              return this.finalize(node, new Node.ArrayExpression(elements));
            };
            Parser2.prototype.parsePropertyMethod = function(params) {
              this.context.isAssignmentTarget = false;
              this.context.isBindingElement = false;
              var previousStrict = this.context.strict;
              var previousAllowStrictDirective = this.context.allowStrictDirective;
              this.context.allowStrictDirective = params.simple;
              var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
              if (this.context.strict && params.firstRestricted) {
                this.tolerateUnexpectedToken(params.firstRestricted, params.message);
              }
              if (this.context.strict && params.stricted) {
                this.tolerateUnexpectedToken(params.stricted, params.message);
              }
              this.context.strict = previousStrict;
              this.context.allowStrictDirective = previousAllowStrictDirective;
              return body;
            };
            Parser2.prototype.parsePropertyMethodFunction = function() {
              var isGenerator = false;
              var node = this.createNode();
              var previousAllowYield = this.context.allowYield;
              this.context.allowYield = true;
              var params = this.parseFormalParameters();
              var method = this.parsePropertyMethod(params);
              this.context.allowYield = previousAllowYield;
              return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
            };
            Parser2.prototype.parsePropertyMethodAsyncFunction = function() {
              var node = this.createNode();
              var previousAllowYield = this.context.allowYield;
              var previousAwait = this.context.await;
              this.context.allowYield = false;
              this.context.await = true;
              var params = this.parseFormalParameters();
              var method = this.parsePropertyMethod(params);
              this.context.allowYield = previousAllowYield;
              this.context.await = previousAwait;
              return this.finalize(node, new Node.AsyncFunctionExpression(null, params.params, method));
            };
            Parser2.prototype.parseObjectPropertyKey = function() {
              var node = this.createNode();
              var token2 = this.nextToken();
              var key;
              switch (token2.type) {
                case 8:
                case 6:
                  if (this.context.strict && token2.octal) {
                    this.tolerateUnexpectedToken(token2, messages_1.Messages.StrictOctalLiteral);
                  }
                  var raw = this.getTokenRaw(token2);
                  key = this.finalize(node, new Node.Literal(token2.value, raw));
                  break;
                case 3:
                case 1:
                case 5:
                case 4:
                  key = this.finalize(node, new Node.Identifier(token2.value));
                  break;
                case 7:
                  if (token2.value === "[") {
                    key = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    this.expect("]");
                  } else {
                    key = this.throwUnexpectedToken(token2);
                  }
                  break;
                default:
                  key = this.throwUnexpectedToken(token2);
              }
              return key;
            };
            Parser2.prototype.isPropertyKey = function(key, value) {
              return key.type === syntax_1.Syntax.Identifier && key.name === value || key.type === syntax_1.Syntax.Literal && key.value === value;
            };
            Parser2.prototype.parseObjectProperty = function(hasProto) {
              var node = this.createNode();
              var token2 = this.lookahead;
              var kind;
              var key = null;
              var value = null;
              var computed = false;
              var method = false;
              var shorthand = false;
              var isAsync = false;
              if (token2.type === 3) {
                var id = token2.value;
                this.nextToken();
                computed = this.match("[");
                isAsync = !this.hasLineTerminator && id === "async" && !this.match(":") && !this.match("(") && !this.match("*") && !this.match(",");
                key = isAsync ? this.parseObjectPropertyKey() : this.finalize(node, new Node.Identifier(id));
              } else if (this.match("*")) {
                this.nextToken();
              } else {
                computed = this.match("[");
                key = this.parseObjectPropertyKey();
              }
              var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
              if (token2.type === 3 && !isAsync && token2.value === "get" && lookaheadPropertyKey) {
                kind = "get";
                computed = this.match("[");
                key = this.parseObjectPropertyKey();
                this.context.allowYield = false;
                value = this.parseGetterMethod();
              } else if (token2.type === 3 && !isAsync && token2.value === "set" && lookaheadPropertyKey) {
                kind = "set";
                computed = this.match("[");
                key = this.parseObjectPropertyKey();
                value = this.parseSetterMethod();
              } else if (token2.type === 7 && token2.value === "*" && lookaheadPropertyKey) {
                kind = "init";
                computed = this.match("[");
                key = this.parseObjectPropertyKey();
                value = this.parseGeneratorMethod();
                method = true;
              } else {
                if (!key) {
                  this.throwUnexpectedToken(this.lookahead);
                }
                kind = "init";
                if (this.match(":") && !isAsync) {
                  if (!computed && this.isPropertyKey(key, "__proto__")) {
                    if (hasProto.value) {
                      this.tolerateError(messages_1.Messages.DuplicateProtoProperty);
                    }
                    hasProto.value = true;
                  }
                  this.nextToken();
                  value = this.inheritCoverGrammar(this.parseAssignmentExpression);
                } else if (this.match("(")) {
                  value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
                  method = true;
                } else if (token2.type === 3) {
                  var id = this.finalize(node, new Node.Identifier(token2.value));
                  if (this.match("=")) {
                    this.context.firstCoverInitializedNameError = this.lookahead;
                    this.nextToken();
                    shorthand = true;
                    var init = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    value = this.finalize(node, new Node.AssignmentPattern(id, init));
                  } else {
                    shorthand = true;
                    value = id;
                  }
                } else {
                  this.throwUnexpectedToken(this.nextToken());
                }
              }
              return this.finalize(node, new Node.Property(kind, key, computed, value, method, shorthand));
            };
            Parser2.prototype.parseObjectInitializer = function() {
              var node = this.createNode();
              this.expect("{");
              var properties = [];
              var hasProto = { value: false };
              while (!this.match("}")) {
                properties.push(this.parseObjectProperty(hasProto));
                if (!this.match("}")) {
                  this.expectCommaSeparator();
                }
              }
              this.expect("}");
              return this.finalize(node, new Node.ObjectExpression(properties));
            };
            Parser2.prototype.parseTemplateHead = function() {
              assert_1.assert(this.lookahead.head, "Template literal must start with a template head");
              var node = this.createNode();
              var token2 = this.nextToken();
              var raw = token2.value;
              var cooked = token2.cooked;
              return this.finalize(node, new Node.TemplateElement({ raw, cooked }, token2.tail));
            };
            Parser2.prototype.parseTemplateElement = function() {
              if (this.lookahead.type !== 10) {
                this.throwUnexpectedToken();
              }
              var node = this.createNode();
              var token2 = this.nextToken();
              var raw = token2.value;
              var cooked = token2.cooked;
              return this.finalize(node, new Node.TemplateElement({ raw, cooked }, token2.tail));
            };
            Parser2.prototype.parseTemplateLiteral = function() {
              var node = this.createNode();
              var expressions = [];
              var quasis = [];
              var quasi = this.parseTemplateHead();
              quasis.push(quasi);
              while (!quasi.tail) {
                expressions.push(this.parseExpression());
                quasi = this.parseTemplateElement();
                quasis.push(quasi);
              }
              return this.finalize(node, new Node.TemplateLiteral(quasis, expressions));
            };
            Parser2.prototype.reinterpretExpressionAsPattern = function(expr) {
              switch (expr.type) {
                case syntax_1.Syntax.Identifier:
                case syntax_1.Syntax.MemberExpression:
                case syntax_1.Syntax.RestElement:
                case syntax_1.Syntax.AssignmentPattern:
                  break;
                case syntax_1.Syntax.SpreadElement:
                  expr.type = syntax_1.Syntax.RestElement;
                  this.reinterpretExpressionAsPattern(expr.argument);
                  break;
                case syntax_1.Syntax.ArrayExpression:
                  expr.type = syntax_1.Syntax.ArrayPattern;
                  for (var i = 0; i < expr.elements.length; i++) {
                    if (expr.elements[i] !== null) {
                      this.reinterpretExpressionAsPattern(expr.elements[i]);
                    }
                  }
                  break;
                case syntax_1.Syntax.ObjectExpression:
                  expr.type = syntax_1.Syntax.ObjectPattern;
                  for (var i = 0; i < expr.properties.length; i++) {
                    this.reinterpretExpressionAsPattern(expr.properties[i].value);
                  }
                  break;
                case syntax_1.Syntax.AssignmentExpression:
                  expr.type = syntax_1.Syntax.AssignmentPattern;
                  delete expr.operator;
                  this.reinterpretExpressionAsPattern(expr.left);
                  break;
                default:
                  break;
              }
            };
            Parser2.prototype.parseGroupExpression = function() {
              var expr;
              this.expect("(");
              if (this.match(")")) {
                this.nextToken();
                if (!this.match("=>")) {
                  this.expect("=>");
                }
                expr = {
                  type: ArrowParameterPlaceHolder,
                  params: [],
                  async: false
                };
              } else {
                var startToken = this.lookahead;
                var params = [];
                if (this.match("...")) {
                  expr = this.parseRestElement(params);
                  this.expect(")");
                  if (!this.match("=>")) {
                    this.expect("=>");
                  }
                  expr = {
                    type: ArrowParameterPlaceHolder,
                    params: [expr],
                    async: false
                  };
                } else {
                  var arrow = false;
                  this.context.isBindingElement = true;
                  expr = this.inheritCoverGrammar(this.parseAssignmentExpression);
                  if (this.match(",")) {
                    var expressions = [];
                    this.context.isAssignmentTarget = false;
                    expressions.push(expr);
                    while (this.lookahead.type !== 2) {
                      if (!this.match(",")) {
                        break;
                      }
                      this.nextToken();
                      if (this.match(")")) {
                        this.nextToken();
                        for (var i = 0; i < expressions.length; i++) {
                          this.reinterpretExpressionAsPattern(expressions[i]);
                        }
                        arrow = true;
                        expr = {
                          type: ArrowParameterPlaceHolder,
                          params: expressions,
                          async: false
                        };
                      } else if (this.match("...")) {
                        if (!this.context.isBindingElement) {
                          this.throwUnexpectedToken(this.lookahead);
                        }
                        expressions.push(this.parseRestElement(params));
                        this.expect(")");
                        if (!this.match("=>")) {
                          this.expect("=>");
                        }
                        this.context.isBindingElement = false;
                        for (var i = 0; i < expressions.length; i++) {
                          this.reinterpretExpressionAsPattern(expressions[i]);
                        }
                        arrow = true;
                        expr = {
                          type: ArrowParameterPlaceHolder,
                          params: expressions,
                          async: false
                        };
                      } else {
                        expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
                      }
                      if (arrow) {
                        break;
                      }
                    }
                    if (!arrow) {
                      expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
                    }
                  }
                  if (!arrow) {
                    this.expect(")");
                    if (this.match("=>")) {
                      if (expr.type === syntax_1.Syntax.Identifier && expr.name === "yield") {
                        arrow = true;
                        expr = {
                          type: ArrowParameterPlaceHolder,
                          params: [expr],
                          async: false
                        };
                      }
                      if (!arrow) {
                        if (!this.context.isBindingElement) {
                          this.throwUnexpectedToken(this.lookahead);
                        }
                        if (expr.type === syntax_1.Syntax.SequenceExpression) {
                          for (var i = 0; i < expr.expressions.length; i++) {
                            this.reinterpretExpressionAsPattern(expr.expressions[i]);
                          }
                        } else {
                          this.reinterpretExpressionAsPattern(expr);
                        }
                        var parameters = expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [expr];
                        expr = {
                          type: ArrowParameterPlaceHolder,
                          params: parameters,
                          async: false
                        };
                      }
                    }
                    this.context.isBindingElement = false;
                  }
                }
              }
              return expr;
            };
            Parser2.prototype.parseArguments = function() {
              this.expect("(");
              var args = [];
              if (!this.match(")")) {
                while (true) {
                  var expr = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAssignmentExpression);
                  args.push(expr);
                  if (this.match(")")) {
                    break;
                  }
                  this.expectCommaSeparator();
                  if (this.match(")")) {
                    break;
                  }
                }
              }
              this.expect(")");
              return args;
            };
            Parser2.prototype.isIdentifierName = function(token2) {
              return token2.type === 3 || token2.type === 4 || token2.type === 1 || token2.type === 5;
            };
            Parser2.prototype.parseIdentifierName = function() {
              var node = this.createNode();
              var token2 = this.nextToken();
              if (!this.isIdentifierName(token2)) {
                this.throwUnexpectedToken(token2);
              }
              return this.finalize(node, new Node.Identifier(token2.value));
            };
            Parser2.prototype.parseNewExpression = function() {
              var node = this.createNode();
              var id = this.parseIdentifierName();
              assert_1.assert(id.name === "new", "New expression must start with `new`");
              var expr;
              if (this.match(".")) {
                this.nextToken();
                if (this.lookahead.type === 3 && this.context.inFunctionBody && this.lookahead.value === "target") {
                  var property = this.parseIdentifierName();
                  expr = new Node.MetaProperty(id, property);
                } else {
                  this.throwUnexpectedToken(this.lookahead);
                }
              } else {
                var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);
                var args = this.match("(") ? this.parseArguments() : [];
                expr = new Node.NewExpression(callee, args);
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
              }
              return this.finalize(node, expr);
            };
            Parser2.prototype.parseAsyncArgument = function() {
              var arg = this.parseAssignmentExpression();
              this.context.firstCoverInitializedNameError = null;
              return arg;
            };
            Parser2.prototype.parseAsyncArguments = function() {
              this.expect("(");
              var args = [];
              if (!this.match(")")) {
                while (true) {
                  var expr = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAsyncArgument);
                  args.push(expr);
                  if (this.match(")")) {
                    break;
                  }
                  this.expectCommaSeparator();
                  if (this.match(")")) {
                    break;
                  }
                }
              }
              this.expect(")");
              return args;
            };
            Parser2.prototype.parseLeftHandSideExpressionAllowCall = function() {
              var startToken = this.lookahead;
              var maybeAsync = this.matchContextualKeyword("async");
              var previousAllowIn = this.context.allowIn;
              this.context.allowIn = true;
              var expr;
              if (this.matchKeyword("super") && this.context.inFunctionBody) {
                expr = this.createNode();
                this.nextToken();
                expr = this.finalize(expr, new Node.Super());
                if (!this.match("(") && !this.match(".") && !this.match("[")) {
                  this.throwUnexpectedToken(this.lookahead);
                }
              } else {
                expr = this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression);
              }
              while (true) {
                if (this.match(".")) {
                  this.context.isBindingElement = false;
                  this.context.isAssignmentTarget = true;
                  this.expect(".");
                  var property = this.parseIdentifierName();
                  expr = this.finalize(this.startNode(startToken), new Node.StaticMemberExpression(expr, property));
                } else if (this.match("(")) {
                  var asyncArrow = maybeAsync && startToken.lineNumber === this.lookahead.lineNumber;
                  this.context.isBindingElement = false;
                  this.context.isAssignmentTarget = false;
                  var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();
                  expr = this.finalize(this.startNode(startToken), new Node.CallExpression(expr, args));
                  if (asyncArrow && this.match("=>")) {
                    for (var i = 0; i < args.length; ++i) {
                      this.reinterpretExpressionAsPattern(args[i]);
                    }
                    expr = {
                      type: ArrowParameterPlaceHolder,
                      params: args,
                      async: true
                    };
                  }
                } else if (this.match("[")) {
                  this.context.isBindingElement = false;
                  this.context.isAssignmentTarget = true;
                  this.expect("[");
                  var property = this.isolateCoverGrammar(this.parseExpression);
                  this.expect("]");
                  expr = this.finalize(this.startNode(startToken), new Node.ComputedMemberExpression(expr, property));
                } else if (this.lookahead.type === 10 && this.lookahead.head) {
                  var quasi = this.parseTemplateLiteral();
                  expr = this.finalize(this.startNode(startToken), new Node.TaggedTemplateExpression(expr, quasi));
                } else {
                  break;
                }
              }
              this.context.allowIn = previousAllowIn;
              return expr;
            };
            Parser2.prototype.parseSuper = function() {
              var node = this.createNode();
              this.expectKeyword("super");
              if (!this.match("[") && !this.match(".")) {
                this.throwUnexpectedToken(this.lookahead);
              }
              return this.finalize(node, new Node.Super());
            };
            Parser2.prototype.parseLeftHandSideExpression = function() {
              assert_1.assert(this.context.allowIn, "callee of new expression always allow in keyword.");
              var node = this.startNode(this.lookahead);
              var expr = this.matchKeyword("super") && this.context.inFunctionBody ? this.parseSuper() : this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression);
              while (true) {
                if (this.match("[")) {
                  this.context.isBindingElement = false;
                  this.context.isAssignmentTarget = true;
                  this.expect("[");
                  var property = this.isolateCoverGrammar(this.parseExpression);
                  this.expect("]");
                  expr = this.finalize(node, new Node.ComputedMemberExpression(expr, property));
                } else if (this.match(".")) {
                  this.context.isBindingElement = false;
                  this.context.isAssignmentTarget = true;
                  this.expect(".");
                  var property = this.parseIdentifierName();
                  expr = this.finalize(node, new Node.StaticMemberExpression(expr, property));
                } else if (this.lookahead.type === 10 && this.lookahead.head) {
                  var quasi = this.parseTemplateLiteral();
                  expr = this.finalize(node, new Node.TaggedTemplateExpression(expr, quasi));
                } else {
                  break;
                }
              }
              return expr;
            };
            Parser2.prototype.parseUpdateExpression = function() {
              var expr;
              var startToken = this.lookahead;
              if (this.match("++") || this.match("--")) {
                var node = this.startNode(startToken);
                var token2 = this.nextToken();
                expr = this.inheritCoverGrammar(this.parseUnaryExpression);
                if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
                  this.tolerateError(messages_1.Messages.StrictLHSPrefix);
                }
                if (!this.context.isAssignmentTarget) {
                  this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                }
                var prefix = true;
                expr = this.finalize(node, new Node.UpdateExpression(token2.value, expr, prefix));
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
              } else {
                expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
                if (!this.hasLineTerminator && this.lookahead.type === 7) {
                  if (this.match("++") || this.match("--")) {
                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
                      this.tolerateError(messages_1.Messages.StrictLHSPostfix);
                    }
                    if (!this.context.isAssignmentTarget) {
                      this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                    }
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                    var operator = this.nextToken().value;
                    var prefix = false;
                    expr = this.finalize(this.startNode(startToken), new Node.UpdateExpression(operator, expr, prefix));
                  }
                }
              }
              return expr;
            };
            Parser2.prototype.parseAwaitExpression = function() {
              var node = this.createNode();
              this.nextToken();
              var argument = this.parseUnaryExpression();
              return this.finalize(node, new Node.AwaitExpression(argument));
            };
            Parser2.prototype.parseUnaryExpression = function() {
              var expr;
              if (this.match("+") || this.match("-") || this.match("~") || this.match("!") || this.matchKeyword("delete") || this.matchKeyword("void") || this.matchKeyword("typeof")) {
                var node = this.startNode(this.lookahead);
                var token2 = this.nextToken();
                expr = this.inheritCoverGrammar(this.parseUnaryExpression);
                expr = this.finalize(node, new Node.UnaryExpression(token2.value, expr));
                if (this.context.strict && expr.operator === "delete" && expr.argument.type === syntax_1.Syntax.Identifier) {
                  this.tolerateError(messages_1.Messages.StrictDelete);
                }
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
              } else if (this.context.await && this.matchContextualKeyword("await")) {
                expr = this.parseAwaitExpression();
              } else {
                expr = this.parseUpdateExpression();
              }
              return expr;
            };
            Parser2.prototype.parseExponentiationExpression = function() {
              var startToken = this.lookahead;
              var expr = this.inheritCoverGrammar(this.parseUnaryExpression);
              if (expr.type !== syntax_1.Syntax.UnaryExpression && this.match("**")) {
                this.nextToken();
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
                var left = expr;
                var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
                expr = this.finalize(this.startNode(startToken), new Node.BinaryExpression("**", left, right));
              }
              return expr;
            };
            Parser2.prototype.binaryPrecedence = function(token2) {
              var op = token2.value;
              var precedence;
              if (token2.type === 7) {
                precedence = this.operatorPrecedence[op] || 0;
              } else if (token2.type === 4) {
                precedence = op === "instanceof" || this.context.allowIn && op === "in" ? 7 : 0;
              } else {
                precedence = 0;
              }
              return precedence;
            };
            Parser2.prototype.parseBinaryExpression = function() {
              var startToken = this.lookahead;
              var expr = this.inheritCoverGrammar(this.parseExponentiationExpression);
              var token2 = this.lookahead;
              var prec = this.binaryPrecedence(token2);
              if (prec > 0) {
                this.nextToken();
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
                var markers = [startToken, this.lookahead];
                var left = expr;
                var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
                var stack = [left, token2.value, right];
                var precedences = [prec];
                while (true) {
                  prec = this.binaryPrecedence(this.lookahead);
                  if (prec <= 0) {
                    break;
                  }
                  while (stack.length > 2 && prec <= precedences[precedences.length - 1]) {
                    right = stack.pop();
                    var operator = stack.pop();
                    precedences.pop();
                    left = stack.pop();
                    markers.pop();
                    var node = this.startNode(markers[markers.length - 1]);
                    stack.push(this.finalize(node, new Node.BinaryExpression(operator, left, right)));
                  }
                  stack.push(this.nextToken().value);
                  precedences.push(prec);
                  markers.push(this.lookahead);
                  stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
                }
                var i = stack.length - 1;
                expr = stack[i];
                var lastMarker = markers.pop();
                while (i > 1) {
                  var marker = markers.pop();
                  var lastLineStart = lastMarker && lastMarker.lineStart;
                  var node = this.startNode(marker, lastLineStart);
                  var operator = stack[i - 1];
                  expr = this.finalize(node, new Node.BinaryExpression(operator, stack[i - 2], expr));
                  i -= 2;
                  lastMarker = marker;
                }
              }
              return expr;
            };
            Parser2.prototype.parseConditionalExpression = function() {
              var startToken = this.lookahead;
              var expr = this.inheritCoverGrammar(this.parseBinaryExpression);
              if (this.match("?")) {
                this.nextToken();
                var previousAllowIn = this.context.allowIn;
                this.context.allowIn = true;
                var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
                this.context.allowIn = previousAllowIn;
                this.expect(":");
                var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
                expr = this.finalize(this.startNode(startToken), new Node.ConditionalExpression(expr, consequent, alternate));
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
              }
              return expr;
            };
            Parser2.prototype.checkPatternParam = function(options2, param) {
              switch (param.type) {
                case syntax_1.Syntax.Identifier:
                  this.validateParam(options2, param, param.name);
                  break;
                case syntax_1.Syntax.RestElement:
                  this.checkPatternParam(options2, param.argument);
                  break;
                case syntax_1.Syntax.AssignmentPattern:
                  this.checkPatternParam(options2, param.left);
                  break;
                case syntax_1.Syntax.ArrayPattern:
                  for (var i = 0; i < param.elements.length; i++) {
                    if (param.elements[i] !== null) {
                      this.checkPatternParam(options2, param.elements[i]);
                    }
                  }
                  break;
                case syntax_1.Syntax.ObjectPattern:
                  for (var i = 0; i < param.properties.length; i++) {
                    this.checkPatternParam(options2, param.properties[i].value);
                  }
                  break;
                default:
                  break;
              }
              options2.simple = options2.simple && param instanceof Node.Identifier;
            };
            Parser2.prototype.reinterpretAsCoverFormalsList = function(expr) {
              var params = [expr];
              var options2;
              var asyncArrow = false;
              switch (expr.type) {
                case syntax_1.Syntax.Identifier:
                  break;
                case ArrowParameterPlaceHolder:
                  params = expr.params;
                  asyncArrow = expr.async;
                  break;
                default:
                  return null;
              }
              options2 = {
                simple: true,
                paramSet: {}
              };
              for (var i = 0; i < params.length; ++i) {
                var param = params[i];
                if (param.type === syntax_1.Syntax.AssignmentPattern) {
                  if (param.right.type === syntax_1.Syntax.YieldExpression) {
                    if (param.right.argument) {
                      this.throwUnexpectedToken(this.lookahead);
                    }
                    param.right.type = syntax_1.Syntax.Identifier;
                    param.right.name = "yield";
                    delete param.right.argument;
                    delete param.right.delegate;
                  }
                } else if (asyncArrow && param.type === syntax_1.Syntax.Identifier && param.name === "await") {
                  this.throwUnexpectedToken(this.lookahead);
                }
                this.checkPatternParam(options2, param);
                params[i] = param;
              }
              if (this.context.strict || !this.context.allowYield) {
                for (var i = 0; i < params.length; ++i) {
                  var param = params[i];
                  if (param.type === syntax_1.Syntax.YieldExpression) {
                    this.throwUnexpectedToken(this.lookahead);
                  }
                }
              }
              if (options2.message === messages_1.Messages.StrictParamDupe) {
                var token2 = this.context.strict ? options2.stricted : options2.firstRestricted;
                this.throwUnexpectedToken(token2, options2.message);
              }
              return {
                simple: options2.simple,
                params,
                stricted: options2.stricted,
                firstRestricted: options2.firstRestricted,
                message: options2.message
              };
            };
            Parser2.prototype.parseAssignmentExpression = function() {
              var expr;
              if (!this.context.allowYield && this.matchKeyword("yield")) {
                expr = this.parseYieldExpression();
              } else {
                var startToken = this.lookahead;
                var token2 = startToken;
                expr = this.parseConditionalExpression();
                if (token2.type === 3 && token2.lineNumber === this.lookahead.lineNumber && token2.value === "async") {
                  if (this.lookahead.type === 3 || this.matchKeyword("yield")) {
                    var arg = this.parsePrimaryExpression();
                    this.reinterpretExpressionAsPattern(arg);
                    expr = {
                      type: ArrowParameterPlaceHolder,
                      params: [arg],
                      async: true
                    };
                  }
                }
                if (expr.type === ArrowParameterPlaceHolder || this.match("=>")) {
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                  var isAsync = expr.async;
                  var list = this.reinterpretAsCoverFormalsList(expr);
                  if (list) {
                    if (this.hasLineTerminator) {
                      this.tolerateUnexpectedToken(this.lookahead);
                    }
                    this.context.firstCoverInitializedNameError = null;
                    var previousStrict = this.context.strict;
                    var previousAllowStrictDirective = this.context.allowStrictDirective;
                    this.context.allowStrictDirective = list.simple;
                    var previousAllowYield = this.context.allowYield;
                    var previousAwait = this.context.await;
                    this.context.allowYield = true;
                    this.context.await = isAsync;
                    var node = this.startNode(startToken);
                    this.expect("=>");
                    var body = void 0;
                    if (this.match("{")) {
                      var previousAllowIn = this.context.allowIn;
                      this.context.allowIn = true;
                      body = this.parseFunctionSourceElements();
                      this.context.allowIn = previousAllowIn;
                    } else {
                      body = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    }
                    var expression = body.type !== syntax_1.Syntax.BlockStatement;
                    if (this.context.strict && list.firstRestricted) {
                      this.throwUnexpectedToken(list.firstRestricted, list.message);
                    }
                    if (this.context.strict && list.stricted) {
                      this.tolerateUnexpectedToken(list.stricted, list.message);
                    }
                    expr = isAsync ? this.finalize(node, new Node.AsyncArrowFunctionExpression(list.params, body, expression)) : this.finalize(node, new Node.ArrowFunctionExpression(list.params, body, expression));
                    this.context.strict = previousStrict;
                    this.context.allowStrictDirective = previousAllowStrictDirective;
                    this.context.allowYield = previousAllowYield;
                    this.context.await = previousAwait;
                  }
                } else {
                  if (this.matchAssign()) {
                    if (!this.context.isAssignmentTarget) {
                      this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                    }
                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier) {
                      var id = expr;
                      if (this.scanner.isRestrictedWord(id.name)) {
                        this.tolerateUnexpectedToken(token2, messages_1.Messages.StrictLHSAssignment);
                      }
                      if (this.scanner.isStrictModeReservedWord(id.name)) {
                        this.tolerateUnexpectedToken(token2, messages_1.Messages.StrictReservedWord);
                      }
                    }
                    if (!this.match("=")) {
                      this.context.isAssignmentTarget = false;
                      this.context.isBindingElement = false;
                    } else {
                      this.reinterpretExpressionAsPattern(expr);
                    }
                    token2 = this.nextToken();
                    var operator = token2.value;
                    var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    expr = this.finalize(this.startNode(startToken), new Node.AssignmentExpression(operator, expr, right));
                    this.context.firstCoverInitializedNameError = null;
                  }
                }
              }
              return expr;
            };
            Parser2.prototype.parseExpression = function() {
              var startToken = this.lookahead;
              var expr = this.isolateCoverGrammar(this.parseAssignmentExpression);
              if (this.match(",")) {
                var expressions = [];
                expressions.push(expr);
                while (this.lookahead.type !== 2) {
                  if (!this.match(",")) {
                    break;
                  }
                  this.nextToken();
                  expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                }
                expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
              }
              return expr;
            };
            Parser2.prototype.parseStatementListItem = function() {
              var statement;
              this.context.isAssignmentTarget = true;
              this.context.isBindingElement = true;
              if (this.lookahead.type === 4) {
                switch (this.lookahead.value) {
                  case "export":
                    if (!this.context.isModule) {
                      this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration);
                    }
                    statement = this.parseExportDeclaration();
                    break;
                  case "import":
                    if (!this.context.isModule) {
                      this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration);
                    }
                    statement = this.parseImportDeclaration();
                    break;
                  case "const":
                    statement = this.parseLexicalDeclaration({ inFor: false });
                    break;
                  case "function":
                    statement = this.parseFunctionDeclaration();
                    break;
                  case "class":
                    statement = this.parseClassDeclaration();
                    break;
                  case "let":
                    statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: false }) : this.parseStatement();
                    break;
                  default:
                    statement = this.parseStatement();
                    break;
                }
              } else {
                statement = this.parseStatement();
              }
              return statement;
            };
            Parser2.prototype.parseBlock = function() {
              var node = this.createNode();
              this.expect("{");
              var block = [];
              while (true) {
                if (this.match("}")) {
                  break;
                }
                block.push(this.parseStatementListItem());
              }
              this.expect("}");
              return this.finalize(node, new Node.BlockStatement(block));
            };
            Parser2.prototype.parseLexicalBinding = function(kind, options2) {
              var node = this.createNode();
              var params = [];
              var id = this.parsePattern(params, kind);
              if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
                if (this.scanner.isRestrictedWord(id.name)) {
                  this.tolerateError(messages_1.Messages.StrictVarName);
                }
              }
              var init = null;
              if (kind === "const") {
                if (!this.matchKeyword("in") && !this.matchContextualKeyword("of")) {
                  if (this.match("=")) {
                    this.nextToken();
                    init = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  } else {
                    this.throwError(messages_1.Messages.DeclarationMissingInitializer, "const");
                  }
                }
              } else if (!options2.inFor && id.type !== syntax_1.Syntax.Identifier || this.match("=")) {
                this.expect("=");
                init = this.isolateCoverGrammar(this.parseAssignmentExpression);
              }
              return this.finalize(node, new Node.VariableDeclarator(id, init));
            };
            Parser2.prototype.parseBindingList = function(kind, options2) {
              var list = [this.parseLexicalBinding(kind, options2)];
              while (this.match(",")) {
                this.nextToken();
                list.push(this.parseLexicalBinding(kind, options2));
              }
              return list;
            };
            Parser2.prototype.isLexicalDeclaration = function() {
              var state = this.scanner.saveState();
              this.scanner.scanComments();
              var next = this.scanner.lex();
              this.scanner.restoreState(state);
              return next.type === 3 || next.type === 7 && next.value === "[" || next.type === 7 && next.value === "{" || next.type === 4 && next.value === "let" || next.type === 4 && next.value === "yield";
            };
            Parser2.prototype.parseLexicalDeclaration = function(options2) {
              var node = this.createNode();
              var kind = this.nextToken().value;
              assert_1.assert(kind === "let" || kind === "const", "Lexical declaration must be either let or const");
              var declarations = this.parseBindingList(kind, options2);
              this.consumeSemicolon();
              return this.finalize(node, new Node.VariableDeclaration(declarations, kind));
            };
            Parser2.prototype.parseBindingRestElement = function(params, kind) {
              var node = this.createNode();
              this.expect("...");
              var arg = this.parsePattern(params, kind);
              return this.finalize(node, new Node.RestElement(arg));
            };
            Parser2.prototype.parseArrayPattern = function(params, kind) {
              var node = this.createNode();
              this.expect("[");
              var elements = [];
              while (!this.match("]")) {
                if (this.match(",")) {
                  this.nextToken();
                  elements.push(null);
                } else {
                  if (this.match("...")) {
                    elements.push(this.parseBindingRestElement(params, kind));
                    break;
                  } else {
                    elements.push(this.parsePatternWithDefault(params, kind));
                  }
                  if (!this.match("]")) {
                    this.expect(",");
                  }
                }
              }
              this.expect("]");
              return this.finalize(node, new Node.ArrayPattern(elements));
            };
            Parser2.prototype.parsePropertyPattern = function(params, kind) {
              var node = this.createNode();
              var computed = false;
              var shorthand = false;
              var method = false;
              var key;
              var value;
              if (this.lookahead.type === 3) {
                var keyToken = this.lookahead;
                key = this.parseVariableIdentifier();
                var init = this.finalize(node, new Node.Identifier(keyToken.value));
                if (this.match("=")) {
                  params.push(keyToken);
                  shorthand = true;
                  this.nextToken();
                  var expr = this.parseAssignmentExpression();
                  value = this.finalize(this.startNode(keyToken), new Node.AssignmentPattern(init, expr));
                } else if (!this.match(":")) {
                  params.push(keyToken);
                  shorthand = true;
                  value = init;
                } else {
                  this.expect(":");
                  value = this.parsePatternWithDefault(params, kind);
                }
              } else {
                computed = this.match("[");
                key = this.parseObjectPropertyKey();
                this.expect(":");
                value = this.parsePatternWithDefault(params, kind);
              }
              return this.finalize(node, new Node.Property("init", key, computed, value, method, shorthand));
            };
            Parser2.prototype.parseObjectPattern = function(params, kind) {
              var node = this.createNode();
              var properties = [];
              this.expect("{");
              while (!this.match("}")) {
                properties.push(this.parsePropertyPattern(params, kind));
                if (!this.match("}")) {
                  this.expect(",");
                }
              }
              this.expect("}");
              return this.finalize(node, new Node.ObjectPattern(properties));
            };
            Parser2.prototype.parsePattern = function(params, kind) {
              var pattern;
              if (this.match("[")) {
                pattern = this.parseArrayPattern(params, kind);
              } else if (this.match("{")) {
                pattern = this.parseObjectPattern(params, kind);
              } else {
                if (this.matchKeyword("let") && (kind === "const" || kind === "let")) {
                  this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding);
                }
                params.push(this.lookahead);
                pattern = this.parseVariableIdentifier(kind);
              }
              return pattern;
            };
            Parser2.prototype.parsePatternWithDefault = function(params, kind) {
              var startToken = this.lookahead;
              var pattern = this.parsePattern(params, kind);
              if (this.match("=")) {
                this.nextToken();
                var previousAllowYield = this.context.allowYield;
                this.context.allowYield = true;
                var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
                this.context.allowYield = previousAllowYield;
                pattern = this.finalize(this.startNode(startToken), new Node.AssignmentPattern(pattern, right));
              }
              return pattern;
            };
            Parser2.prototype.parseVariableIdentifier = function(kind) {
              var node = this.createNode();
              var token2 = this.nextToken();
              if (token2.type === 4 && token2.value === "yield") {
                if (this.context.strict) {
                  this.tolerateUnexpectedToken(token2, messages_1.Messages.StrictReservedWord);
                } else if (!this.context.allowYield) {
                  this.throwUnexpectedToken(token2);
                }
              } else if (token2.type !== 3) {
                if (this.context.strict && token2.type === 4 && this.scanner.isStrictModeReservedWord(token2.value)) {
                  this.tolerateUnexpectedToken(token2, messages_1.Messages.StrictReservedWord);
                } else {
                  if (this.context.strict || token2.value !== "let" || kind !== "var") {
                    this.throwUnexpectedToken(token2);
                  }
                }
              } else if ((this.context.isModule || this.context.await) && token2.type === 3 && token2.value === "await") {
                this.tolerateUnexpectedToken(token2);
              }
              return this.finalize(node, new Node.Identifier(token2.value));
            };
            Parser2.prototype.parseVariableDeclaration = function(options2) {
              var node = this.createNode();
              var params = [];
              var id = this.parsePattern(params, "var");
              if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
                if (this.scanner.isRestrictedWord(id.name)) {
                  this.tolerateError(messages_1.Messages.StrictVarName);
                }
              }
              var init = null;
              if (this.match("=")) {
                this.nextToken();
                init = this.isolateCoverGrammar(this.parseAssignmentExpression);
              } else if (id.type !== syntax_1.Syntax.Identifier && !options2.inFor) {
                this.expect("=");
              }
              return this.finalize(node, new Node.VariableDeclarator(id, init));
            };
            Parser2.prototype.parseVariableDeclarationList = function(options2) {
              var opt = { inFor: options2.inFor };
              var list = [];
              list.push(this.parseVariableDeclaration(opt));
              while (this.match(",")) {
                this.nextToken();
                list.push(this.parseVariableDeclaration(opt));
              }
              return list;
            };
            Parser2.prototype.parseVariableStatement = function() {
              var node = this.createNode();
              this.expectKeyword("var");
              var declarations = this.parseVariableDeclarationList({ inFor: false });
              this.consumeSemicolon();
              return this.finalize(node, new Node.VariableDeclaration(declarations, "var"));
            };
            Parser2.prototype.parseEmptyStatement = function() {
              var node = this.createNode();
              this.expect(";");
              return this.finalize(node, new Node.EmptyStatement());
            };
            Parser2.prototype.parseExpressionStatement = function() {
              var node = this.createNode();
              var expr = this.parseExpression();
              this.consumeSemicolon();
              return this.finalize(node, new Node.ExpressionStatement(expr));
            };
            Parser2.prototype.parseIfClause = function() {
              if (this.context.strict && this.matchKeyword("function")) {
                this.tolerateError(messages_1.Messages.StrictFunction);
              }
              return this.parseStatement();
            };
            Parser2.prototype.parseIfStatement = function() {
              var node = this.createNode();
              var consequent;
              var alternate = null;
              this.expectKeyword("if");
              this.expect("(");
              var test = this.parseExpression();
              if (!this.match(")") && this.config.tolerant) {
                this.tolerateUnexpectedToken(this.nextToken());
                consequent = this.finalize(this.createNode(), new Node.EmptyStatement());
              } else {
                this.expect(")");
                consequent = this.parseIfClause();
                if (this.matchKeyword("else")) {
                  this.nextToken();
                  alternate = this.parseIfClause();
                }
              }
              return this.finalize(node, new Node.IfStatement(test, consequent, alternate));
            };
            Parser2.prototype.parseDoWhileStatement = function() {
              var node = this.createNode();
              this.expectKeyword("do");
              var previousInIteration = this.context.inIteration;
              this.context.inIteration = true;
              var body = this.parseStatement();
              this.context.inIteration = previousInIteration;
              this.expectKeyword("while");
              this.expect("(");
              var test = this.parseExpression();
              if (!this.match(")") && this.config.tolerant) {
                this.tolerateUnexpectedToken(this.nextToken());
              } else {
                this.expect(")");
                if (this.match(";")) {
                  this.nextToken();
                }
              }
              return this.finalize(node, new Node.DoWhileStatement(body, test));
            };
            Parser2.prototype.parseWhileStatement = function() {
              var node = this.createNode();
              var body;
              this.expectKeyword("while");
              this.expect("(");
              var test = this.parseExpression();
              if (!this.match(")") && this.config.tolerant) {
                this.tolerateUnexpectedToken(this.nextToken());
                body = this.finalize(this.createNode(), new Node.EmptyStatement());
              } else {
                this.expect(")");
                var previousInIteration = this.context.inIteration;
                this.context.inIteration = true;
                body = this.parseStatement();
                this.context.inIteration = previousInIteration;
              }
              return this.finalize(node, new Node.WhileStatement(test, body));
            };
            Parser2.prototype.parseForStatement = function() {
              var init = null;
              var test = null;
              var update = null;
              var forIn = true;
              var left, right;
              var node = this.createNode();
              this.expectKeyword("for");
              this.expect("(");
              if (this.match(";")) {
                this.nextToken();
              } else {
                if (this.matchKeyword("var")) {
                  init = this.createNode();
                  this.nextToken();
                  var previousAllowIn = this.context.allowIn;
                  this.context.allowIn = false;
                  var declarations = this.parseVariableDeclarationList({ inFor: true });
                  this.context.allowIn = previousAllowIn;
                  if (declarations.length === 1 && this.matchKeyword("in")) {
                    var decl = declarations[0];
                    if (decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict)) {
                      this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, "for-in");
                    }
                    init = this.finalize(init, new Node.VariableDeclaration(declarations, "var"));
                    this.nextToken();
                    left = init;
                    right = this.parseExpression();
                    init = null;
                  } else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword("of")) {
                    init = this.finalize(init, new Node.VariableDeclaration(declarations, "var"));
                    this.nextToken();
                    left = init;
                    right = this.parseAssignmentExpression();
                    init = null;
                    forIn = false;
                  } else {
                    init = this.finalize(init, new Node.VariableDeclaration(declarations, "var"));
                    this.expect(";");
                  }
                } else if (this.matchKeyword("const") || this.matchKeyword("let")) {
                  init = this.createNode();
                  var kind = this.nextToken().value;
                  if (!this.context.strict && this.lookahead.value === "in") {
                    init = this.finalize(init, new Node.Identifier(kind));
                    this.nextToken();
                    left = init;
                    right = this.parseExpression();
                    init = null;
                  } else {
                    var previousAllowIn = this.context.allowIn;
                    this.context.allowIn = false;
                    var declarations = this.parseBindingList(kind, { inFor: true });
                    this.context.allowIn = previousAllowIn;
                    if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword("in")) {
                      init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
                      this.nextToken();
                      left = init;
                      right = this.parseExpression();
                      init = null;
                    } else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword("of")) {
                      init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
                      this.nextToken();
                      left = init;
                      right = this.parseAssignmentExpression();
                      init = null;
                      forIn = false;
                    } else {
                      this.consumeSemicolon();
                      init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
                    }
                  }
                } else {
                  var initStartToken = this.lookahead;
                  var previousAllowIn = this.context.allowIn;
                  this.context.allowIn = false;
                  init = this.inheritCoverGrammar(this.parseAssignmentExpression);
                  this.context.allowIn = previousAllowIn;
                  if (this.matchKeyword("in")) {
                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
                      this.tolerateError(messages_1.Messages.InvalidLHSInForIn);
                    }
                    this.nextToken();
                    this.reinterpretExpressionAsPattern(init);
                    left = init;
                    right = this.parseExpression();
                    init = null;
                  } else if (this.matchContextualKeyword("of")) {
                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
                      this.tolerateError(messages_1.Messages.InvalidLHSInForLoop);
                    }
                    this.nextToken();
                    this.reinterpretExpressionAsPattern(init);
                    left = init;
                    right = this.parseAssignmentExpression();
                    init = null;
                    forIn = false;
                  } else {
                    if (this.match(",")) {
                      var initSeq = [init];
                      while (this.match(",")) {
                        this.nextToken();
                        initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                      }
                      init = this.finalize(this.startNode(initStartToken), new Node.SequenceExpression(initSeq));
                    }
                    this.expect(";");
                  }
                }
              }
              if (typeof left === "undefined") {
                if (!this.match(";")) {
                  test = this.parseExpression();
                }
                this.expect(";");
                if (!this.match(")")) {
                  update = this.parseExpression();
                }
              }
              var body;
              if (!this.match(")") && this.config.tolerant) {
                this.tolerateUnexpectedToken(this.nextToken());
                body = this.finalize(this.createNode(), new Node.EmptyStatement());
              } else {
                this.expect(")");
                var previousInIteration = this.context.inIteration;
                this.context.inIteration = true;
                body = this.isolateCoverGrammar(this.parseStatement);
                this.context.inIteration = previousInIteration;
              }
              return typeof left === "undefined" ? this.finalize(node, new Node.ForStatement(init, test, update, body)) : forIn ? this.finalize(node, new Node.ForInStatement(left, right, body)) : this.finalize(node, new Node.ForOfStatement(left, right, body));
            };
            Parser2.prototype.parseContinueStatement = function() {
              var node = this.createNode();
              this.expectKeyword("continue");
              var label = null;
              if (this.lookahead.type === 3 && !this.hasLineTerminator) {
                var id = this.parseVariableIdentifier();
                label = id;
                var key = "$" + id.name;
                if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                  this.throwError(messages_1.Messages.UnknownLabel, id.name);
                }
              }
              this.consumeSemicolon();
              if (label === null && !this.context.inIteration) {
                this.throwError(messages_1.Messages.IllegalContinue);
              }
              return this.finalize(node, new Node.ContinueStatement(label));
            };
            Parser2.prototype.parseBreakStatement = function() {
              var node = this.createNode();
              this.expectKeyword("break");
              var label = null;
              if (this.lookahead.type === 3 && !this.hasLineTerminator) {
                var id = this.parseVariableIdentifier();
                var key = "$" + id.name;
                if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                  this.throwError(messages_1.Messages.UnknownLabel, id.name);
                }
                label = id;
              }
              this.consumeSemicolon();
              if (label === null && !this.context.inIteration && !this.context.inSwitch) {
                this.throwError(messages_1.Messages.IllegalBreak);
              }
              return this.finalize(node, new Node.BreakStatement(label));
            };
            Parser2.prototype.parseReturnStatement = function() {
              if (!this.context.inFunctionBody) {
                this.tolerateError(messages_1.Messages.IllegalReturn);
              }
              var node = this.createNode();
              this.expectKeyword("return");
              var hasArgument = !this.match(";") && !this.match("}") && !this.hasLineTerminator && this.lookahead.type !== 2 || this.lookahead.type === 8 || this.lookahead.type === 10;
              var argument = hasArgument ? this.parseExpression() : null;
              this.consumeSemicolon();
              return this.finalize(node, new Node.ReturnStatement(argument));
            };
            Parser2.prototype.parseWithStatement = function() {
              if (this.context.strict) {
                this.tolerateError(messages_1.Messages.StrictModeWith);
              }
              var node = this.createNode();
              var body;
              this.expectKeyword("with");
              this.expect("(");
              var object = this.parseExpression();
              if (!this.match(")") && this.config.tolerant) {
                this.tolerateUnexpectedToken(this.nextToken());
                body = this.finalize(this.createNode(), new Node.EmptyStatement());
              } else {
                this.expect(")");
                body = this.parseStatement();
              }
              return this.finalize(node, new Node.WithStatement(object, body));
            };
            Parser2.prototype.parseSwitchCase = function() {
              var node = this.createNode();
              var test;
              if (this.matchKeyword("default")) {
                this.nextToken();
                test = null;
              } else {
                this.expectKeyword("case");
                test = this.parseExpression();
              }
              this.expect(":");
              var consequent = [];
              while (true) {
                if (this.match("}") || this.matchKeyword("default") || this.matchKeyword("case")) {
                  break;
                }
                consequent.push(this.parseStatementListItem());
              }
              return this.finalize(node, new Node.SwitchCase(test, consequent));
            };
            Parser2.prototype.parseSwitchStatement = function() {
              var node = this.createNode();
              this.expectKeyword("switch");
              this.expect("(");
              var discriminant = this.parseExpression();
              this.expect(")");
              var previousInSwitch = this.context.inSwitch;
              this.context.inSwitch = true;
              var cases = [];
              var defaultFound = false;
              this.expect("{");
              while (true) {
                if (this.match("}")) {
                  break;
                }
                var clause = this.parseSwitchCase();
                if (clause.test === null) {
                  if (defaultFound) {
                    this.throwError(messages_1.Messages.MultipleDefaultsInSwitch);
                  }
                  defaultFound = true;
                }
                cases.push(clause);
              }
              this.expect("}");
              this.context.inSwitch = previousInSwitch;
              return this.finalize(node, new Node.SwitchStatement(discriminant, cases));
            };
            Parser2.prototype.parseLabelledStatement = function() {
              var node = this.createNode();
              var expr = this.parseExpression();
              var statement;
              if (expr.type === syntax_1.Syntax.Identifier && this.match(":")) {
                this.nextToken();
                var id = expr;
                var key = "$" + id.name;
                if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                  this.throwError(messages_1.Messages.Redeclaration, "Label", id.name);
                }
                this.context.labelSet[key] = true;
                var body = void 0;
                if (this.matchKeyword("class")) {
                  this.tolerateUnexpectedToken(this.lookahead);
                  body = this.parseClassDeclaration();
                } else if (this.matchKeyword("function")) {
                  var token2 = this.lookahead;
                  var declaration = this.parseFunctionDeclaration();
                  if (this.context.strict) {
                    this.tolerateUnexpectedToken(token2, messages_1.Messages.StrictFunction);
                  } else if (declaration.generator) {
                    this.tolerateUnexpectedToken(token2, messages_1.Messages.GeneratorInLegacyContext);
                  }
                  body = declaration;
                } else {
                  body = this.parseStatement();
                }
                delete this.context.labelSet[key];
                statement = new Node.LabeledStatement(id, body);
              } else {
                this.consumeSemicolon();
                statement = new Node.ExpressionStatement(expr);
              }
              return this.finalize(node, statement);
            };
            Parser2.prototype.parseThrowStatement = function() {
              var node = this.createNode();
              this.expectKeyword("throw");
              if (this.hasLineTerminator) {
                this.throwError(messages_1.Messages.NewlineAfterThrow);
              }
              var argument = this.parseExpression();
              this.consumeSemicolon();
              return this.finalize(node, new Node.ThrowStatement(argument));
            };
            Parser2.prototype.parseCatchClause = function() {
              var node = this.createNode();
              this.expectKeyword("catch");
              this.expect("(");
              if (this.match(")")) {
                this.throwUnexpectedToken(this.lookahead);
              }
              var params = [];
              var param = this.parsePattern(params);
              var paramMap = {};
              for (var i = 0; i < params.length; i++) {
                var key = "$" + params[i].value;
                if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
                  this.tolerateError(messages_1.Messages.DuplicateBinding, params[i].value);
                }
                paramMap[key] = true;
              }
              if (this.context.strict && param.type === syntax_1.Syntax.Identifier) {
                if (this.scanner.isRestrictedWord(param.name)) {
                  this.tolerateError(messages_1.Messages.StrictCatchVariable);
                }
              }
              this.expect(")");
              var body = this.parseBlock();
              return this.finalize(node, new Node.CatchClause(param, body));
            };
            Parser2.prototype.parseFinallyClause = function() {
              this.expectKeyword("finally");
              return this.parseBlock();
            };
            Parser2.prototype.parseTryStatement = function() {
              var node = this.createNode();
              this.expectKeyword("try");
              var block = this.parseBlock();
              var handler = this.matchKeyword("catch") ? this.parseCatchClause() : null;
              var finalizer = this.matchKeyword("finally") ? this.parseFinallyClause() : null;
              if (!handler && !finalizer) {
                this.throwError(messages_1.Messages.NoCatchOrFinally);
              }
              return this.finalize(node, new Node.TryStatement(block, handler, finalizer));
            };
            Parser2.prototype.parseDebuggerStatement = function() {
              var node = this.createNode();
              this.expectKeyword("debugger");
              this.consumeSemicolon();
              return this.finalize(node, new Node.DebuggerStatement());
            };
            Parser2.prototype.parseStatement = function() {
              var statement;
              switch (this.lookahead.type) {
                case 1:
                case 5:
                case 6:
                case 8:
                case 10:
                case 9:
                  statement = this.parseExpressionStatement();
                  break;
                case 7:
                  var value = this.lookahead.value;
                  if (value === "{") {
                    statement = this.parseBlock();
                  } else if (value === "(") {
                    statement = this.parseExpressionStatement();
                  } else if (value === ";") {
                    statement = this.parseEmptyStatement();
                  } else {
                    statement = this.parseExpressionStatement();
                  }
                  break;
                case 3:
                  statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
                  break;
                case 4:
                  switch (this.lookahead.value) {
                    case "break":
                      statement = this.parseBreakStatement();
                      break;
                    case "continue":
                      statement = this.parseContinueStatement();
                      break;
                    case "debugger":
                      statement = this.parseDebuggerStatement();
                      break;
                    case "do":
                      statement = this.parseDoWhileStatement();
                      break;
                    case "for":
                      statement = this.parseForStatement();
                      break;
                    case "function":
                      statement = this.parseFunctionDeclaration();
                      break;
                    case "if":
                      statement = this.parseIfStatement();
                      break;
                    case "return":
                      statement = this.parseReturnStatement();
                      break;
                    case "switch":
                      statement = this.parseSwitchStatement();
                      break;
                    case "throw":
                      statement = this.parseThrowStatement();
                      break;
                    case "try":
                      statement = this.parseTryStatement();
                      break;
                    case "var":
                      statement = this.parseVariableStatement();
                      break;
                    case "while":
                      statement = this.parseWhileStatement();
                      break;
                    case "with":
                      statement = this.parseWithStatement();
                      break;
                    default:
                      statement = this.parseExpressionStatement();
                      break;
                  }
                  break;
                default:
                  statement = this.throwUnexpectedToken(this.lookahead);
              }
              return statement;
            };
            Parser2.prototype.parseFunctionSourceElements = function() {
              var node = this.createNode();
              this.expect("{");
              var body = this.parseDirectivePrologues();
              var previousLabelSet = this.context.labelSet;
              var previousInIteration = this.context.inIteration;
              var previousInSwitch = this.context.inSwitch;
              var previousInFunctionBody = this.context.inFunctionBody;
              this.context.labelSet = {};
              this.context.inIteration = false;
              this.context.inSwitch = false;
              this.context.inFunctionBody = true;
              while (this.lookahead.type !== 2) {
                if (this.match("}")) {
                  break;
                }
                body.push(this.parseStatementListItem());
              }
              this.expect("}");
              this.context.labelSet = previousLabelSet;
              this.context.inIteration = previousInIteration;
              this.context.inSwitch = previousInSwitch;
              this.context.inFunctionBody = previousInFunctionBody;
              return this.finalize(node, new Node.BlockStatement(body));
            };
            Parser2.prototype.validateParam = function(options2, param, name) {
              var key = "$" + name;
              if (this.context.strict) {
                if (this.scanner.isRestrictedWord(name)) {
                  options2.stricted = param;
                  options2.message = messages_1.Messages.StrictParamName;
                }
                if (Object.prototype.hasOwnProperty.call(options2.paramSet, key)) {
                  options2.stricted = param;
                  options2.message = messages_1.Messages.StrictParamDupe;
                }
              } else if (!options2.firstRestricted) {
                if (this.scanner.isRestrictedWord(name)) {
                  options2.firstRestricted = param;
                  options2.message = messages_1.Messages.StrictParamName;
                } else if (this.scanner.isStrictModeReservedWord(name)) {
                  options2.firstRestricted = param;
                  options2.message = messages_1.Messages.StrictReservedWord;
                } else if (Object.prototype.hasOwnProperty.call(options2.paramSet, key)) {
                  options2.stricted = param;
                  options2.message = messages_1.Messages.StrictParamDupe;
                }
              }
              if (typeof Object.defineProperty === "function") {
                Object.defineProperty(options2.paramSet, key, { value: true, enumerable: true, writable: true, configurable: true });
              } else {
                options2.paramSet[key] = true;
              }
            };
            Parser2.prototype.parseRestElement = function(params) {
              var node = this.createNode();
              this.expect("...");
              var arg = this.parsePattern(params);
              if (this.match("=")) {
                this.throwError(messages_1.Messages.DefaultRestParameter);
              }
              if (!this.match(")")) {
                this.throwError(messages_1.Messages.ParameterAfterRestParameter);
              }
              return this.finalize(node, new Node.RestElement(arg));
            };
            Parser2.prototype.parseFormalParameter = function(options2) {
              var params = [];
              var param = this.match("...") ? this.parseRestElement(params) : this.parsePatternWithDefault(params);
              for (var i = 0; i < params.length; i++) {
                this.validateParam(options2, params[i], params[i].value);
              }
              options2.simple = options2.simple && param instanceof Node.Identifier;
              options2.params.push(param);
            };
            Parser2.prototype.parseFormalParameters = function(firstRestricted) {
              var options2;
              options2 = {
                simple: true,
                params: [],
                firstRestricted
              };
              this.expect("(");
              if (!this.match(")")) {
                options2.paramSet = {};
                while (this.lookahead.type !== 2) {
                  this.parseFormalParameter(options2);
                  if (this.match(")")) {
                    break;
                  }
                  this.expect(",");
                  if (this.match(")")) {
                    break;
                  }
                }
              }
              this.expect(")");
              return {
                simple: options2.simple,
                params: options2.params,
                stricted: options2.stricted,
                firstRestricted: options2.firstRestricted,
                message: options2.message
              };
            };
            Parser2.prototype.matchAsyncFunction = function() {
              var match = this.matchContextualKeyword("async");
              if (match) {
                var state = this.scanner.saveState();
                this.scanner.scanComments();
                var next = this.scanner.lex();
                this.scanner.restoreState(state);
                match = state.lineNumber === next.lineNumber && next.type === 4 && next.value === "function";
              }
              return match;
            };
            Parser2.prototype.parseFunctionDeclaration = function(identifierIsOptional) {
              var node = this.createNode();
              var isAsync = this.matchContextualKeyword("async");
              if (isAsync) {
                this.nextToken();
              }
              this.expectKeyword("function");
              var isGenerator = isAsync ? false : this.match("*");
              if (isGenerator) {
                this.nextToken();
              }
              var message;
              var id = null;
              var firstRestricted = null;
              if (!identifierIsOptional || !this.match("(")) {
                var token2 = this.lookahead;
                id = this.parseVariableIdentifier();
                if (this.context.strict) {
                  if (this.scanner.isRestrictedWord(token2.value)) {
                    this.tolerateUnexpectedToken(token2, messages_1.Messages.StrictFunctionName);
                  }
                } else {
                  if (this.scanner.isRestrictedWord(token2.value)) {
                    firstRestricted = token2;
                    message = messages_1.Messages.StrictFunctionName;
                  } else if (this.scanner.isStrictModeReservedWord(token2.value)) {
                    firstRestricted = token2;
                    message = messages_1.Messages.StrictReservedWord;
                  }
                }
              }
              var previousAllowAwait = this.context.await;
              var previousAllowYield = this.context.allowYield;
              this.context.await = isAsync;
              this.context.allowYield = !isGenerator;
              var formalParameters = this.parseFormalParameters(firstRestricted);
              var params = formalParameters.params;
              var stricted = formalParameters.stricted;
              firstRestricted = formalParameters.firstRestricted;
              if (formalParameters.message) {
                message = formalParameters.message;
              }
              var previousStrict = this.context.strict;
              var previousAllowStrictDirective = this.context.allowStrictDirective;
              this.context.allowStrictDirective = formalParameters.simple;
              var body = this.parseFunctionSourceElements();
              if (this.context.strict && firstRestricted) {
                this.throwUnexpectedToken(firstRestricted, message);
              }
              if (this.context.strict && stricted) {
                this.tolerateUnexpectedToken(stricted, message);
              }
              this.context.strict = previousStrict;
              this.context.allowStrictDirective = previousAllowStrictDirective;
              this.context.await = previousAllowAwait;
              this.context.allowYield = previousAllowYield;
              return isAsync ? this.finalize(node, new Node.AsyncFunctionDeclaration(id, params, body)) : this.finalize(node, new Node.FunctionDeclaration(id, params, body, isGenerator));
            };
            Parser2.prototype.parseFunctionExpression = function() {
              var node = this.createNode();
              var isAsync = this.matchContextualKeyword("async");
              if (isAsync) {
                this.nextToken();
              }
              this.expectKeyword("function");
              var isGenerator = isAsync ? false : this.match("*");
              if (isGenerator) {
                this.nextToken();
              }
              var message;
              var id = null;
              var firstRestricted;
              var previousAllowAwait = this.context.await;
              var previousAllowYield = this.context.allowYield;
              this.context.await = isAsync;
              this.context.allowYield = !isGenerator;
              if (!this.match("(")) {
                var token2 = this.lookahead;
                id = !this.context.strict && !isGenerator && this.matchKeyword("yield") ? this.parseIdentifierName() : this.parseVariableIdentifier();
                if (this.context.strict) {
                  if (this.scanner.isRestrictedWord(token2.value)) {
                    this.tolerateUnexpectedToken(token2, messages_1.Messages.StrictFunctionName);
                  }
                } else {
                  if (this.scanner.isRestrictedWord(token2.value)) {
                    firstRestricted = token2;
                    message = messages_1.Messages.StrictFunctionName;
                  } else if (this.scanner.isStrictModeReservedWord(token2.value)) {
                    firstRestricted = token2;
                    message = messages_1.Messages.StrictReservedWord;
                  }
                }
              }
              var formalParameters = this.parseFormalParameters(firstRestricted);
              var params = formalParameters.params;
              var stricted = formalParameters.stricted;
              firstRestricted = formalParameters.firstRestricted;
              if (formalParameters.message) {
                message = formalParameters.message;
              }
              var previousStrict = this.context.strict;
              var previousAllowStrictDirective = this.context.allowStrictDirective;
              this.context.allowStrictDirective = formalParameters.simple;
              var body = this.parseFunctionSourceElements();
              if (this.context.strict && firstRestricted) {
                this.throwUnexpectedToken(firstRestricted, message);
              }
              if (this.context.strict && stricted) {
                this.tolerateUnexpectedToken(stricted, message);
              }
              this.context.strict = previousStrict;
              this.context.allowStrictDirective = previousAllowStrictDirective;
              this.context.await = previousAllowAwait;
              this.context.allowYield = previousAllowYield;
              return isAsync ? this.finalize(node, new Node.AsyncFunctionExpression(id, params, body)) : this.finalize(node, new Node.FunctionExpression(id, params, body, isGenerator));
            };
            Parser2.prototype.parseDirective = function() {
              var token2 = this.lookahead;
              var node = this.createNode();
              var expr = this.parseExpression();
              var directive = expr.type === syntax_1.Syntax.Literal ? this.getTokenRaw(token2).slice(1, -1) : null;
              this.consumeSemicolon();
              return this.finalize(node, directive ? new Node.Directive(expr, directive) : new Node.ExpressionStatement(expr));
            };
            Parser2.prototype.parseDirectivePrologues = function() {
              var firstRestricted = null;
              var body = [];
              while (true) {
                var token2 = this.lookahead;
                if (token2.type !== 8) {
                  break;
                }
                var statement = this.parseDirective();
                body.push(statement);
                var directive = statement.directive;
                if (typeof directive !== "string") {
                  break;
                }
                if (directive === "use strict") {
                  this.context.strict = true;
                  if (firstRestricted) {
                    this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral);
                  }
                  if (!this.context.allowStrictDirective) {
                    this.tolerateUnexpectedToken(token2, messages_1.Messages.IllegalLanguageModeDirective);
                  }
                } else {
                  if (!firstRestricted && token2.octal) {
                    firstRestricted = token2;
                  }
                }
              }
              return body;
            };
            Parser2.prototype.qualifiedPropertyName = function(token2) {
              switch (token2.type) {
                case 3:
                case 8:
                case 1:
                case 5:
                case 6:
                case 4:
                  return true;
                case 7:
                  return token2.value === "[";
                default:
                  break;
              }
              return false;
            };
            Parser2.prototype.parseGetterMethod = function() {
              var node = this.createNode();
              var isGenerator = false;
              var previousAllowYield = this.context.allowYield;
              this.context.allowYield = !isGenerator;
              var formalParameters = this.parseFormalParameters();
              if (formalParameters.params.length > 0) {
                this.tolerateError(messages_1.Messages.BadGetterArity);
              }
              var method = this.parsePropertyMethod(formalParameters);
              this.context.allowYield = previousAllowYield;
              return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
            };
            Parser2.prototype.parseSetterMethod = function() {
              var node = this.createNode();
              var isGenerator = false;
              var previousAllowYield = this.context.allowYield;
              this.context.allowYield = !isGenerator;
              var formalParameters = this.parseFormalParameters();
              if (formalParameters.params.length !== 1) {
                this.tolerateError(messages_1.Messages.BadSetterArity);
              } else if (formalParameters.params[0] instanceof Node.RestElement) {
                this.tolerateError(messages_1.Messages.BadSetterRestParameter);
              }
              var method = this.parsePropertyMethod(formalParameters);
              this.context.allowYield = previousAllowYield;
              return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
            };
            Parser2.prototype.parseGeneratorMethod = function() {
              var node = this.createNode();
              var isGenerator = true;
              var previousAllowYield = this.context.allowYield;
              this.context.allowYield = true;
              var params = this.parseFormalParameters();
              this.context.allowYield = false;
              var method = this.parsePropertyMethod(params);
              this.context.allowYield = previousAllowYield;
              return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
            };
            Parser2.prototype.isStartOfExpression = function() {
              var start = true;
              var value = this.lookahead.value;
              switch (this.lookahead.type) {
                case 7:
                  start = value === "[" || value === "(" || value === "{" || value === "+" || value === "-" || value === "!" || value === "~" || value === "++" || value === "--" || value === "/" || value === "/=";
                  break;
                case 4:
                  start = value === "class" || value === "delete" || value === "function" || value === "let" || value === "new" || value === "super" || value === "this" || value === "typeof" || value === "void" || value === "yield";
                  break;
                default:
                  break;
              }
              return start;
            };
            Parser2.prototype.parseYieldExpression = function() {
              var node = this.createNode();
              this.expectKeyword("yield");
              var argument = null;
              var delegate = false;
              if (!this.hasLineTerminator) {
                var previousAllowYield = this.context.allowYield;
                this.context.allowYield = false;
                delegate = this.match("*");
                if (delegate) {
                  this.nextToken();
                  argument = this.parseAssignmentExpression();
                } else if (this.isStartOfExpression()) {
                  argument = this.parseAssignmentExpression();
                }
                this.context.allowYield = previousAllowYield;
              }
              return this.finalize(node, new Node.YieldExpression(argument, delegate));
            };
            Parser2.prototype.parseClassElement = function(hasConstructor) {
              var token2 = this.lookahead;
              var node = this.createNode();
              var kind = "";
              var key = null;
              var value = null;
              var computed = false;
              var method = false;
              var isStatic = false;
              var isAsync = false;
              if (this.match("*")) {
                this.nextToken();
              } else {
                computed = this.match("[");
                key = this.parseObjectPropertyKey();
                var id = key;
                if (id.name === "static" && (this.qualifiedPropertyName(this.lookahead) || this.match("*"))) {
                  token2 = this.lookahead;
                  isStatic = true;
                  computed = this.match("[");
                  if (this.match("*")) {
                    this.nextToken();
                  } else {
                    key = this.parseObjectPropertyKey();
                  }
                }
                if (token2.type === 3 && !this.hasLineTerminator && token2.value === "async") {
                  var punctuator = this.lookahead.value;
                  if (punctuator !== ":" && punctuator !== "(" && punctuator !== "*") {
                    isAsync = true;
                    token2 = this.lookahead;
                    key = this.parseObjectPropertyKey();
                    if (token2.type === 3 && token2.value === "constructor") {
                      this.tolerateUnexpectedToken(token2, messages_1.Messages.ConstructorIsAsync);
                    }
                  }
                }
              }
              var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
              if (token2.type === 3) {
                if (token2.value === "get" && lookaheadPropertyKey) {
                  kind = "get";
                  computed = this.match("[");
                  key = this.parseObjectPropertyKey();
                  this.context.allowYield = false;
                  value = this.parseGetterMethod();
                } else if (token2.value === "set" && lookaheadPropertyKey) {
                  kind = "set";
                  computed = this.match("[");
                  key = this.parseObjectPropertyKey();
                  value = this.parseSetterMethod();
                }
              } else if (token2.type === 7 && token2.value === "*" && lookaheadPropertyKey) {
                kind = "init";
                computed = this.match("[");
                key = this.parseObjectPropertyKey();
                value = this.parseGeneratorMethod();
                method = true;
              }
              if (!kind && key && this.match("(")) {
                kind = "init";
                value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
                method = true;
              }
              if (!kind) {
                this.throwUnexpectedToken(this.lookahead);
              }
              if (kind === "init") {
                kind = "method";
              }
              if (!computed) {
                if (isStatic && this.isPropertyKey(key, "prototype")) {
                  this.throwUnexpectedToken(token2, messages_1.Messages.StaticPrototype);
                }
                if (!isStatic && this.isPropertyKey(key, "constructor")) {
                  if (kind !== "method" || !method || value && value.generator) {
                    this.throwUnexpectedToken(token2, messages_1.Messages.ConstructorSpecialMethod);
                  }
                  if (hasConstructor.value) {
                    this.throwUnexpectedToken(token2, messages_1.Messages.DuplicateConstructor);
                  } else {
                    hasConstructor.value = true;
                  }
                  kind = "constructor";
                }
              }
              return this.finalize(node, new Node.MethodDefinition(key, computed, value, kind, isStatic));
            };
            Parser2.prototype.parseClassElementList = function() {
              var body = [];
              var hasConstructor = { value: false };
              this.expect("{");
              while (!this.match("}")) {
                if (this.match(";")) {
                  this.nextToken();
                } else {
                  body.push(this.parseClassElement(hasConstructor));
                }
              }
              this.expect("}");
              return body;
            };
            Parser2.prototype.parseClassBody = function() {
              var node = this.createNode();
              var elementList = this.parseClassElementList();
              return this.finalize(node, new Node.ClassBody(elementList));
            };
            Parser2.prototype.parseClassDeclaration = function(identifierIsOptional) {
              var node = this.createNode();
              var previousStrict = this.context.strict;
              this.context.strict = true;
              this.expectKeyword("class");
              var id = identifierIsOptional && this.lookahead.type !== 3 ? null : this.parseVariableIdentifier();
              var superClass = null;
              if (this.matchKeyword("extends")) {
                this.nextToken();
                superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
              }
              var classBody = this.parseClassBody();
              this.context.strict = previousStrict;
              return this.finalize(node, new Node.ClassDeclaration(id, superClass, classBody));
            };
            Parser2.prototype.parseClassExpression = function() {
              var node = this.createNode();
              var previousStrict = this.context.strict;
              this.context.strict = true;
              this.expectKeyword("class");
              var id = this.lookahead.type === 3 ? this.parseVariableIdentifier() : null;
              var superClass = null;
              if (this.matchKeyword("extends")) {
                this.nextToken();
                superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
              }
              var classBody = this.parseClassBody();
              this.context.strict = previousStrict;
              return this.finalize(node, new Node.ClassExpression(id, superClass, classBody));
            };
            Parser2.prototype.parseModule = function() {
              this.context.strict = true;
              this.context.isModule = true;
              this.scanner.isModule = true;
              var node = this.createNode();
              var body = this.parseDirectivePrologues();
              while (this.lookahead.type !== 2) {
                body.push(this.parseStatementListItem());
              }
              return this.finalize(node, new Node.Module(body));
            };
            Parser2.prototype.parseScript = function() {
              var node = this.createNode();
              var body = this.parseDirectivePrologues();
              while (this.lookahead.type !== 2) {
                body.push(this.parseStatementListItem());
              }
              return this.finalize(node, new Node.Script(body));
            };
            Parser2.prototype.parseModuleSpecifier = function() {
              var node = this.createNode();
              if (this.lookahead.type !== 8) {
                this.throwError(messages_1.Messages.InvalidModuleSpecifier);
              }
              var token2 = this.nextToken();
              var raw = this.getTokenRaw(token2);
              return this.finalize(node, new Node.Literal(token2.value, raw));
            };
            Parser2.prototype.parseImportSpecifier = function() {
              var node = this.createNode();
              var imported;
              var local;
              if (this.lookahead.type === 3) {
                imported = this.parseVariableIdentifier();
                local = imported;
                if (this.matchContextualKeyword("as")) {
                  this.nextToken();
                  local = this.parseVariableIdentifier();
                }
              } else {
                imported = this.parseIdentifierName();
                local = imported;
                if (this.matchContextualKeyword("as")) {
                  this.nextToken();
                  local = this.parseVariableIdentifier();
                } else {
                  this.throwUnexpectedToken(this.nextToken());
                }
              }
              return this.finalize(node, new Node.ImportSpecifier(local, imported));
            };
            Parser2.prototype.parseNamedImports = function() {
              this.expect("{");
              var specifiers = [];
              while (!this.match("}")) {
                specifiers.push(this.parseImportSpecifier());
                if (!this.match("}")) {
                  this.expect(",");
                }
              }
              this.expect("}");
              return specifiers;
            };
            Parser2.prototype.parseImportDefaultSpecifier = function() {
              var node = this.createNode();
              var local = this.parseIdentifierName();
              return this.finalize(node, new Node.ImportDefaultSpecifier(local));
            };
            Parser2.prototype.parseImportNamespaceSpecifier = function() {
              var node = this.createNode();
              this.expect("*");
              if (!this.matchContextualKeyword("as")) {
                this.throwError(messages_1.Messages.NoAsAfterImportNamespace);
              }
              this.nextToken();
              var local = this.parseIdentifierName();
              return this.finalize(node, new Node.ImportNamespaceSpecifier(local));
            };
            Parser2.prototype.parseImportDeclaration = function() {
              if (this.context.inFunctionBody) {
                this.throwError(messages_1.Messages.IllegalImportDeclaration);
              }
              var node = this.createNode();
              this.expectKeyword("import");
              var src;
              var specifiers = [];
              if (this.lookahead.type === 8) {
                src = this.parseModuleSpecifier();
              } else {
                if (this.match("{")) {
                  specifiers = specifiers.concat(this.parseNamedImports());
                } else if (this.match("*")) {
                  specifiers.push(this.parseImportNamespaceSpecifier());
                } else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword("default")) {
                  specifiers.push(this.parseImportDefaultSpecifier());
                  if (this.match(",")) {
                    this.nextToken();
                    if (this.match("*")) {
                      specifiers.push(this.parseImportNamespaceSpecifier());
                    } else if (this.match("{")) {
                      specifiers = specifiers.concat(this.parseNamedImports());
                    } else {
                      this.throwUnexpectedToken(this.lookahead);
                    }
                  }
                } else {
                  this.throwUnexpectedToken(this.nextToken());
                }
                if (!this.matchContextualKeyword("from")) {
                  var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                  this.throwError(message, this.lookahead.value);
                }
                this.nextToken();
                src = this.parseModuleSpecifier();
              }
              this.consumeSemicolon();
              return this.finalize(node, new Node.ImportDeclaration(specifiers, src));
            };
            Parser2.prototype.parseExportSpecifier = function() {
              var node = this.createNode();
              var local = this.parseIdentifierName();
              var exported = local;
              if (this.matchContextualKeyword("as")) {
                this.nextToken();
                exported = this.parseIdentifierName();
              }
              return this.finalize(node, new Node.ExportSpecifier(local, exported));
            };
            Parser2.prototype.parseExportDeclaration = function() {
              if (this.context.inFunctionBody) {
                this.throwError(messages_1.Messages.IllegalExportDeclaration);
              }
              var node = this.createNode();
              this.expectKeyword("export");
              var exportDeclaration;
              if (this.matchKeyword("default")) {
                this.nextToken();
                if (this.matchKeyword("function")) {
                  var declaration = this.parseFunctionDeclaration(true);
                  exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
                } else if (this.matchKeyword("class")) {
                  var declaration = this.parseClassDeclaration(true);
                  exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
                } else if (this.matchContextualKeyword("async")) {
                  var declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();
                  exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
                } else {
                  if (this.matchContextualKeyword("from")) {
                    this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);
                  }
                  var declaration = this.match("{") ? this.parseObjectInitializer() : this.match("[") ? this.parseArrayInitializer() : this.parseAssignmentExpression();
                  this.consumeSemicolon();
                  exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
                }
              } else if (this.match("*")) {
                this.nextToken();
                if (!this.matchContextualKeyword("from")) {
                  var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                  this.throwError(message, this.lookahead.value);
                }
                this.nextToken();
                var src = this.parseModuleSpecifier();
                this.consumeSemicolon();
                exportDeclaration = this.finalize(node, new Node.ExportAllDeclaration(src));
              } else if (this.lookahead.type === 4) {
                var declaration = void 0;
                switch (this.lookahead.value) {
                  case "let":
                  case "const":
                    declaration = this.parseLexicalDeclaration({ inFor: false });
                    break;
                  case "var":
                  case "class":
                  case "function":
                    declaration = this.parseStatementListItem();
                    break;
                  default:
                    this.throwUnexpectedToken(this.lookahead);
                }
                exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
              } else if (this.matchAsyncFunction()) {
                var declaration = this.parseFunctionDeclaration();
                exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
              } else {
                var specifiers = [];
                var source = null;
                var isExportFromIdentifier = false;
                this.expect("{");
                while (!this.match("}")) {
                  isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword("default");
                  specifiers.push(this.parseExportSpecifier());
                  if (!this.match("}")) {
                    this.expect(",");
                  }
                }
                this.expect("}");
                if (this.matchContextualKeyword("from")) {
                  this.nextToken();
                  source = this.parseModuleSpecifier();
                  this.consumeSemicolon();
                } else if (isExportFromIdentifier) {
                  var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                  this.throwError(message, this.lookahead.value);
                } else {
                  this.consumeSemicolon();
                }
                exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(null, specifiers, source));
              }
              return exportDeclaration;
            };
            return Parser2;
          }();
          exports3.Parser = Parser;
        },
        function(module3, exports3) {
          "use strict";
          Object.defineProperty(exports3, "__esModule", { value: true });
          function assert(condition, message) {
            if (!condition) {
              throw new Error("ASSERT: " + message);
            }
          }
          exports3.assert = assert;
        },
        function(module3, exports3) {
          "use strict";
          Object.defineProperty(exports3, "__esModule", { value: true });
          var ErrorHandler = function() {
            function ErrorHandler2() {
              this.errors = [];
              this.tolerant = false;
            }
            ErrorHandler2.prototype.recordError = function(error3) {
              this.errors.push(error3);
            };
            ErrorHandler2.prototype.tolerate = function(error3) {
              if (this.tolerant) {
                this.recordError(error3);
              } else {
                throw error3;
              }
            };
            ErrorHandler2.prototype.constructError = function(msg, column) {
              var error3 = new Error(msg);
              try {
                throw error3;
              } catch (base) {
                if (Object.create && Object.defineProperty) {
                  error3 = Object.create(base);
                  Object.defineProperty(error3, "column", { value: column });
                }
              }
              return error3;
            };
            ErrorHandler2.prototype.createError = function(index, line, col, description) {
              var msg = "Line " + line + ": " + description;
              var error3 = this.constructError(msg, col);
              error3.index = index;
              error3.lineNumber = line;
              error3.description = description;
              return error3;
            };
            ErrorHandler2.prototype.throwError = function(index, line, col, description) {
              throw this.createError(index, line, col, description);
            };
            ErrorHandler2.prototype.tolerateError = function(index, line, col, description) {
              var error3 = this.createError(index, line, col, description);
              if (this.tolerant) {
                this.recordError(error3);
              } else {
                throw error3;
              }
            };
            return ErrorHandler2;
          }();
          exports3.ErrorHandler = ErrorHandler;
        },
        function(module3, exports3) {
          "use strict";
          Object.defineProperty(exports3, "__esModule", { value: true });
          exports3.Messages = {
            BadGetterArity: "Getter must not have any formal parameters",
            BadSetterArity: "Setter must have exactly one formal parameter",
            BadSetterRestParameter: "Setter function argument must not be a rest parameter",
            ConstructorIsAsync: "Class constructor may not be an async method",
            ConstructorSpecialMethod: "Class constructor may not be an accessor",
            DeclarationMissingInitializer: "Missing initializer in %0 declaration",
            DefaultRestParameter: "Unexpected token =",
            DuplicateBinding: "Duplicate binding %0",
            DuplicateConstructor: "A class may only have one constructor",
            DuplicateProtoProperty: "Duplicate __proto__ fields are not allowed in object literals",
            ForInOfLoopInitializer: "%0 loop variable declaration may not have an initializer",
            GeneratorInLegacyContext: "Generator declarations are not allowed in legacy contexts",
            IllegalBreak: "Illegal break statement",
            IllegalContinue: "Illegal continue statement",
            IllegalExportDeclaration: "Unexpected token",
            IllegalImportDeclaration: "Unexpected token",
            IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list",
            IllegalReturn: "Illegal return statement",
            InvalidEscapedReservedWord: "Keyword must not contain escaped characters",
            InvalidHexEscapeSequence: "Invalid hexadecimal escape sequence",
            InvalidLHSInAssignment: "Invalid left-hand side in assignment",
            InvalidLHSInForIn: "Invalid left-hand side in for-in",
            InvalidLHSInForLoop: "Invalid left-hand side in for-loop",
            InvalidModuleSpecifier: "Unexpected token",
            InvalidRegExp: "Invalid regular expression",
            LetInLexicalBinding: "let is disallowed as a lexically bound name",
            MissingFromClause: "Unexpected token",
            MultipleDefaultsInSwitch: "More than one default clause in switch statement",
            NewlineAfterThrow: "Illegal newline after throw",
            NoAsAfterImportNamespace: "Unexpected token",
            NoCatchOrFinally: "Missing catch or finally after try",
            ParameterAfterRestParameter: "Rest parameter must be last formal parameter",
            Redeclaration: "%0 '%1' has already been declared",
            StaticPrototype: "Classes may not have static property named prototype",
            StrictCatchVariable: "Catch variable may not be eval or arguments in strict mode",
            StrictDelete: "Delete of an unqualified identifier in strict mode.",
            StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block",
            StrictFunctionName: "Function name may not be eval or arguments in strict mode",
            StrictLHSAssignment: "Assignment to eval or arguments is not allowed in strict mode",
            StrictLHSPostfix: "Postfix increment/decrement may not have eval or arguments operand in strict mode",
            StrictLHSPrefix: "Prefix increment/decrement may not have eval or arguments operand in strict mode",
            StrictModeWith: "Strict mode code may not include a with statement",
            StrictOctalLiteral: "Octal literals are not allowed in strict mode.",
            StrictParamDupe: "Strict mode function may not have duplicate parameter names",
            StrictParamName: "Parameter name eval or arguments is not allowed in strict mode",
            StrictReservedWord: "Use of future reserved word in strict mode",
            StrictVarName: "Variable name may not be eval or arguments in strict mode",
            TemplateOctalLiteral: "Octal literals are not allowed in template strings.",
            UnexpectedEOS: "Unexpected end of input",
            UnexpectedIdentifier: "Unexpected identifier",
            UnexpectedNumber: "Unexpected number",
            UnexpectedReserved: "Unexpected reserved word",
            UnexpectedString: "Unexpected string",
            UnexpectedTemplate: "Unexpected quasi %0",
            UnexpectedToken: "Unexpected token %0",
            UnexpectedTokenIllegal: "Unexpected token ILLEGAL",
            UnknownLabel: "Undefined label '%0'",
            UnterminatedRegExp: "Invalid regular expression: missing /"
          };
        },
        function(module3, exports3, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports3, "__esModule", { value: true });
          var assert_1 = __webpack_require__(9);
          var character_1 = __webpack_require__(4);
          var messages_1 = __webpack_require__(11);
          function hexValue(ch) {
            return "0123456789abcdef".indexOf(ch.toLowerCase());
          }
          function octalValue(ch) {
            return "01234567".indexOf(ch);
          }
          var Scanner = function() {
            function Scanner2(code, handler) {
              this.source = code;
              this.errorHandler = handler;
              this.trackComment = false;
              this.isModule = false;
              this.length = code.length;
              this.index = 0;
              this.lineNumber = code.length > 0 ? 1 : 0;
              this.lineStart = 0;
              this.curlyStack = [];
            }
            Scanner2.prototype.saveState = function() {
              return {
                index: this.index,
                lineNumber: this.lineNumber,
                lineStart: this.lineStart
              };
            };
            Scanner2.prototype.restoreState = function(state) {
              this.index = state.index;
              this.lineNumber = state.lineNumber;
              this.lineStart = state.lineStart;
            };
            Scanner2.prototype.eof = function() {
              return this.index >= this.length;
            };
            Scanner2.prototype.throwUnexpectedToken = function(message) {
              if (message === void 0) {
                message = messages_1.Messages.UnexpectedTokenIllegal;
              }
              return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
            };
            Scanner2.prototype.tolerateUnexpectedToken = function(message) {
              if (message === void 0) {
                message = messages_1.Messages.UnexpectedTokenIllegal;
              }
              this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
            };
            Scanner2.prototype.skipSingleLineComment = function(offset) {
              var comments = [];
              var start, loc;
              if (this.trackComment) {
                comments = [];
                start = this.index - offset;
                loc = {
                  start: {
                    line: this.lineNumber,
                    column: this.index - this.lineStart - offset
                  },
                  end: {}
                };
              }
              while (!this.eof()) {
                var ch = this.source.charCodeAt(this.index);
                ++this.index;
                if (character_1.Character.isLineTerminator(ch)) {
                  if (this.trackComment) {
                    loc.end = {
                      line: this.lineNumber,
                      column: this.index - this.lineStart - 1
                    };
                    var entry = {
                      multiLine: false,
                      slice: [start + offset, this.index - 1],
                      range: [start, this.index - 1],
                      loc
                    };
                    comments.push(entry);
                  }
                  if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
                    ++this.index;
                  }
                  ++this.lineNumber;
                  this.lineStart = this.index;
                  return comments;
                }
              }
              if (this.trackComment) {
                loc.end = {
                  line: this.lineNumber,
                  column: this.index - this.lineStart
                };
                var entry = {
                  multiLine: false,
                  slice: [start + offset, this.index],
                  range: [start, this.index],
                  loc
                };
                comments.push(entry);
              }
              return comments;
            };
            Scanner2.prototype.skipMultiLineComment = function() {
              var comments = [];
              var start, loc;
              if (this.trackComment) {
                comments = [];
                start = this.index - 2;
                loc = {
                  start: {
                    line: this.lineNumber,
                    column: this.index - this.lineStart - 2
                  },
                  end: {}
                };
              }
              while (!this.eof()) {
                var ch = this.source.charCodeAt(this.index);
                if (character_1.Character.isLineTerminator(ch)) {
                  if (ch === 13 && this.source.charCodeAt(this.index + 1) === 10) {
                    ++this.index;
                  }
                  ++this.lineNumber;
                  ++this.index;
                  this.lineStart = this.index;
                } else if (ch === 42) {
                  if (this.source.charCodeAt(this.index + 1) === 47) {
                    this.index += 2;
                    if (this.trackComment) {
                      loc.end = {
                        line: this.lineNumber,
                        column: this.index - this.lineStart
                      };
                      var entry = {
                        multiLine: true,
                        slice: [start + 2, this.index - 2],
                        range: [start, this.index],
                        loc
                      };
                      comments.push(entry);
                    }
                    return comments;
                  }
                  ++this.index;
                } else {
                  ++this.index;
                }
              }
              if (this.trackComment) {
                loc.end = {
                  line: this.lineNumber,
                  column: this.index - this.lineStart
                };
                var entry = {
                  multiLine: true,
                  slice: [start + 2, this.index],
                  range: [start, this.index],
                  loc
                };
                comments.push(entry);
              }
              this.tolerateUnexpectedToken();
              return comments;
            };
            Scanner2.prototype.scanComments = function() {
              var comments;
              if (this.trackComment) {
                comments = [];
              }
              var start = this.index === 0;
              while (!this.eof()) {
                var ch = this.source.charCodeAt(this.index);
                if (character_1.Character.isWhiteSpace(ch)) {
                  ++this.index;
                } else if (character_1.Character.isLineTerminator(ch)) {
                  ++this.index;
                  if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
                    ++this.index;
                  }
                  ++this.lineNumber;
                  this.lineStart = this.index;
                  start = true;
                } else if (ch === 47) {
                  ch = this.source.charCodeAt(this.index + 1);
                  if (ch === 47) {
                    this.index += 2;
                    var comment = this.skipSingleLineComment(2);
                    if (this.trackComment) {
                      comments = comments.concat(comment);
                    }
                    start = true;
                  } else if (ch === 42) {
                    this.index += 2;
                    var comment = this.skipMultiLineComment();
                    if (this.trackComment) {
                      comments = comments.concat(comment);
                    }
                  } else {
                    break;
                  }
                } else if (start && ch === 45) {
                  if (this.source.charCodeAt(this.index + 1) === 45 && this.source.charCodeAt(this.index + 2) === 62) {
                    this.index += 3;
                    var comment = this.skipSingleLineComment(3);
                    if (this.trackComment) {
                      comments = comments.concat(comment);
                    }
                  } else {
                    break;
                  }
                } else if (ch === 60 && !this.isModule) {
                  if (this.source.slice(this.index + 1, this.index + 4) === "!--") {
                    this.index += 4;
                    var comment = this.skipSingleLineComment(4);
                    if (this.trackComment) {
                      comments = comments.concat(comment);
                    }
                  } else {
                    break;
                  }
                } else {
                  break;
                }
              }
              return comments;
            };
            Scanner2.prototype.isFutureReservedWord = function(id) {
              switch (id) {
                case "enum":
                case "export":
                case "import":
                case "super":
                  return true;
                default:
                  return false;
              }
            };
            Scanner2.prototype.isStrictModeReservedWord = function(id) {
              switch (id) {
                case "implements":
                case "interface":
                case "package":
                case "private":
                case "protected":
                case "public":
                case "static":
                case "yield":
                case "let":
                  return true;
                default:
                  return false;
              }
            };
            Scanner2.prototype.isRestrictedWord = function(id) {
              return id === "eval" || id === "arguments";
            };
            Scanner2.prototype.isKeyword = function(id) {
              switch (id.length) {
                case 2:
                  return id === "if" || id === "in" || id === "do";
                case 3:
                  return id === "var" || id === "for" || id === "new" || id === "try" || id === "let";
                case 4:
                  return id === "this" || id === "else" || id === "case" || id === "void" || id === "with" || id === "enum";
                case 5:
                  return id === "while" || id === "break" || id === "catch" || id === "throw" || id === "const" || id === "yield" || id === "class" || id === "super";
                case 6:
                  return id === "return" || id === "typeof" || id === "delete" || id === "switch" || id === "export" || id === "import";
                case 7:
                  return id === "default" || id === "finally" || id === "extends";
                case 8:
                  return id === "function" || id === "continue" || id === "debugger";
                case 10:
                  return id === "instanceof";
                default:
                  return false;
              }
            };
            Scanner2.prototype.codePointAt = function(i) {
              var cp = this.source.charCodeAt(i);
              if (cp >= 55296 && cp <= 56319) {
                var second = this.source.charCodeAt(i + 1);
                if (second >= 56320 && second <= 57343) {
                  var first = cp;
                  cp = (first - 55296) * 1024 + second - 56320 + 65536;
                }
              }
              return cp;
            };
            Scanner2.prototype.scanHexEscape = function(prefix) {
              var len = prefix === "u" ? 4 : 2;
              var code = 0;
              for (var i = 0; i < len; ++i) {
                if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
                  code = code * 16 + hexValue(this.source[this.index++]);
                } else {
                  return null;
                }
              }
              return String.fromCharCode(code);
            };
            Scanner2.prototype.scanUnicodeCodePointEscape = function() {
              var ch = this.source[this.index];
              var code = 0;
              if (ch === "}") {
                this.throwUnexpectedToken();
              }
              while (!this.eof()) {
                ch = this.source[this.index++];
                if (!character_1.Character.isHexDigit(ch.charCodeAt(0))) {
                  break;
                }
                code = code * 16 + hexValue(ch);
              }
              if (code > 1114111 || ch !== "}") {
                this.throwUnexpectedToken();
              }
              return character_1.Character.fromCodePoint(code);
            };
            Scanner2.prototype.getIdentifier = function() {
              var start = this.index++;
              while (!this.eof()) {
                var ch = this.source.charCodeAt(this.index);
                if (ch === 92) {
                  this.index = start;
                  return this.getComplexIdentifier();
                } else if (ch >= 55296 && ch < 57343) {
                  this.index = start;
                  return this.getComplexIdentifier();
                }
                if (character_1.Character.isIdentifierPart(ch)) {
                  ++this.index;
                } else {
                  break;
                }
              }
              return this.source.slice(start, this.index);
            };
            Scanner2.prototype.getComplexIdentifier = function() {
              var cp = this.codePointAt(this.index);
              var id = character_1.Character.fromCodePoint(cp);
              this.index += id.length;
              var ch;
              if (cp === 92) {
                if (this.source.charCodeAt(this.index) !== 117) {
                  this.throwUnexpectedToken();
                }
                ++this.index;
                if (this.source[this.index] === "{") {
                  ++this.index;
                  ch = this.scanUnicodeCodePointEscape();
                } else {
                  ch = this.scanHexEscape("u");
                  if (ch === null || ch === "\\" || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) {
                    this.throwUnexpectedToken();
                  }
                }
                id = ch;
              }
              while (!this.eof()) {
                cp = this.codePointAt(this.index);
                if (!character_1.Character.isIdentifierPart(cp)) {
                  break;
                }
                ch = character_1.Character.fromCodePoint(cp);
                id += ch;
                this.index += ch.length;
                if (cp === 92) {
                  id = id.substr(0, id.length - 1);
                  if (this.source.charCodeAt(this.index) !== 117) {
                    this.throwUnexpectedToken();
                  }
                  ++this.index;
                  if (this.source[this.index] === "{") {
                    ++this.index;
                    ch = this.scanUnicodeCodePointEscape();
                  } else {
                    ch = this.scanHexEscape("u");
                    if (ch === null || ch === "\\" || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
                      this.throwUnexpectedToken();
                    }
                  }
                  id += ch;
                }
              }
              return id;
            };
            Scanner2.prototype.octalToDecimal = function(ch) {
              var octal = ch !== "0";
              var code = octalValue(ch);
              if (!this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                octal = true;
                code = code * 8 + octalValue(this.source[this.index++]);
                if ("0123".indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                  code = code * 8 + octalValue(this.source[this.index++]);
                }
              }
              return {
                code,
                octal
              };
            };
            Scanner2.prototype.scanIdentifier = function() {
              var type;
              var start = this.index;
              var id = this.source.charCodeAt(start) === 92 ? this.getComplexIdentifier() : this.getIdentifier();
              if (id.length === 1) {
                type = 3;
              } else if (this.isKeyword(id)) {
                type = 4;
              } else if (id === "null") {
                type = 5;
              } else if (id === "true" || id === "false") {
                type = 1;
              } else {
                type = 3;
              }
              if (type !== 3 && start + id.length !== this.index) {
                var restore = this.index;
                this.index = start;
                this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord);
                this.index = restore;
              }
              return {
                type,
                value: id,
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start,
                end: this.index
              };
            };
            Scanner2.prototype.scanPunctuator = function() {
              var start = this.index;
              var str = this.source[this.index];
              switch (str) {
                case "(":
                case "{":
                  if (str === "{") {
                    this.curlyStack.push("{");
                  }
                  ++this.index;
                  break;
                case ".":
                  ++this.index;
                  if (this.source[this.index] === "." && this.source[this.index + 1] === ".") {
                    this.index += 2;
                    str = "...";
                  }
                  break;
                case "}":
                  ++this.index;
                  this.curlyStack.pop();
                  break;
                case ")":
                case ";":
                case ",":
                case "[":
                case "]":
                case ":":
                case "?":
                case "~":
                  ++this.index;
                  break;
                default:
                  str = this.source.substr(this.index, 4);
                  if (str === ">>>=") {
                    this.index += 4;
                  } else {
                    str = str.substr(0, 3);
                    if (str === "===" || str === "!==" || str === ">>>" || str === "<<=" || str === ">>=" || str === "**=") {
                      this.index += 3;
                    } else {
                      str = str.substr(0, 2);
                      if (str === "&&" || str === "||" || str === "==" || str === "!=" || str === "+=" || str === "-=" || str === "*=" || str === "/=" || str === "++" || str === "--" || str === "<<" || str === ">>" || str === "&=" || str === "|=" || str === "^=" || str === "%=" || str === "<=" || str === ">=" || str === "=>" || str === "**") {
                        this.index += 2;
                      } else {
                        str = this.source[this.index];
                        if ("<>=!+-*%&|^/".indexOf(str) >= 0) {
                          ++this.index;
                        }
                      }
                    }
                  }
              }
              if (this.index === start) {
                this.throwUnexpectedToken();
              }
              return {
                type: 7,
                value: str,
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start,
                end: this.index
              };
            };
            Scanner2.prototype.scanHexLiteral = function(start) {
              var num = "";
              while (!this.eof()) {
                if (!character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
                  break;
                }
                num += this.source[this.index++];
              }
              if (num.length === 0) {
                this.throwUnexpectedToken();
              }
              if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
                this.throwUnexpectedToken();
              }
              return {
                type: 6,
                value: parseInt("0x" + num, 16),
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start,
                end: this.index
              };
            };
            Scanner2.prototype.scanBinaryLiteral = function(start) {
              var num = "";
              var ch;
              while (!this.eof()) {
                ch = this.source[this.index];
                if (ch !== "0" && ch !== "1") {
                  break;
                }
                num += this.source[this.index++];
              }
              if (num.length === 0) {
                this.throwUnexpectedToken();
              }
              if (!this.eof()) {
                ch = this.source.charCodeAt(this.index);
                if (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) {
                  this.throwUnexpectedToken();
                }
              }
              return {
                type: 6,
                value: parseInt(num, 2),
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start,
                end: this.index
              };
            };
            Scanner2.prototype.scanOctalLiteral = function(prefix, start) {
              var num = "";
              var octal = false;
              if (character_1.Character.isOctalDigit(prefix.charCodeAt(0))) {
                octal = true;
                num = "0" + this.source[this.index++];
              } else {
                ++this.index;
              }
              while (!this.eof()) {
                if (!character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                  break;
                }
                num += this.source[this.index++];
              }
              if (!octal && num.length === 0) {
                this.throwUnexpectedToken();
              }
              if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                this.throwUnexpectedToken();
              }
              return {
                type: 6,
                value: parseInt(num, 8),
                octal,
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start,
                end: this.index
              };
            };
            Scanner2.prototype.isImplicitOctalLiteral = function() {
              for (var i = this.index + 1; i < this.length; ++i) {
                var ch = this.source[i];
                if (ch === "8" || ch === "9") {
                  return false;
                }
                if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                  return true;
                }
              }
              return true;
            };
            Scanner2.prototype.scanNumericLiteral = function() {
              var start = this.index;
              var ch = this.source[start];
              assert_1.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || ch === ".", "Numeric literal must start with a decimal digit or a decimal point");
              var num = "";
              if (ch !== ".") {
                num = this.source[this.index++];
                ch = this.source[this.index];
                if (num === "0") {
                  if (ch === "x" || ch === "X") {
                    ++this.index;
                    return this.scanHexLiteral(start);
                  }
                  if (ch === "b" || ch === "B") {
                    ++this.index;
                    return this.scanBinaryLiteral(start);
                  }
                  if (ch === "o" || ch === "O") {
                    return this.scanOctalLiteral(ch, start);
                  }
                  if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                    if (this.isImplicitOctalLiteral()) {
                      return this.scanOctalLiteral(ch, start);
                    }
                  }
                }
                while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                  num += this.source[this.index++];
                }
                ch = this.source[this.index];
              }
              if (ch === ".") {
                num += this.source[this.index++];
                while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                  num += this.source[this.index++];
                }
                ch = this.source[this.index];
              }
              if (ch === "e" || ch === "E") {
                num += this.source[this.index++];
                ch = this.source[this.index];
                if (ch === "+" || ch === "-") {
                  num += this.source[this.index++];
                }
                if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                  while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                    num += this.source[this.index++];
                  }
                } else {
                  this.throwUnexpectedToken();
                }
              }
              if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
                this.throwUnexpectedToken();
              }
              return {
                type: 6,
                value: parseFloat(num),
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start,
                end: this.index
              };
            };
            Scanner2.prototype.scanStringLiteral = function() {
              var start = this.index;
              var quote = this.source[start];
              assert_1.assert(quote === "'" || quote === '"', "String literal must starts with a quote");
              ++this.index;
              var octal = false;
              var str = "";
              while (!this.eof()) {
                var ch = this.source[this.index++];
                if (ch === quote) {
                  quote = "";
                  break;
                } else if (ch === "\\") {
                  ch = this.source[this.index++];
                  if (!ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                      case "u":
                        if (this.source[this.index] === "{") {
                          ++this.index;
                          str += this.scanUnicodeCodePointEscape();
                        } else {
                          var unescaped_1 = this.scanHexEscape(ch);
                          if (unescaped_1 === null) {
                            this.throwUnexpectedToken();
                          }
                          str += unescaped_1;
                        }
                        break;
                      case "x":
                        var unescaped = this.scanHexEscape(ch);
                        if (unescaped === null) {
                          this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
                        }
                        str += unescaped;
                        break;
                      case "n":
                        str += "\n";
                        break;
                      case "r":
                        str += "\r";
                        break;
                      case "t":
                        str += "	";
                        break;
                      case "b":
                        str += "\b";
                        break;
                      case "f":
                        str += "\f";
                        break;
                      case "v":
                        str += "\v";
                        break;
                      case "8":
                      case "9":
                        str += ch;
                        this.tolerateUnexpectedToken();
                        break;
                      default:
                        if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                          var octToDec = this.octalToDecimal(ch);
                          octal = octToDec.octal || octal;
                          str += String.fromCharCode(octToDec.code);
                        } else {
                          str += ch;
                        }
                        break;
                    }
                  } else {
                    ++this.lineNumber;
                    if (ch === "\r" && this.source[this.index] === "\n") {
                      ++this.index;
                    }
                    this.lineStart = this.index;
                  }
                } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                  break;
                } else {
                  str += ch;
                }
              }
              if (quote !== "") {
                this.index = start;
                this.throwUnexpectedToken();
              }
              return {
                type: 8,
                value: str,
                octal,
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start,
                end: this.index
              };
            };
            Scanner2.prototype.scanTemplate = function() {
              var cooked = "";
              var terminated = false;
              var start = this.index;
              var head = this.source[start] === "`";
              var tail = false;
              var rawOffset = 2;
              ++this.index;
              while (!this.eof()) {
                var ch = this.source[this.index++];
                if (ch === "`") {
                  rawOffset = 1;
                  tail = true;
                  terminated = true;
                  break;
                } else if (ch === "$") {
                  if (this.source[this.index] === "{") {
                    this.curlyStack.push("${");
                    ++this.index;
                    terminated = true;
                    break;
                  }
                  cooked += ch;
                } else if (ch === "\\") {
                  ch = this.source[this.index++];
                  if (!character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                      case "n":
                        cooked += "\n";
                        break;
                      case "r":
                        cooked += "\r";
                        break;
                      case "t":
                        cooked += "	";
                        break;
                      case "u":
                        if (this.source[this.index] === "{") {
                          ++this.index;
                          cooked += this.scanUnicodeCodePointEscape();
                        } else {
                          var restore = this.index;
                          var unescaped_2 = this.scanHexEscape(ch);
                          if (unescaped_2 !== null) {
                            cooked += unescaped_2;
                          } else {
                            this.index = restore;
                            cooked += ch;
                          }
                        }
                        break;
                      case "x":
                        var unescaped = this.scanHexEscape(ch);
                        if (unescaped === null) {
                          this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
                        }
                        cooked += unescaped;
                        break;
                      case "b":
                        cooked += "\b";
                        break;
                      case "f":
                        cooked += "\f";
                        break;
                      case "v":
                        cooked += "\v";
                        break;
                      default:
                        if (ch === "0") {
                          if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                            this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
                          }
                          cooked += "\0";
                        } else if (character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                          this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
                        } else {
                          cooked += ch;
                        }
                        break;
                    }
                  } else {
                    ++this.lineNumber;
                    if (ch === "\r" && this.source[this.index] === "\n") {
                      ++this.index;
                    }
                    this.lineStart = this.index;
                  }
                } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                  ++this.lineNumber;
                  if (ch === "\r" && this.source[this.index] === "\n") {
                    ++this.index;
                  }
                  this.lineStart = this.index;
                  cooked += "\n";
                } else {
                  cooked += ch;
                }
              }
              if (!terminated) {
                this.throwUnexpectedToken();
              }
              if (!head) {
                this.curlyStack.pop();
              }
              return {
                type: 10,
                value: this.source.slice(start + 1, this.index - rawOffset),
                cooked,
                head,
                tail,
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start,
                end: this.index
              };
            };
            Scanner2.prototype.testRegExp = function(pattern, flags) {
              var astralSubstitute = "\uFFFF";
              var tmp = pattern;
              var self2 = this;
              if (flags.indexOf("u") >= 0) {
                tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function($0, $1, $2) {
                  var codePoint = parseInt($1 || $2, 16);
                  if (codePoint > 1114111) {
                    self2.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
                  }
                  if (codePoint <= 65535) {
                    return String.fromCharCode(codePoint);
                  }
                  return astralSubstitute;
                }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, astralSubstitute);
              }
              try {
                RegExp(tmp);
              } catch (e) {
                this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
              }
              try {
                return new RegExp(pattern, flags);
              } catch (exception) {
                return null;
              }
            };
            Scanner2.prototype.scanRegExpBody = function() {
              var ch = this.source[this.index];
              assert_1.assert(ch === "/", "Regular expression literal must start with a slash");
              var str = this.source[this.index++];
              var classMarker = false;
              var terminated = false;
              while (!this.eof()) {
                ch = this.source[this.index++];
                str += ch;
                if (ch === "\\") {
                  ch = this.source[this.index++];
                  if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                    this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
                  }
                  str += ch;
                } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                  this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
                } else if (classMarker) {
                  if (ch === "]") {
                    classMarker = false;
                  }
                } else {
                  if (ch === "/") {
                    terminated = true;
                    break;
                  } else if (ch === "[") {
                    classMarker = true;
                  }
                }
              }
              if (!terminated) {
                this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
              }
              return str.substr(1, str.length - 2);
            };
            Scanner2.prototype.scanRegExpFlags = function() {
              var str = "";
              var flags = "";
              while (!this.eof()) {
                var ch = this.source[this.index];
                if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
                  break;
                }
                ++this.index;
                if (ch === "\\" && !this.eof()) {
                  ch = this.source[this.index];
                  if (ch === "u") {
                    ++this.index;
                    var restore = this.index;
                    var char = this.scanHexEscape("u");
                    if (char !== null) {
                      flags += char;
                      for (str += "\\u"; restore < this.index; ++restore) {
                        str += this.source[restore];
                      }
                    } else {
                      this.index = restore;
                      flags += "u";
                      str += "\\u";
                    }
                    this.tolerateUnexpectedToken();
                  } else {
                    str += "\\";
                    this.tolerateUnexpectedToken();
                  }
                } else {
                  flags += ch;
                  str += ch;
                }
              }
              return flags;
            };
            Scanner2.prototype.scanRegExp = function() {
              var start = this.index;
              var pattern = this.scanRegExpBody();
              var flags = this.scanRegExpFlags();
              var value = this.testRegExp(pattern, flags);
              return {
                type: 9,
                value: "",
                pattern,
                flags,
                regex: value,
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start,
                end: this.index
              };
            };
            Scanner2.prototype.lex = function() {
              if (this.eof()) {
                return {
                  type: 2,
                  value: "",
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start: this.index,
                  end: this.index
                };
              }
              var cp = this.source.charCodeAt(this.index);
              if (character_1.Character.isIdentifierStart(cp)) {
                return this.scanIdentifier();
              }
              if (cp === 40 || cp === 41 || cp === 59) {
                return this.scanPunctuator();
              }
              if (cp === 39 || cp === 34) {
                return this.scanStringLiteral();
              }
              if (cp === 46) {
                if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {
                  return this.scanNumericLiteral();
                }
                return this.scanPunctuator();
              }
              if (character_1.Character.isDecimalDigit(cp)) {
                return this.scanNumericLiteral();
              }
              if (cp === 96 || cp === 125 && this.curlyStack[this.curlyStack.length - 1] === "${") {
                return this.scanTemplate();
              }
              if (cp >= 55296 && cp < 57343) {
                if (character_1.Character.isIdentifierStart(this.codePointAt(this.index))) {
                  return this.scanIdentifier();
                }
              }
              return this.scanPunctuator();
            };
            return Scanner2;
          }();
          exports3.Scanner = Scanner;
        },
        function(module3, exports3) {
          "use strict";
          Object.defineProperty(exports3, "__esModule", { value: true });
          exports3.TokenName = {};
          exports3.TokenName[1] = "Boolean";
          exports3.TokenName[2] = "<end>";
          exports3.TokenName[3] = "Identifier";
          exports3.TokenName[4] = "Keyword";
          exports3.TokenName[5] = "Null";
          exports3.TokenName[6] = "Numeric";
          exports3.TokenName[7] = "Punctuator";
          exports3.TokenName[8] = "String";
          exports3.TokenName[9] = "RegularExpression";
          exports3.TokenName[10] = "Template";
        },
        function(module3, exports3) {
          "use strict";
          Object.defineProperty(exports3, "__esModule", { value: true });
          exports3.XHTMLEntities = {
            quot: '"',
            amp: "&",
            apos: "'",
            gt: ">",
            nbsp: "\xA0",
            iexcl: "\xA1",
            cent: "\xA2",
            pound: "\xA3",
            curren: "\xA4",
            yen: "\xA5",
            brvbar: "\xA6",
            sect: "\xA7",
            uml: "\xA8",
            copy: "\xA9",
            ordf: "\xAA",
            laquo: "\xAB",
            not: "\xAC",
            shy: "\xAD",
            reg: "\xAE",
            macr: "\xAF",
            deg: "\xB0",
            plusmn: "\xB1",
            sup2: "\xB2",
            sup3: "\xB3",
            acute: "\xB4",
            micro: "\xB5",
            para: "\xB6",
            middot: "\xB7",
            cedil: "\xB8",
            sup1: "\xB9",
            ordm: "\xBA",
            raquo: "\xBB",
            frac14: "\xBC",
            frac12: "\xBD",
            frac34: "\xBE",
            iquest: "\xBF",
            Agrave: "\xC0",
            Aacute: "\xC1",
            Acirc: "\xC2",
            Atilde: "\xC3",
            Auml: "\xC4",
            Aring: "\xC5",
            AElig: "\xC6",
            Ccedil: "\xC7",
            Egrave: "\xC8",
            Eacute: "\xC9",
            Ecirc: "\xCA",
            Euml: "\xCB",
            Igrave: "\xCC",
            Iacute: "\xCD",
            Icirc: "\xCE",
            Iuml: "\xCF",
            ETH: "\xD0",
            Ntilde: "\xD1",
            Ograve: "\xD2",
            Oacute: "\xD3",
            Ocirc: "\xD4",
            Otilde: "\xD5",
            Ouml: "\xD6",
            times: "\xD7",
            Oslash: "\xD8",
            Ugrave: "\xD9",
            Uacute: "\xDA",
            Ucirc: "\xDB",
            Uuml: "\xDC",
            Yacute: "\xDD",
            THORN: "\xDE",
            szlig: "\xDF",
            agrave: "\xE0",
            aacute: "\xE1",
            acirc: "\xE2",
            atilde: "\xE3",
            auml: "\xE4",
            aring: "\xE5",
            aelig: "\xE6",
            ccedil: "\xE7",
            egrave: "\xE8",
            eacute: "\xE9",
            ecirc: "\xEA",
            euml: "\xEB",
            igrave: "\xEC",
            iacute: "\xED",
            icirc: "\xEE",
            iuml: "\xEF",
            eth: "\xF0",
            ntilde: "\xF1",
            ograve: "\xF2",
            oacute: "\xF3",
            ocirc: "\xF4",
            otilde: "\xF5",
            ouml: "\xF6",
            divide: "\xF7",
            oslash: "\xF8",
            ugrave: "\xF9",
            uacute: "\xFA",
            ucirc: "\xFB",
            uuml: "\xFC",
            yacute: "\xFD",
            thorn: "\xFE",
            yuml: "\xFF",
            OElig: "\u0152",
            oelig: "\u0153",
            Scaron: "\u0160",
            scaron: "\u0161",
            Yuml: "\u0178",
            fnof: "\u0192",
            circ: "\u02C6",
            tilde: "\u02DC",
            Alpha: "\u0391",
            Beta: "\u0392",
            Gamma: "\u0393",
            Delta: "\u0394",
            Epsilon: "\u0395",
            Zeta: "\u0396",
            Eta: "\u0397",
            Theta: "\u0398",
            Iota: "\u0399",
            Kappa: "\u039A",
            Lambda: "\u039B",
            Mu: "\u039C",
            Nu: "\u039D",
            Xi: "\u039E",
            Omicron: "\u039F",
            Pi: "\u03A0",
            Rho: "\u03A1",
            Sigma: "\u03A3",
            Tau: "\u03A4",
            Upsilon: "\u03A5",
            Phi: "\u03A6",
            Chi: "\u03A7",
            Psi: "\u03A8",
            Omega: "\u03A9",
            alpha: "\u03B1",
            beta: "\u03B2",
            gamma: "\u03B3",
            delta: "\u03B4",
            epsilon: "\u03B5",
            zeta: "\u03B6",
            eta: "\u03B7",
            theta: "\u03B8",
            iota: "\u03B9",
            kappa: "\u03BA",
            lambda: "\u03BB",
            mu: "\u03BC",
            nu: "\u03BD",
            xi: "\u03BE",
            omicron: "\u03BF",
            pi: "\u03C0",
            rho: "\u03C1",
            sigmaf: "\u03C2",
            sigma: "\u03C3",
            tau: "\u03C4",
            upsilon: "\u03C5",
            phi: "\u03C6",
            chi: "\u03C7",
            psi: "\u03C8",
            omega: "\u03C9",
            thetasym: "\u03D1",
            upsih: "\u03D2",
            piv: "\u03D6",
            ensp: "\u2002",
            emsp: "\u2003",
            thinsp: "\u2009",
            zwnj: "\u200C",
            zwj: "\u200D",
            lrm: "\u200E",
            rlm: "\u200F",
            ndash: "\u2013",
            mdash: "\u2014",
            lsquo: "\u2018",
            rsquo: "\u2019",
            sbquo: "\u201A",
            ldquo: "\u201C",
            rdquo: "\u201D",
            bdquo: "\u201E",
            dagger: "\u2020",
            Dagger: "\u2021",
            bull: "\u2022",
            hellip: "\u2026",
            permil: "\u2030",
            prime: "\u2032",
            Prime: "\u2033",
            lsaquo: "\u2039",
            rsaquo: "\u203A",
            oline: "\u203E",
            frasl: "\u2044",
            euro: "\u20AC",
            image: "\u2111",
            weierp: "\u2118",
            real: "\u211C",
            trade: "\u2122",
            alefsym: "\u2135",
            larr: "\u2190",
            uarr: "\u2191",
            rarr: "\u2192",
            darr: "\u2193",
            harr: "\u2194",
            crarr: "\u21B5",
            lArr: "\u21D0",
            uArr: "\u21D1",
            rArr: "\u21D2",
            dArr: "\u21D3",
            hArr: "\u21D4",
            forall: "\u2200",
            part: "\u2202",
            exist: "\u2203",
            empty: "\u2205",
            nabla: "\u2207",
            isin: "\u2208",
            notin: "\u2209",
            ni: "\u220B",
            prod: "\u220F",
            sum: "\u2211",
            minus: "\u2212",
            lowast: "\u2217",
            radic: "\u221A",
            prop: "\u221D",
            infin: "\u221E",
            ang: "\u2220",
            and: "\u2227",
            or: "\u2228",
            cap: "\u2229",
            cup: "\u222A",
            int: "\u222B",
            there4: "\u2234",
            sim: "\u223C",
            cong: "\u2245",
            asymp: "\u2248",
            ne: "\u2260",
            equiv: "\u2261",
            le: "\u2264",
            ge: "\u2265",
            sub: "\u2282",
            sup: "\u2283",
            nsub: "\u2284",
            sube: "\u2286",
            supe: "\u2287",
            oplus: "\u2295",
            otimes: "\u2297",
            perp: "\u22A5",
            sdot: "\u22C5",
            lceil: "\u2308",
            rceil: "\u2309",
            lfloor: "\u230A",
            rfloor: "\u230B",
            loz: "\u25CA",
            spades: "\u2660",
            clubs: "\u2663",
            hearts: "\u2665",
            diams: "\u2666",
            lang: "\u27E8",
            rang: "\u27E9"
          };
        },
        function(module3, exports3, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports3, "__esModule", { value: true });
          var error_handler_1 = __webpack_require__(10);
          var scanner_1 = __webpack_require__(12);
          var token_1 = __webpack_require__(13);
          var Reader = function() {
            function Reader2() {
              this.values = [];
              this.curly = this.paren = -1;
            }
            Reader2.prototype.beforeFunctionExpression = function(t) {
              return [
                "(",
                "{",
                "[",
                "in",
                "typeof",
                "instanceof",
                "new",
                "return",
                "case",
                "delete",
                "throw",
                "void",
                "=",
                "+=",
                "-=",
                "*=",
                "**=",
                "/=",
                "%=",
                "<<=",
                ">>=",
                ">>>=",
                "&=",
                "|=",
                "^=",
                ",",
                "+",
                "-",
                "*",
                "**",
                "/",
                "%",
                "++",
                "--",
                "<<",
                ">>",
                ">>>",
                "&",
                "|",
                "^",
                "!",
                "~",
                "&&",
                "||",
                "?",
                ":",
                "===",
                "==",
                ">=",
                "<=",
                "<",
                ">",
                "!=",
                "!=="
              ].indexOf(t) >= 0;
            };
            Reader2.prototype.isRegexStart = function() {
              var previous = this.values[this.values.length - 1];
              var regex = previous !== null;
              switch (previous) {
                case "this":
                case "]":
                  regex = false;
                  break;
                case ")":
                  var keyword = this.values[this.paren - 1];
                  regex = keyword === "if" || keyword === "while" || keyword === "for" || keyword === "with";
                  break;
                case "}":
                  regex = false;
                  if (this.values[this.curly - 3] === "function") {
                    var check = this.values[this.curly - 4];
                    regex = check ? !this.beforeFunctionExpression(check) : false;
                  } else if (this.values[this.curly - 4] === "function") {
                    var check = this.values[this.curly - 5];
                    regex = check ? !this.beforeFunctionExpression(check) : true;
                  }
                  break;
                default:
                  break;
              }
              return regex;
            };
            Reader2.prototype.push = function(token2) {
              if (token2.type === 7 || token2.type === 4) {
                if (token2.value === "{") {
                  this.curly = this.values.length;
                } else if (token2.value === "(") {
                  this.paren = this.values.length;
                }
                this.values.push(token2.value);
              } else {
                this.values.push(null);
              }
            };
            return Reader2;
          }();
          var Tokenizer = function() {
            function Tokenizer2(code, config) {
              this.errorHandler = new error_handler_1.ErrorHandler();
              this.errorHandler.tolerant = config ? typeof config.tolerant === "boolean" && config.tolerant : false;
              this.scanner = new scanner_1.Scanner(code, this.errorHandler);
              this.scanner.trackComment = config ? typeof config.comment === "boolean" && config.comment : false;
              this.trackRange = config ? typeof config.range === "boolean" && config.range : false;
              this.trackLoc = config ? typeof config.loc === "boolean" && config.loc : false;
              this.buffer = [];
              this.reader = new Reader();
            }
            Tokenizer2.prototype.errors = function() {
              return this.errorHandler.errors;
            };
            Tokenizer2.prototype.getNextToken = function() {
              if (this.buffer.length === 0) {
                var comments = this.scanner.scanComments();
                if (this.scanner.trackComment) {
                  for (var i = 0; i < comments.length; ++i) {
                    var e = comments[i];
                    var value = this.scanner.source.slice(e.slice[0], e.slice[1]);
                    var comment = {
                      type: e.multiLine ? "BlockComment" : "LineComment",
                      value
                    };
                    if (this.trackRange) {
                      comment.range = e.range;
                    }
                    if (this.trackLoc) {
                      comment.loc = e.loc;
                    }
                    this.buffer.push(comment);
                  }
                }
                if (!this.scanner.eof()) {
                  var loc = void 0;
                  if (this.trackLoc) {
                    loc = {
                      start: {
                        line: this.scanner.lineNumber,
                        column: this.scanner.index - this.scanner.lineStart
                      },
                      end: {}
                    };
                  }
                  var startRegex = this.scanner.source[this.scanner.index] === "/" && this.reader.isRegexStart();
                  var token2 = startRegex ? this.scanner.scanRegExp() : this.scanner.lex();
                  this.reader.push(token2);
                  var entry = {
                    type: token_1.TokenName[token2.type],
                    value: this.scanner.source.slice(token2.start, token2.end)
                  };
                  if (this.trackRange) {
                    entry.range = [token2.start, token2.end];
                  }
                  if (this.trackLoc) {
                    loc.end = {
                      line: this.scanner.lineNumber,
                      column: this.scanner.index - this.scanner.lineStart
                    };
                    entry.loc = loc;
                  }
                  if (token2.type === 9) {
                    var pattern = token2.pattern;
                    var flags = token2.flags;
                    entry.regex = { pattern, flags };
                  }
                  this.buffer.push(entry);
                }
              }
              return this.buffer.shift();
            };
            return Tokenizer2;
          }();
          exports3.Tokenizer = Tokenizer;
        }
      ]);
    });
  }
});

// ../../node_modules/core-util-is/lib/util.js
var require_util2 = __commonJS({
  "../../node_modules/core-util-is/lib/util.js"(exports2) {
    function isArray(arg) {
      if (Array.isArray) {
        return Array.isArray(arg);
      }
      return objectToString(arg) === "[object Array]";
    }
    exports2.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports2.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports2.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports2.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports2.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports2.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports2.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports2.isUndefined = isUndefined;
    function isRegExp(re) {
      return objectToString(re) === "[object RegExp]";
    }
    exports2.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports2.isObject = isObject;
    function isDate(d) {
      return objectToString(d) === "[object Date]";
    }
    exports2.isDate = isDate;
    function isError(e) {
      return objectToString(e) === "[object Error]" || e instanceof Error;
    }
    exports2.isError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports2.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
    }
    exports2.isPrimitive = isPrimitive;
    exports2.isBuffer = Buffer.isBuffer;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  }
});

// ../../node_modules/array-timsort/src/index.js
var require_src4 = __commonJS({
  "../../node_modules/array-timsort/src/index.js"(exports2, module2) {
    var DEFAULT_MIN_MERGE = 32;
    var DEFAULT_MIN_GALLOPING = 7;
    var DEFAULT_TMP_STORAGE_LENGTH = 256;
    var POWERS_OF_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9];
    var results;
    var log10 = (x) => x < 1e5 ? x < 100 ? x < 10 ? 0 : 1 : x < 1e4 ? x < 1e3 ? 2 : 3 : 4 : x < 1e7 ? x < 1e6 ? 5 : 6 : x < 1e9 ? x < 1e8 ? 7 : 8 : 9;
    function alphabeticalCompare(a, b) {
      if (a === b) {
        return 0;
      }
      if (~~a === a && ~~b === b) {
        if (a === 0 || b === 0) {
          return a < b ? -1 : 1;
        }
        if (a < 0 || b < 0) {
          if (b >= 0) {
            return -1;
          }
          if (a >= 0) {
            return 1;
          }
          a = -a;
          b = -b;
        }
        const al = log10(a);
        const bl = log10(b);
        let t = 0;
        if (al < bl) {
          a *= POWERS_OF_TEN[bl - al - 1];
          b /= 10;
          t = -1;
        } else if (al > bl) {
          b *= POWERS_OF_TEN[al - bl - 1];
          a /= 10;
          t = 1;
        }
        if (a === b) {
          return t;
        }
        return a < b ? -1 : 1;
      }
      const aStr = String(a);
      const bStr = String(b);
      if (aStr === bStr) {
        return 0;
      }
      return aStr < bStr ? -1 : 1;
    }
    function minRunLength(n) {
      let r = 0;
      while (n >= DEFAULT_MIN_MERGE) {
        r |= n & 1;
        n >>= 1;
      }
      return n + r;
    }
    function makeAscendingRun(array, lo, hi, compare) {
      let runHi = lo + 1;
      if (runHi === hi) {
        return 1;
      }
      if (compare(array[runHi++], array[lo]) < 0) {
        while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {
          runHi++;
        }
        reverseRun(array, lo, runHi);
        reverseRun(results, lo, runHi);
      } else {
        while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {
          runHi++;
        }
      }
      return runHi - lo;
    }
    function reverseRun(array, lo, hi) {
      hi--;
      while (lo < hi) {
        const t = array[lo];
        array[lo++] = array[hi];
        array[hi--] = t;
      }
    }
    function binaryInsertionSort(array, lo, hi, start, compare) {
      if (start === lo) {
        start++;
      }
      for (; start < hi; start++) {
        const pivot = array[start];
        const pivotIndex = results[start];
        let left = lo;
        let right = start;
        while (left < right) {
          const mid = left + right >>> 1;
          if (compare(pivot, array[mid]) < 0) {
            right = mid;
          } else {
            left = mid + 1;
          }
        }
        let n = start - left;
        switch (n) {
          case 3:
            array[left + 3] = array[left + 2];
            results[left + 3] = results[left + 2];
          case 2:
            array[left + 2] = array[left + 1];
            results[left + 2] = results[left + 1];
          case 1:
            array[left + 1] = array[left];
            results[left + 1] = results[left];
            break;
          default:
            while (n > 0) {
              array[left + n] = array[left + n - 1];
              results[left + n] = results[left + n - 1];
              n--;
            }
        }
        array[left] = pivot;
        results[left] = pivotIndex;
      }
    }
    function gallopLeft(value, array, start, length, hint, compare) {
      let lastOffset = 0;
      let maxOffset = 0;
      let offset = 1;
      if (compare(value, array[start + hint]) > 0) {
        maxOffset = length - hint;
        while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {
          lastOffset = offset;
          offset = (offset << 1) + 1;
          if (offset <= 0) {
            offset = maxOffset;
          }
        }
        if (offset > maxOffset) {
          offset = maxOffset;
        }
        lastOffset += hint;
        offset += hint;
      } else {
        maxOffset = hint + 1;
        while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {
          lastOffset = offset;
          offset = (offset << 1) + 1;
          if (offset <= 0) {
            offset = maxOffset;
          }
        }
        if (offset > maxOffset) {
          offset = maxOffset;
        }
        const tmp = lastOffset;
        lastOffset = hint - offset;
        offset = hint - tmp;
      }
      lastOffset++;
      while (lastOffset < offset) {
        const m = lastOffset + (offset - lastOffset >>> 1);
        if (compare(value, array[start + m]) > 0) {
          lastOffset = m + 1;
        } else {
          offset = m;
        }
      }
      return offset;
    }
    function gallopRight(value, array, start, length, hint, compare) {
      let lastOffset = 0;
      let maxOffset = 0;
      let offset = 1;
      if (compare(value, array[start + hint]) < 0) {
        maxOffset = hint + 1;
        while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {
          lastOffset = offset;
          offset = (offset << 1) + 1;
          if (offset <= 0) {
            offset = maxOffset;
          }
        }
        if (offset > maxOffset) {
          offset = maxOffset;
        }
        const tmp = lastOffset;
        lastOffset = hint - offset;
        offset = hint - tmp;
      } else {
        maxOffset = length - hint;
        while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {
          lastOffset = offset;
          offset = (offset << 1) + 1;
          if (offset <= 0) {
            offset = maxOffset;
          }
        }
        if (offset > maxOffset) {
          offset = maxOffset;
        }
        lastOffset += hint;
        offset += hint;
      }
      lastOffset++;
      while (lastOffset < offset) {
        const m = lastOffset + (offset - lastOffset >>> 1);
        if (compare(value, array[start + m]) < 0) {
          offset = m;
        } else {
          lastOffset = m + 1;
        }
      }
      return offset;
    }
    var TimSort = class {
      constructor(array, compare) {
        this.array = array;
        this.compare = compare;
        const { length } = array;
        this.length = length;
        this.minGallop = DEFAULT_MIN_GALLOPING;
        this.tmpStorageLength = length < 2 * DEFAULT_TMP_STORAGE_LENGTH ? length >>> 1 : DEFAULT_TMP_STORAGE_LENGTH;
        this.tmp = new Array(this.tmpStorageLength);
        this.tmpIndex = new Array(this.tmpStorageLength);
        this.stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;
        this.runStart = new Array(this.stackLength);
        this.runLength = new Array(this.stackLength);
        this.stackSize = 0;
      }
      pushRun(runStart, runLength) {
        this.runStart[this.stackSize] = runStart;
        this.runLength[this.stackSize] = runLength;
        this.stackSize += 1;
      }
      mergeRuns() {
        while (this.stackSize > 1) {
          let n = this.stackSize - 2;
          if (n >= 1 && this.runLength[n - 1] <= this.runLength[n] + this.runLength[n + 1] || n >= 2 && this.runLength[n - 2] <= this.runLength[n] + this.runLength[n - 1]) {
            if (this.runLength[n - 1] < this.runLength[n + 1]) {
              n--;
            }
          } else if (this.runLength[n] > this.runLength[n + 1]) {
            break;
          }
          this.mergeAt(n);
        }
      }
      forceMergeRuns() {
        while (this.stackSize > 1) {
          let n = this.stackSize - 2;
          if (n > 0 && this.runLength[n - 1] < this.runLength[n + 1]) {
            n--;
          }
          this.mergeAt(n);
        }
      }
      mergeAt(i) {
        const { compare } = this;
        const { array } = this;
        let start1 = this.runStart[i];
        let length1 = this.runLength[i];
        const start2 = this.runStart[i + 1];
        let length2 = this.runLength[i + 1];
        this.runLength[i] = length1 + length2;
        if (i === this.stackSize - 3) {
          this.runStart[i + 1] = this.runStart[i + 2];
          this.runLength[i + 1] = this.runLength[i + 2];
        }
        this.stackSize--;
        const k = gallopRight(array[start2], array, start1, length1, 0, compare);
        start1 += k;
        length1 -= k;
        if (length1 === 0) {
          return;
        }
        length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);
        if (length2 === 0) {
          return;
        }
        if (length1 <= length2) {
          this.mergeLow(start1, length1, start2, length2);
        } else {
          this.mergeHigh(start1, length1, start2, length2);
        }
      }
      mergeLow(start1, length1, start2, length2) {
        const { compare } = this;
        const { array } = this;
        const { tmp } = this;
        const { tmpIndex } = this;
        let i = 0;
        for (i = 0; i < length1; i++) {
          tmp[i] = array[start1 + i];
          tmpIndex[i] = results[start1 + i];
        }
        let cursor1 = 0;
        let cursor2 = start2;
        let dest = start1;
        array[dest] = array[cursor2];
        results[dest] = results[cursor2];
        dest++;
        cursor2++;
        if (--length2 === 0) {
          for (i = 0; i < length1; i++) {
            array[dest + i] = tmp[cursor1 + i];
            results[dest + i] = tmpIndex[cursor1 + i];
          }
          return;
        }
        if (length1 === 1) {
          for (i = 0; i < length2; i++) {
            array[dest + i] = array[cursor2 + i];
            results[dest + i] = results[cursor2 + i];
          }
          array[dest + length2] = tmp[cursor1];
          results[dest + length2] = tmpIndex[cursor1];
          return;
        }
        let { minGallop } = this;
        while (true) {
          let count1 = 0;
          let count2 = 0;
          let exit = false;
          do {
            if (compare(array[cursor2], tmp[cursor1]) < 0) {
              array[dest] = array[cursor2];
              results[dest] = results[cursor2];
              dest++;
              cursor2++;
              count2++;
              count1 = 0;
              if (--length2 === 0) {
                exit = true;
                break;
              }
            } else {
              array[dest] = tmp[cursor1];
              results[dest] = tmpIndex[cursor1];
              dest++;
              cursor1++;
              count1++;
              count2 = 0;
              if (--length1 === 1) {
                exit = true;
                break;
              }
            }
          } while ((count1 | count2) < minGallop);
          if (exit) {
            break;
          }
          do {
            count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);
            if (count1 !== 0) {
              for (i = 0; i < count1; i++) {
                array[dest + i] = tmp[cursor1 + i];
                results[dest + i] = tmpIndex[cursor1 + i];
              }
              dest += count1;
              cursor1 += count1;
              length1 -= count1;
              if (length1 <= 1) {
                exit = true;
                break;
              }
            }
            array[dest] = array[cursor2];
            results[dest] = results[cursor2];
            dest++;
            cursor2++;
            if (--length2 === 0) {
              exit = true;
              break;
            }
            count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);
            if (count2 !== 0) {
              for (i = 0; i < count2; i++) {
                array[dest + i] = array[cursor2 + i];
                results[dest + i] = results[cursor2 + i];
              }
              dest += count2;
              cursor2 += count2;
              length2 -= count2;
              if (length2 === 0) {
                exit = true;
                break;
              }
            }
            array[dest] = tmp[cursor1];
            results[dest] = tmpIndex[cursor1];
            dest++;
            cursor1++;
            if (--length1 === 1) {
              exit = true;
              break;
            }
            minGallop--;
          } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
          if (exit) {
            break;
          }
          if (minGallop < 0) {
            minGallop = 0;
          }
          minGallop += 2;
        }
        this.minGallop = minGallop;
        if (minGallop < 1) {
          this.minGallop = 1;
        }
        if (length1 === 1) {
          for (i = 0; i < length2; i++) {
            array[dest + i] = array[cursor2 + i];
            results[dest + i] = results[cursor2 + i];
          }
          array[dest + length2] = tmp[cursor1];
          results[dest + length2] = tmpIndex[cursor1];
        } else if (length1 === 0) {
          throw new Error("mergeLow preconditions were not respected");
        } else {
          for (i = 0; i < length1; i++) {
            array[dest + i] = tmp[cursor1 + i];
            results[dest + i] = tmpIndex[cursor1 + i];
          }
        }
      }
      mergeHigh(start1, length1, start2, length2) {
        const { compare } = this;
        const { array } = this;
        const { tmp } = this;
        const { tmpIndex } = this;
        let i = 0;
        for (i = 0; i < length2; i++) {
          tmp[i] = array[start2 + i];
          tmpIndex[i] = results[start2 + i];
        }
        let cursor1 = start1 + length1 - 1;
        let cursor2 = length2 - 1;
        let dest = start2 + length2 - 1;
        let customCursor = 0;
        let customDest = 0;
        array[dest] = array[cursor1];
        results[dest] = results[cursor1];
        dest--;
        cursor1--;
        if (--length1 === 0) {
          customCursor = dest - (length2 - 1);
          for (i = 0; i < length2; i++) {
            array[customCursor + i] = tmp[i];
            results[customCursor + i] = tmpIndex[i];
          }
          return;
        }
        if (length2 === 1) {
          dest -= length1;
          cursor1 -= length1;
          customDest = dest + 1;
          customCursor = cursor1 + 1;
          for (i = length1 - 1; i >= 0; i--) {
            array[customDest + i] = array[customCursor + i];
            results[customDest + i] = results[customCursor + i];
          }
          array[dest] = tmp[cursor2];
          results[dest] = tmpIndex[cursor2];
          return;
        }
        let { minGallop } = this;
        while (true) {
          let count1 = 0;
          let count2 = 0;
          let exit = false;
          do {
            if (compare(tmp[cursor2], array[cursor1]) < 0) {
              array[dest] = array[cursor1];
              results[dest] = results[cursor1];
              dest--;
              cursor1--;
              count1++;
              count2 = 0;
              if (--length1 === 0) {
                exit = true;
                break;
              }
            } else {
              array[dest] = tmp[cursor2];
              results[dest] = tmpIndex[cursor2];
              dest--;
              cursor2--;
              count2++;
              count1 = 0;
              if (--length2 === 1) {
                exit = true;
                break;
              }
            }
          } while ((count1 | count2) < minGallop);
          if (exit) {
            break;
          }
          do {
            count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);
            if (count1 !== 0) {
              dest -= count1;
              cursor1 -= count1;
              length1 -= count1;
              customDest = dest + 1;
              customCursor = cursor1 + 1;
              for (i = count1 - 1; i >= 0; i--) {
                array[customDest + i] = array[customCursor + i];
                results[customDest + i] = results[customCursor + i];
              }
              if (length1 === 0) {
                exit = true;
                break;
              }
            }
            array[dest] = tmp[cursor2];
            results[dest] = tmpIndex[cursor2];
            dest--;
            cursor2--;
            if (--length2 === 1) {
              exit = true;
              break;
            }
            count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);
            if (count2 !== 0) {
              dest -= count2;
              cursor2 -= count2;
              length2 -= count2;
              customDest = dest + 1;
              customCursor = cursor2 + 1;
              for (i = 0; i < count2; i++) {
                array[customDest + i] = tmp[customCursor + i];
                results[customDest + i] = tmpIndex[customCursor + i];
              }
              if (length2 <= 1) {
                exit = true;
                break;
              }
            }
            array[dest] = array[cursor1];
            results[dest] = results[cursor1];
            dest--;
            cursor1--;
            if (--length1 === 0) {
              exit = true;
              break;
            }
            minGallop--;
          } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
          if (exit) {
            break;
          }
          if (minGallop < 0) {
            minGallop = 0;
          }
          minGallop += 2;
        }
        this.minGallop = minGallop;
        if (minGallop < 1) {
          this.minGallop = 1;
        }
        if (length2 === 1) {
          dest -= length1;
          cursor1 -= length1;
          customDest = dest + 1;
          customCursor = cursor1 + 1;
          for (i = length1 - 1; i >= 0; i--) {
            array[customDest + i] = array[customCursor + i];
            results[customDest + i] = results[customCursor + i];
          }
          array[dest] = tmp[cursor2];
          results[dest] = tmpIndex[cursor2];
        } else if (length2 === 0) {
          throw new Error("mergeHigh preconditions were not respected");
        } else {
          customCursor = dest - (length2 - 1);
          for (i = 0; i < length2; i++) {
            array[customCursor + i] = tmp[i];
            results[customCursor + i] = tmpIndex[i];
          }
        }
      }
    };
    function sort(array, compare, lo, hi) {
      if (!Array.isArray(array)) {
        throw new TypeError(`The "array" argument must be an array. Received ${array}`);
      }
      results = [];
      const { length } = array;
      let i = 0;
      while (i < length) {
        results[i] = i++;
      }
      if (!compare) {
        compare = alphabeticalCompare;
      } else if (typeof compare !== "function") {
        hi = lo;
        lo = compare;
        compare = alphabeticalCompare;
      }
      if (!lo) {
        lo = 0;
      }
      if (!hi) {
        hi = length;
      }
      let remaining = hi - lo;
      if (remaining < 2) {
        return results;
      }
      let runLength = 0;
      if (remaining < DEFAULT_MIN_MERGE) {
        runLength = makeAscendingRun(array, lo, hi, compare);
        binaryInsertionSort(array, lo, hi, lo + runLength, compare);
        return results;
      }
      const ts = new TimSort(array, compare);
      const minRun = minRunLength(remaining);
      do {
        runLength = makeAscendingRun(array, lo, hi, compare);
        if (runLength < minRun) {
          let force = remaining;
          if (force > minRun) {
            force = minRun;
          }
          binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);
          runLength = force;
        }
        ts.pushRun(lo, runLength);
        ts.mergeRuns();
        remaining -= runLength;
        lo += runLength;
      } while (remaining !== 0);
      ts.forceMergeRuns();
      return results;
    }
    module2.exports = {
      sort
    };
  }
});

// ../../node_modules/has-own-prop/index.js
var require_has_own_prop = __commonJS({
  "../../node_modules/has-own-prop/index.js"(exports2, module2) {
    "use strict";
    var hasOwnProp = Object.prototype.hasOwnProperty;
    module2.exports = (object, property) => hasOwnProp.call(object, property);
  }
});

// ../../node_modules/comment-json/src/common.js
var require_common4 = __commonJS({
  "../../node_modules/comment-json/src/common.js"(exports2, module2) {
    var hasOwnProperty = require_has_own_prop();
    var { isObject, isArray } = require_util2();
    var PREFIX_BEFORE = "before";
    var PREFIX_AFTER_PROP = "after-prop";
    var PREFIX_AFTER_COLON = "after-colon";
    var PREFIX_AFTER_VALUE = "after-value";
    var PREFIX_AFTER = "after";
    var PREFIX_BEFORE_ALL = "before-all";
    var PREFIX_AFTER_ALL = "after-all";
    var BRACKET_OPEN = "[";
    var BRACKET_CLOSE = "]";
    var CURLY_BRACKET_OPEN = "{";
    var CURLY_BRACKET_CLOSE = "}";
    var COMMA = ",";
    var EMPTY = "";
    var MINUS = "-";
    var SYMBOL_PREFIXES = [
      PREFIX_BEFORE,
      PREFIX_AFTER_PROP,
      PREFIX_AFTER_COLON,
      PREFIX_AFTER_VALUE,
      PREFIX_AFTER
    ];
    var NON_PROP_SYMBOL_KEYS = [
      PREFIX_BEFORE,
      PREFIX_BEFORE_ALL,
      PREFIX_AFTER_ALL
    ].map(Symbol.for);
    var COLON = ":";
    var UNDEFINED = void 0;
    var symbol = (prefix, key) => Symbol.for(prefix + COLON + key);
    var define2 = (target, key, value) => Object.defineProperty(target, key, {
      value,
      writable: true,
      configurable: true
    });
    var copy_comments_by_kind = (target, source, target_key, source_key, prefix, remove_source) => {
      const source_prop = symbol(prefix, source_key);
      if (!hasOwnProperty(source, source_prop)) {
        return;
      }
      const target_prop = target_key === source_key ? source_prop : symbol(prefix, target_key);
      define2(target, target_prop, source[source_prop]);
      if (remove_source) {
        delete source[source_prop];
      }
    };
    var copy_comments = (target, source, target_key, source_key, remove_source) => {
      SYMBOL_PREFIXES.forEach((prefix) => {
        copy_comments_by_kind(target, source, target_key, source_key, prefix, remove_source);
      });
    };
    var swap_comments = (array, from, to) => {
      if (from === to) {
        return;
      }
      SYMBOL_PREFIXES.forEach((prefix) => {
        const target_prop = symbol(prefix, to);
        if (!hasOwnProperty(array, target_prop)) {
          copy_comments_by_kind(array, array, to, from, prefix, true);
          return;
        }
        const comments = array[target_prop];
        delete array[target_prop];
        copy_comments_by_kind(array, array, to, from, prefix, true);
        define2(array, symbol(prefix, from), comments);
      });
    };
    var assign_non_prop_comments = (target, source) => {
      NON_PROP_SYMBOL_KEYS.forEach((key) => {
        const comments = source[key];
        if (comments) {
          define2(target, key, comments);
        }
      });
    };
    var assign2 = (target, source, keys) => {
      keys.forEach((key) => {
        if (!hasOwnProperty(source, key)) {
          return;
        }
        target[key] = source[key];
        copy_comments(target, source, key, key);
      });
      return target;
    };
    module2.exports = {
      SYMBOL_PREFIXES,
      PREFIX_BEFORE,
      PREFIX_AFTER_PROP,
      PREFIX_AFTER_COLON,
      PREFIX_AFTER_VALUE,
      PREFIX_AFTER,
      PREFIX_BEFORE_ALL,
      PREFIX_AFTER_ALL,
      BRACKET_OPEN,
      BRACKET_CLOSE,
      CURLY_BRACKET_OPEN,
      CURLY_BRACKET_CLOSE,
      COLON,
      COMMA,
      MINUS,
      EMPTY,
      UNDEFINED,
      symbol,
      define: define2,
      copy_comments,
      swap_comments,
      assign_non_prop_comments,
      assign(target, source, keys) {
        if (!isObject(target)) {
          throw new TypeError("Cannot convert undefined or null to object");
        }
        if (!isObject(source)) {
          return target;
        }
        if (keys === UNDEFINED) {
          keys = Object.keys(source);
          assign_non_prop_comments(target, source);
        } else if (!isArray(keys)) {
          throw new TypeError("keys must be array or undefined");
        } else if (keys.length === 0) {
          assign_non_prop_comments(target, source);
        }
        return assign2(target, source, keys);
      }
    };
  }
});

// ../../node_modules/comment-json/src/array.js
var require_array = __commonJS({
  "../../node_modules/comment-json/src/array.js"(exports2, module2) {
    var { isArray } = require_util2();
    var { sort } = require_src4();
    var {
      SYMBOL_PREFIXES,
      UNDEFINED,
      symbol,
      copy_comments,
      swap_comments
    } = require_common4();
    var reverse_comments = (array) => {
      const { length } = array;
      let i = 0;
      const max = length / 2;
      for (; i < max; i++) {
        swap_comments(array, i, length - i - 1);
      }
    };
    var move_comment = (target, source, i, offset, remove3) => {
      copy_comments(target, source, i + offset, i, remove3);
    };
    var move_comments = (target, source, start, count, offset, remove3) => {
      if (offset > 0) {
        let i2 = count;
        while (i2-- > 0) {
          move_comment(target, source, start + i2, offset, remove3);
        }
        return;
      }
      let i = 0;
      while (i < count) {
        const ii = i++;
        move_comment(target, source, start + ii, offset, remove3);
      }
    };
    var remove_comments = (array, key) => {
      SYMBOL_PREFIXES.forEach((prefix) => {
        const prop = symbol(prefix, key);
        delete array[prop];
      });
    };
    var get_mapped = (map, key) => {
      let mapped = key;
      while (mapped in map) {
        mapped = map[mapped];
      }
      return mapped;
    };
    var CommentArray = class extends Array {
      splice(...args) {
        const { length } = this;
        const ret = super.splice(...args);
        let [begin, deleteCount, ...items] = args;
        if (begin < 0) {
          begin += length;
        }
        if (arguments.length === 1) {
          deleteCount = length - begin;
        } else {
          deleteCount = Math.min(length - begin, deleteCount);
        }
        const {
          length: item_length
        } = items;
        const offset = item_length - deleteCount;
        const start = begin + deleteCount;
        const count = length - start;
        move_comments(this, this, start, count, offset, true);
        return ret;
      }
      slice(...args) {
        const { length } = this;
        const array = super.slice(...args);
        if (!array.length) {
          return new CommentArray();
        }
        let [begin, before] = args;
        if (before === UNDEFINED) {
          before = length;
        } else if (before < 0) {
          before += length;
        }
        if (begin < 0) {
          begin += length;
        } else if (begin === UNDEFINED) {
          begin = 0;
        }
        move_comments(array, this, begin, before - begin, -begin);
        return array;
      }
      unshift(...items) {
        const { length } = this;
        const ret = super.unshift(...items);
        const {
          length: items_length
        } = items;
        if (items_length > 0) {
          move_comments(this, this, 0, length, items_length, true);
        }
        return ret;
      }
      shift() {
        const ret = super.shift();
        const { length } = this;
        remove_comments(this, 0);
        move_comments(this, this, 1, length, -1, true);
        return ret;
      }
      reverse() {
        super.reverse();
        reverse_comments(this);
        return this;
      }
      pop() {
        const ret = super.pop();
        remove_comments(this, this.length);
        return ret;
      }
      concat(...items) {
        let { length } = this;
        const ret = super.concat(...items);
        if (!items.length) {
          return ret;
        }
        items.forEach((item) => {
          const prev = length;
          length += isArray(item) ? item.length : 1;
          if (!(item instanceof CommentArray)) {
            return;
          }
          move_comments(ret, item, 0, item.length, prev);
        });
        return ret;
      }
      sort(...args) {
        const result2 = sort(this, ...args.slice(0, 1));
        const map = /* @__PURE__ */ Object.create(null);
        result2.forEach((source_index, index) => {
          if (source_index === index) {
            return;
          }
          const real_source_index = get_mapped(map, source_index);
          if (real_source_index === index) {
            return;
          }
          map[index] = real_source_index;
          swap_comments(this, index, real_source_index);
        });
      }
    };
    module2.exports = {
      CommentArray
    };
  }
});

// ../../node_modules/comment-json/src/parse.js
var require_parse3 = __commonJS({
  "../../node_modules/comment-json/src/parse.js"(exports2, module2) {
    var esprima = require_esprima();
    var {
      CommentArray
    } = require_array();
    var {
      PREFIX_BEFORE,
      PREFIX_AFTER_PROP,
      PREFIX_AFTER_COLON,
      PREFIX_AFTER_VALUE,
      PREFIX_AFTER,
      PREFIX_BEFORE_ALL,
      PREFIX_AFTER_ALL,
      BRACKET_OPEN,
      BRACKET_CLOSE,
      CURLY_BRACKET_OPEN,
      CURLY_BRACKET_CLOSE,
      COLON,
      COMMA,
      MINUS,
      EMPTY,
      UNDEFINED,
      define: define2,
      assign_non_prop_comments
    } = require_common4();
    var tokenize = (code) => esprima.tokenize(code, {
      comment: true,
      loc: true
    });
    var previous_hosts = [];
    var comments_host = null;
    var unassigned_comments = null;
    var previous_props = [];
    var last_prop;
    var remove_comments = false;
    var inline = false;
    var tokens = null;
    var last = null;
    var current = null;
    var index;
    var reviver = null;
    var clean = () => {
      previous_props.length = previous_hosts.length = 0;
      last = null;
      last_prop = UNDEFINED;
    };
    var free = () => {
      clean();
      tokens.length = 0;
      unassigned_comments = comments_host = tokens = last = current = reviver = null;
    };
    var symbolFor = (prefix) => Symbol.for(last_prop !== UNDEFINED ? prefix + COLON + last_prop : prefix);
    var transform = (k, v) => reviver ? reviver(k, v) : v;
    var unexpected = () => {
      const error3 = new SyntaxError(`Unexpected token ${current.value.slice(0, 1)}`);
      Object.assign(error3, current.loc.start);
      throw error3;
    };
    var unexpected_end = () => {
      const error3 = new SyntaxError("Unexpected end of JSON input");
      Object.assign(error3, last ? last.loc.end : {
        line: 1,
        column: 0
      });
      throw error3;
    };
    var next = () => {
      const new_token = tokens[++index];
      inline = current && new_token && current.loc.end.line === new_token.loc.start.line || false;
      last = current;
      current = new_token;
    };
    var type = () => {
      if (!current) {
        unexpected_end();
      }
      return current.type === "Punctuator" ? current.value : current.type;
    };
    var is = (t) => type() === t;
    var expect = (a) => {
      if (!is(a)) {
        unexpected();
      }
    };
    var set_comments_host = (new_host) => {
      previous_hosts.push(comments_host);
      comments_host = new_host;
    };
    var restore_comments_host = () => {
      comments_host = previous_hosts.pop();
    };
    var assign_after_comments = () => {
      if (!unassigned_comments) {
        return;
      }
      const after_comments = [];
      for (const comment of unassigned_comments) {
        if (comment.inline) {
          after_comments.push(comment);
        } else {
          break;
        }
      }
      const { length } = after_comments;
      if (!length) {
        return;
      }
      if (length === unassigned_comments.length) {
        unassigned_comments = null;
      } else {
        unassigned_comments.splice(0, length);
      }
      define2(comments_host, symbolFor(PREFIX_AFTER), after_comments);
    };
    var assign_comments = (prefix) => {
      if (!unassigned_comments) {
        return;
      }
      define2(comments_host, symbolFor(prefix), unassigned_comments);
      unassigned_comments = null;
    };
    var parse_comments = (prefix) => {
      const comments = [];
      while (current && (is("LineComment") || is("BlockComment"))) {
        const comment = {
          ...current,
          inline
        };
        comments.push(comment);
        next();
      }
      if (remove_comments) {
        return;
      }
      if (!comments.length) {
        return;
      }
      if (prefix) {
        define2(comments_host, symbolFor(prefix), comments);
        return;
      }
      unassigned_comments = comments;
    };
    var set_prop = (prop, push) => {
      if (push) {
        previous_props.push(last_prop);
      }
      last_prop = prop;
    };
    var restore_prop = () => {
      last_prop = previous_props.pop();
    };
    var parse_object = () => {
      const obj = {};
      set_comments_host(obj);
      set_prop(UNDEFINED, true);
      let started = false;
      let name;
      parse_comments();
      while (!is(CURLY_BRACKET_CLOSE)) {
        if (started) {
          assign_comments(PREFIX_AFTER_VALUE);
          expect(COMMA);
          next();
          parse_comments();
          assign_after_comments();
          if (is(CURLY_BRACKET_CLOSE)) {
            break;
          }
        }
        started = true;
        expect("String");
        name = JSON.parse(current.value);
        set_prop(name);
        assign_comments(PREFIX_BEFORE);
        next();
        parse_comments(PREFIX_AFTER_PROP);
        expect(COLON);
        next();
        parse_comments(PREFIX_AFTER_COLON);
        obj[name] = transform(name, walk());
        parse_comments();
      }
      if (started) {
        assign_comments(PREFIX_AFTER);
      }
      next();
      last_prop = void 0;
      if (!started) {
        assign_comments(PREFIX_BEFORE);
      }
      restore_comments_host();
      restore_prop();
      return obj;
    };
    var parse_array = () => {
      const array = new CommentArray();
      set_comments_host(array);
      set_prop(UNDEFINED, true);
      let started = false;
      let i = 0;
      parse_comments();
      while (!is(BRACKET_CLOSE)) {
        if (started) {
          assign_comments(PREFIX_AFTER_VALUE);
          expect(COMMA);
          next();
          parse_comments();
          assign_after_comments();
          if (is(BRACKET_CLOSE)) {
            break;
          }
        }
        started = true;
        set_prop(i);
        assign_comments(PREFIX_BEFORE);
        array[i] = transform(i, walk());
        i++;
        parse_comments();
      }
      if (started) {
        assign_comments(PREFIX_AFTER);
      }
      next();
      last_prop = void 0;
      if (!started) {
        assign_comments(PREFIX_BEFORE);
      }
      restore_comments_host();
      restore_prop();
      return array;
    };
    function walk() {
      let tt = type();
      if (tt === CURLY_BRACKET_OPEN) {
        next();
        return parse_object();
      }
      if (tt === BRACKET_OPEN) {
        next();
        return parse_array();
      }
      let negative = EMPTY;
      if (tt === MINUS) {
        next();
        tt = type();
        negative = MINUS;
      }
      let v;
      switch (tt) {
        case "String":
        case "Boolean":
        case "Null":
        case "Numeric":
          v = current.value;
          next();
          return JSON.parse(negative + v);
        default:
      }
    }
    var isObject = (subject) => Object(subject) === subject;
    var parse2 = (code, rev, no_comments) => {
      clean();
      tokens = tokenize(code);
      reviver = rev;
      remove_comments = no_comments;
      if (!tokens.length) {
        unexpected_end();
      }
      index = -1;
      next();
      set_comments_host({});
      parse_comments(PREFIX_BEFORE_ALL);
      let result2 = walk();
      parse_comments(PREFIX_AFTER_ALL);
      if (current) {
        unexpected();
      }
      if (!no_comments && result2 !== null) {
        if (!isObject(result2)) {
          result2 = new Object(result2);
        }
        assign_non_prop_comments(result2, comments_host);
      }
      restore_comments_host();
      result2 = transform("", result2);
      free();
      return result2;
    };
    module2.exports = {
      parse: parse2,
      tokenize
    };
  }
});

// ../../node_modules/repeat-string/index.js
var require_repeat_string = __commonJS({
  "../../node_modules/repeat-string/index.js"(exports2, module2) {
    "use strict";
    var res = "";
    var cache;
    module2.exports = repeat;
    function repeat(str, num) {
      if (typeof str !== "string") {
        throw new TypeError("expected a string");
      }
      if (num === 1)
        return str;
      if (num === 2)
        return str + str;
      var max = str.length * num;
      if (cache !== str || typeof cache === "undefined") {
        cache = str;
        res = "";
      } else if (res.length >= max) {
        return res.substr(0, max);
      }
      while (max > res.length && num > 1) {
        if (num & 1) {
          res += str;
        }
        num >>= 1;
        str += str;
      }
      res += str;
      res = res.substr(0, max);
      return res;
    }
  }
});

// ../../node_modules/comment-json/src/stringify.js
var require_stringify3 = __commonJS({
  "../../node_modules/comment-json/src/stringify.js"(exports2, module2) {
    var {
      isArray,
      isObject,
      isFunction,
      isNumber,
      isString
    } = require_util2();
    var repeat = require_repeat_string();
    var {
      PREFIX_BEFORE_ALL,
      PREFIX_BEFORE,
      PREFIX_AFTER_PROP,
      PREFIX_AFTER_COLON,
      PREFIX_AFTER_VALUE,
      PREFIX_AFTER,
      PREFIX_AFTER_ALL,
      BRACKET_OPEN,
      BRACKET_CLOSE,
      CURLY_BRACKET_OPEN,
      CURLY_BRACKET_CLOSE,
      COLON,
      COMMA,
      EMPTY,
      UNDEFINED
    } = require_common4();
    var ESCAPABLE = /[\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
    var SPACE = " ";
    var LF = "\n";
    var STR_NULL = "null";
    var BEFORE = (prop) => `${PREFIX_BEFORE}:${prop}`;
    var AFTER_PROP = (prop) => `${PREFIX_AFTER_PROP}:${prop}`;
    var AFTER_COLON = (prop) => `${PREFIX_AFTER_COLON}:${prop}`;
    var AFTER_VALUE = (prop) => `${PREFIX_AFTER_VALUE}:${prop}`;
    var AFTER = (prop) => `${PREFIX_AFTER}:${prop}`;
    var meta = {
      "\b": "\\b",
      "	": "\\t",
      "\n": "\\n",
      "\f": "\\f",
      "\r": "\\r",
      '"': '\\"',
      "\\": "\\\\"
    };
    var escape4 = (string) => {
      ESCAPABLE.lastIndex = 0;
      if (!ESCAPABLE.test(string)) {
        return string;
      }
      return string.replace(ESCAPABLE, (a) => {
        const c = meta[a];
        return typeof c === "string" ? c : a;
      });
    };
    var quote = (string) => `"${escape4(string)}"`;
    var comment_stringify = (value, line) => line ? `//${value}` : `/*${value}*/`;
    var process_comments = (host, symbol_tag, deeper_gap, display_block) => {
      const comments = host[Symbol.for(symbol_tag)];
      if (!comments || !comments.length) {
        return EMPTY;
      }
      let is_line_comment = false;
      const str = comments.reduce((prev, {
        inline,
        type,
        value
      }) => {
        const delimiter = inline ? SPACE : LF + deeper_gap;
        is_line_comment = type === "LineComment";
        return prev + delimiter + comment_stringify(value, is_line_comment);
      }, EMPTY);
      return display_block || is_line_comment ? str + LF + deeper_gap : str;
    };
    var replacer = null;
    var indent = EMPTY;
    var clean = () => {
      replacer = null;
      indent = EMPTY;
    };
    var join2 = (one, two, gap) => one ? two ? one + two.trim() + LF + gap : one.trimRight() + LF + gap : two ? two.trimRight() + LF + gap : EMPTY;
    var join_content = (inside, value, gap) => {
      const comment = process_comments(value, PREFIX_BEFORE, gap + indent, true);
      return join2(comment, inside, gap);
    };
    var array_stringify = (value, gap) => {
      const deeper_gap = gap + indent;
      const { length } = value;
      let inside = EMPTY;
      let after_comma = EMPTY;
      for (let i = 0; i < length; i++) {
        if (i !== 0) {
          inside += COMMA;
        }
        const before = join2(after_comma, process_comments(value, BEFORE(i), deeper_gap), deeper_gap);
        inside += before || LF + deeper_gap;
        inside += stringify(i, value, deeper_gap) || STR_NULL;
        inside += process_comments(value, AFTER_VALUE(i), deeper_gap);
        after_comma = process_comments(value, AFTER(i), deeper_gap);
      }
      inside += join2(after_comma, process_comments(value, PREFIX_AFTER, deeper_gap), deeper_gap);
      return BRACKET_OPEN + join_content(inside, value, gap) + BRACKET_CLOSE;
    };
    var object_stringify = (value, gap) => {
      if (!value) {
        return "null";
      }
      const deeper_gap = gap + indent;
      let inside = EMPTY;
      let after_comma = EMPTY;
      let first = true;
      const keys = isArray(replacer) ? replacer : Object.keys(value);
      const iteratee = (key) => {
        const sv = stringify(key, value, deeper_gap);
        if (sv === UNDEFINED) {
          return;
        }
        if (!first) {
          inside += COMMA;
        }
        first = false;
        const before = join2(after_comma, process_comments(value, BEFORE(key), deeper_gap), deeper_gap);
        inside += before || LF + deeper_gap;
        inside += quote(key) + process_comments(value, AFTER_PROP(key), deeper_gap) + COLON + process_comments(value, AFTER_COLON(key), deeper_gap) + SPACE + sv + process_comments(value, AFTER_VALUE(key), deeper_gap);
        after_comma = process_comments(value, AFTER(key), deeper_gap);
      };
      keys.forEach(iteratee);
      inside += join2(after_comma, process_comments(value, PREFIX_AFTER, deeper_gap), deeper_gap);
      return CURLY_BRACKET_OPEN + join_content(inside, value, gap) + CURLY_BRACKET_CLOSE;
    };
    function stringify(key, holder, gap) {
      let value = holder[key];
      if (isObject(value) && isFunction(value.toJSON)) {
        value = value.toJSON(key);
      }
      if (isFunction(replacer)) {
        value = replacer.call(holder, key, value);
      }
      switch (typeof value) {
        case "string":
          return quote(value);
        case "number":
          return Number.isFinite(value) ? String(value) : STR_NULL;
        case "boolean":
        case "null":
          return String(value);
        case "object":
          return isArray(value) ? array_stringify(value, gap) : object_stringify(value, gap);
        default:
      }
    }
    var get_indent = (space) => isString(space) ? space : isNumber(space) ? repeat(SPACE, space) : EMPTY;
    var { toString } = Object.prototype;
    var PRIMITIVE_OBJECT_TYPES = [
      "[object Number]",
      "[object String]",
      "[object Boolean]"
    ];
    var is_primitive_object = (subject) => {
      if (typeof subject !== "object") {
        return false;
      }
      const str = toString.call(subject);
      return PRIMITIVE_OBJECT_TYPES.includes(str);
    };
    module2.exports = (value, replacer_, space) => {
      const indent_ = get_indent(space);
      if (!indent_) {
        return JSON.stringify(value, replacer_);
      }
      if (!isFunction(replacer_) && !isArray(replacer_)) {
        replacer_ = null;
      }
      replacer = replacer_;
      indent = indent_;
      const str = is_primitive_object(value) ? JSON.stringify(value) : stringify("", { "": value }, EMPTY);
      clean();
      return isObject(value) ? process_comments(value, PREFIX_BEFORE_ALL, EMPTY).trimLeft() + str + process_comments(value, PREFIX_AFTER_ALL, EMPTY).trimRight() : str;
    };
  }
});

// ../../node_modules/comment-json/src/index.js
var require_src5 = __commonJS({
  "../../node_modules/comment-json/src/index.js"(exports2, module2) {
    var { parse: parse2, tokenize } = require_parse3();
    var stringify = require_stringify3();
    var { CommentArray } = require_array();
    var { assign: assign2 } = require_common4();
    module2.exports = {
      parse: parse2,
      stringify,
      tokenize,
      CommentArray,
      assign: assign2
    };
  }
});

// ../../node_modules/lodash/lodash.js
var require_lodash = __commonJS({
  "../../node_modules/lodash/lodash.js"(exports2, module2) {
    (function() {
      var undefined2;
      var VERSION = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        "\xC0": "A",
        "\xC1": "A",
        "\xC2": "A",
        "\xC3": "A",
        "\xC4": "A",
        "\xC5": "A",
        "\xE0": "a",
        "\xE1": "a",
        "\xE2": "a",
        "\xE3": "a",
        "\xE4": "a",
        "\xE5": "a",
        "\xC7": "C",
        "\xE7": "c",
        "\xD0": "D",
        "\xF0": "d",
        "\xC8": "E",
        "\xC9": "E",
        "\xCA": "E",
        "\xCB": "E",
        "\xE8": "e",
        "\xE9": "e",
        "\xEA": "e",
        "\xEB": "e",
        "\xCC": "I",
        "\xCD": "I",
        "\xCE": "I",
        "\xCF": "I",
        "\xEC": "i",
        "\xED": "i",
        "\xEE": "i",
        "\xEF": "i",
        "\xD1": "N",
        "\xF1": "n",
        "\xD2": "O",
        "\xD3": "O",
        "\xD4": "O",
        "\xD5": "O",
        "\xD6": "O",
        "\xD8": "O",
        "\xF2": "o",
        "\xF3": "o",
        "\xF4": "o",
        "\xF5": "o",
        "\xF6": "o",
        "\xF8": "o",
        "\xD9": "U",
        "\xDA": "U",
        "\xDB": "U",
        "\xDC": "U",
        "\xF9": "u",
        "\xFA": "u",
        "\xFB": "u",
        "\xFC": "u",
        "\xDD": "Y",
        "\xFD": "y",
        "\xFF": "y",
        "\xC6": "Ae",
        "\xE6": "ae",
        "\xDE": "Th",
        "\xFE": "th",
        "\xDF": "ss",
        "\u0100": "A",
        "\u0102": "A",
        "\u0104": "A",
        "\u0101": "a",
        "\u0103": "a",
        "\u0105": "a",
        "\u0106": "C",
        "\u0108": "C",
        "\u010A": "C",
        "\u010C": "C",
        "\u0107": "c",
        "\u0109": "c",
        "\u010B": "c",
        "\u010D": "c",
        "\u010E": "D",
        "\u0110": "D",
        "\u010F": "d",
        "\u0111": "d",
        "\u0112": "E",
        "\u0114": "E",
        "\u0116": "E",
        "\u0118": "E",
        "\u011A": "E",
        "\u0113": "e",
        "\u0115": "e",
        "\u0117": "e",
        "\u0119": "e",
        "\u011B": "e",
        "\u011C": "G",
        "\u011E": "G",
        "\u0120": "G",
        "\u0122": "G",
        "\u011D": "g",
        "\u011F": "g",
        "\u0121": "g",
        "\u0123": "g",
        "\u0124": "H",
        "\u0126": "H",
        "\u0125": "h",
        "\u0127": "h",
        "\u0128": "I",
        "\u012A": "I",
        "\u012C": "I",
        "\u012E": "I",
        "\u0130": "I",
        "\u0129": "i",
        "\u012B": "i",
        "\u012D": "i",
        "\u012F": "i",
        "\u0131": "i",
        "\u0134": "J",
        "\u0135": "j",
        "\u0136": "K",
        "\u0137": "k",
        "\u0138": "k",
        "\u0139": "L",
        "\u013B": "L",
        "\u013D": "L",
        "\u013F": "L",
        "\u0141": "L",
        "\u013A": "l",
        "\u013C": "l",
        "\u013E": "l",
        "\u0140": "l",
        "\u0142": "l",
        "\u0143": "N",
        "\u0145": "N",
        "\u0147": "N",
        "\u014A": "N",
        "\u0144": "n",
        "\u0146": "n",
        "\u0148": "n",
        "\u014B": "n",
        "\u014C": "O",
        "\u014E": "O",
        "\u0150": "O",
        "\u014D": "o",
        "\u014F": "o",
        "\u0151": "o",
        "\u0154": "R",
        "\u0156": "R",
        "\u0158": "R",
        "\u0155": "r",
        "\u0157": "r",
        "\u0159": "r",
        "\u015A": "S",
        "\u015C": "S",
        "\u015E": "S",
        "\u0160": "S",
        "\u015B": "s",
        "\u015D": "s",
        "\u015F": "s",
        "\u0161": "s",
        "\u0162": "T",
        "\u0164": "T",
        "\u0166": "T",
        "\u0163": "t",
        "\u0165": "t",
        "\u0167": "t",
        "\u0168": "U",
        "\u016A": "U",
        "\u016C": "U",
        "\u016E": "U",
        "\u0170": "U",
        "\u0172": "U",
        "\u0169": "u",
        "\u016B": "u",
        "\u016D": "u",
        "\u016F": "u",
        "\u0171": "u",
        "\u0173": "u",
        "\u0174": "W",
        "\u0175": "w",
        "\u0176": "Y",
        "\u0177": "y",
        "\u0178": "Y",
        "\u0179": "Z",
        "\u017B": "Z",
        "\u017D": "Z",
        "\u017A": "z",
        "\u017C": "z",
        "\u017E": "z",
        "\u0132": "IJ",
        "\u0133": "ij",
        "\u0152": "Oe",
        "\u0153": "oe",
        "\u0149": "'n",
        "\u017F": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
      var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result2[resIndex++] = value;
          }
        }
        return result2;
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result2 = Array(length);
        while (++index < length) {
          result2[index] = iteratee(array[index], index, array);
        }
        return result2;
      }
      function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result2;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result2 = key;
            return false;
          }
        });
        return result2;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined2 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined2 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result2, index = -1, length = array.length;
        while (++index < length) {
          var current = iteratee(array[index]);
          if (current !== undefined2) {
            result2 = result2 === undefined2 ? current : result2 + current;
          }
        }
        return result2;
      }
      function baseTimes(n, iteratee) {
        var index = -1, result2 = Array(n);
        while (++index < n) {
          result2[index] = iteratee(index);
        }
        return result2;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length = strSymbols.length;
        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function countHolders(array, placeholder) {
        var length = array.length, result2 = 0;
        while (length--) {
          if (array[length] === placeholder) {
            ++result2;
          }
        }
        return result2;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object, key) {
        return object == null ? undefined2 : object[key];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator) {
        var data2, result2 = [];
        while (!(data2 = iterator.next()).done) {
          result2.push(data2.value);
        }
        return result2;
      }
      function mapToArray(map) {
        var index = -1, result2 = Array(map.size);
        map.forEach(function(value, key) {
          result2[++index] = [key, value];
        });
        return result2;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index = -1, length = array.length, resIndex = 0, result2 = [];
        while (++index < length) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result2[resIndex++] = index;
          }
        }
        return result2;
      }
      function setToArray(set) {
        var index = -1, result2 = Array(set.size);
        set.forEach(function(value) {
          result2[++index] = value;
        });
        return result2;
      }
      function setToPairs(set) {
        var index = -1, result2 = Array(set.size);
        set.forEach(function(value) {
          result2[++index] = [value, value];
        });
        return result2;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return index;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {
        }
        return index;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result2 = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result2;
        }
        return result2;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root : _45.defaults(root.Object(), context, _45.pick(root, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
        var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap2 && new WeakMap2();
        var realNames = {};
        var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = function() {
          function object() {
          }
          return function(proto) {
            if (!isObject(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result3 = new object();
            object.prototype = undefined2;
            return result3;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash.templateSettings = {
          "escape": reEscape,
          "evaluate": reEvaluate,
          "interpolate": reInterpolate,
          "variable": "",
          "imports": {
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result3 = new LazyWrapper(this.__wrapped__);
          result3.__actions__ = copyArray(this.__actions__);
          result3.__dir__ = this.__dir__;
          result3.__filtered__ = this.__filtered__;
          result3.__iteratees__ = copyArray(this.__iteratees__);
          result3.__takeCount__ = this.__takeCount__;
          result3.__views__ = copyArray(this.__views__);
          return result3;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result3 = new LazyWrapper(this);
            result3.__dir__ = -1;
            result3.__filtered__ = true;
          } else {
            result3 = this.clone();
            result3.__dir__ *= -1;
          }
          return result3;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result3 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1, value = array[index];
              while (++iterIndex < iterLength) {
                var data2 = iteratees[iterIndex], iteratee2 = data2.iteratee, type = data2.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result3[resIndex++] = value;
            }
          return result3;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result3 = this.has(key) && delete this.__data__[key];
          this.size -= result3 ? 1 : 0;
          return result3;
        }
        function hashGet(key) {
          var data2 = this.__data__;
          if (nativeCreate) {
            var result3 = data2[key];
            return result3 === HASH_UNDEFINED ? undefined2 : result3;
          }
          return hasOwnProperty.call(data2, key) ? data2[key] : undefined2;
        }
        function hashHas(key) {
          var data2 = this.__data__;
          return nativeCreate ? data2[key] !== undefined2 : hasOwnProperty.call(data2, key);
        }
        function hashSet(key, value) {
          var data2 = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data2[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data2 = this.__data__, index = assocIndexOf(data2, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data2.length - 1;
          if (index == lastIndex) {
            data2.pop();
          } else {
            splice.call(data2, index, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data2 = this.__data__, index = assocIndexOf(data2, key);
          return index < 0 ? undefined2 : data2[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data2 = this.__data__, index = assocIndexOf(data2, key);
          if (index < 0) {
            ++this.size;
            data2.push([key, value]);
          } else {
            data2[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result3 = getMapData(this, key)["delete"](key);
          this.size -= result3 ? 1 : 0;
          return result3;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data2 = getMapData(this, key), size2 = data2.size;
          data2.set(key, value);
          this.size += data2.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index = -1, length = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index < length) {
            this.add(values2[index]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data2 = this.__data__ = new ListCache(entries);
          this.size = data2.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data2 = this.__data__, result3 = data2["delete"](key);
          this.size = data2.size;
          return result3;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data2 = this.__data__;
          if (data2 instanceof ListCache) {
            var pairs = data2.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data2.size;
              return this;
            }
            data2 = this.__data__ = new MapCache(pairs);
          }
          data2.set(key, value);
          this.size = data2.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result3 = skipIndexes ? baseTimes(value.length, String2) : [], length = result3.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
              result3.push(key);
            }
          }
          return result3;
        }
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined2;
        }
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index = -1, length = paths.length, result3 = Array2(length), skip = object == null;
          while (++index < length) {
            result3[index] = skip ? undefined2 : get3(object, paths[index]);
          }
          return result3;
        }
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined2) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined2) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result3, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result3 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result3 !== undefined2) {
            return result3;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result3 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result3);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result3 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result3, value)) : copySymbols(value, baseAssign(result3, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result3 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result3);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result3.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result3.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result3, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result3;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (length--) {
            var key = props[length], predicate = source[key], value = object[key];
            if (value === undefined2 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined2, args);
          }, wait);
        }
        function baseDifference(array, values2, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result3 = [], valuesLength = values2.length;
          if (!length) {
            return result3;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result3.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result3.push(value);
              }
            }
          return result3;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result3 = true;
          baseEach(collection, function(value, index, collection2) {
            result3 = !!predicate(value, index, collection2);
            return result3;
          });
          return result3;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index = -1, length = array.length;
          while (++index < length) {
            var value = array[index], current = iteratee2(value);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result3 = value;
            }
          }
          return result3;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end === undefined2 || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result3 = [];
          baseEach(collection, function(value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result3.push(value);
            }
          });
          return result3;
        }
        function baseFlatten(array, depth, predicate, isStrict, result3) {
          var index = -1, length = array.length;
          predicate || (predicate = isFlattenable);
          result3 || (result3 = []);
          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result3);
              } else {
                arrayPush(result3, value);
              }
            } else if (!isStrict) {
              result3[result3.length] = value;
            }
          }
          return result3;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object[key]);
          });
        }
        function baseGet(object, path) {
          path = castPath(path, object);
          var index = 0, length = path.length;
          while (object != null && index < length) {
            object = object[toKey(path[index++])];
          }
          return index && index == length ? object : undefined2;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result3 = keysFunc(object);
          return isArray(object) ? result3 : arrayPush(result3, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result3 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
          }
          array = arrays[0];
          var index = -1, seen = caches[0];
          outer:
            while (++index < length && result3.length < maxLength) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result3, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result3.push(value);
              }
            }
          return result3;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func = object == null ? object : object[toKey(last(path))];
          return func == null ? undefined2 : apply(func, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length, length = index, noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (index--) {
            var data2 = matchData[index];
            if (noCustomizer && data2[2] ? data2[1] !== object[data2[0]] : !(data2[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data2 = matchData[index];
            var key = data2[0], objValue = object[key], srcValue = data2[1];
            if (noCustomizer && data2[2]) {
              if (objValue === undefined2 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result3 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result3 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result3)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == "object") {
            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result3 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty.call(object, key) && key != "constructor") {
              result3.push(key);
            }
          }
          return result3;
        }
        function baseKeysIn(object) {
          if (!isObject(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result3 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
              result3.push(key);
            }
          }
          return result3;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index = -1, result3 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result3[++index] = iteratee2(value, key, collection2);
          });
          return result3;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get3(object, path);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n) {
          var length = array.length;
          if (!length) {
            return;
          }
          n += n < 0 ? length : 0;
          return isIndex(n, length) ? array[n] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity];
          }
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result3 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index, "value": value };
          });
          return baseSortBy(result3, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn(object, path);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index = -1, length = paths.length, result3 = {};
          while (++index < length) {
            var path = paths[index], value = baseGet(object, path);
            if (predicate(value, path)) {
              baseSet(result3, castPath(path, object), value);
            }
          }
          return result3;
        }
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
          if (array === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index < length) {
            var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array, index, 1);
              } else {
                baseUnset(array, index);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result3 = Array2(length);
          while (length--) {
            result3[fromRight ? length : ++index] = start;
            start += step;
          }
          return result3;
        }
        function baseRepeat(string, n) {
          var result3 = "";
          if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
            return result3;
          }
          do {
            if (n % 2) {
              result3 += string;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string += string;
            }
          } while (n);
          return result3;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n, 0, array.length));
        }
        function baseSet(object, path, value, customizer) {
          if (!isObject(object)) {
            return object;
          }
          path = castPath(path, object);
          var index = -1, length = path.length, lastIndex = length - 1, nested = object;
          while (nested != null && ++index < length) {
            var key = toKey(path[index]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity : function(func, data2) {
          metaMap.set(func, data2);
          return func;
        };
        var baseSetToString = !defineProperty ? identity : function(func, string) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array, start, end) {
          var index = -1, length = array.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result3 = Array2(length);
          while (++index < length) {
            result3[index] = array[index + start];
          }
          return result3;
        }
        function baseSome(collection, predicate) {
          var result3;
          baseEach(collection, function(value, index, collection2) {
            result3 = predicate(value, index, collection2);
            return !result3;
          });
          return !!result3;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index = -1, length = array.length, resIndex = 0, result3 = [];
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result3[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result3;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result3 = value + "";
          return result3 == "0" && 1 / value == -INFINITY ? "-0" : result3;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result3 = [], seen = result3;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set2 = iteratee2 ? null : createSet(array);
            if (set2) {
              return setToArray(set2);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result3;
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result3.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result3) {
                  seen.push(computed);
                }
                result3.push(value);
              }
            }
          return result3;
        }
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last(path))];
        }
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length, index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions) {
          var result3 = value;
          if (result3 instanceof LazyWrapper) {
            result3 = result3.value();
          }
          return arrayReduce(actions, function(result4, action) {
            return action.func.apply(action.thisArg, arrayPush([result4], action.args));
          }, result3);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1, result3 = Array2(length);
          while (++index < length) {
            var array = arrays[index], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index) {
                result3[index] = baseDifference(result3[index] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result3, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index = -1, length = props.length, valsLength = values2.length, result3 = {};
          while (++index < length) {
            var value = index < valsLength ? values2[index] : undefined2;
            assignFunc(result3, props[index], value);
          }
          return result3;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity;
        }
        function castPath(value, object) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }
        var castRest = baseRest;
        function castSlice(array, start, end) {
          var length = array.length;
          end = end === undefined2 ? length : end;
          return !start && end >= length ? array : baseSlice(array, start, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result3 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
          buffer.copy(result3);
          return result3;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result3 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result3).set(new Uint8Array2(arrayBuffer));
          return result3;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result3 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result3.lastIndex = regexp.lastIndex;
          return result3;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index < length) {
            var result3 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result3) {
              if (index >= ordersLength) {
                return result3;
              }
              var order = orders[index];
              return result3 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result3 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result3[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result3[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result3[leftIndex++] = args[argsIndex++];
          }
          return result3;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result3 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result3[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result3[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result3[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result3;
        }
        function copyArray(source, array) {
          var index = -1, length = source.length;
          array || (array = Array2(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1, length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined2 : customizer;
              length = 1;
            }
            object = Object2(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result3 = Ctor.apply(thisBinding, args);
            return isObject(result3) ? result3 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined2, args, holders, undefined2, undefined2, arity - length);
            }
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func), data2 = funcName == "wrapper" ? getData(func) : undefined2;
              if (data2 && isLaziable(data2[0]) && data2[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data2[4].length && data2[9] == 1) {
                wrapper = wrapper[getFuncName(data2[0])].apply(wrapper, data2[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray(value)) {
                return wrapper.plant(value).value();
              }
              var index2 = 0, result3 = length ? funcs[index2].apply(this, args) : value;
              while (++index2 < length) {
                result3 = funcs[index2].call(this, result3);
              }
              return result3;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary2, arity - length);
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result3;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result3 = value;
            }
            if (other !== undefined2) {
              if (result3 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result3 = operator(value, other);
            }
            return result3;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result3 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result3), 0, length).join("") : result3.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined2;
            }
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result3 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData(result3, newData);
          }
          result3.placeholder = placeholder;
          return setWrapToString(result3, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number, precision) {
            number = toNumber(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop3 : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data2 = isBindKey ? undefined2 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data2) {
            mergeData(newData, data2);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result3 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result3 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result3 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result3 = createHybrid.apply(undefined2, newData);
          }
          var setter = data2 ? baseSetData : setData;
          return setWrapToString(setter(result3, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject(objValue) && isObject(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined2 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1, result3 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array, other);
          stack.set(other, array);
          while (++index < arrLength) {
            var arrValue = array[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result3 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result3 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result3 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result3;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result3 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result3;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result3 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result3 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result3 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result3 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result3;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined2, flatten), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop3 : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result3 = func.name + "", array = realNames[result3], length = hasOwnProperty.call(realNames, result3) ? array.length : 0;
          while (length--) {
            var data2 = array[length], otherFunc = data2.func;
            if (otherFunc == null || otherFunc == func) {
              return data2.name;
            }
          }
          return result3;
        }
        function getHolder(func) {
          var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result3 = lodash.iteratee || iteratee;
          result3 = result3 === iteratee ? baseIteratee : result3;
          return arguments.length ? result3(arguments[0], arguments[1]) : result3;
        }
        function getMapData(map2, key) {
          var data2 = map2.__data__;
          return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
        }
        function getMatchData(object) {
          var result3 = keys(object), length = result3.length;
          while (length--) {
            var key = result3[length], value = object[key];
            result3[length] = [key, value, isStrictComparable(value)];
          }
          return result3;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined2;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e) {
          }
          var result3 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result3;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result3 = [];
          while (object) {
            arrayPush(result3, getSymbols(object));
            object = getPrototype(object);
          }
          return result3;
        };
        var getTag = baseGetTag;
        if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
          getTag = function(value) {
            var result3 = baseGetTag(value), Ctor = result3 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result3;
          };
        }
        function getView(start, end, transforms) {
          var index = -1, length = transforms.length;
          while (++index < length) {
            var data2 = transforms[index], size2 = data2.size;
            switch (data2.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax(start, end - size2);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index = -1, length = path.length, result3 = false;
          while (++index < length) {
            var key = toKey(path[index]);
            if (!(result3 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result3 || ++index != length) {
            return result3;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
        }
        function initCloneArray(array) {
          var length = array.length, result3 = new array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
            result3.index = array.index;
            result3.input = array.input;
          }
          return result3;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
            return eq(object[index], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data2 = getData(other);
          return !!data2 && func === data2[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result3 = memoize(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result3.cache;
          return result3;
        }
        function mergeData(data2, source) {
          var bitmask = data2[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data2[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data2;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data2[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data2[3];
            data2[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data2[4] = partials ? replaceHolders(data2[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data2[5];
            data2[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data2[6] = partials ? replaceHolders(data2[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data2[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data2[8] = data2[8] == null ? source[8] : nativeMin(data2[8], source[8]);
          }
          if (data2[9] == null) {
            data2[9] = source[9];
          }
          data2[0] = source[0];
          data2[1] = newBitmask;
          return data2;
        }
        function nativeKeysIn(object) {
          var result3 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result3.push(key);
            }
          }
          return result3;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform2) {
          start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
            while (++index < length) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array2(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform2(array);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
          }
          return array;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array, size2) {
          var index = -1, length = array.length, lastIndex = length - 1;
          size2 = size2 === undefined2 ? length : size2;
          while (++index < size2) {
            var rand = baseRandom(index, lastIndex), value = array[rand];
            array[rand] = array[index];
            array[index] = value;
          }
          array.length = size2;
          return array;
        }
        var stringToPath = memoizeCapped(function(string) {
          var result3 = [];
          if (string.charCodeAt(0) === 46) {
            result3.push("");
          }
          string.replace(rePropName, function(match, number, quote, subString) {
            result3.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
          });
          return result3;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result3 = value + "";
          return result3 == "0" && 1 / value == -INFINITY ? "-0" : result3;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result3 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result3.__actions__ = copyArray(wrapper.__actions__);
          result3.__index__ = wrapper.__index__;
          result3.__values__ = wrapper.__values__;
          return result3;
        }
        function chunk(array, size2, guard) {
          if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size2 < 1) {
            return [];
          }
          var index = 0, resIndex = 0, result3 = Array2(nativeCeil(length / size2));
          while (index < length) {
            result3[resIndex++] = baseSlice(array, index, index += size2);
          }
          return result3;
        }
        function compact(array) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result3 = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result3[resIndex++] = value;
            }
          }
          return result3;
        }
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array = arguments[0], index = length;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function dropRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        function findIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }
        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs) {
          var index = -1, length = pairs == null ? 0 : pairs.length, result3 = {};
          while (++index < length) {
            var pair = pairs[index];
            result3[pair[0]] = pair[1];
          }
          return result3;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined2;
        }
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array, value, index);
        }
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join2(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined2;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
        }
        function nth(array, n) {
          return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
        }
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length, result3 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending));
          return result3;
        });
        function remove3(array, predicate) {
          var result3 = [];
          if (!(array && array.length)) {
            return result3;
          }
          var index = -1, indexes = [], length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result3.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result3;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice(array, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined2 ? length : toInteger(end);
          }
          return baseSlice(array, start, end);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value);
            if (index < length && eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }
        function take(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array && array.length ? baseUniq(array, undefined2, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array, baseProperty(index));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result3 = unzip(array);
          if (iteratee2 == null) {
            return result3;
          }
          return arrayMap(result3, function(group) {
            return apply(iteratee2, undefined2, group);
          });
        }
        var without = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result3 = lodash(value);
          result3.__chain__ = true;
          return result3;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined2);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result3, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone2 = wrapperClone(parent2);
            clone2.__index__ = 0;
            clone2.__values__ = undefined2;
            if (result3) {
              previous.__wrapped__ = clone2;
            } else {
              result3 = clone2;
            }
            var previous = clone2;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result3;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result3, value, key) {
          if (hasOwnProperty.call(result3, key)) {
            ++result3[key];
          } else {
            baseAssignValue(result3, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map(collection, iteratee2), depth);
        }
        function forEach(collection, iteratee2) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result3, value, key) {
          if (hasOwnProperty.call(result3, key)) {
            result3[key].push(value);
          } else {
            baseAssignValue(result3, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path, args) {
          var index = -1, isFunc = typeof path == "function", result3 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result3[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result3;
        });
        var keyBy = createAggregator(function(result3, value, key) {
          baseAssignValue(result3, key, value);
        });
        function map(collection, iteratee2) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result3, value, key) {
          result3[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          var func = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        function shuffle(collection) {
          var func = isArray(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now = ctxNow || function() {
          return root.Date.now();
        };
        function after(n, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          n = guard ? undefined2 : n;
          n = func && n == null ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
        }
        function before(n, func) {
          var result3;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result3 = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined2;
            }
            return result3;
          };
        }
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result3 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result3.placeholder = curry.placeholder;
          return result3;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result3 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result3.placeholder = curryRight.placeholder;
          return result3;
        }
        function debounce(func, wait, options2) {
          var lastArgs, lastThis, maxWait, result3, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject(options2)) {
            leading = !!options2.leading;
            maxing = "maxWait" in options2;
            maxWait = maxing ? nativeMax(toNumber(options2.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options2 ? !!options2.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result3 = func.apply(thisArg, args);
            return result3;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result3;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result3;
          }
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush() {
            return timerId === undefined2 ? result3 : trailingEdge(now());
          }
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result3;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer3 = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result3 = func.apply(this, args);
            memoized.cache = cache.set(key, result3) || cache;
            return result3;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1, length = nativeMin(args.length, funcsLength);
            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined2 ? start : toInteger(start);
          return baseRest(func, start);
        }
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array = args[start], otherArgs = castSlice(args, 0, start);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle(func, wait, options2) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject(options2)) {
            leading = "leading" in options2 ? !!options2.leading : leading;
            trailing = "trailing" in options2 ? !!options2.trailing : trailing;
          }
          return debounce(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result3 = customizer ? customizer(value, other) : undefined2;
          return result3 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result3;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
        }
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction(value) {
          if (!isObject(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString(value) {
          return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined(value) {
          return value === undefined2;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result3 = toFinite(value), remainder = result3 % 1;
          return result3 === result3 ? remainder ? result3 - remainder : result3 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign2 = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create(prototype, properties) {
          var result3 = baseCreate(prototype);
          return properties == null ? result3 : baseAssign(result3, properties);
        }
        var defaults = baseRest(function(object, sources) {
          object = Object2(object);
          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith, undefined2, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get3(object, path, defaultValue) {
          var result3 = object == null ? undefined2 : baseGet(object, path);
          return result3 === undefined2 ? defaultValue : result3;
        }
        function has(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        var invert = createInverter(function(result3, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result3[value] = key;
        }, constant(identity));
        var invertBy = createInverter(function(result3, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty.call(result3, value)) {
            result3[value].push(key);
          } else {
            result3[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result3 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result3, iteratee2(value, key, object2), value);
          });
          return result3;
        }
        function mapValues(object, iteratee2) {
          var result3 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result3, key, iteratee2(value, key, object2));
          });
          return result3;
        }
        var merge = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object, paths) {
          var result3 = {};
          if (object == null) {
            return result3;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result3);
          if (isDeep) {
            result3 = baseClone(result3, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result3, paths[length]);
          }
          return result3;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        function result2(object, path, defaultValue) {
          path = castPath(path, object);
          var index = -1, length = path.length;
          if (!length) {
            length = 1;
            object = undefined2;
          }
          while (++index < length) {
            var value = object == null ? undefined2 : object[toKey(path[index])];
            if (value === undefined2) {
              index = length;
              value = defaultValue;
            }
            object = isFunction(value) ? value.call(object) : value;
          }
          return object;
        }
        function set(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseSet(object, path, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject(object)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
            return iteratee2(accumulator, value, index, object2);
          });
          return accumulator;
        }
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }
        function update(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp(number, lower, upper) {
          if (upper === undefined2) {
            upper = lower;
            lower = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined2) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number), lower, upper);
        }
        function inRange(number, start, end) {
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber(number);
          return baseInRange(number, start, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined2;
            }
          }
          if (lower === undefined2 && upper === undefined2) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined2) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result3, word2, index) {
          word2 = word2.toLowerCase();
          return result3 + (index ? capitalize3(word2) : word2);
        });
        function capitalize3(string) {
          return upperFirst(toString(string).toLowerCase());
        }
        function deburr(string) {
          string = toString(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string, target, position) {
          string = toString(string);
          target = baseToString(target);
          var length = string.length;
          position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }
        function escape4(string) {
          string = toString(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = toString(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase = createCompounder(function(result3, word2, index) {
          return result3 + (index ? "-" : "") + word2.toLowerCase();
        });
        var lowerCase = createCompounder(function(result3, word2, index) {
          return result3 + (index ? " " : "") + word2.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad2(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        function padStart(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string, n, guard) {
          if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString(string), n);
        }
        function replace() {
          var args = arguments, string = toString(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result3, word2, index) {
          return result3 + (index ? "_" : "") + word2.toLowerCase();
        });
        function split(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        var startCase = createCompounder(function(result3, word2, index) {
          return result3 + (index ? " " : "") + upperFirst(word2);
        });
        function startsWith(string, target, position) {
          string = toString(string);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }
        function template(string, options2, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall(string, options2, guard)) {
            options2 = undefined2;
          }
          string = toString(string);
          options2 = assignInWith({}, options2, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options2.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index = 0, interpolate = options2.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2((options2.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options2.evaluate || reNoMatch).source + "|$", "g");
          var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options2, "sourceURL") ? (options2.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty.call(options2, "variable") && options2.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result3 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result3.source = source;
          if (isError(result3)) {
            throw result3;
          }
          return result3;
        }
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        function trim(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string, options2) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject(options2)) {
            var separator = "separator" in options2 ? options2.separator : separator;
            length = "length" in options2 ? toInteger(options2.length) : length;
            omission = "omission" in options2 ? baseToString(options2.omission) : omission;
          }
          string = toString(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result3 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator === undefined2) {
            return result3 + omission;
          }
          if (strSymbols) {
            end += result3.length - end;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match, substring = result3;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result3 = result3.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index = result3.lastIndexOf(separator);
            if (index > -1) {
              result3 = result3.slice(0, index);
            }
          }
          return result3 + omission;
        }
        function unescape2(string) {
          string = toString(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result3, word2, index) {
          return result3 + (index ? " " : "") + word2.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined2, args);
          } catch (e) {
            return isError(e) ? e : new Error2(e);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });
        function mixin(object, source, options2) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options2 == null && !(isObject(source) && (methodNames.length || !props.length))) {
            options2 = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject(options2) && "chain" in options2) || !!options2.chain, isFunc = isFunction(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result3 = object(this.__wrapped__), actions = result3.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object });
                  result3.__chain__ = chainAll;
                  return result3;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop3() {
        }
        function nthArg(n) {
          n = toInteger(n);
          return baseRest(function(args) {
            return baseNth(args, n);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined2 : baseGet(object, path);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n, iteratee2) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n -= MAX_ARRAY_LENGTH;
          var result3 = baseTimes(length, iteratee2);
          while (++index < n) {
            iteratee2(index);
          }
          return result3;
        }
        function toPath(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString(prefix) + id;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max(array) {
          return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean(array) {
          return baseMean(array, identity);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min(array) {
          return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign2;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer3;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove3;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize3;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape4;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get3;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite2;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN2;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join2;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop3;
        lodash.now = now;
        lodash.pad = pad2;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt2;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result2;
        lodash.round = round;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape2;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(["drop", "take"], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
            var result3 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            if (result3.__filtered__) {
              result3.__takeCount__ = nativeMin(n, result3.__takeCount__);
            } else {
              result3.__views__.push({
                "size": nativeMin(n, MAX_ARRAY_LENGTH),
                "type": methodName + (result3.__dir__ < 0 ? "Right" : "")
              });
            }
            return result3;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
          var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result3 = this.clone();
            result3.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result3.__filtered__ = result3.__filtered__ || isFilter;
            return result3;
          };
        });
        arrayEach(["head", "last"], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result3 = this;
          if (result3.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result3);
          }
          if (start < 0) {
            result3 = result3.takeRight(-start);
          } else if (start) {
            result3 = result3.drop(start);
          }
          if (end !== undefined2) {
            end = toInteger(end);
            result3 = end < 0 ? result3.dropRight(-end) : result3.take(end - start);
          }
          return result3;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
            var interceptor = function(value2) {
              var result4 = lodashFunc.apply(lodash, arrayPush([value2], args));
              return isTaker && chainAll ? result4[0] : result4;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result3 = func.apply(value, args);
              result3.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
              return new LodashWrapper(result3, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result3 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result3.value()[0] : result3.value() : result3;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      };
      var _45 = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _45;
        define(function() {
          return _45;
        });
      } else if (freeModule) {
        (freeModule.exports = _45)._ = _45;
        freeExports._ = _45;
      } else {
        root._ = _45;
      }
    }).call(exports2);
  }
});

// ../../node_modules/@sap/cf-tools/out/src/cli.js
var require_cli = __commonJS({
  "../../node_modules/@sap/cf-tools/out/src/cli.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Cli = void 0;
    var child_process_1 = require("child_process");
    var comment_json_1 = require_src5();
    var _45 = require_lodash();
    var types_1 = require_types2();
    var Cli = class {
      static execute(args, options2, token2) {
        token2 = token2 || { isCancellationRequested: false, onCancellationRequested: () => {
          return;
        } };
        Cli.updateSpawnOptions(options2);
        return new Promise((resolve) => {
          let stderr = "";
          let stdout = "";
          if (token2.isCancellationRequested) {
            Cli.cliResultOnExit(stdout, resolve, stderr, types_1.CF_CMD_EXIT_CODE.CANCEL_REQ);
            return;
          }
          const childProcess = (0, child_process_1.spawn)(Cli.CF_CMD, args, options2);
          childProcess.stdin.end();
          childProcess.stdout.on("data", (data2) => {
            stdout = stdout.concat(data2);
          });
          childProcess.stderr.on("data", (data2) => {
            stderr = stderr.concat(data2);
          });
          childProcess.on("exit", (code) => {
            Cli.cliResultOnExit(stdout, resolve, stderr, code);
          });
          childProcess.on("error", (err) => {
            const message = _45.get(err, "code") === "ENOENT" ? `${Cli.CF_CMD}: command not found` : _45.get(err, "message");
            resolve({ "stdout": stdout, "stderr": stderr, error: message, exitCode: types_1.CF_CMD_EXIT_CODE.ERROR });
          });
          token2.onCancellationRequested(() => {
            childProcess.kill();
            Cli.cliResultOnExit("", resolve, "", types_1.CF_CMD_EXIT_CODE.CANCELED);
          });
        });
      }
      static cliResultOnExit(stdout, resolve, stderr, code) {
        if (stdout) {
          if (stdout.indexOf("error_code") > 0) {
            try {
              const cfErr = (0, comment_json_1.parse)(stdout);
              const message = _45.get(cfErr, "code") === 10002 ? Cli.CF_LOGIN_ERROR : _45.get(cfErr, "description", "Internal error occured");
              resolve({ "stdout": stdout, "stderr": stderr, exitCode: types_1.CF_CMD_EXIT_CODE.ERROR, error: message });
              return;
            } catch (e) {
            }
          } else if (stdout.startsWith("FAILED") && stdout.indexOf("Error creating request") > 0) {
            resolve({ "stdout": stdout, "stderr": stderr, error: Cli.CF_LOGIN_ERROR, exitCode: types_1.CF_CMD_EXIT_CODE.ERROR });
            return;
          } else if (/failed.*\bError\b:/g.test(stdout)) {
            try {
              (0, comment_json_1.parse)(stdout);
            } catch (e) {
              resolve({ "stdout": stdout, "stderr": stderr, error: stdout, exitCode: types_1.CF_CMD_EXIT_CODE.ERROR });
              return;
            }
          } else if (stdout.startsWith("FAILED") && stdout.indexOf("No API endpoint set") > 0) {
            resolve({ "stdout": stdout, "stderr": stderr, error: stdout, exitCode: types_1.CF_CMD_EXIT_CODE.ERROR });
            return;
          }
        }
        resolve({ "stdout": stdout, "stderr": stderr, exitCode: code });
      }
      static updateSpawnOptions(options2) {
        if (options2) {
          options2.env = Object.assign(Object.assign(Object.assign({}, process.env), { NODE_VERSION: process.versions.node }), options2.env);
          _45.defaults(options2, { cwd: _45.get(options2, "cmd", __dirname) });
        }
      }
    };
    exports2.Cli = Cli;
    Cli.CF_LOGIN_ERROR = "Not logged in. Use 'cf login' to log in.";
    Cli.CF_CMD = "cf";
  }
});

// ../../node_modules/@sap/cf-tools/out/src/messages.js
var require_messages = __commonJS({
  "../../node_modules/@sap/cf-tools/out/src/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.messages = void 0;
    exports2.messages = {
      space_not_set: `The selected action failed because there is no Cloud Foundry space assigned.`,
      service_creation_started: `Service instance creation started, waiting for 'Ready' state...`,
      create_service_canceled_by_requester: `The service instance creation was cancelled by the requester. The service may have been partially created, consider deleting it using the 'cf delete-service' command.`,
      cf_setting_not_set: `Could not find the Cloud Foundry settings. Make sure you have assigned an org and space in Cloud Foundry.`,
      no_valid_filters: `Could not find any valid filters.`,
      failed_creating_entity: (description, name) => `Could not create the entity since ${description}, consider deleting it using the 'cf delete-service ${name} command'.`,
      exceed_number_of_attempts: (name) => `Could not verify the service instance creation. Check its status using the 'cf service ${name}' command.`,
      service_not_found: (instanceName) => `Could not find the '${instanceName}' service instance.`,
      service_creation_failed: (error3) => `Service instance creation failed: ${error3}`,
      not_allowed_filter: (param, query) => `The '${param}' parameter is not allowed in the '${query}' query.`
    };
  }
});

// ../../node_modules/@sap/cf-tools/out/src/utils.js
var require_utils6 = __commonJS({
  "../../node_modules/@sap/cf-tools/out/src/utils.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseRawDictData = exports2.padQuerySpace = exports2.getSpaceGuidThrowIfUndefined = exports2.cfGetConfigFileField = exports2.cfGetConfigFileJson = exports2.isUpsType = exports2.cfGetConfigFilePath = exports2.getTags = exports2.getOrgGUID = exports2.getSpaceFieldGUID = exports2.getDescription = exports2.getLabel = exports2.getName = exports2.getGuid = exports2.padQuery = exports2.ensureQuery = exports2.dataContentAsObject = void 0;
    var _45 = require_lodash();
    var os = require("os");
    var fs2 = require("fs");
    var path = require("path");
    var comment_json_1 = require_src5();
    var messages_1 = require_messages();
    var types_1 = require_types2();
    function dataContentAsObject(filePath) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          return _45.reduce(_45.split(yield fs2.promises.readFile(filePath, { encoding: "utf8" }), os.EOL), (data2, line) => {
            const parts = _45.split(line, "=");
            if (_45.size(parts) > 1) {
              data2[_45.trim(parts[0])] = _45.trim(parts[1]);
            }
            return data2;
          }, {});
        } catch (error3) {
          return {};
        }
      });
    }
    exports2.dataContentAsObject = dataContentAsObject;
    function ensureQuery(query) {
      query = query || {};
      _45.defaults(query, { filters: [] });
      _45.defaults(query, { per_page: types_1.CF_PAGE_SIZE });
      return query;
    }
    exports2.ensureQuery = ensureQuery;
    function padQuery(query, otherFilters) {
      query = ensureQuery(query);
      _45.each(otherFilters, (other) => {
        const filter = _45.find(query.filters, ["key", other.key]);
        if (!_45.size(filter === null || filter === void 0 ? void 0 : filter.value)) {
          query.filters = _45.concat(query.filters, [other]);
        }
      });
      return query;
    }
    exports2.padQuery = padQuery;
    function getGuid(resource) {
      return _45.get(resource, "guid", "");
    }
    exports2.getGuid = getGuid;
    function getName(resource) {
      return _45.get(resource, "name", "");
    }
    exports2.getName = getName;
    function getLabel(resource) {
      return _45.get(resource, "label", "");
    }
    exports2.getLabel = getLabel;
    function getDescription(resource) {
      return _45.get(resource, "description", "");
    }
    exports2.getDescription = getDescription;
    function getSpaceFieldGUID(spaceField) {
      return _45.get(spaceField, "GUID", "");
    }
    exports2.getSpaceFieldGUID = getSpaceFieldGUID;
    function getOrgGUID(resource) {
      return _45.get(resource, ["relationships", "organization", "data", "guid"], "");
    }
    exports2.getOrgGUID = getOrgGUID;
    function getTags(resource) {
      return _45.get(resource, "tags", []);
    }
    exports2.getTags = getTags;
    function cfGetConfigFilePath(target) {
      const relatives = target ? ["targets", `${target}.config.json`] : [`config.json`];
      return path.join(_45.get(process, "env.CF_HOME", os.homedir()), ".cf", ...relatives);
    }
    exports2.cfGetConfigFilePath = cfGetConfigFilePath;
    function isUpsType(resource) {
      return _45.get(resource, "type", types_1.eServiceTypes.managed) === types_1.eServiceTypes.user_provided;
    }
    exports2.isUpsType = isUpsType;
    function cfGetConfigFileJson(target) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          return (0, comment_json_1.parse)(yield fs2.promises.readFile(cfGetConfigFilePath(target), { encoding: "utf8" }));
        } catch (error3) {
        }
      });
    }
    exports2.cfGetConfigFileJson = cfGetConfigFileJson;
    function cfGetConfigFileField(field, target) {
      return __awaiter(this, void 0, void 0, function* () {
        return _45.get(yield cfGetConfigFileJson(target), `${field}`);
      });
    }
    exports2.cfGetConfigFileField = cfGetConfigFileField;
    function getSpaceGuidThrowIfUndefined() {
      return __awaiter(this, void 0, void 0, function* () {
        const space = getSpaceFieldGUID(yield cfGetConfigFileField("SpaceFields"));
        if (!space) {
          throw new Error(messages_1.messages.cf_setting_not_set);
        }
        return space;
      });
    }
    exports2.getSpaceGuidThrowIfUndefined = getSpaceGuidThrowIfUndefined;
    function padQuerySpace(query, otherFilters) {
      return __awaiter(this, void 0, void 0, function* () {
        query = padQuery(query, otherFilters);
        const filter = _45.find(query.filters, ["key", types_1.eFilters.space_guids]);
        if (!_45.size(filter === null || filter === void 0 ? void 0 : filter.value)) {
          query.filters = _45.concat(query.filters, [{ key: types_1.eFilters.space_guids, value: yield getSpaceGuidThrowIfUndefined() }]);
        }
        return query;
      });
    }
    exports2.padQuerySpace = padQuerySpace;
    function parseRawDictData(data2) {
      const result2 = {};
      _45.each(_45.compact(_45.split(data2, "\n")), (item) => {
        item = _45.replace(_45.trim(item), /^['"]|['"]$/g, "");
        const sep = _45.indexOf(item, ":");
        if (sep > -1) {
          const key = _45.toLower(_45.trim(_45.join(_45.slice(item, 0, sep), "")));
          const value = _45.trim(_45.join(_45.slice(item, sep + 1), ""));
          result2[`${key}`] = value;
        }
      });
      return result2;
    }
    exports2.parseRawDictData = parseRawDictData;
  }
});

// ../../node_modules/@sap/cf-tools/out/src/cf-local.js
var require_cf_local = __commonJS({
  "../../node_modules/@sap/cf-tools/out/src/cf-local.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.cfApi = exports2.cfGetApps = exports2.cfGetServiceInstancesList = exports2.cfGetInstanceKeyParameters = exports2.cfGetInstanceCredentials = exports2.cfGetServiceKeys = exports2.cfLogout = exports2.cfGetServicePlans = exports2.cfGetTarget = exports2.cfGetAuthToken = exports2.cfGetInstanceMetadata = exports2.cfBindLocalUps = exports2.cfBindLocalServices = exports2.cfGetSpaceServices = exports2.cfGetServices = exports2.cfGetTargets = exports2.cfSetOrgSpace = exports2.cfGetManagedServiceInstances = exports2.cfGetServiceInstances = exports2.cfGetServicePlansList = exports2.cfGetAvailableSpaces = exports2.cfGetAvailableOrgs = exports2.cfLogin = exports2.cfCreateUpsInstance = exports2.cfCreateService = exports2.cfGetUpsInstances = exports2.clearCacheServiceInstances = exports2.resolveEndpoint = void 0;
    var comment_json_1 = require_src5();
    var _45 = require_lodash();
    var cli_1 = require_cli();
    var messages_1 = require_messages();
    var types_1 = require_types2();
    var utils_1 = require_utils6();
    var url_1 = require("url");
    var baseParams = [
      types_1.eFilters.page,
      types_1.eFilters.per_page,
      types_1.eFilters.oder_by,
      types_1.eFilters.label_selector,
      types_1.eFilters.created_ats,
      types_1.eFilters.updated_ats
    ];
    var resourceServiceInstances = {
      name: "service_instances",
      params: _45.uniq(_45.concat(baseParams, [
        types_1.eFilters.names,
        types_1.eFilters.type,
        types_1.eFilters.space_guids,
        types_1.eFilters.organization_guids,
        types_1.eFilters.service_plan_guids,
        types_1.eFilters.service_plan,
        types_1.eFilters.service_plan_names
      ]))
    };
    var resourceOrganizations = {
      name: "organizations",
      params: _45.uniq(_45.concat(baseParams, [types_1.eFilters.names, types_1.eFilters.guids]))
    };
    var resourceSpaces = {
      name: "spaces",
      params: _45.uniq(_45.concat(baseParams, [types_1.eFilters.names, types_1.eFilters.guids, types_1.eFilters.organization_guids, types_1.eFilters.include]))
    };
    var resourceServicePlan = {
      name: "service_plan",
      params: _45.uniq(_45.concat(baseParams, [
        types_1.eFilters.names,
        types_1.eFilters.guids,
        types_1.eFilters.available,
        types_1.eFilters.broker_catalog_ids,
        types_1.eFilters.space_guids,
        types_1.eFilters.organization_guids,
        types_1.eFilters.service_broker_guids,
        types_1.eFilters.service_broker_names,
        types_1.eFilters.service_offering_guids,
        types_1.eFilters.service_offering_names,
        types_1.eFilters.service_instance_guids,
        types_1.eFilters.include
      ]))
    };
    var resourceServiceOfferings = {
      name: "service_offerings",
      params: _45.uniq(_45.concat(baseParams, [
        types_1.eFilters.names,
        types_1.eFilters.available,
        types_1.eFilters.service_broker_guids,
        types_1.eFilters.service_broker_names,
        types_1.eFilters.space_guids,
        types_1.eFilters.organization_guids
      ]))
    };
    var resourceServiceCredentialsBinding = {
      name: "service_credential_bindings",
      params: _45.uniq(_45.concat(baseParams, [
        types_1.eFilters.names,
        types_1.eFilters.guids,
        types_1.eFilters.include,
        types_1.eFilters.service_instance_guids,
        types_1.eFilters.broker_catalog_ids,
        types_1.eFilters.space_guids,
        types_1.eFilters.service_instance_names,
        types_1.eFilters.app_guids,
        types_1.eFilters.app_names,
        types_1.eFilters.service_plan_names,
        types_1.eFilters.service_offering_guids,
        types_1.eFilters.service_offering_names,
        types_1.eFilters.type
      ]))
    };
    var resourceApps = {
      name: "apps",
      params: _45.uniq(_45.concat(baseParams, [types_1.eFilters.names, types_1.eFilters.space_guids, types_1.eFilters.organization_guids, types_1.eFilters.guids, types_1.eFilters.include]))
    };
    function evaluateResponse(data2) {
      if (_45.size(_45.get(data2, "errors"))) {
        throw new Error(`${_45.get(data2, ["errors", "0", "detail"])} [code: ${_45.get(data2, ["errors", "0", "code"])} title: ${_45.get(data2, ["errors", "0", "title"])}]`);
      }
      return data2;
    }
    function resolveEndpoint(query) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          return /http/.test(new url_1.URL(query).protocol) ? _45.replace(query, (yield cfGetTarget(true))["api endpoint"], "") : query;
        } catch (e) {
          return query;
        }
      });
    }
    exports2.resolveEndpoint = resolveEndpoint;
    var cacheServiceInstanceTypes = {};
    function clearCacheServiceInstances() {
      cacheServiceInstanceTypes = {};
    }
    exports2.clearCacheServiceInstances = clearCacheServiceInstances;
    function evaluateQueryFilters(query, resource) {
      _45.each(query === null || query === void 0 ? void 0 : query.filters, (filter) => {
        if (!resource.params.includes(filter.key)) {
          throw new Error(messages_1.messages.not_allowed_filter(filter.key, resource.name));
        }
      });
    }
    var ENTITY_STATE_INPROGRESS = "in progress";
    var ENTITY_STATE_FAILED = "failed";
    function composeQuery(query) {
      query = (0, utils_1.ensureQuery)(query);
      function _generate_statement(filter) {
        const value = _45.get(filter, "value");
        if (value) {
          return filter.op === types_1.eOperation.fields ? `${filter.op}[${filter.key}]=${value}` : `${filter.key}` + (filter.op ? `[${filter.op}]` : ``) + `=${value}`;
        }
      }
      function _queryFilters(filters) {
        return _45.compact(_45.values(_45.map(filters, _generate_statement)));
      }
      function _queryParams(object) {
        return _45.compact(_45.map(_45.keys(object), (key) => {
          const value = _45.get(object, key);
          if (value) {
            return `${key}=${value}`;
          }
        }));
      }
      return _45.compact(_45.concat(_queryFilters(query.filters).join("&"), _queryParams(_45.omit(query, "filters")))).join("&");
    }
    function waitForEntity(resolve, reject, resource, attempt, maxNumberOfAttemps, jobFunction, progress) {
      if (_45.size(_45.get(resource, "errors"))) {
        reject(new Error(messages_1.messages.service_creation_failed(_45.get(resource, ["errors", "0", "detail"]))));
        return;
      }
      if (attempt < maxNumberOfAttemps) {
        if (progress.cancelToken.isCancellationRequested) {
          reject(new Error(messages_1.messages.create_service_canceled_by_requester));
          return;
        }
        const state = _45.get(resource, "last_operation.state", ENTITY_STATE_INPROGRESS);
        if (state === ENTITY_STATE_INPROGRESS) {
          progress.progress.report({ "message": `
${messages_1.messages.service_creation_started}`, increment: Math.floor(1 / maxNumberOfAttemps * 100) });
          setTimeout(() => {
            jobFunction().then((retriedResource) => {
              waitForEntity(resolve, reject, retriedResource, attempt + 1, maxNumberOfAttemps, jobFunction, progress);
            }).catch((error3) => {
              reject(error3);
            });
          }, 2e3);
        } else if (state === ENTITY_STATE_FAILED) {
          reject(new Error(messages_1.messages.failed_creating_entity(_45.get(resource, "last_operation.description"), (0, utils_1.getName)(resource))));
        } else {
          progress.progress.report({ "message": `
${messages_1.messages.service_creation_started}`, increment: 100 });
          resolve(resource);
        }
      } else {
        reject(new Error(messages_1.messages.exceed_number_of_attempts((0, utils_1.getName)(resource))));
      }
    }
    function execQuery(args, fncParse, reverseErrorOrder) {
      return __awaiter(this, void 0, void 0, function* () {
        const cliResult = yield cli_1.Cli.execute(args.query, args.options, args.token);
        if (cliResult.exitCode !== 0) {
          throw new Error(reverseErrorOrder ? cliResult.stdout || cliResult.stderr || cliResult.error : cliResult.error || cliResult.stderr || cliResult.stdout);
        }
        return fncParse ? yield fncParse(evaluateResponse((0, comment_json_1.parse)(cliResult.stdout))) : cliResult.stdout || cliResult.stderr;
      });
    }
    function execTotal(args, fncParse) {
      return __awaiter(this, void 0, void 0, function* () {
        const collection = [];
        let query = args.query;
        while (query) {
          const result2 = (0, comment_json_1.parse)(yield execQuery({ query: ["curl", yield resolveEndpoint(query)], options: args.options, token: args.token }));
          for (const resource of _45.get(result2, "resources", [])) {
            collection.push(fncParse ? yield fncParse(resource, _45.get(result2, "included")) : resource);
          }
          query = _45.get(result2, ["pagination", "next", "href"]);
        }
        return _45.compact(collection);
      });
    }
    function getServiceInstance(query, token2) {
      return __awaiter(this, void 0, void 0, function* () {
        evaluateQueryFilters(query, resourceServiceInstances);
        query = yield (0, utils_1.padQuerySpace)(query, [{ key: types_1.eFilters.type, value: types_1.eServiceTypes.managed }]);
        const result2 = yield execTotal({ query: `/v3/service_instances?${composeQuery(query)}`, token: token2 });
        if (_45.size(result2) >= 1) {
          return _45.head(result2);
        }
        throw new Error(messages_1.messages.service_not_found(decodeURIComponent(_45.get(_45.find(query.filters, ["key", types_1.eFilters.names]), "value")) || "unknown"));
      });
    }
    function getUpsCredentials(instanceGuid, token2) {
      return __awaiter(this, void 0, void 0, function* () {
        return execQuery({ query: ["curl", `/v3/service_instances/${instanceGuid}/credentials`], token: token2 }, (data2) => data2);
      });
    }
    function resolveCfResource(data2, service) {
      return _45.merge({
        name: (0, utils_1.getName)(data2),
        guid: (0, utils_1.getGuid)(data2),
        description: (0, utils_1.getDescription)(data2)
      }, service ? {
        service_offering: {
          guid: (0, utils_1.getGuid)(service),
          description: (0, utils_1.getDescription)(service),
          name: (0, utils_1.getName)(service)
        }
      } : {});
    }
    function getCachedServicePlan(plan) {
      if (!cacheServiceInstanceTypes[plan.guid]) {
        cacheServiceInstanceTypes[plan.guid] = execQuery({ query: ["curl", `/v3/service_plans/${plan.guid}?include=service_offering`] }, (data2) => {
          return Promise.resolve(resolveCfResource(data2, _45.find(_45.get(data2, ["included", "service_offerings"]), ["guid", _45.get(data2, ["relationships", "service_offering", "data", "guid"])])));
        });
      }
      return cacheServiceInstanceTypes[plan.guid];
    }
    function getServiceInstanceItem(item) {
      const planGuid = _45.get(item, ["relationships", "service_plan", "data", "guid"]);
      return Promise.resolve({
        guid: (0, utils_1.getGuid)(item),
        label: (0, utils_1.getName)(item),
        tags: (0, utils_1.getTags)(item),
        serviceName: (0, utils_1.isUpsType)(item) ? Promise.resolve({ service_offering: { name: types_1.eServiceTypes.user_provided }, name: "" }) : getCachedServicePlan({ guid: planGuid }).then((plan) => plan).catch(() => {
          return {};
        }),
        plan_guid: planGuid,
        credentials: (0, utils_1.isUpsType)(item) ? getUpsCredentials((0, utils_1.getGuid)(item)).then((data2) => data2).catch(() => {
          return {};
        }) : Promise.resolve()
      });
    }
    function resolveServiceInstances(results) {
      return __awaiter(this, void 0, void 0, function* () {
        const queries = _45.concat(_45.map(results, "serviceName"), _45.map(results, "credentials"));
        if (!_45.size(queries)) {
          return [];
        }
        return Promise.all(queries).then(() => __awaiter(this, void 0, void 0, function* () {
          const instances = [];
          for (const result2 of results) {
            const serviceName = yield _45.get(result2, "serviceName");
            instances.push({
              guid: (0, utils_1.getGuid)(result2),
              label: (0, utils_1.getLabel)(result2),
              serviceName: _45.get(serviceName, ["service_offering", "name"], "unknown"),
              plan_guid: _45.get(result2, "plan_guid"),
              plan: _45.get(serviceName, "name", "unknown"),
              tags: _45.get(result2, "tags"),
              credentials: yield result2.credentials
            });
          }
          return _45.compact(instances);
        }));
      });
    }
    function cfGetUpsInstances(query, token2) {
      return __awaiter(this, void 0, void 0, function* () {
        evaluateQueryFilters(query, resourceServiceInstances);
        query = yield (0, utils_1.padQuerySpace)(query, [{ key: types_1.eFilters.type, value: types_1.eServiceTypes.user_provided }]);
        return resolveServiceInstances(yield execTotal({ query: `/v3/service_instances?${composeQuery(query)}`, token: token2 }, (info) => __awaiter(this, void 0, void 0, function* () {
          return getServiceInstanceItem(info);
        })));
      });
    }
    exports2.cfGetUpsInstances = cfGetUpsInstances;
    function cfCreateService(planGuid, instanceName, params, tags, progress, maxNumberOfAttemps) {
      return __awaiter(this, void 0, void 0, function* () {
        const spaceGuid = yield (0, utils_1.getSpaceGuidThrowIfUndefined)();
        maxNumberOfAttemps = _45.isNil(maxNumberOfAttemps) ? 45 : maxNumberOfAttemps;
        progress = _45.defaults(progress, { progress: { report: () => "" } }, { cancelToken: { isCancellationRequested: false, onCancellationRequested: () => "" } });
        const request = {
          type: types_1.eServiceTypes.managed,
          name: instanceName,
          relationships: {
            space: { data: { guid: spaceGuid } },
            service_plan: { data: { guid: planGuid } }
          },
          parameters: params,
          tags
        };
        const result2 = yield execQuery({ query: ["curl", "/v3/service_instances", "-d", (0, comment_json_1.stringify)(request), "-X", "POST"], token: progress.cancelToken });
        progress.progress.report({ "message": `
${messages_1.messages.service_creation_started}`, increment: 1 });
        const query = { filters: [{ key: types_1.eFilters.names, value: encodeURIComponent(instanceName) }, { key: types_1.eFilters.space_guids, value: spaceGuid }] };
        return new Promise((resolve, reject) => {
          waitForEntity(resolve, reject, !_45.isEmpty(_45.replace(result2, "\n", "")) ? (0, comment_json_1.parse)(result2) : result2, 0, maxNumberOfAttemps, () => getServiceInstance(query, progress.cancelToken), progress);
        });
      });
    }
    exports2.cfCreateService = cfCreateService;
    function cfCreateUpsInstance(info) {
      return __awaiter(this, void 0, void 0, function* () {
        let spaceGuid = info.space_guid;
        if (!spaceGuid) {
          spaceGuid = yield (0, utils_1.getSpaceGuidThrowIfUndefined)();
        }
        return evaluateResponse((0, comment_json_1.parse)(yield execQuery({
          query: ["curl", `/v3/service_instances`, "-d", (0, comment_json_1.stringify)(_45.merge({
            name: info.instanceName,
            type: types_1.eServiceTypes.user_provided,
            relationships: { space: { data: { guid: spaceGuid } } }
          }, info.credentials ? { "credentials": info.credentials } : {}, info.route_service_url ? { "route_service_url": info.route_service_url } : {}, info.syslog_drain_url ? { "syslog_drain_url": info.syslog_drain_url } : {}, info.tags ? { "tags": info.tags } : {})), "-X", "POST"]
        })));
      });
    }
    exports2.cfCreateUpsInstance = cfCreateUpsInstance;
    function cfLogin(endpoint, user, pwd) {
      return __awaiter(this, void 0, void 0, function* () {
        let result2;
        try {
          result2 = yield execQuery({ query: ["login", "-a", endpoint, "-u", user, "-p", pwd, "-o", "no-org-for-now", "-s", "no-space-for-now"], options: { env: { "CF_COLOR": "false" } } }, void 0, true);
        } catch (e) {
          result2 = _45.get(e, "message", "");
        }
        return result2.includes(`Authenticating...${types_1.NEW_LINE}${types_1.OK}`) ? types_1.OK : result2;
      });
    }
    exports2.cfLogin = cfLogin;
    function cfGetAvailableOrgs(query) {
      return __awaiter(this, void 0, void 0, function* () {
        evaluateQueryFilters(query, resourceOrganizations);
        return execTotal({ query: `/v3/organizations?${composeQuery(query)}` }, (resource) => {
          return Promise.resolve({ label: (0, utils_1.getName)(resource), guid: (0, utils_1.getGuid)(resource) });
        });
      });
    }
    exports2.cfGetAvailableOrgs = cfGetAvailableOrgs;
    function cfGetAvailableSpaces(orgGuid) {
      return __awaiter(this, void 0, void 0, function* () {
        const query = (0, utils_1.ensureQuery)();
        if (orgGuid) {
          _45.merge(query.filters, [{ key: types_1.eFilters.organization_guids, value: orgGuid }]);
        }
        evaluateQueryFilters(query, resourceSpaces);
        return execTotal({ query: `/v3/spaces?${composeQuery(query)}` }, (resource) => {
          return Promise.resolve({
            label: (0, utils_1.getName)(resource),
            guid: (0, utils_1.getGuid)(resource),
            orgGUID: (0, utils_1.getOrgGUID)(resource)
          });
        });
      });
    }
    exports2.cfGetAvailableSpaces = cfGetAvailableSpaces;
    function resolvePlanInfo(data2, service) {
      return _45.merge({
        label: (0, utils_1.getName)(data2),
        guid: (0, utils_1.getGuid)(data2),
        description: (0, utils_1.getDescription)(data2)
      }, service ? {
        service_offering: {
          guid: (0, utils_1.getGuid)(service),
          description: (0, utils_1.getDescription)(service),
          name: (0, utils_1.getName)(service)
        }
      } : {});
    }
    function cfGetServicePlansList(query, token2) {
      return __awaiter(this, void 0, void 0, function* () {
        query = yield (0, utils_1.padQuerySpace)(query, [{ key: types_1.eFilters.include, value: "service_offering" }]);
        evaluateQueryFilters(query, resourceServicePlan);
        return execTotal({ query: `/v3/service_plans?${composeQuery(query)}`, token: token2 }, (data2, included) => {
          return Promise.resolve(resolvePlanInfo(data2, _45.find(_45.get(included, "service_offerings"), ["guid", _45.get(data2, ["relationships", "service_offering", "data", "guid"])])));
        });
      });
    }
    exports2.cfGetServicePlansList = cfGetServicePlansList;
    function cfGetServiceInstances(query, token2) {
      return __awaiter(this, void 0, void 0, function* () {
        query = yield (0, utils_1.padQuerySpace)(query, [
          { key: types_1.eFilters.service_plan, value: "guid,name", op: types_1.eOperation.fields },
          { key: types_1.eFilters.type, value: types_1.eServiceTypes.managed }
        ]);
        evaluateQueryFilters(query, resourceServiceInstances);
        return resolveServiceInstances(yield execTotal({ query: `/v3/service_instances?${composeQuery(query)}`, token: token2 }, (info) => getServiceInstanceItem(info)));
      });
    }
    exports2.cfGetServiceInstances = cfGetServiceInstances;
    function cfGetManagedServiceInstances(query, token2) {
      return __awaiter(this, void 0, void 0, function* () {
        return cfGetServiceInstances(query, token2);
      });
    }
    exports2.cfGetManagedServiceInstances = cfGetManagedServiceInstances;
    function cfSetOrgSpace(org, space) {
      return __awaiter(this, void 0, void 0, function* () {
        yield execQuery({ query: _45.concat(["target", "-o", org], space ? ["-s", space] : []) });
        clearCacheServiceInstances();
        void cfGetManagedServiceInstances();
      });
    }
    exports2.cfSetOrgSpace = cfSetOrgSpace;
    function cfGetTargets() {
      return __awaiter(this, void 0, void 0, function* () {
        const targets = yield execQuery({ query: ["targets"] });
        if (_45.includes(targets, "No targets have been saved yet") || _45.includes(targets, "is not a registered command")) {
          return [{ label: types_1.DEFAULT_TARGET, isCurrent: true, isDirty: false }];
        }
        const targetSubstrings = _45.compact(_45.map(targets.split(types_1.NEW_LINE), (targetSubstring) => targetSubstring.trim()));
        return _45.map(targetSubstrings, (targetSubstring) => {
          const parentthesisPos = targetSubstring.indexOf("(current");
          if (parentthesisPos > 0) {
            targetSubstring = targetSubstring.substring(0, parentthesisPos);
            return { label: targetSubstring.trim(), isCurrent: true, isDirty: targetSubstring.includes("modified") };
          }
          return { label: targetSubstring, isCurrent: false, isDirty: false };
        });
      });
    }
    exports2.cfGetTargets = cfGetTargets;
    function cfGetServices(query, cancellationToken) {
      return __awaiter(this, void 0, void 0, function* () {
        evaluateQueryFilters(query, resourceServiceOfferings);
        return execTotal({ query: `/v3/service_offerings?${composeQuery(yield (0, utils_1.padQuerySpace)(query))}`, token: cancellationToken }, (service) => {
          return Promise.resolve({
            label: (0, utils_1.getName)(service),
            service_plans_url: _45.get(service, ["links", "service_plans", "href"]),
            guid: (0, utils_1.getGuid)(service),
            description: (0, utils_1.getDescription)(service)
          });
        });
      });
    }
    exports2.cfGetServices = cfGetServices;
    function cfGetSpaceServices(query, spaceGUID, cancellationToken) {
      return __awaiter(this, void 0, void 0, function* () {
        return cfGetServices((0, utils_1.padQuery)(query, [{ key: types_1.eFilters.space_guids, value: spaceGUID }]), cancellationToken);
      });
    }
    exports2.cfGetSpaceServices = cfGetSpaceServices;
    function cfBindLocalServices(filePath, instanceNames, tags, serviceKeyNames, serviceKeyParams) {
      return __awaiter(this, void 0, void 0, function* () {
        yield execQuery({
          query: [
            "bind-local",
            "-path",
            filePath,
            "-service-names",
            ...instanceNames,
            ..._45.size(tags) ? _45.concat(["-tags"], tags) : [],
            ..._45.size(serviceKeyNames) ? _45.concat(["-service-keys"], serviceKeyNames) : [],
            ..._45.size(serviceKeyParams) ? _45.concat(["-params"], _45.map(serviceKeyParams, (param) => {
              return (0, comment_json_1.stringify)(param);
            })) : []
          ]
        });
      });
    }
    exports2.cfBindLocalServices = cfBindLocalServices;
    function cfBindLocalUps(filePath, instanceNames, tags) {
      return __awaiter(this, void 0, void 0, function* () {
        yield execQuery({
          query: _45.concat(["bind-local-ups", "-path", filePath], _45.reduce(instanceNames, (result2, instanceName) => {
            result2 = _45.concat(result2, [`-service-names`, `${instanceName}`]);
            return result2;
          }, []), _45.reduce(tags, (result2, tag) => {
            result2 = _45.concat(result2, [`-tags`, `${tag}`]);
            return result2;
          }, []))
        });
      });
    }
    exports2.cfBindLocalUps = cfBindLocalUps;
    function cfGetInstanceMetadata(instanceName) {
      return __awaiter(this, void 0, void 0, function* () {
        const result2 = yield cfGetServiceInstances(yield (0, utils_1.padQuerySpace)({
          filters: [
            { key: types_1.eFilters.names, value: encodeURIComponent(instanceName) },
            { key: types_1.eFilters.type, value: types_1.eServiceTypes.managed }
          ]
        }));
        if (!_45.size(result2)) {
          throw new Error(messages_1.messages.service_not_found(instanceName));
        }
        const serviceInstance = _45.head(result2);
        return {
          serviceName: (0, utils_1.getLabel)(serviceInstance),
          plan: _45.get(serviceInstance, "plan"),
          plan_guid: _45.get(serviceInstance, "plan_guid"),
          service: _45.get(serviceInstance, "serviceName")
        };
      });
    }
    exports2.cfGetInstanceMetadata = cfGetInstanceMetadata;
    function cfGetAuthToken() {
      return __awaiter(this, void 0, void 0, function* () {
        return yield execQuery({ query: ["oauth-token"] });
      });
    }
    exports2.cfGetAuthToken = cfGetAuthToken;
    function cfGetTarget(weak) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!weak) {
          yield cfGetAuthToken();
        }
        return (0, utils_1.parseRawDictData)(yield execQuery({ query: ["target"], options: { env: { "CF_COLOR": "false" } } }));
      });
    }
    exports2.cfGetTarget = cfGetTarget;
    function cfGetServicePlans(servicePlansUrl) {
      return __awaiter(this, void 0, void 0, function* () {
        return execTotal({ query: servicePlansUrl }, (data2) => {
          return Promise.resolve({ label: (0, utils_1.getName)(data2), guid: (0, utils_1.getGuid)(data2), description: (0, utils_1.getDescription)(data2) });
        });
      });
    }
    exports2.cfGetServicePlans = cfGetServicePlans;
    function cfLogout() {
      return __awaiter(this, void 0, void 0, function* () {
        yield execQuery({ query: ["logout"] });
      });
    }
    exports2.cfLogout = cfLogout;
    function cfGetServiceKeys(query, token2) {
      return __awaiter(this, void 0, void 0, function* () {
        evaluateQueryFilters(query, resourceServiceCredentialsBinding);
        return execTotal({ query: `/v3/service_credential_bindings?${composeQuery((0, utils_1.padQuery)(query, [{ key: types_1.eFilters.type, value: "key" }]))}`, token: token2 });
      });
    }
    exports2.cfGetServiceKeys = cfGetServiceKeys;
    function cfGetInstanceCredentials(query, token2) {
      return __awaiter(this, void 0, void 0, function* () {
        const results = _45.map(yield cfGetServiceKeys(query, token2), (resource) => {
          return execQuery({ query: ["curl", `/v3/service_credential_bindings/${(0, utils_1.getGuid)(resource)}/details`], token: token2 }, (data2) => data2).then((data2) => data2).catch(() => {
            return {};
          });
        });
        return Promise.all(_45.compact(results));
      });
    }
    exports2.cfGetInstanceCredentials = cfGetInstanceCredentials;
    function cfGetInstanceKeyParameters(instanceName) {
      return __awaiter(this, void 0, void 0, function* () {
        const instance = yield getServiceInstance({ filters: [{ key: types_1.eFilters.names, value: encodeURIComponent(instanceName) }] });
        const query = { filters: [{ key: types_1.eFilters.service_instance_guids, value: (0, utils_1.getGuid)(instance) }] };
        let keys = yield cfGetServiceKeys(query);
        if (!_45.size(keys)) {
          yield cli_1.Cli.execute(["create-service-key", encodeURIComponent(instanceName), "key"]);
          keys = yield cfGetServiceKeys((0, utils_1.padQuery)(query, [{ key: types_1.eFilters.names, value: "key" }]));
        }
        return execQuery({ query: ["curl", `/v3/service_credential_bindings/${(0, utils_1.getGuid)(_45.head(keys))}/details`] }, (data2) => data2).then((data2) => data2).catch(() => {
          return {};
        });
      });
    }
    exports2.cfGetInstanceKeyParameters = cfGetInstanceKeyParameters;
    function cfGetServiceInstancesList(query, token2) {
      return __awaiter(this, void 0, void 0, function* () {
        query = yield (0, utils_1.padQuerySpace)(query, [{ key: types_1.eFilters.service_plan, value: "guid,name", op: types_1.eOperation.fields }]);
        evaluateQueryFilters(query, resourceServiceInstances);
        return resolveServiceInstances(yield execTotal({ query: `/v3/service_instances?${composeQuery(query)}`, token: token2 }, (info) => getServiceInstanceItem(info)));
      });
    }
    exports2.cfGetServiceInstancesList = cfGetServiceInstancesList;
    function cfGetApps(query, token2) {
      return __awaiter(this, void 0, void 0, function* () {
        evaluateQueryFilters(query, resourceApps);
        return execTotal({ query: `/v3/apps?${composeQuery(yield (0, utils_1.padQuerySpace)(query))}`, token: token2 });
      });
    }
    exports2.cfGetApps = cfGetApps;
    function cfApi(params) {
      return __awaiter(this, void 0, void 0, function* () {
        const query = ["api"];
        if (params === null || params === void 0 ? void 0 : params.url) {
          query.push(params.url);
        }
        if (params === null || params === void 0 ? void 0 : params.skip_ssl_validation) {
          query.push("--skip-ssl-validation");
        }
        if (params === null || params === void 0 ? void 0 : params.unset) {
          query.push("--unset");
        }
        return (0, utils_1.parseRawDictData)(yield execQuery({ query: [...query] }));
      });
    }
    exports2.cfApi = cfApi;
  }
});

// ../../node_modules/@sap/cf-tools/out/src/cfServicesUtil.js
var require_cfServicesUtil = __commonJS({
  "../../node_modules/@sap/cf-tools/out/src/cfServicesUtil.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isTargetSet = exports2.getInstanceMetadata = exports2.createServiceInstance = exports2.getInstanceCredentials = exports2.getServicesInstancesFilteredByType = void 0;
    var cli_1 = require_cli();
    var _45 = require_lodash();
    var types_1 = require_types2();
    var cf_local_1 = require_cf_local();
    function getServicesInstancesFilteredByType(serviceTypes) {
      return __awaiter(this, void 0, void 0, function* () {
        const guids = _45.map(yield (0, cf_local_1.cfGetServicePlansList)({ filters: [{ key: types_1.eFilters.service_offering_names, value: _45.join(_45.map(serviceTypes, encodeURIComponent)) }] }), "guid");
        return _45.size(guids) ? (0, cf_local_1.cfGetManagedServiceInstances)({ "filters": [{ key: types_1.eFilters.service_plan_guids, value: _45.join(guids) }] }) : [];
      });
    }
    exports2.getServicesInstancesFilteredByType = getServicesInstancesFilteredByType;
    function getInstanceCredentials(instanceName) {
      return (0, cf_local_1.cfGetInstanceKeyParameters)(instanceName);
    }
    exports2.getInstanceCredentials = getInstanceCredentials;
    function createServiceInstance(serviceType, servicePlan, serviceInstanceName, config) {
      let args = ["create-service", serviceType, servicePlan, serviceInstanceName];
      if (config) {
        args = args.concat(["-c", config]);
      }
      return cli_1.Cli.execute(args);
    }
    exports2.createServiceInstance = createServiceInstance;
    function getInstanceMetadata(instanceName) {
      return (0, cf_local_1.cfGetInstanceMetadata)(instanceName);
    }
    exports2.getInstanceMetadata = getInstanceMetadata;
    function isTargetSet() {
      return __awaiter(this, void 0, void 0, function* () {
        const target = yield (0, cf_local_1.cfGetTarget)();
        return !_45.isEmpty(target.org) && !_45.isEmpty(target.space);
      });
    }
    exports2.isTargetSet = isTargetSet;
  }
});

// ../../node_modules/@sap/cf-tools/out/src/index.js
var require_src6 = __commonJS({
  "../../node_modules/@sap/cf-tools/out/src/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.apiGetInstanceMetadata = exports2.apiCreateServiceInstance = exports2.apiGetInstanceCredentials = exports2.apiGetServicesInstancesFilteredByType = void 0;
    __exportStar(require_types2(), exports2);
    __exportStar(require_cli(), exports2);
    __exportStar(require_cf_local(), exports2);
    __exportStar(require_messages(), exports2);
    __exportStar(require_utils6(), exports2);
    var serviceUtils = require_cfServicesUtil();
    function apiGetServicesInstancesFilteredByType(serviceTypes) {
      return __awaiter(this, void 0, void 0, function* () {
        return serviceUtils.getServicesInstancesFilteredByType(serviceTypes);
      });
    }
    exports2.apiGetServicesInstancesFilteredByType = apiGetServicesInstancesFilteredByType;
    function apiGetInstanceCredentials(instanceName) {
      return __awaiter(this, void 0, void 0, function* () {
        return serviceUtils.getInstanceCredentials(instanceName);
      });
    }
    exports2.apiGetInstanceCredentials = apiGetInstanceCredentials;
    function apiCreateServiceInstance(serviceType, servicePlan, instanceName, config) {
      return __awaiter(this, void 0, void 0, function* () {
        return serviceUtils.createServiceInstance(serviceType, servicePlan, instanceName, config);
      });
    }
    exports2.apiCreateServiceInstance = apiCreateServiceInstance;
    function apiGetInstanceMetadata(instanceName) {
      return __awaiter(this, void 0, void 0, function* () {
        return serviceUtils.getInstanceMetadata(instanceName);
      });
    }
    exports2.apiGetInstanceMetadata = apiGetInstanceMetadata;
  }
});

// ../lib/odata-client/dist/connection/destination.js
var require_destination = __commonJS({
  "../lib/odata-client/dist/connection/destination.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.updateSystemConfig = exports2.replaceUrlForAppStudio = exports2.listDestinations = void 0;
    var axios_1 = __importDefault(require_axios2());
    var config_1 = require_config();
    var ux_common_utils_1 = require_dist();
    var cf_tools_1 = require_src6();
    var DEST = ".dest";
    async function fetchDestinations() {
      var _a2;
      const destinations = {};
      await axios_1.default.get(ux_common_utils_1.getAppStudioProxyURL() + "/reload");
      const response = await axios_1.default.get(ux_common_utils_1.getAppStudioBaseURL() + "/api/listDestinations");
      (_a2 = response == null ? void 0 : response.data) == null ? void 0 : _a2.forEach((destination) => {
        if (destination.WebIDEEnabled) {
          destinations[destination.Name] = destination;
        }
      });
      return destinations;
    }
    async function getAuthHeaderForInstanceBasedDest(destinationInstance) {
      var _a2, _b;
      try {
        const credentials = (await cf_tools_1.apiGetInstanceCredentials(destinationInstance)).credentials;
        const clientId = ((_a2 = credentials.uaa) == null ? void 0 : _a2.clientid) || credentials.clientid;
        const clientSecret = ((_b = credentials.uaa) == null ? void 0 : _b.clientsecret) || credentials.clientsecret;
        return Buffer.from(`${encodeURIComponent(clientId)}:${encodeURIComponent(clientSecret)}`).toString("base64");
      } catch (error3) {
        throw new Error(`An error occurred while retrieving service key for the destination instance ${destinationInstance}: ${error3}`);
      }
    }
    async function listDestinations() {
      if (ux_common_utils_1.isAppStudio()) {
        return fetchDestinations();
      } else {
        return {};
      }
    }
    exports2.listDestinations = listDestinations;
    async function replaceUrlForAppStudio(systemConfig, destinationName, destinationInstance) {
      var _a2, _b;
      systemConfig.originalUrl = systemConfig.url;
      if (destinationName && destinationInstance) {
        systemConfig.url = `https://${destinationName}${DEST}`;
        systemConfig.basDestinationInstanceCred = await getAuthHeaderForInstanceBasedDest(destinationInstance);
      } else {
        systemConfig.url = ux_common_utils_1.getAppStudioBaseURL();
        systemConfig.service = `/destinations/${destinationName != null ? destinationName : systemConfig.destination}${(_b = (_a2 = systemConfig.service) == null ? void 0 : _a2.replace(/^\/?/, "/")) != null ? _b : ""}`;
      }
      delete systemConfig.scp;
      delete systemConfig.client;
    }
    exports2.replaceUrlForAppStudio = replaceUrlForAppStudio;
    async function updateSystemConfig(system) {
      if (ux_common_utils_1.isAppStudio() && system.destination) {
        if (system.destinationInstance) {
          await replaceUrlForAppStudio(system, system.destination, system.destinationInstance);
        } else {
          const destinations = await fetchDestinations();
          if (destinations[system.destination]) {
            const dest = destinations[system.destination];
            system.destinationAuthType = dest.Authentication;
            if (config_1.hasFullUrlDestAttribute({
              ["WebIDEAdditionalData"]: dest["WebIDEAdditionalData"]
            })) {
              system.isDestinationFullUrl = true;
              system.destinationServiceUrl = new URL(dest.Host).pathname;
            }
            if (system.isDestinationFullUrl) {
              delete system.service;
            }
            await replaceUrlForAppStudio(system, dest.Name);
          }
        }
      }
    }
    exports2.updateSystemConfig = updateSystemConfig;
  }
});

// ../lib/odata-client/dist/connection/index.js
var require_connection = __commonJS({
  "../lib/odata-client/dist/connection/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Cookies = exports2.connect = exports2.SAP_CLIENT = void 0;
    var axios_1 = __importDefault(require_axios2());
    var cookies_1 = require_cookies2();
    Object.defineProperty(exports2, "Cookies", { enumerable: true, get: function() {
      return cookies_1.Cookies;
    } });
    var config_1 = require_config();
    var ux_common_utils_1 = require_dist();
    var uaaOauth_1 = require_uaaOauth();
    var https_1 = __importDefault(require("https"));
    var url_1 = require("url");
    var common_1 = require_common3();
    var connectWithReentranceTicket_1 = require_connectWithReentranceTicket();
    var detect_content_type_1 = __importDefault(require_lib2());
    exports2.SAP_CLIENT = "sap-client";
    async function connectWithBasicAuth({ target, credentials, autoAddTrailingSlash = true, timeout, ignoreCertError = false, logger = console }) {
      var _a2;
      const url = new url_1.URL(target.service, target.url).toString();
      const hasCredentials = !!((_a2 = credentials == null ? void 0 : credentials.username) == null ? void 0 : _a2.length);
      const config = {
        params: {},
        headers: {
          [common_1.CSRF.requestHeaderName]: common_1.CSRF.requestHeaderValue
        },
        withCredentials: hasCredentials,
        httpsAgent: new https_1.default.Agent({
          rejectUnauthorized: !ignoreCertError
        })
      };
      if (hasCredentials) {
        config.auth = credentials;
      }
      if (typeof timeout === "number" && timeout > 0) {
        const CancelToken = axios_1.default.CancelToken;
        const source = CancelToken.source();
        setTimeout(() => {
          source.cancel("CONNECT_TIMEOUT");
        }, timeout);
        config.cancelToken = source.token;
      }
      if (target.params) {
        Object.assign(config.params, target.params);
      }
      if (target.client) {
        config.params[exports2.SAP_CLIENT] = target.client;
      }
      const isTargetDestOnAppStudio = ux_common_utils_1.isAppStudio() && target.destination;
      if (isTargetDestOnAppStudio) {
        config.params.saml2 = "disabled";
      }
      const urlPath = !(url == null ? void 0 : url.endsWith("/")) && autoAddTrailingSlash ? `${url}/` : url;
      if ((config == null ? void 0 : config.auth) && Object.keys(config.auth).length > 0) {
        config.withCredentials = true;
      } else {
        delete config.auth;
        config.withCredentials = false;
      }
      let response = await axios_1.default.get(urlPath, config);
      if (!isTargetDestOnAppStudio && isSamlLogonNeeded(response)) {
        logger.warn("Disabling SAML2. Falling back to basic authentication");
        config.params.saml2 = "disabled";
        response = await axios_1.default.get(urlPath, config);
      }
      throwIfHtmlLoginForm(response);
      return {
        auth: config.auth,
        cookies: new cookies_1.Cookies().setCookie(response),
        xsrfToken: response.headers[common_1.CSRF.responseHeaderName]
      };
    }
    function throwIfHtmlLoginForm(response) {
      if ((response == null ? void 0 : response.status) !== 200) {
        return;
      }
      if (response.headers["sap-err-id"] === "ICFLOGONREQUIRED" || isHtmlLoginForm(response)) {
        const err = new Error();
        err.response = { status: 401 };
        err.isAxiosError = true;
        err.toJSON = () => {
          return { status: 401 };
        };
        throw err;
      }
    }
    function isHtmlResponse(response) {
      return getContentType(response.headers["content-type"], response.data).startsWith("text/html");
    }
    function isHtmlLoginForm(response) {
      return isHtmlResponse(response) && typeof response.data === "string" && !!response.data.match(/log[io]n/i);
    }
    function getContentType(contentTypeHeader, responseData) {
      var _a2, _b;
      if (contentTypeHeader) {
        return contentTypeHeader.toLowerCase();
      } else if (typeof responseData === "string") {
        return (_b = (_a2 = detect_content_type_1.default(Buffer.from(responseData))) == null ? void 0 : _a2.toLowerCase()) != null ? _b : "";
      } else {
        return "";
      }
    }
    function isSamlLogonNeeded(response) {
      return (response == null ? void 0 : response.status) === 200 && isHtmlResponse(response) && typeof response.data === "string" && !!response.data.match(/saml/i);
    }
    async function connect({ target, credentials, log: log4, autoAddTrailingSlash = true, timeout, ignoreCertError = false, postConnectionCallback }) {
      const targetAuthType = target.authenticationType;
      if (targetAuthType === config_1.AuthenticationType.OAuth2RefreshToken) {
        return uaaOauth_1.connectUsingUaa({ target, credentials, log: log4, postConnectionCallback });
      } else if (targetAuthType === config_1.AuthenticationType.OAuth2ClientCredential) {
        return uaaOauth_1.connectUsingUaaClientCredential({ target, credentials, log: log4 });
      } else if (targetAuthType === config_1.AuthenticationType.ReentranceTicket) {
        return connectWithReentranceTicket_1.connectWithReentranceTicket({ target, logger: log4, ignoreCertError });
      } else {
        return connectWithBasicAuth({
          target,
          credentials,
          autoAddTrailingSlash,
          timeout,
          ignoreCertError,
          logger: log4
        });
      }
    }
    exports2.connect = connect;
    __exportStar(require_destination(), exports2);
    __exportStar(require_error2(), exports2);
  }
});

// ../lib/odata-client/dist/client/httpClient.js
var require_httpClient = __commonJS({
  "../lib/odata-client/dist/client/httpClient.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.newHttpClient = void 0;
    var axios_1 = __importDefault(require_axios2());
    var connection_1 = require_connection();
    var https_1 = __importDefault(require("https"));
    var url_1 = require("url");
    async function newHttpClient({ system, credentials, log: log4, existingConnection, autoAddTrailingSlash = true, timeout, ignoreCertError, postConnectionCallback }) {
      const connection = existingConnection || await connection_1.connect({
        target: system,
        credentials,
        log: log4,
        autoAddTrailingSlash,
        timeout,
        ignoreCertError,
        postConnectionCallback
      });
      const headers = {
        Cookie: connection.cookies.toString()
      };
      if (connection.xsrfToken) {
        headers["x-csrf-token"] = connection.xsrfToken;
      }
      const config = {
        baseURL: new url_1.URL(system.service, system.url).toString(),
        headers,
        withCredentials: true,
        httpsAgent: new https_1.default.Agent({
          rejectUnauthorized: !ignoreCertError
        })
      };
      if (connection == null ? void 0 : connection.auth) {
        config.auth = connection.auth;
      }
      axios_1.default.defaults.headers.common["Accept"] = "application/json,application/xml,text/plain,*/*";
      const httpClient = axios_1.default.create(config);
      return { connection, httpClient };
    }
    exports2.newHttpClient = newHttpClient;
  }
});

// ../../node_modules/color-name/index.js
var require_color_name = __commonJS({
  "../../node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// ../../node_modules/ansi-styles/node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "../../node_modules/ansi-styles/node_modules/color-convert/conversions.js"(exports2, module2) {
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    var convert = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    module2.exports = convert;
    for (const model of Object.keys(convert)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert[model];
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", { value: channels });
      Object.defineProperty(convert[model], "labels", { value: labels });
    }
    convert.rgb.hsl = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const min = Math.min(r, g, b);
      const max = Math.max(r, g, b);
      const delta = max - min;
      let h;
      let s;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      const l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h;
      let s;
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const v = Math.max(r, g, b);
      const diff = v - Math.min(r, g, b);
      const diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = 0;
        s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      const r = rgb[0];
      const g = rgb[1];
      let b = rgb[2];
      const h = convert.rgb.hsl(rgb)[0];
      const w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const k = Math.min(1 - r, 1 - g, 1 - b);
      const c = (1 - r - k) / (1 - k) || 0;
      const m = (1 - g - k) / (1 - k) || 0;
      const y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
    }
    convert.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      let r = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b = rgb[2] / 255;
      r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
      g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
      const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      const xyz = convert.rgb.xyz(rgb);
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      const h = hsl[0] / 360;
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      let t2;
      let t3;
      let val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      const t1 = 2 * l - t2;
      const rgb = [0, 0, 0];
      for (let i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      const h = hsl[0];
      let s = hsl[1] / 100;
      let l = hsl[2] / 100;
      let smin = s;
      const lmin = Math.max(l, 0.01);
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v = (l + s) / 2;
      const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      const h = hsv[0] / 60;
      const s = hsv[1] / 100;
      let v = hsv[2] / 100;
      const hi = Math.floor(h) % 6;
      const f = h - Math.floor(h);
      const p = 255 * v * (1 - s);
      const q = 255 * v * (1 - s * f);
      const t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      const h = hsv[0];
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const vmin = Math.max(v, 0.01);
      let sl;
      let l;
      l = (2 - s) * v;
      const lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      const h = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i = Math.floor(6 * h);
      const v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      const n = wh + f * (v - wh);
      let r;
      let g;
      let b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      const c = cmyk[0] / 100;
      const m = cmyk[1] / 100;
      const y = cmyk[2] / 100;
      const k = cmyk[3] / 100;
      const r = 1 - Math.min(1, c * (1 - k) + k);
      const g = 1 - Math.min(1, m * (1 - k) + k);
      const b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      const x = xyz[0] / 100;
      const y = xyz[1] / 100;
      const z = xyz[2] / 100;
      let r;
      let g;
      let b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let x;
      let y;
      let z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      const y2 = y ** 3;
      const x2 = x ** 3;
      const z2 = z ** 3;
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let h;
      const hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      const c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      const l = lch[0];
      const c = lch[1];
      const h = lch[2];
      const hr = h / 360 * 2 * Math.PI;
      const a = c * Math.cos(hr);
      const b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args, saturation = null) {
      const [r, g, b] = args;
      let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      const r = args[0];
      const g = args[1];
      const b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      let color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r = (color & 1) * mult * 255;
      const g = (color >> 1 & 1) * mult * 255;
      const b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      let rem;
      const r = Math.floor(args / 36) / 5 * 255;
      const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      let colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r = integer >> 16 & 255;
      const g = integer >> 8 & 255;
      const b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const max = Math.max(Math.max(r, g), b);
      const min = Math.min(Math.min(r, g), b);
      const chroma = max - min;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
      let f = 0;
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const c = s * v;
      let f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      const h = hcg[0] / 360;
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      const pure = [0, 0, 0];
      const hi = h % 1 * 6;
      const v = hi % 1;
      const w = 1 - v;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      let f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const l = g * (1 - c) + 0.5 * c;
      let s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      const w = hwb[1] / 100;
      const b = hwb[2] / 100;
      const v = 1 - b;
      const c = v - w;
      let g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hsv = convert.gray.hsl;
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// ../../node_modules/ansi-styles/node_modules/color-convert/route.js
var require_route = __commonJS({
  "../../node_modules/ansi-styles/node_modules/color-convert/route.js"(exports2, module2) {
    var conversions = require_conversions();
    function buildGraph() {
      const graph = {};
      const models = Object.keys(conversions);
      for (let len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        const current = queue.pop();
        const adjacents = Object.keys(conversions[current]);
        for (let len = adjacents.length, i = 0; i < len; i++) {
          const adjacent = adjacents[i];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path = [graph[toModel].parent, toModel];
      let fn = conversions[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    module2.exports = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models = Object.keys(graph);
      for (let len = models.length, i = 0; i < len; i++) {
        const toModel = models[i];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// ../../node_modules/ansi-styles/node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "../../node_modules/ansi-styles/node_modules/color-convert/index.js"(exports2, module2) {
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result2 = fn(args);
        if (typeof result2 === "object") {
          for (let len = result2.length, i = 0; i < len; i++) {
            result2[i] = Math.round(result2[i]);
          }
        }
        return result2;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});

// ../../node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "../../node_modules/ansi-styles/index.js"(exports2, module2) {
    "use strict";
    var wrapAnsi16 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `\x1B[${code + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `\x1B[${38 + offset};5;${code}m`;
    };
    var wrapAnsi16m = (fn, offset) => (...args) => {
      const rgb = fn(...args);
      return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    var ansi2ansi = (n) => n;
    var rgb2rgb = (r, g, b) => [r, g, b];
    var setLazyProperty = (object, property, get3) => {
      Object.defineProperty(object, property, {
        get: () => {
          const value = get3();
          Object.defineProperty(object, property, {
            value,
            enumerable: true,
            configurable: true
          });
          return value;
        },
        enumerable: true,
        configurable: true
      });
    };
    var colorConvert;
    var makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
      if (colorConvert === void 0) {
        colorConvert = require_color_convert();
      }
      const offset = isBackground ? 10 : 0;
      const styles = {};
      for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
        const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
        if (sourceSpace === targetSpace) {
          styles[name] = wrap(identity, offset);
        } else if (typeof suite === "object") {
          styles[name] = wrap(suite[targetSpace], offset);
        }
      }
      return styles;
    };
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.gray = styles.color.blackBright;
      styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
      styles.color.grey = styles.color.blackBright;
      styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
      styles.color.close = "\x1B[39m";
      styles.bgColor.close = "\x1B[49m";
      setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
      setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
      return styles;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// ../../node_modules/chalk/source/util.js
var require_util3 = __commonJS({
  "../../node_modules/chalk/source/util.js"(exports2, module2) {
    "use strict";
    var stringReplaceAll = (string, substring, replacer) => {
      let index = string.indexOf(substring);
      if (index === -1) {
        return string;
      }
      const substringLength = substring.length;
      let endIndex = 0;
      let returnValue = "";
      do {
        returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
        endIndex = index + substringLength;
        index = string.indexOf(substring, endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    var stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
      let endIndex = 0;
      let returnValue = "";
      do {
        const gotCR = string[index - 1] === "\r";
        returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
        endIndex = index + 1;
        index = string.indexOf("\n", endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    module2.exports = {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    };
  }
});

// ../../node_modules/chalk/source/templates.js
var require_templates = __commonJS({
  "../../node_modules/chalk/source/templates.js"(exports2, module2) {
    "use strict";
    var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = /* @__PURE__ */ new Map([
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", "\x1B"],
      ["a", "\x07"]
    ]);
    function unescape2(c) {
      const u = c[0] === "u";
      const bracket = c[1] === "{";
      if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
        return String.fromCharCode(parseInt(c.slice(1), 16));
      }
      if (u && bracket) {
        return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
      }
      return ESCAPES.get(c) || c;
    }
    function parseArguments(name, arguments_) {
      const results = [];
      const chunks = arguments_.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        const number = Number(chunk);
        if (!Number.isNaN(number)) {
          results.push(number);
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape4, character) => escape4 ? unescape2(escape4) : character));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
        }
      }
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style)) !== null) {
        const name = matches[1];
        if (matches[2]) {
          const args = parseArguments(name, matches[2]);
          results.push([name].concat(args));
        } else {
          results.push([name]);
        }
      }
      return results;
    }
    function buildStyle(chalk, styles) {
      const enabled = {};
      for (const layer of styles) {
        for (const style of layer.styles) {
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }
      let current = chalk;
      for (const [styleName, styles2] of Object.entries(enabled)) {
        if (!Array.isArray(styles2)) {
          continue;
        }
        if (!(styleName in current)) {
          throw new Error(`Unknown Chalk style: ${styleName}`);
        }
        current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
      }
      return current;
    }
    module2.exports = (chalk, temporary) => {
      const styles = [];
      const chunks = [];
      let chunk = [];
      temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
        if (escapeCharacter) {
          chunk.push(unescape2(escapeCharacter));
        } else if (style) {
          const string = chunk.join("");
          chunk = [];
          chunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));
          styles.push({ inverse, styles: parseStyle(style) });
        } else if (close) {
          if (styles.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk, styles)(chunk.join("")));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(character);
        }
      });
      chunks.push(chunk.join(""));
      if (styles.length > 0) {
        const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMessage);
      }
      return chunks.join("");
    };
  }
});

// ../../node_modules/chalk/source/index.js
var require_source = __commonJS({
  "../../node_modules/chalk/source/index.js"(exports2, module2) {
    "use strict";
    var ansiStyles = require_ansi_styles();
    var { stdout: stdoutColor, stderr: stderrColor } = require_supports_color();
    var {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    } = require_util3();
    var { isArray } = Array;
    var levelMapping = [
      "ansi",
      "ansi",
      "ansi256",
      "ansi16m"
    ];
    var styles = /* @__PURE__ */ Object.create(null);
    var applyOptions = (object, options2 = {}) => {
      if (options2.level && !(Number.isInteger(options2.level) && options2.level >= 0 && options2.level <= 3)) {
        throw new Error("The `level` option should be an integer from 0 to 3");
      }
      const colorLevel = stdoutColor ? stdoutColor.level : 0;
      object.level = options2.level === void 0 ? colorLevel : options2.level;
    };
    var ChalkClass = class {
      constructor(options2) {
        return chalkFactory(options2);
      }
    };
    var chalkFactory = (options2) => {
      const chalk2 = {};
      applyOptions(chalk2, options2);
      chalk2.template = (...arguments_) => chalkTag(chalk2.template, ...arguments_);
      Object.setPrototypeOf(chalk2, Chalk.prototype);
      Object.setPrototypeOf(chalk2.template, chalk2);
      chalk2.template.constructor = () => {
        throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
      };
      chalk2.template.Instance = ChalkClass;
      return chalk2.template;
    };
    function Chalk(options2) {
      return chalkFactory(options2);
    }
    for (const [styleName, style] of Object.entries(ansiStyles)) {
      styles[styleName] = {
        get() {
          const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
          Object.defineProperty(this, styleName, { value: builder });
          return builder;
        }
      };
    }
    styles.visible = {
      get() {
        const builder = createBuilder(this, this._styler, true);
        Object.defineProperty(this, "visible", { value: builder });
        return builder;
      }
    };
    var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
    for (const model of usedModels) {
      styles[model] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    for (const model of usedModels) {
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    var proto = Object.defineProperties(() => {
    }, {
      ...styles,
      level: {
        enumerable: true,
        get() {
          return this._generator.level;
        },
        set(level) {
          this._generator.level = level;
        }
      }
    });
    var createStyler = (open, close, parent) => {
      let openAll;
      let closeAll;
      if (parent === void 0) {
        openAll = open;
        closeAll = close;
      } else {
        openAll = parent.openAll + open;
        closeAll = close + parent.closeAll;
      }
      return {
        open,
        close,
        openAll,
        closeAll,
        parent
      };
    };
    var createBuilder = (self2, _styler, _isEmpty) => {
      const builder = (...arguments_) => {
        if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
          return applyStyle(builder, chalkTag(builder, ...arguments_));
        }
        return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
      };
      Object.setPrototypeOf(builder, proto);
      builder._generator = self2;
      builder._styler = _styler;
      builder._isEmpty = _isEmpty;
      return builder;
    };
    var applyStyle = (self2, string) => {
      if (self2.level <= 0 || !string) {
        return self2._isEmpty ? "" : string;
      }
      let styler = self2._styler;
      if (styler === void 0) {
        return string;
      }
      const { openAll, closeAll } = styler;
      if (string.indexOf("\x1B") !== -1) {
        while (styler !== void 0) {
          string = stringReplaceAll(string, styler.close, styler.open);
          styler = styler.parent;
        }
      }
      const lfIndex = string.indexOf("\n");
      if (lfIndex !== -1) {
        string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
      }
      return openAll + string + closeAll;
    };
    var template;
    var chalkTag = (chalk2, ...strings) => {
      const [firstString] = strings;
      if (!isArray(firstString) || !isArray(firstString.raw)) {
        return strings.join(" ");
      }
      const arguments_ = strings.slice(1);
      const parts = [firstString.raw[0]];
      for (let i = 1; i < firstString.length; i++) {
        parts.push(String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"), String(firstString.raw[i]));
      }
      if (template === void 0) {
        template = require_templates();
      }
      return template(chalk2, parts.join(""));
    };
    Object.defineProperties(Chalk.prototype, styles);
    var chalk = Chalk();
    chalk.supportsColor = stdoutColor;
    chalk.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });
    chalk.stderr.supportsColor = stderrColor;
    module2.exports = chalk;
  }
});

// ../lib/odata-client/dist/client/message.js
var require_message = __commonJS({
  "../lib/odata-client/dist/client/message.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.printErrorDetails = exports2.prettyPrintError = exports2.prettyPrintMessage = void 0;
    var chalk_1 = __importDefault(require_source());
    function prettyPrintMessage(msg, log4, logData) {
      logLevel(msg.severity, msg.message, log4);
      if (msg.longtextUrl && logData.frontendUrl) {
        printUrl(msg.longtextUrl, logData.frontendUrl, log4);
      }
      if (msg.details) {
        msg.details.forEach((entry) => {
          logLevel(entry.severity, entry.message, log4);
        });
      }
    }
    exports2.prettyPrintMessage = prettyPrintMessage;
    function printUrl(longtextUrl, frontendUrl, log4) {
      const fullLongTextUrl = frontendUrl.concat(longtextUrl).replace(/'/g, "%27");
      log4.info(fullLongTextUrl);
    }
    function logLevel(severity, msg, log4, error3 = false) {
      if (severity) {
        severity = severity.toLowerCase();
        if (severity === "success") {
          log4.info(chalk_1.default.greenBright(msg));
        } else {
          if (severity === "warning") {
            severity = "warn";
          }
          log4[severity](msg);
        }
      } else {
        error3 ? log4.error(msg) : log4.info(msg);
      }
    }
    function prettyPrintError(error3, log4, logData) {
      var _a2;
      if (error3) {
        log4.error((_a2 = error3.message) == null ? void 0 : _a2.value);
        if (error3.innererror) {
          if (error3.innererror.errordetails) {
            printErrorDetails(error3.innererror.errordetails, log4, logData);
          }
          if (error3.innererror.Error_Resolution) {
            for (const key in error3.innererror.Error_Resolution) {
              log4.error(`${key}: ${error3.innererror.Error_Resolution[key]}`);
            }
          }
        }
      }
    }
    exports2.prettyPrintError = prettyPrintError;
    function printErrorDetails(errors, log4, logData) {
      if (errors) {
        errors.forEach((entry) => {
          if (!entry.message.startsWith("<![CDATA")) {
            logLevel(entry.severity, entry.message, log4, true);
          }
          if (entry["longtext_url"] && (logData == null ? void 0 : logData.frontendUrl)) {
            printUrl(entry["longtext_url"], logData.frontendUrl, log4);
          }
        });
      }
    }
    exports2.printErrorDetails = printErrorDetails;
  }
});

// ../lib/odata-client/dist/client/patchTls.js
var require_patchTls = __commonJS({
  "../lib/odata-client/dist/client/patchTls.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TlsPatch = void 0;
    var tls_1 = __importDefault(require("tls"));
    var static_1 = require_static();
    var TlsPatch = class {
      static get isPatched() {
        return TlsPatch._patched;
      }
      static isPatchRequired(url) {
        return !TlsPatch.isPatched && url && url.includes(".sap.corp");
      }
      static apply() {
        if (TlsPatch.isPatched) {
          return;
        }
        const origCreateSecureContext = tls_1.default.createSecureContext;
        tls_1.default.createSecureContext = (options2) => {
          const context = origCreateSecureContext(options2);
          const pem = static_1.globalRootCaPem.replace(/\r\n/g, "\n");
          const certs = pem.match(/-----BEGIN CERTIFICATE-----\n[\s\S]+?\n-----END CERTIFICATE-----/g);
          certs.forEach((cert) => {
            context.context.addCACert(cert.trim());
          });
          return context;
        };
        TlsPatch._patched = true;
      }
    };
    exports2.TlsPatch = TlsPatch;
  }
});

// ../lib/odata-client/dist/utils/index.js
var require_utils7 = __commonJS({
  "../lib/odata-client/dist/utils/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hasServices = exports2.isSystemNameValid = exports2.getBTPSystem = exports2.getOnPremSystem = exports2.guessAuthType = exports2.xmlToJson = void 0;
    var fast_xml_parser_1 = __importDefault(require_parser2());
    var config_1 = require_config();
    var __1 = require_dist5();
    function xmlToJson(xml) {
      if (!xml || fast_xml_parser_1.default.validate(xml) !== true) {
        return;
      }
      const options2 = {
        attributeNamePrefix: "",
        ignoreAttributes: false,
        ignoreNameSpace: true,
        parseAttributeValue: true
      };
      const obj = fast_xml_parser_1.default.getTraversalObj(xml, options2);
      return fast_xml_parser_1.default.convertToJson(obj, options2);
    }
    exports2.xmlToJson = xmlToJson;
    function guessAuthType({ credentials, fallback = false }) {
      var _a2, _b;
      let authType = (credentials == null ? void 0 : credentials.serviceKeys) || (credentials == null ? void 0 : credentials.serviceKeysContents) ? config_1.AuthenticationType.OAuth2RefreshToken : void 0;
      if (!authType && credentials && ((_b = (_a2 = credentials.serviceInfo) == null ? void 0 : _a2.uaa) == null ? void 0 : _b.username)) {
        authType = config_1.AuthenticationType.OAuth2ClientCredential;
      }
      if (!authType && fallback) {
        authType = config_1.AuthenticationType.Basic;
      }
      return authType;
    }
    exports2.guessAuthType = guessAuthType;
    async function getOnPremSystem(system, isImportedSystem = false) {
      var _a2, _b;
      let sapSystem = await __1.getSapSystem(system.url, system.client);
      let isNewSapSystem = false;
      const creds = {
        username: (_a2 = system.credentials) == null ? void 0 : _a2.systemUsername,
        password: (_b = system.credentials) == null ? void 0 : _b.systemPassword
      };
      if (sapSystem) {
        if (!isImportedSystem) {
          sapSystem.name = system.name || "";
          sapSystem.setCredentials(creds);
        }
      } else {
        sapSystem = __1.newSapSystem(system.name || "", system.url, system.client, creds, true);
        isNewSapSystem = true;
      }
      return { sapSystem, isNewSapSystem };
    }
    exports2.getOnPremSystem = getOnPremSystem;
    async function getBTPSystem(system, savedSapSystemServiceKey) {
      let sapSystem;
      let isNewSapSystem = false;
      if (system.url && system.credentials === savedSapSystemServiceKey) {
        sapSystem = await __1.getSapSystem(system.url, system.client);
      }
      if (sapSystem) {
        sapSystem.name = system.name || "";
      } else {
        const newBTPSapSystem = __1.newSapSystemForSteampunk(system.name || "", system.credentials, true);
        sapSystem = await __1.getSapSystem(newBTPSapSystem.url, newBTPSapSystem.client);
        if (!sapSystem) {
          isNewSapSystem = true;
          sapSystem = newBTPSapSystem;
        }
      }
      return { sapSystem, isNewSapSystem };
    }
    exports2.getBTPSystem = getBTPSystem;
    async function isSystemNameValid(newName, savedSystemName) {
      if (!newName) {
        return false;
      }
      let isValid = true;
      const isNameInUse = await __1.isSystemNameInUse(newName);
      if (isNameInUse && newName !== savedSystemName) {
        isValid = false;
      }
      return isValid;
    }
    exports2.isSystemNameValid = isSystemNameValid;
    async function hasServices(sapSystem) {
      const versions = [__1.ODataVersion.v2, __1.ODataVersion.v4];
      const result2 = {};
      let error3;
      for (const version of versions) {
        try {
          const catalog = await sapSystem.getCatalog(version);
          const services = await catalog.listServices();
          result2[version] = services.length;
        } catch (e) {
          result2[version] = 0;
          error3 = e.message;
        }
      }
      return {
        v2Count: result2[__1.ODataVersion.v2],
        v4Count: result2[__1.ODataVersion.v4],
        error: error3
      };
    }
    exports2.hasServices = hasServices;
  }
});

// ../lib/odata-client/dist/client/oDataClient.js
var require_oDataClient = __commonJS({
  "../lib/odata-client/dist/client/oDataClient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ODataClient = void 0;
    var config_1 = require_config();
    var ux_common_utils_1 = require_dist();
    var httpClient_1 = require_httpClient();
    var message_1 = require_message();
    var destination_1 = require_destination();
    var patchTls_1 = require_patchTls();
    var utils_1 = require_utils7();
    var error_1 = require_error();
    var ODataClient = class {
      constructor({ system, credentials = void 0, log: log4 = console, connection = void 0, autoAddTrailingSlash = true, timeout, ignoreCertError, postConnectionCallback }) {
        this.autoAddTrailingSlash = true;
        this.system = system;
        this.credentials = credentials;
        this.log = log4;
        this.connection = connection;
        this.autoAddTrailingSlash = autoAddTrailingSlash;
        this.timeout = timeout;
        this.ignoreCertError = ignoreCertError;
        this.postConnectionCallback = postConnectionCallback;
        if (system && patchTls_1.TlsPatch.isPatchRequired(system.url)) {
          patchTls_1.TlsPatch.apply();
        }
        this.validateSysAuthType(system, credentials);
      }
      validateSysAuthType(system, credentials) {
        system.authenticationType = system.authenticationType || utils_1.guessAuthType({ credentials, fallback: true });
        if (!Object.values(config_1.AuthenticationType).includes(system.authenticationType)) {
          throw new error_1.UnknownSystemAuthenticationType(system.authenticationType);
        }
      }
      logError(e, logData) {
        this.log.error(e.message);
        if (e.isAxiosError && e.response.data["error"]) {
          message_1.prettyPrintError(e.response.data["error"], this.log, logData);
        }
      }
      async getClient() {
        if (!this.client) {
          if (ux_common_utils_1.isAppStudio()) {
            await destination_1.updateSystemConfig(this.system);
          }
          const { connection, httpClient } = await httpClient_1.newHttpClient({
            system: this.system,
            credentials: this.credentials,
            log: this.log,
            existingConnection: this.connection,
            autoAddTrailingSlash: this.autoAddTrailingSlash,
            timeout: this.timeout,
            ignoreCertError: this.ignoreCertError,
            updateUserInfo: this.updateUserInfo,
            postConnectionCallback: this.postConnectionCallback
          });
          this.connection = connection;
          this.client = httpClient;
        }
        return this.client;
      }
      async getConnection() {
        if (!this.connection) {
          await this.getClient();
        }
        return this.connection;
      }
      async metadata() {
        var _a2;
        const metadataPath = ((_a2 = this.system.service) == null ? void 0 : _a2.endsWith("/")) ? "$metadata" : "/$metadata";
        return this.get(metadataPath, { Accept: "application/xml" });
      }
      async get(path, headers) {
        var _a2, _b, _c;
        const httpClient = await this.getClient();
        const response = await ((_a2 = httpClient.get(path, headers === void 0 ? {} : { headers })) == null ? void 0 : _a2.catch((error3) => {
          var _a3, _b2, _c2;
          if (((_a3 = error3.request) == null ? void 0 : _a3._isRedirect) && ((_c2 = (_b2 = error3.request) == null ? void 0 : _b2._options) == null ? void 0 : _c2.path)) {
            return httpClient.get(error3.request._options.path, headers === void 0 ? {} : { headers });
          } else {
            throw error3;
          }
        }));
        if ((_b = response == null ? void 0 : response.data) == null ? void 0 : _b.d) {
          if (response.data.d.results) {
            return response.data.d.results;
          } else {
            return response.data.d;
          }
        }
        if ((_c = response == null ? void 0 : response.data) == null ? void 0 : _c.value) {
          return response.data;
        }
        return response == null ? void 0 : response.data;
      }
    };
    exports2.ODataClient = ODataClient;
  }
});

// ../lib/odata-client/dist/constants.js
var require_constants4 = __commonJS({
  "../lib/odata-client/dist/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DEFAULT_SERVICE_PATH = exports2.abapUrlReplaceMap = exports2.API_HUB_API_KEY = void 0;
    exports2.API_HUB_API_KEY = "API_HUB_API_KEY";
    exports2.abapUrlReplaceMap = /* @__PURE__ */ new Map([
      [/\.abap\./, ".abap-web."],
      [/-api.s4hana.ondemand.com/, ".s4hana.ondemand.com"],
      [/-api.saps4hanacloud.cn/, ".saps4hanacloud.cn"]
    ]);
    exports2.DEFAULT_SERVICE_PATH = "/sap/opu/odata/UI5/ABAP_REPOSITORY_SRV";
  }
});

// ../lib/odata-client/dist/client/ui5AbapRepository.js
var require_ui5AbapRepository = __commonJS({
  "../lib/odata-client/dist/client/ui5AbapRepository.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Ui5AbapRepository = void 0;
    var oDataClient_1 = require_oDataClient();
    var fs_1 = require("fs");
    var message_1 = require_message();
    var constants_1 = require_constants4();
    var xmlReplaceMap = {
      "&": "&amp;",
      '"': "&quot;",
      "'": "&apos;",
      "<": "&lt;",
      ">": "&gt;"
    };
    var xmlReplaceRegex = /[<>&"']/g;
    function encodeXmlValue(xmlValue) {
      return xmlValue.replace(xmlReplaceRegex, (c) => xmlReplaceMap[c]);
    }
    var Ui5AbapRepository = class extends oDataClient_1.ODataClient {
      constructor({ system, credentials = void 0, log: log4 = console, connection = void 0, ignoreCertError, postConnectionCallback }) {
        var _a2;
        system.service = (_a2 = system.service) != null ? _a2 : constants_1.DEFAULT_SERVICE_PATH;
        super({ system, credentials, log: log4, connection, ignoreCertError, postConnectionCallback });
      }
      async getInfo(app) {
        try {
          return await this.get(`/Repositories('${encodeURIComponent(app)}')`);
        } catch (error3) {
          return void 0;
        }
      }
      async deploy(archivePath, app, testMode = false, safeMode = true) {
        var _a2, _b, _c;
        const httpClient = await this.getClient();
        const info = await this.getInfo(app.name);
        const payload = this.createPayload(archivePath, app.name, app.description || "Deployed with SAP Fiori tools", info ? info.Package : app.package, httpClient);
        const config = this.createConfig(app.transport, testMode, safeMode);
        const frontendUrl = this.getAbapFrontendUrl(this.system.originalUrl || this.system.url);
        try {
          const response = await this.updateRepoRequest(!!info, app.name, httpClient, payload, config);
          if ((_a2 = response == null ? void 0 : response.headers) == null ? void 0 : _a2["sap-message"]) {
            const message = JSON.parse(response.headers["sap-message"]);
            message["longtextUrl"] = message["longtext_url"];
            message_1.prettyPrintMessage(message, this.log, { frontendUrl });
            const path = "/sap/bc/ui5_ui5" + (!app.name.startsWith("/") ? "/sap/" : "") + app.name.toLowerCase();
            const query = this.system.client ? "?sap-client=" + this.system.client : "";
            this.log.info(`App available at ${frontendUrl}${path}${query}`);
          } else if (testMode) {
            message_1.printErrorDetails((_c = (_b = response == null ? void 0 : response.data.error) == null ? void 0 : _b.innererror) == null ? void 0 : _c.errordetails, this.log, {
              frontendUrl
            });
          }
          return response;
        } catch (error3) {
          this.logError(error3, { frontendUrl });
          throw error3;
        }
      }
      async undeploy(app, testMode = false) {
        var _a2;
        const httpClient = await this.getClient();
        const config = this.createConfig(app.transport, testMode);
        try {
          const response = await this.deleteRepoRequest(app.name, httpClient, config);
          if ((_a2 = response == null ? void 0 : response.headers) == null ? void 0 : _a2["sap-message"]) {
            const message = JSON.parse(response.headers["sap-message"]);
            message_1.prettyPrintMessage(message, this.log);
          }
          return response;
        } catch (error3) {
          this.logError(error3);
          throw error3;
        }
      }
      getAbapFrontendUrl(technicalUrl) {
        constants_1.abapUrlReplaceMap.forEach((value, key) => {
          technicalUrl = technicalUrl.replace(key, value);
        });
        return technicalUrl;
      }
      createConfig(transport, testMode = false, safeMode = true) {
        const headers = {
          "Content-Type": "application/atom+xml",
          type: "entry",
          charset: "UTF8"
        };
        const params = {
          CodePage: "'UTF8'",
          CondenseMessagesInHttpResponseHeader: "X",
          format: "json"
        };
        if (transport) {
          params.TransportRequest = transport;
        }
        params.TestMode = testMode;
        params.SafeMode = safeMode;
        const maxBodyLength = Infinity;
        const maxContentLength = Infinity;
        return { headers, params, maxBodyLength, maxContentLength };
      }
      createPayload(archive, name, description, abapPackage, httpClient) {
        const base64Data = fs_1.readFileSync(archive, { encoding: "base64" });
        const time = new Date().toISOString();
        const escapedName = encodeXmlValue(name);
        return `<entry xmlns="http://www.w3.org/2005/Atom"       xmlns:m="http://schemas.microsoft.com/ado/2007/08/dataservices/metadata"       xmlns:d="http://schemas.microsoft.com/ado/2007/08/dataservices"       xml:base="${httpClient.defaults.baseURL}">  <id>${httpClient.defaults.baseURL}/Repositories('${escapedName}')</id>  <title type="text">Repositories('${escapedName}')</title>  <updated>${time}</updated>  <category term="/UI5/ABAP_REPOSITORY_SRV.Repository" scheme="http://schemas.microsoft.com/ado/2007/08/dataservices/scheme"/>  <link href="Repositories('${escapedName}')" rel="edit" title="Repository"/>  <content type="application/xml">    <m:properties>      <d:Name>${escapedName}</d:Name>      <d:Package>${abapPackage == null ? void 0 : abapPackage.toUpperCase()}</d:Package>      <d:Description>${encodeXmlValue(description)}</d:Description>      <d:ZipArchive>${base64Data}</d:ZipArchive>      <d:Info/>    </m:properties>  </content></entry>`;
      }
      async updateRepoRequest(isExisting, appName, httpClient, payload, config, tryCount = 1) {
        var _a2, _b;
        try {
          if (tryCount === 2) {
            this.log.warn("Warning: The application was deployed despite a time out response from the backend. Increasing the value of the HTML5.Timeout property for the destination may solve the issue");
          }
          if (tryCount !== 1 && !isExisting && await this.getInfo(appName) !== void 0) {
            return;
          }
          return isExisting ? await httpClient.put(`/Repositories('${encodeURIComponent(appName)}')`, payload, config) : await httpClient.post("/Repositories", payload, config);
        } catch (error3) {
          if (((_a2 = error3 == null ? void 0 : error3.response) == null ? void 0 : _a2.status) === 504) {
            if (tryCount >= 3) {
              throw error3;
            }
            return await this.updateRepoRequest(isExisting, appName, httpClient, payload, config, ++tryCount);
          } else if ((_b = config == null ? void 0 : config.params) == null ? void 0 : _b.TestMode) {
            return error3.response;
          } else {
            throw error3;
          }
        }
      }
      async deleteRepoRequest(appName, httpClient, config, tryCount = 1) {
        var _a2;
        try {
          if (tryCount === 2) {
            this.log.warn("Warning: retry undeploy to handle a backend rejection...");
          }
          return await httpClient.delete(`/Repositories('${encodeURIComponent(appName)}')`, config);
        } catch (error3) {
          if (((_a2 = error3 == null ? void 0 : error3.response) == null ? void 0 : _a2.status) === 400) {
            if (tryCount >= 2) {
              throw error3;
            }
            return await this.deleteRepoRequest(appName, httpClient, config, ++tryCount);
          } else {
            throw error3;
          }
        }
      }
    };
    exports2.Ui5AbapRepository = Ui5AbapRepository;
  }
});

// ../lib/odata-client/dist/client/catalog/common.js
var require_common5 = __commonJS({
  "../lib/odata-client/dist/client/catalog/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CATALOG_REQ_TYPE = exports2.Catalog = exports2.ODataVersion = exports2.ODATA_SKIP_QUERY = exports2.ODATA_COUNT_QUERY = exports2.ATO_CATALOG_URL_PATH = exports2.V2_ODATA_CATALOG_FILTER_FOR_S4_HANA_SERVICES = exports2.V4_RECOMMENDED_SERVICES_PATH_PROD = exports2.V4_SERVICES_PATH_PROD = exports2.V4_SERVICES_PATH_DEV = exports2.V2_RECOMMENDED_SERVICES_PATH = exports2.V2_SERVICES_PATH = exports2.V4_CATALOG_URL_PATH_PROD = exports2.V4_CATALOG_URL_PATH_DEV = exports2.V2_CATALOG_URL_PATH = void 0;
    var oDataClient_1 = require_oDataClient();
    exports2.V2_CATALOG_URL_PATH = "/sap/opu/odata/IWFND/CATALOGSERVICE;v=2";
    exports2.V4_CATALOG_URL_PATH_DEV = "/sap/opu/odata4/iwfnd/config/default/iwfnd/catalog/0001";
    exports2.V4_CATALOG_URL_PATH_PROD = "/sap/opu/odata4/iwfnd/config/default/iwfnd/catalog/0002";
    exports2.V2_SERVICES_PATH = "/ServiceCollection";
    exports2.V2_RECOMMENDED_SERVICES_PATH = "/RecommendedServiceCollection";
    exports2.V4_SERVICES_PATH_DEV = `/ServiceGroups('%2FIWBEP%2FALL')?$expand=Systems($expand=Services)`;
    exports2.V4_SERVICES_PATH_PROD = `/ServiceGroups?$expand=DefaultSystem($expand=Services)`;
    exports2.V4_RECOMMENDED_SERVICES_PATH_PROD = `/ServiceGroups?$expand=DefaultSystem($expand=RecommendedServices)`;
    exports2.V2_ODATA_CATALOG_FILTER_FOR_S4_HANA_SERVICES = "?%24filter=((IsSapService%20eq%20true)and(ReleaseStatus%20eq%20%27RELEASED%27))or((IsSapService%20eq%20false))";
    exports2.ATO_CATALOG_URL_PATH = "/sap/bc/adt/ato/settings";
    exports2.ODATA_COUNT_QUERY = "$count=true";
    exports2.ODATA_SKIP_QUERY = "$skiptoken";
    var ODataVersion;
    (function(ODataVersion2) {
      ODataVersion2["v2"] = "2";
      ODataVersion2["v4"] = "4";
    })(ODataVersion = exports2.ODataVersion || (exports2.ODataVersion = {}));
    var Catalog = class extends oDataClient_1.ODataClient {
    };
    exports2.Catalog = Catalog;
    var CATALOG_REQ_TYPE;
    (function(CATALOG_REQ_TYPE2) {
      CATALOG_REQ_TYPE2[CATALOG_REQ_TYPE2["RECOMMENDED"] = 0] = "RECOMMENDED";
      CATALOG_REQ_TYPE2[CATALOG_REQ_TYPE2["LEGACY"] = 1] = "LEGACY";
    })(CATALOG_REQ_TYPE = exports2.CATALOG_REQ_TYPE || (exports2.CATALOG_REQ_TYPE = {}));
  }
});

// ../lib/odata-client/dist/client/catalog/atoCatalog.js
var require_atoCatalog = __commonJS({
  "../lib/odata-client/dist/client/catalog/atoCatalog.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AtoCatalog = void 0;
    var utils_1 = require_utils7();
    var oDataClient_1 = require_oDataClient();
    var common_1 = require_common5();
    var AtoCatalog = class {
      static async getATOData({ system, credentials, log: log4 = console, connection = void 0, systemInstance }) {
        let systemConfig;
        let creds;
        if (systemInstance) {
          systemConfig = { ...systemInstance.config, service: common_1.ATO_CATALOG_URL_PATH };
          const sys = systemInstance.serialize();
          creds = {
            username: sys.username,
            password: sys.password,
            serviceKeysContents: sys.serviceKeys
          };
        } else {
          systemConfig = { ...system, service: common_1.ATO_CATALOG_URL_PATH };
          if (credentials) {
            creds = credentials;
          }
        }
        const atoDataXml = await new oDataClient_1.ODataClient({
          system: systemConfig,
          credentials: creds,
          log: log4,
          connection,
          autoAddTrailingSlash: false
        }).get();
        return this.getAtoData(atoDataXml);
      }
      static getAtoData(atoDataXml) {
        const atoData = utils_1.xmlToJson(atoDataXml);
        const settings = atoData == null ? void 0 : atoData["settings"];
        if (!settings) {
          throw new Error("ATO settings unavailable");
        }
        const atoSettings = {
          tenantType: settings.tenantType,
          operationsType: settings.operationsType,
          isExtensibilityDevSystem: settings.isExtensibilityDevelopmentSystem === true,
          devPackage: settings.developmentPackage,
          devPrefix: settings.developmentPrefix
        };
        return atoSettings;
      }
    };
    exports2.AtoCatalog = AtoCatalog;
  }
});

// ../lib/odata-client/dist/client/catalog/utils.js
var require_utils8 = __commonJS({
  "../lib/odata-client/dist/client/catalog/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isS4HanaCloudSystem = void 0;
    function isS4HanaCloudSystem(atoSettings) {
      return atoSettings.tenantType === "CUSTOMER" && atoSettings.operationsType === "C" && atoSettings.isExtensibilityDevSystem === true && atoSettings.devPrefix !== "" && atoSettings.devPackage !== "";
    }
    exports2.isS4HanaCloudSystem = isS4HanaCloudSystem;
  }
});

// ../lib/odata-client/dist/client/catalog/v2Catalog.js
var require_v2Catalog = __commonJS({
  "../lib/odata-client/dist/client/catalog/v2Catalog.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.V2Catalog = void 0;
    var uaaOauth_1 = require_uaaOauth();
    var atoCatalog_1 = require_atoCatalog();
    var common_1 = require_common5();
    var utils_1 = require_utils8();
    var V2Catalog = class extends common_1.Catalog {
      constructor({ system, credentials = void 0, log: log4 = console, connection = void 0, postConnectionCallback }) {
        var _a2, _b;
        if ((credentials == null ? void 0 : credentials.serviceKeys) || (credentials == null ? void 0 : credentials.serviceKeysContents)) {
          const serviceInfo = uaaOauth_1.getServiceInfo(credentials);
          credentials.serviceInfo = serviceInfo;
          system.url = serviceInfo.url;
          if ((_b = (_a2 = serviceInfo.catalogs) == null ? void 0 : _a2.abap) == null ? void 0 : _b.path) {
            system.service = serviceInfo.catalogs.abap.path;
          }
        } else if (!system.service) {
          system.service = common_1.V2_CATALOG_URL_PATH;
        }
        super({ system, credentials, log: log4, connection, postConnectionCallback });
      }
      async listServices(recommended = false) {
        if (recommended) {
          return this.get(common_1.V2_RECOMMENDED_SERVICES_PATH);
        } else {
          let isS4C = false;
          try {
            await this.getConnection();
            isS4C = utils_1.isS4HanaCloudSystem(await atoCatalog_1.AtoCatalog.getATOData({
              system: this.system,
              connection: this.connection,
              log: this.log,
              credentials: this.credentials
            }));
          } catch (error3) {
          }
          return this.get(isS4C ? common_1.V2_SERVICES_PATH + common_1.V2_ODATA_CATALOG_FILTER_FOR_S4_HANA_SERVICES : common_1.V2_SERVICES_PATH);
        }
      }
      async findService({ title, path }) {
        if (!title) {
          title = path.replace(/\/$/, "").split("/").pop();
          if (!title) {
            throw new Error(`Cannot determine service title from path: ${path}`);
          }
        }
        title = title.toUpperCase();
        const services = await this.get(`/ServiceCollection/?$filter=Title%20eq%20%27${title}%27&$format=json`);
        if (services.length > 1) {
          const servicesWithSameNameSpace = services.filter((service) => {
            var _a2;
            return (_a2 = service.ServiceUrl) == null ? void 0 : _a2.toUpperCase().includes(path.toUpperCase());
          });
          if (servicesWithSameNameSpace.length > 1) {
            this.log.warn("Service filter was not sufficient to identify one service.");
          } else if (servicesWithSameNameSpace.length > 0) {
            this.log.info(`Service filter chose service: ${servicesWithSameNameSpace[0].TechnicalServiceName}`);
            return servicesWithSameNameSpace[0];
          }
        }
        return services.length > 0 ? services[0] : void 0;
      }
      async getAnnotations({ id, title, path }) {
        if (!id && !title && !path) {
          throw new Error("No filter parameters passed in");
        }
        const serviceAnnotations = await this.getServiceAnnotations({ id, title, path });
        const annotations = [];
        if (serviceAnnotations) {
          for (const service of serviceAnnotations) {
            const _path = `/Annotations(TechnicalName='${encodeURIComponent(service.TechnicalName)}',Version='${service.Version}')/$value/`;
            const annotDefs = await this.get(_path);
            if (annotDefs) {
              annotations.push({
                TechnicalName: service.TechnicalName,
                Version: service.Version,
                Definitions: annotDefs,
                Uri: this.system.service + _path
              });
            } else {
              this.log.warn(`No annotations found for TechnicalName=${service.TechnicalName}, Version=${service.Version}`);
            }
          }
        }
        return annotations;
      }
      async getServiceAnnotations({ id, title, path }) {
        if (!id) {
          const serviceInfo = await this.findService({ title, path });
          if (serviceInfo) {
            id = serviceInfo.ID;
          }
        }
        if (id) {
          return this.get(`/ServiceCollection('${encodeURIComponent(id)}')/Annotations?$format=json`);
        } else {
          return void 0;
        }
      }
    };
    exports2.V2Catalog = V2Catalog;
  }
});

// ../lib/odata-client/dist/client/catalog/v4Catalog.js
var require_v4Catalog = __commonJS({
  "../lib/odata-client/dist/client/catalog/v4Catalog.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.V4Catalog = void 0;
    var uaaOauth_1 = require_uaaOauth();
    var common_1 = require_common5();
    var V4Catalog = class extends common_1.Catalog {
      constructor({ system, credentials = void 0, log: log4 = console, connection = void 0, postConnectionCallback }) {
        if ((credentials == null ? void 0 : credentials.serviceKeys) || (credentials == null ? void 0 : credentials.serviceKeysContents)) {
          const serviceInfo = uaaOauth_1.getServiceInfo(credentials);
          credentials.serviceInfo = serviceInfo;
          system.url = serviceInfo.url;
        }
        system.service = common_1.V4_CATALOG_URL_PATH_PROD;
        super({ system, credentials, log: log4, connection, postConnectionCallback });
      }
      parseServiceData(serviceGroups, recommended) {
        if (serviceGroups && Array.isArray(serviceGroups)) {
          const servicePropName = recommended ? "RecommendedServices" : "Services";
          const services = [];
          serviceGroups.forEach(({ DefaultSystem, GroupId }) => {
            services.push(...DefaultSystem[servicePropName].map((service) => Object.assign(service, { GroupId })));
          });
          return services;
        }
        return [];
      }
      async listServices(recommended = false) {
        var _a2, _b;
        if (!this.services) {
          const servicePath = recommended ? common_1.V4_RECOMMENDED_SERVICES_PATH_PROD : common_1.V4_SERVICES_PATH_PROD;
          this.services = [];
          const respValues = await this.get(`${servicePath}&${common_1.ODATA_COUNT_QUERY}`);
          this.services = this.services.concat(this.parseServiceData(respValues.value, recommended));
          if (respValues["@odata.nextLink"]) {
            let skipval = parseInt((_a2 = respValues["@odata.nextLink"]) == null ? void 0 : _a2.split("skiptoken=")[1]);
            while (!isNaN(skipval) && skipval > 0) {
              const groupsResp = await this.get(`${servicePath}&${common_1.ODATA_SKIP_QUERY}=${skipval}`);
              this.services.push(...this.parseServiceData(groupsResp.value, recommended));
              skipval = parseInt((_b = groupsResp["@odata.nextLink"]) == null ? void 0 : _b.split("skiptoken=")[1]);
            }
          }
        }
        return this.services;
      }
      async getAnnotations() {
        return Promise.resolve([]);
      }
    };
    exports2.V4Catalog = V4Catalog;
  }
});

// ../lib/odata-client/dist/client/catalog/index.js
var require_catalog = __commonJS({
  "../lib/odata-client/dist/client/catalog/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getCatalog = void 0;
    var __1 = require_client2();
    __exportStar(require_common5(), exports2);
    __exportStar(require_atoCatalog(), exports2);
    __exportStar(require_v2Catalog(), exports2);
    __exportStar(require_v4Catalog(), exports2);
    __exportStar(require_utils8(), exports2);
    function getCatalog(options2) {
      return options2.odataVersion === __1.ODataVersion.v4 ? new __1.V4Catalog(options2) : new __1.V2Catalog(options2);
    }
    exports2.getCatalog = getCatalog;
  }
});

// ../lib/odata-client/dist/client/index.js
var require_client2 = __commonJS({
  "../lib/odata-client/dist/client/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_oDataClient(), exports2);
    __exportStar(require_ui5AbapRepository(), exports2);
    __exportStar(require_catalog(), exports2);
    __exportStar(require_message(), exports2);
    __exportStar(require_patchTls(), exports2);
  }
});

// ../lib/odata-client/dist/api-hub/index.js
var require_api_hub = __commonJS({
  "../lib/odata-client/dist/api-hub/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.saveApiHubApiKey = exports2.getApiHubApiKey = void 0;
    var config_1 = require_config();
    var ux_store_1 = require_dist4();
    var constants_1 = require_constants4();
    async function getApiHubApiKey(log4 = console) {
      const keyStore = ux_store_1.getSecureStore(log4);
      const apiHubServiceName = config_1.ServiceName.ApiHub;
      const apiHubApiKey = await keyStore.retrieve(apiHubServiceName, constants_1.API_HUB_API_KEY);
      if (apiHubApiKey) {
        log4.info("Retrieved stored API hub key");
      }
      return apiHubApiKey;
    }
    exports2.getApiHubApiKey = getApiHubApiKey;
    async function saveApiHubApiKey(val, log4 = console) {
      const keyStore = ux_store_1.getSecureStore(log4);
      const apiHubServiceName = config_1.ServiceName.ApiHub;
      const existingKey = await getApiHubApiKey(log4);
      if (existingKey !== void 0) {
        await keyStore.delete(apiHubServiceName, constants_1.API_HUB_API_KEY);
      }
      return keyStore.save(apiHubServiceName, constants_1.API_HUB_API_KEY, val);
    }
    exports2.saveApiHubApiKey = saveApiHubApiKey;
  }
});

// ../lib/odata-client/dist/types.js
var require_types3 = __commonJS({
  "../lib/odata-client/dist/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SystemType = void 0;
    var SystemType;
    (function(SystemType2) {
      SystemType2["OnPremise"] = "abap_onpremise";
      SystemType2["Cloud"] = "abap_btp";
    })(SystemType = exports2.SystemType || (exports2.SystemType = {}));
  }
});

// ../lib/odata-client/dist/system/sapSystem.js
var require_sapSystem = __commonJS({
  "../lib/odata-client/dist/system/sapSystem.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.stripOldSCPSuffix = exports2.SapSystem = void 0;
    var ux_store_1 = require_dist4();
    var __1 = require_dist5();
    var client_1 = require_client2();
    var config_1 = require_config();
    var ux_common_utils_1 = require_dist();
    var types_1 = require_types3();
    var NEW_SCP_SUFFIX = " (BTP)";
    var SapSystem = class {
      constructor(name, config, credentials = {}, userDisplayName, unSaved = false, postConnectionCallbackCreator) {
        this.config = config;
        this.credentials = credentials;
        this._unSaved = false;
        this.postConnectionCallbackInitialized = false;
        this._name = name;
        if (this.config.scp === void 0) {
          this.config.scp = !!(credentials == null ? void 0 : credentials.serviceKeysContents) || !!(credentials == null ? void 0 : credentials.serviceKeys);
        }
        this._unSaved = unSaved;
        this._userDisplayName = userDisplayName;
        this._postConnectionCallbackCreator = postConnectionCallbackCreator;
      }
      postConnectionCallback() {
        var _a2;
        if (!this.postConnectionCallbackInitialized) {
          this._postConnectionCallback = (_a2 = this._postConnectionCallbackCreator) == null ? void 0 : _a2.call(this, this);
          this.postConnectionCallbackInitialized = true;
        }
        return this._postConnectionCallback;
      }
      static fromSerialized(s) {
        const credentials = s.serviceKeys || s.username || s.password ? {
          serviceKeysContents: s.serviceKeys,
          username: s.username,
          password: s.password,
          refreshToken: s.refreshToken
        } : void 0;
        const authenticationType = Object.values(ux_store_1.AuthenticationType).find((v) => v === s.authenticationType) || __1.guessAuthType({ credentials, fallback: false });
        return new SapSystem(s.name, { url: s.url, client: s.client, authenticationType }, credentials, s.userDisplayName, void 0, void 0);
      }
      getConnection() {
        return this.connection;
      }
      clone({ retainConnection } = { retainConnection: false }) {
        var _a2;
        const copy3 = SapSystem.fromSerialized(this.serialize());
        if (retainConnection) {
          copy3.connection = this.connection;
          copy3.config.destination = (_a2 = this.config) == null ? void 0 : _a2.destination;
        }
        return copy3;
      }
      get refreshToken() {
        var _a2;
        return (_a2 = this.credentials) == null ? void 0 : _a2.refreshToken;
      }
      set refreshToken(value) {
        this.credentials = Object.assign(this.credentials || {}, { refreshToken: value });
      }
      get name() {
        return this._name;
      }
      set name(newName) {
        this._name = newName;
      }
      get username() {
        var _a2;
        return (_a2 = this.credentials) == null ? void 0 : _a2.username;
      }
      get password() {
        var _a2;
        return (_a2 = this.credentials) == null ? void 0 : _a2.password;
      }
      get serviceKeys() {
        var _a2;
        return (_a2 = this.credentials) == null ? void 0 : _a2.serviceKeysContents;
      }
      get unSaved() {
        return this._unSaved;
      }
      set unSaved(val) {
        this._unSaved = val;
      }
      get url() {
        return this.config.url;
      }
      get client() {
        return this.config.client;
      }
      get userDisplayName() {
        return this._userDisplayName;
      }
      set postConnectionCallbackCreator(cbCreator) {
        this._postConnectionCallbackCreator = cbCreator;
        this.postConnectionCallbackInitialized = false;
        this._postConnectionCallback = void 0;
      }
      get postConnectionCallbackCreator() {
        return this._postConnectionCallbackCreator;
      }
      getDisplayName({ includeUserName } = { includeUserName: true }) {
        const userDisplayName = includeUserName && this.userDisplayName ? ` [${this.userDisplayName}]` : "";
        let systemDisplayName;
        if (this.isScp()) {
          systemDisplayName = toSCPSystemName(this.name);
        } else if (this.isS4HC()) {
          systemDisplayName = this.addS4HCSuffix(this.name);
        } else {
          systemDisplayName = this.name;
        }
        return systemDisplayName + userDisplayName;
      }
      isOnPremSystem() {
        var _a2;
        return ((_a2 = this.config) == null ? void 0 : _a2.authenticationType) === ux_store_1.AuthenticationType.Basic || Object.keys(this.credentials).length !== 0 && !(this.isScp() || this.isS4HC());
      }
      isS4HC() {
        var _a2;
        return ((_a2 = this.config) == null ? void 0 : _a2.authenticationType) === ux_store_1.AuthenticationType.ReentranceTicket;
      }
      addS4HCSuffix(name) {
        const S4HC_SUFFIX = " (S4HC)";
        return (name == null ? void 0 : name.trim().match(`${ux_common_utils_1.escapeRegExp(S4HC_SUFFIX)}$`)) ? name : name + S4HC_SUFFIX;
      }
      get bareName() {
        return stripOldSCPSuffix(this.name);
      }
      isScp() {
        return this.config.scp;
      }
      isPartialUrlDest() {
        return !config_1.hasDestinationAttrib("WebIDEAdditionalData", config_1.DestinationAttributeProperty.FULL_URL, this.config.destinationAttributes) && this.isGenericODataDest();
      }
      isGenericODataDest() {
        return this.config.destination ? config_1.hasDestinationAttrib("WebIDEUsage", config_1.DestinationAttributeProperty.ODATA_GENERIC, this.config.destinationAttributes) && !config_1.hasDestinationAttrib("WebIDEUsage", config_1.DestinationAttributeProperty.ODATA_ABAP, this.config.destinationAttributes) : false;
      }
      isFullUrlDest() {
        return this.config.destination ? config_1.hasDestinationAttrib("WebIDEAdditionalData", config_1.DestinationAttributeProperty.FULL_URL, this.config.destinationAttributes) && this.isGenericODataDest() : false;
      }
      isAbapCatalogDest() {
        return this.config.destination ? config_1.hasDestinationAttrib("WebIDEUsage", config_1.DestinationAttributeProperty.ODATA_ABAP, this.config.destinationAttributes) && !this.isFullUrlDest() : false;
      }
      isHTML5DynamicDestination() {
        return this.config.destination ? config_1.hasHTML5DynamicDestinationAttrib(this.config.destinationAttributes) : false;
      }
      toString() {
        var _a2;
        const urlString = () => {
          var _a3, _b, _c;
          const url = (_b = (_a3 = this.config) == null ? void 0 : _a3.url) == null ? void 0 : _b.trim();
          if (url) {
            const client = ((_c = this.config) == null ? void 0 : _c.client) ? `?sap-client=${this.config.client}` : "";
            return url + client;
          } else {
            return void 0;
          }
        };
        return ((_a2 = this.config) == null ? void 0 : _a2.destination) || urlString() || this.getDisplayName() || "";
      }
      serialize() {
        var _a2, _b, _c, _d, _e, _f;
        return new ux_store_1.BackendSystem({
          name: this._name,
          url: (_a2 = this.config) == null ? void 0 : _a2.url,
          client: (_b = this.config) == null ? void 0 : _b.client,
          authenticationType: (_c = this.config) == null ? void 0 : _c.authenticationType,
          serviceKeys: (_d = this.credentials) == null ? void 0 : _d.serviceKeysContents,
          refreshToken: this.refreshToken,
          username: (_e = this.credentials) == null ? void 0 : _e.username,
          password: (_f = this.credentials) == null ? void 0 : _f.password,
          userDisplayName: this.userDisplayName
        });
      }
      async getService(path) {
        const system = deepClone(this.config);
        system.service = path;
        if (this.connection) {
          return new client_1.ODataClient({
            system,
            connection: this.connection,
            postConnectionCallback: this.postConnectionCallback()
          });
        } else {
          const client = new client_1.ODataClient({
            system,
            credentials: this.credentials,
            postConnectionCallback: this.postConnectionCallback()
          });
          this.connection = await client.getConnection();
          return client;
        }
      }
      setUserDisplayName(u) {
        this._userDisplayName = u;
      }
      setRefreshToken(r) {
        this.refreshToken = r;
      }
      async getCatalog(odataVersion) {
        const system = deepClone(this.config);
        if (this.connection) {
          return client_1.getCatalog({
            system,
            connection: this.connection,
            odataVersion,
            postConnectionCallback: this.postConnectionCallback()
          });
        } else {
          const catalog = client_1.getCatalog({
            system,
            credentials: this.credentials,
            odataVersion,
            postConnectionCallback: this.postConnectionCallback()
          });
          this.connection = await catalog.getConnection();
          return catalog;
        }
      }
      async getUi5Repository(log4 = console, ignoreCertError) {
        const system = deepClone(this.config);
        if (this.connection) {
          return new client_1.Ui5AbapRepository({
            system,
            connection: this.connection,
            log: log4,
            ignoreCertError,
            postConnectionCallback: this.postConnectionCallback()
          });
        } else {
          const repo = new client_1.Ui5AbapRepository({
            system,
            credentials: this.credentials,
            log: log4,
            ignoreCertError,
            postConnectionCallback: this.postConnectionCallback()
          });
          this.connection = await repo.getConnection();
          return repo;
        }
      }
      setCredentials(credentials) {
        this.credentials = credentials;
      }
      isSameSystem(url, client) {
        var _a2, _b, _c;
        return ((_b = (_a2 = this.url) == null ? void 0 : _a2.trim()) == null ? void 0 : _b.replace(/\/$/, "")) === ((_c = url == null ? void 0 : url.trim()) == null ? void 0 : _c.replace(/\/$/, "")) && this.client === client;
      }
      getSystemForExport() {
        return {
          name: this.name,
          type: this.isScp() ? types_1.SystemType.Cloud : types_1.SystemType.OnPremise,
          url: this.url,
          client: this.client
        };
      }
    };
    exports2.SapSystem = SapSystem;
    function toSCPSystemName(systemName) {
      const s = systemName.trim();
      return s.match(`${ux_common_utils_1.escapeRegExp(NEW_SCP_SUFFIX)}$`) ? s : s + NEW_SCP_SUFFIX;
    }
    function stripOldSCPSuffix(name) {
      return name.trim().replace(/ \(SCP\)$/, "");
    }
    exports2.stripOldSCPSuffix = stripOldSCPSuffix;
    function deepClone(o) {
      return JSON.parse(JSON.stringify(o));
    }
  }
});

// ../lib/odata-client/dist/system/systemStore.js
var require_systemStore = __commonJS({
  "../lib/odata-client/dist/system/systemStore.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getSystemStore = void 0;
    var sapSystem_1 = require_sapSystem();
    var ux_store_1 = require_dist4();
    var DefaultImplementation = class {
      constructor(storeService, logger) {
        this.logger = logger;
        this.storeService = storeService;
      }
      static async createInstance(logger) {
        const storeService = await ux_store_1.getService({ logger, entityName: "system" });
        return new DefaultImplementation(storeService, logger);
      }
      async getAll() {
        const systems = await this.storeService.getAll() || [];
        return systems.map((s) => sapSystem_1.SapSystem.fromSerialized(s)).sort((a, b) => a.getDisplayName({ includeUserName: false }).localeCompare(b.getDisplayName({ includeUserName: false }), void 0, {
          numeric: true,
          caseFirst: "lower"
        })).reduce((result2, s) => {
          result2[s.name] = s;
          return result2;
        }, {});
      }
      async get(url, client) {
        const serializedSystem = await this.storeService.read(new ux_store_1.BackendSystemKey({ url, client }));
        if (serializedSystem && Object.keys(serializedSystem).length > 0) {
          return sapSystem_1.SapSystem.fromSerialized(serializedSystem);
        } else {
          return void 0;
        }
      }
      async save(system) {
        if (typeof (system == null ? void 0 : system.serialize) !== "function") {
          this.logger.warn("system does not have a serialize method, unable to save");
        } else {
          await this.storeService.write(system.serialize());
        }
      }
      async delete(system) {
        if (typeof (system == null ? void 0 : system.serialize) !== "function") {
          this.logger.warn("system does not have a serialize method, unable to delete");
        } else {
          return this.storeService.delete(system.serialize());
        }
      }
      async partialUpdate({ url, client, update }) {
        await this.storeService.partialUpdate(new ux_store_1.BackendSystemKey({ url, client }), update);
      }
    };
    var getSystemStore = async (log4 = console) => {
      return DefaultImplementation.createInstance(log4);
    };
    exports2.getSystemStore = getSystemStore;
  }
});

// ../lib/odata-client/dist/system/index.js
var require_system3 = __commonJS({
  "../lib/odata-client/dist/system/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SapSystem = exports2.deleteSapSystem = exports2.saveSapSystem = exports2.newSapSystemForDestinaton = exports2.newS4HCSystem = exports2.newSapSystemForSteampunk = exports2.newSapSystemForServiceUrl = exports2.newSapSystem = exports2.getSapSystem = exports2.isSystemNameInUse = exports2.listSAPSystems = void 0;
    var connection_1 = require_connection();
    var ux_common_utils_1 = require_dist();
    var sapSystem_1 = require_sapSystem();
    Object.defineProperty(exports2, "SapSystem", { enumerable: true, get: function() {
      return sapSystem_1.SapSystem;
    } });
    var systemStore_1 = require_systemStore();
    var url_1 = require("url");
    var __1 = require_dist5();
    async function listSAPSystems2() {
      if (ux_common_utils_1.isAppStudio()) {
        const systems = {};
        const destinations = await connection_1.listDestinations();
        Object.values(destinations).sort((a, b) => a.Name.localeCompare(b.Name, void 0, { numeric: true, caseFirst: "lower" })).forEach((destination) => {
          var _a2, _b;
          systems[destination.Name] = new sapSystem_1.SapSystem(destination.Name, {
            url: destination.Host,
            destination: destination.Name,
            destinationAuthType: destination.Authentication,
            scp: (_b = (_a2 = destination.WebIDEUsage) == null ? void 0 : _a2.includes("abap_cloud")) != null ? _b : false,
            destinationAttributes: Object.assign({}, destination),
            client: destination["sap-client"]
          });
        });
        return systems;
      } else {
        const store = await systemStore_1.getSystemStore();
        return postGetAll({ systems: await store.getAll(), store });
      }
    }
    exports2.listSAPSystems = listSAPSystems2;
    function postGetAll({ systems, store }) {
      const systemsForUpdate = [];
      Object.values(systems).forEach((sys) => {
        if (sys.isScp()) {
          sys.postConnectionCallbackCreator = postConnectionCallbackCreator;
        } else {
          if (!sys.userDisplayName && sys.username) {
            sys.setUserDisplayName(sys.username);
            systemsForUpdate.push(sys);
          }
        }
      });
      if (systemsForUpdate.length > 0) {
        updateUserDisplayNameFor({ systems: systemsForUpdate, store }).catch();
      }
      return systems;
    }
    async function updateUserDisplayNameFor({ systems, store }) {
      return new Promise((resolve) => setTimeout(async () => {
        const updates = [];
        for (const sys of systems) {
          updates.push(store.partialUpdate({
            url: sys.url,
            client: sys.client,
            update: { userDisplayName: sys.userDisplayName }
          }));
        }
        await ux_common_utils_1.allSettled(updates);
        resolve();
      }, 0));
    }
    function postConnectionCallbackCreator(system) {
      if (!system.isScp()) {
        return void 0;
      }
      let cb;
      if (system.unSaved) {
        cb = {
          sync: true,
          updateUserInfo: !system.userDisplayName,
          fn: ({ user, refreshToken }) => {
            !!user && system.setUserDisplayName.bind(system)(user);
            !!refreshToken && system.setRefreshToken.bind(system)(refreshToken);
          }
        };
      } else {
        cb = {
          sync: false,
          updateUserInfo: !system.userDisplayName,
          fn: async ({ user, refreshToken }) => {
            if (user || refreshToken) {
              const update = {};
              !!user && (update.userDisplayName = user);
              !!refreshToken && (update.refreshToken = refreshToken);
              return (await systemStore_1.getSystemStore()).partialUpdate({
                url: system.url,
                client: system.client,
                update
              });
            }
          }
        };
      }
      return cb;
    }
    async function isSystemNameInUse(name) {
      const systems = await (await systemStore_1.getSystemStore()).getAll();
      const sys = name.trim();
      return Object.values(systems).findIndex((system) => system.name === sys || system.bareName === sapSystem_1.stripOldSCPSuffix(sys)) !== -1;
    }
    exports2.isSystemNameInUse = isSystemNameInUse;
    async function getSapSystem(url, client) {
      if (ux_common_utils_1.isAppStudio()) {
        throw Error("Not supported in AppStudio.");
      } else {
        return (await systemStore_1.getSystemStore()).get(url, client);
      }
    }
    exports2.getSapSystem = getSapSystem;
    function newSapSystem(name, url, client, credentials, unSaved = false) {
      const userDisplayName = unSaved ? credentials == null ? void 0 : credentials.username : void 0;
      return new sapSystem_1.SapSystem(name, { url, client }, credentials, userDisplayName, unSaved, postConnectionCallbackCreator);
    }
    exports2.newSapSystem = newSapSystem;
    function newSapSystemForServiceUrl(urlString) {
      const url = new url_1.URL(urlString);
      return {
        system: newSapSystem("temp", url.origin, url.searchParams.get("sap-client")),
        servicePath: url.pathname,
        search: url.search
      };
    }
    exports2.newSapSystemForServiceUrl = newSapSystemForServiceUrl;
    function newSapSystemForSteampunk(name, serviceKey, unSaved = false) {
      const service = typeof serviceKey === "string" ? JSON.parse(serviceKey) : serviceKey;
      const config = {
        url: service.url,
        scp: true
      };
      return new sapSystem_1.SapSystem(name, config, { serviceKeysContents: service }, void 0, unSaved, postConnectionCallbackCreator);
    }
    exports2.newSapSystemForSteampunk = newSapSystemForSteampunk;
    function newS4HCSystem({ name, url, unSaved = false }) {
      return new sapSystem_1.SapSystem(name, { url, authenticationType: __1.AuthenticationType.ReentranceTicket }, void 0, void 0, unSaved, postConnectionCallbackCreator);
    }
    exports2.newS4HCSystem = newS4HCSystem;
    function newSapSystemForDestinaton({ destination, destinationInstance, destinationAuthType, credentials }) {
      return new sapSystem_1.SapSystem(destination, { destination, destinationAuthType, destinationInstance }, credentials, void 0, false);
    }
    exports2.newSapSystemForDestinaton = newSapSystemForDestinaton;
    async function saveSapSystem(system) {
      const store = await systemStore_1.getSystemStore();
      await store.save(system);
    }
    exports2.saveSapSystem = saveSapSystem;
    async function deleteSapSystem(system) {
      const store = await systemStore_1.getSystemStore();
      return store.delete(system);
    }
    exports2.deleteSapSystem = deleteSapSystem;
  }
});

// ../lib/odata-client/dist/index.js
var require_dist5 = __commonJS({
  "../lib/odata-client/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_client2(), exports2);
    __exportStar(require_utils7(), exports2);
    __exportStar(require_config(), exports2);
    __exportStar(require_connection(), exports2);
    __exportStar(require_api_hub(), exports2);
    __exportStar(require_system3(), exports2);
  }
});

// ../lib/ui5-info/core/dist/types.js
var require_types4 = __commonJS({
  "../lib/ui5-info/core/dist/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.inMaintenance = exports2.minUI5VersionForLocalDev = exports2.FioriElementsVersion = exports2.UI5Info = void 0;
    var UI5Info;
    (function(UI5Info2) {
      UI5Info2["OfficialUrl"] = "https://ui5.sap.com";
      UI5Info2["SnapshotUrl"] = "https://sapui5preview-sapui5.dispatcher.int.sap.eu2.hana.ondemand.com";
      UI5Info2["VersionsFile"] = "neo-app.json";
      UI5Info2["DefaultVersion"] = "Latest";
      UI5Info2["LatestVersionString"] = "Latest";
      UI5Info2["VersionsOverview"] = "versionoverview.json";
      UI5Info2["VersionExternalFile"] = "version.json";
    })(UI5Info = exports2.UI5Info || (exports2.UI5Info = {}));
    var FioriElementsVersion;
    (function(FioriElementsVersion2) {
      FioriElementsVersion2["v2"] = "v2";
      FioriElementsVersion2["v4"] = "v4";
    })(FioriElementsVersion = exports2.FioriElementsVersion || (exports2.FioriElementsVersion = {}));
    exports2.minUI5VersionForLocalDev = "1.79.0";
    exports2.inMaintenance = "Maintenance";
  }
});

// ../lib/ui5-info/core/dist/ui5-info.js
var require_ui5_info = __commonJS({
  "../lib/ui5-info/core/dist/ui5-info.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getSpecTagVersion = exports2.getLatestSapui5Version = exports2.getSapSystemUI5Version = exports2.uI5VersionsWithCodeAssist = exports2.getDefaultTheme = exports2.getUi5Themes = exports2.getUI5VersionsEnhanced = exports2.retrieveUI5Versions = exports2.retrieveUI5VersionsCache = exports2.parseUI5VersionsOverview = exports2.parseUI5Versions = exports2.requestUI5Versions = exports2.getManifestVersion = exports2.ui5VersionsCache = exports2.UI5_VERSIONS_TYPE = exports2.ThemeIds = exports2.MIN_UI5_VERSION_FPM_TEMPLATE = exports2.MIN_UI5_VERSION_OVERVIEW_V4_TEMPLATE = exports2.MIN_UI5_VERSION_FORM_ENTRY_TEMPLATE = exports2.MIN_UI5_VERSION_WORKLIST_V4_TEMPLATE = exports2.MIN_UI5_VERSION_ALP_V4_TEMPLATE = exports2.MIN_UI5_VERSION = exports2.MIN_UI5_VERSION_V4_TEMPLATE = void 0;
    var semver_compare_1 = __importDefault(require_semver_compare());
    var semver_1 = require_semver5();
    var ux_odata_client_1 = require_dist5();
    var types_1 = require_types4();
    var commandRunner_1 = require_commandRunner();
    var axios_1 = __importDefault(require_axios2());
    var https_1 = __importDefault(require("https"));
    exports2.MIN_UI5_VERSION_V4_TEMPLATE = "1.84.0";
    exports2.MIN_UI5_VERSION = "1.65.0";
    exports2.MIN_UI5_VERSION_ALP_V4_TEMPLATE = "1.90.0";
    exports2.MIN_UI5_VERSION_WORKLIST_V4_TEMPLATE = "1.99.0";
    exports2.MIN_UI5_VERSION_FORM_ENTRY_TEMPLATE = "1.90.0";
    exports2.MIN_UI5_VERSION_OVERVIEW_V4_TEMPLATE = "1.96.8";
    exports2.MIN_UI5_VERSION_FPM_TEMPLATE = "1.94.0";
    var MIN_UI5_VERSION_V2_TEMPLATE = "1.76.0";
    var MIN_UI5_DARK_THEME = "1.72.0";
    var MIN_UI5_VERSION_HORIZON_THEME = "1.102.0";
    var MIN_UI5_VERSION_CODE_ASSIST = "1.76.0";
    var DEFAULT_UI5_VERSIONS = [
      "Latest",
      "1.104.0",
      "1.103.0",
      "1.102.0",
      "1.101.0",
      "1.100.0",
      "1.99.0",
      "1.98.0",
      "1.97.0",
      "1.96.0",
      "1.95.0",
      "1.94.0",
      "1.93.0",
      "1.92.0",
      "1.91.0",
      "1.90.0",
      "1.89.0",
      "1.88.0",
      "1.87.0",
      "1.86.0",
      "1.85.0",
      "1.84.0",
      "1.82.0",
      "1.81.0",
      "1.80.0",
      "1.79.0",
      "1.78.0",
      "1.77.0",
      "1.76.0",
      "1.75.0",
      "1.74.0",
      "1.73.0",
      "1.72.0",
      "1.71.0",
      "1.70.0",
      "1.69.0",
      "1.68.0",
      "1.67.0",
      "1.66.0",
      exports2.MIN_UI5_VERSION
    ];
    var VERSION_OVERVIEW_FALLBACK = [
      { version: "1.104.*", support: "Maintenance" },
      { version: "1.103.*", support: "Out of maintenance" },
      { version: "1.102.*", support: "Maintenance" },
      { version: "1.101.*", support: "Out of maintenance" },
      { version: "1.100.*", support: "Out of maintenance" },
      { version: "1.99.*", support: "Out of maintenance" },
      { version: "1.98.*", support: "Out of maintenance" },
      { version: "1.97.*", support: "Out of maintenance" },
      { version: "1.96.*", support: "Maintenance" },
      { version: "1.95.*", support: "Out of maintenance" },
      { version: "1.94.*", support: "Out of maintenance" },
      { version: "1.93.*", support: "Out of maintenance" },
      { version: "1.92.*", support: "Out of maintenance" },
      { version: "1.91.*", support: "Out of maintenance" },
      { version: "1.90.*", support: "Out of maintenance" },
      { version: "1.89.*", support: "Out of maintenance" },
      { version: "1.88.*", support: "Out of maintenance" },
      { version: "1.87.*", support: "Out of maintenance" },
      { version: "1.86.*", support: "Out of maintenance" },
      { version: "1.85.*", support: "Out of maintenance" },
      { version: "1.84.*", support: "Maintenance" },
      { version: "1.83.*", support: "Skipped" },
      { version: "1.82.*", support: "Out of maintenance" },
      { version: "1.81.*", support: "Out of maintenance" },
      { version: "1.80.*", support: "Out of maintenance" },
      { version: "1.79.*", support: "Out of maintenance" },
      { version: "1.78.*", support: "Out of maintenance" },
      { version: "1.77.*", support: "Out of maintenance" },
      { version: "1.76.*", support: "Out of maintenance" },
      { version: "1.75.*", support: "Out of maintenance" },
      { version: "1.74.*", support: "Out of maintenance" },
      { version: "1.73.*", support: "Out of maintenance" },
      { version: "1.72.*", support: "Out of maintenance" },
      { version: "1.71.*", support: "Maintenance" },
      { version: "1.70.*", support: "Out of maintenance" },
      { version: "1.69.*", support: "Out of maintenance" },
      { version: "1.68.*", support: "Out of maintenance" },
      { version: "1.67.*", support: "Out of maintenance" },
      { version: "1.66.*", support: "Out of maintenance" },
      { version: "1.65.*", support: "Out of maintenance" },
      { version: "1.64.*", support: "Out of maintenance" },
      { version: "1.63.*", support: "Out of maintenance" },
      { version: "1.62.*", support: "Out of maintenance" },
      { version: "1.61.*", support: "Out of maintenance" },
      { version: "1.60.*", support: "Out of maintenance" },
      { version: "1.58.*", support: "Out of maintenance" },
      { version: "1.56.*", support: "Out of maintenance" },
      { version: "1.54.*", support: "Out of maintenance" },
      { version: "1.52.*", support: "Out of maintenance" },
      { version: "1.50.*", support: "Out of maintenance" },
      { version: "1.48.*", support: "Out of maintenance" },
      { version: "1.46.*", support: "Out of maintenance" },
      { version: "1.44.*", support: "Out of maintenance" },
      { version: "1.42.*", support: "Out of maintenance" },
      { version: "1.40.*", support: "Out of maintenance" },
      { version: "1.38.*", support: "Maintenance" },
      { version: "1.36.*", support: "Out of maintenance" },
      { version: "1.34.*", support: "Out of maintenance" },
      { version: "1.32.*", support: "Out of maintenance" },
      { version: "1.30.*", support: "Out of maintenance" },
      { version: "1.28.*", support: "Out of maintenance" },
      { version: "1.26.*", support: "Out of maintenance" },
      { version: "1.24.*", support: "Out of maintenance" },
      { version: "1.22.*", support: "Out of maintenance" },
      { version: "*", support: "Out of maintenance" }
    ];
    var ThemeIds;
    (function(ThemeIds2) {
      ThemeIds2["SAP_BELIZE"] = "sap_belize";
      ThemeIds2["SAP_FIORI_3"] = "sap_fiori_3";
      ThemeIds2["SAP_FIORI_3_DARK"] = "sap_fiori_3_dark";
      ThemeIds2["SAP_HORIZON"] = "sap_horizon";
      ThemeIds2["SAP_HORIZON_DARK"] = "sap_horizon_dark";
      ThemeIds2["SAP_HORIZON_CONTRAST"] = "sap_horizon_hcw";
      ThemeIds2["SAP_HORIZON_CONTRAST_DARK"] = "sap_horizon_hcb";
    })(ThemeIds = exports2.ThemeIds || (exports2.ThemeIds = {}));
    var THEMES = [
      {
        themeid: "sap_belize",
        label: "Belize"
      },
      {
        themeid: "sap_fiori_3",
        label: "Quartz Light"
      },
      {
        themeid: "sap_fiori_3_dark",
        label: "Quartz Dark"
      },
      {
        themeid: "sap_horizon",
        label: "Morning Horizon"
      },
      {
        themeid: "sap_horizon_dark",
        label: "Evening Horizon"
      }
    ];
    var LATEST_MANIFEST_VERSION = "1.32.0";
    var manifestVersions = {
      "1.30": "1.1.0",
      "1.32": "1.2.0",
      "1.34": "1.3.0",
      "1.38": "1.4.0",
      "1.42": "1.5.0",
      "1.46": "1.6.0",
      "1.48": "1.7.0",
      "1.50": "1.8.0",
      "1.52": "1.9.0",
      "1.54": "1.10.0",
      "1.56": "1.11.0",
      "1.58": "1.12.0",
      "1.61": "1.13.0",
      "1.62": "1.14.0",
      "1.66": "1.15.0",
      "1.70": "1.16.0",
      "1.71": "1.17.0",
      "1.74": "1.18.0",
      "1.75": "1.19.0",
      "1.76": "1.20.0",
      "1.77": "1.21.0",
      "1.78": "1.22.0",
      "1.79": "1.23.0",
      "1.80": "1.24.0",
      "1.81": "1.25.0",
      "1.82": "1.26.0",
      "1.83": "1.27.0",
      "1.84": "1.28.0",
      "1.85": "1.29.0",
      "1.86": "1.30.0",
      "1.87": "1.31.0",
      "1.88": LATEST_MANIFEST_VERSION
    };
    var consoleLogger3 = {
      warning: (message) => {
        console.warn(message);
      },
      error: (message) => {
        console.error(message);
      }
    };
    var PASS_THROUGH_STRINGS = /* @__PURE__ */ new Set(["snapshot", "snapshot-untested", "Latest"]);
    var latestUI5Version;
    var UI5_VERSIONS_TYPE;
    (function(UI5_VERSIONS_TYPE2) {
      UI5_VERSIONS_TYPE2["official"] = "officialVersions";
      UI5_VERSIONS_TYPE2["snapshot"] = "snapshotsVersions";
      UI5_VERSIONS_TYPE2["overview"] = "overview";
    })(UI5_VERSIONS_TYPE = exports2.UI5_VERSIONS_TYPE || (exports2.UI5_VERSIONS_TYPE = {}));
    exports2.ui5VersionsCache = {
      officialVersions: [],
      snapshotsVersions: [],
      overview: []
    };
    function getManifestVersion(ui5Version) {
      const isSnapshot = ui5Version.includes("snapshot");
      ui5Version = ui5Version.replace("snapshot-", "");
      ui5Version = ui5Version.replace("snapshot", "");
      const manifestKeys = Object.keys(manifestVersions).sort(semver_compare_1.default);
      let matchedVersion;
      if (ui5Version && ui5Version !== "Latest") {
        for (const [, v] of manifestKeys.entries()) {
          if (ui5Version >= v) {
            matchedVersion = v;
          }
        }
      }
      if (!matchedVersion) {
        if (isSnapshot) {
          matchedVersion = LATEST_MANIFEST_VERSION;
        } else {
          matchedVersion = latestUI5Version !== void 0 ? latestUI5Version.substring(0, 4) : LATEST_MANIFEST_VERSION;
        }
      }
      return manifestVersions[matchedVersion] || LATEST_MANIFEST_VERSION;
    }
    exports2.getManifestVersion = getManifestVersion;
    function snapshotSort(a, b) {
      a = a.replace("snapshot-", "");
      b = b.replace("snapshot-", "");
      const versions = ["Latest", "snapshot", "untested"];
      if (versions.indexOf(a) > -1 && versions.indexOf(b) > -1) {
        return a.localeCompare(b);
      }
      if (versions.indexOf(a) > -1 || versions.indexOf(b) > -1) {
        return semver_compare_1.default(a, b);
      }
      return semver_compare_1.default(b + ".999", a + ".999");
    }
    function filterNewerEqual(versions, minVersion) {
      return versions.filter((version) => {
        if (PASS_THROUGH_STRINGS.has(version)) {
          return true;
        } else if (version.startsWith("snapshot-")) {
          version = version.replace("snapshot-", "");
        }
        return semver_compare_1.default(version, minVersion) >= 0;
      });
    }
    async function requestUI5Versions(url, service = `/${"neo-app.json"}`) {
      const { system } = ux_odata_client_1.newSapSystemForServiceUrl(url);
      system.config.service = service;
      const odataClient = new ux_odata_client_1.ODataClient({
        system: system.config,
        autoAddTrailingSlash: false,
        timeout: 4e3
      });
      return odataClient.get();
    }
    exports2.requestUI5Versions = requestUI5Versions;
    async function parseUI5Versions(url) {
      const response = await requestUI5Versions(url);
      const result2 = JSON.parse(JSON.stringify(response)).routes.map((route) => {
        if (route.path === "/") {
          latestUI5Version = route.target.version;
        }
        return route.path === "/" ? "Latest" : route.target.version;
      });
      return result2;
    }
    exports2.parseUI5Versions = parseUI5Versions;
    async function parseUI5VersionsOverview() {
      let result2 = [];
      let versions = [];
      try {
        const response = await requestUI5Versions("https://ui5.sap.com", `/${"versionoverview.json"}`);
        versions = JSON.parse(JSON.stringify(response)).versions;
      } catch (error3) {
        console.warn(`Request to '${"https://ui5.sap.com"}' failed. Error was: '${error3.message}'. Fallback to default UI5 versions`);
        versions = VERSION_OVERVIEW_FALLBACK;
      }
      result2 = versions.map((ver) => {
        var _a2;
        const parsedVersion = (_a2 = semver_1.coerce(ver.version)) == null ? void 0 : _a2.version;
        if (parsedVersion !== void 0) {
          return {
            version: parsedVersion,
            support: ver.support
          };
        }
      });
      return result2;
    }
    exports2.parseUI5VersionsOverview = parseUI5VersionsOverview;
    var retrieveUI5VersionsCache = async (type, useCache = false) => {
      if (!useCache) {
        switch (type) {
          case "officialVersions":
            return parseUI5Versions("https://ui5.sap.com");
          case "snapshotsVersions":
            return parseUI5Versions("https://sapui5preview-sapui5.dispatcher.int.sap.eu2.hana.ondemand.com");
          case "overview":
            return parseUI5VersionsOverview();
        }
      }
      if (exports2.ui5VersionsCache[type].length === 0) {
        switch (type) {
          case "officialVersions":
            exports2.ui5VersionsCache[type] = await parseUI5Versions("https://ui5.sap.com");
            break;
          case "snapshotsVersions":
            exports2.ui5VersionsCache[type] = await parseUI5Versions("https://sapui5preview-sapui5.dispatcher.int.sap.eu2.hana.ondemand.com");
            break;
          case "overview":
            exports2.ui5VersionsCache[type] = await parseUI5VersionsOverview();
            break;
        }
      }
      return exports2.ui5VersionsCache[type];
    };
    exports2.retrieveUI5VersionsCache = retrieveUI5VersionsCache;
    async function retrieveUI5Versions(filterOptions, logger = consoleLogger3, returnLatestValue) {
      let officialVersions = [];
      let snapshotVersions = [];
      try {
        officialVersions = (filterOptions == null ? void 0 : filterOptions.onlyNpmVersion) ? await retrieveNpmUI5Versions(filterOptions.fioriElementsVersion || "v2", filterOptions.ui5SelectedVersion) : await exports2.retrieveUI5VersionsCache("officialVersions", filterOptions == null ? void 0 : filterOptions.useCache);
      } catch (error3) {
        logger.warning(`Request to '${"https://ui5.sap.com"}' failed. Error was: '${error3.message}'. Fallback to default UI5 versions`);
        officialVersions = DEFAULT_UI5_VERSIONS.slice();
      }
      if (filterOptions == null ? void 0 : filterOptions.includeSnapshots) {
        try {
          snapshotVersions = await exports2.retrieveUI5VersionsCache("snapshotsVersions", filterOptions == null ? void 0 : filterOptions.useCache);
        } catch (error3) {
          logger.error(`Request to '${"https://sapui5preview-sapui5.dispatcher.int.sap.eu2.hana.ondemand.com"}' failed.  Error was: '${error3.message}'`);
        }
      }
      let versions = [...officialVersions, ...snapshotVersions].sort(snapshotSort);
      if (filterOptions == null ? void 0 : filterOptions.minSupportedUI5Version) {
        versions = filterNewerEqual(versions, filterOptions == null ? void 0 : filterOptions.minSupportedUI5Version);
      } else if ((filterOptions == null ? void 0 : filterOptions.fioriElementsVersion) && filterOptions.fioriElementsVersion === "v4") {
        versions = filterNewerEqual(versions, exports2.MIN_UI5_VERSION_V4_TEMPLATE);
      } else {
        versions = filterNewerEqual(versions, exports2.MIN_UI5_VERSION);
      }
      if (filterOptions == null ? void 0 : filterOptions.onlyVersionNumbers) {
        versions = versions.filter((ele) => ele && /^\d+(\.\d+)*$/.test(ele));
      }
      if (returnLatestValue && versions[0].includes("Latest")) {
        versions[0] = latestUI5Version;
      }
      return (filterOptions == null ? void 0 : filterOptions.removeDuplicateVersions) === true ? [...new Set(versions)] : versions;
    }
    exports2.retrieveUI5Versions = retrieveUI5Versions;
    async function getUI5VersionsEnhanced(filterOptions) {
      let filteredUI5Versions;
      try {
        filteredUI5Versions = await retrieveUI5Versions(filterOptions, void 0, true);
      } catch (error3) {
        console.warn(`Request to '${"https://ui5.sap.com"}' failed. Error was: '${error3.message}'. Fallback to default UI5 versions`);
        filteredUI5Versions = DEFAULT_UI5_VERSIONS.slice();
      }
      const defaultUI5Version = filteredUI5Versions[0];
      if (!(filterOptions == null ? void 0 : filterOptions.includeSnapshots)) {
        filteredUI5Versions = sortUI5Versions(filteredUI5Versions);
      }
      let ui5VersionsOverview = void 0;
      if ((filterOptions == null ? void 0 : filterOptions.groupUI5Versions) === true) {
        ui5VersionsOverview = await exports2.retrieveUI5VersionsCache("overview", filterOptions == null ? void 0 : filterOptions.useCache);
      }
      return filteredUI5Versions.map((ui5) => {
        const ui5Version = {
          name: ui5,
          value: ui5,
          version: {
            semantic: ui5,
            default: defaultUI5Version === ui5
          }
        };
        if ((filterOptions == null ? void 0 : filterOptions.groupUI5Versions) === true && ui5VersionsOverview !== void 0) {
          ui5Version.version.maintained = ui5VersionsOverview.some((v) => {
            if (v !== void 0) {
              return `${semver_1.major(v.version)}.${semver_1.minor(v.version)}` === `${semver_1.major(ui5)}.${semver_1.minor(ui5)}` && v.support === types_1.inMaintenance;
            }
          });
        }
        return ui5Version;
      });
    }
    exports2.getUI5VersionsEnhanced = getUI5VersionsEnhanced;
    function getUi5Themes(ui5Version = "Latest") {
      let filteredUi5Version = ui5Version.replace("snapshot-", "");
      filteredUi5Version = zeroExtendUI5Version(filteredUi5Version);
      const filteredThemes = [];
      for (const theme of THEMES) {
        switch (theme.themeid) {
          case "sap_belize":
          case "sap_fiori_3":
            filteredThemes.push(theme);
            break;
          case "sap_fiori_3_dark":
            (ui5VersionCheck(filteredUi5Version) || semver_compare_1.default(filteredUi5Version, MIN_UI5_DARK_THEME) >= 0) && filteredThemes.push(theme);
            break;
          case "sap_horizon":
          case "sap_horizon_dark":
          case "sap_horizon_hcw":
          case "sap_horizon_hcb":
            (ui5VersionCheck(filteredUi5Version) || semver_compare_1.default(filteredUi5Version, MIN_UI5_VERSION_HORIZON_THEME) >= 0) && filteredThemes.push(theme);
            break;
        }
      }
      return filteredThemes;
    }
    exports2.getUi5Themes = getUi5Themes;
    function getDefaultTheme(ui5Version) {
      if (ui5Version) {
        if (semver_1.coerce(ui5Version) && semver_1.lt(ui5Version, MIN_UI5_VERSION_HORIZON_THEME)) {
          return "sap_fiori_3";
        }
      }
      return "sap_horizon";
    }
    exports2.getDefaultTheme = getDefaultTheme;
    function zeroExtendUI5Version(ui5Version) {
      const versionParts = ui5Version.split(".");
      if (versionParts.length < 3 && !ui5VersionCheck(ui5Version)) {
        ui5Version = ui5Version.concat(".0");
      }
      return ui5Version;
    }
    function ui5VersionCheck(ui5version) {
      return ui5version === "Latest" || ui5version === "untested" || ui5version === "snapshot";
    }
    function sortUI5Versions(ui5Versions) {
      return ui5Versions.filter(Boolean).sort((a, b) => {
        const a1 = a.split(".");
        const b1 = b.split(".");
        const len = Math.max(a1.length, b1.length);
        for (let i = 0; i < len; i++) {
          const _a2 = +a1[i] || 0;
          const _b = +b1[i] || 0;
          if (_a2 === _b) {
            continue;
          } else {
            return _a2 > _b ? 1 : -1;
          }
        }
        return 0;
      }).reverse();
    }
    function uI5VersionsWithCodeAssist(versions, ui5Version) {
      return filterNewerEqual(versions, MIN_UI5_VERSION_CODE_ASSIST).includes(ui5Version) || ui5Version === "Latest";
    }
    exports2.uI5VersionsWithCodeAssist = uI5VersionsWithCodeAssist;
    async function retrieveNpmUI5Versions(fioriElementsVersion, ui5SelectedVersion = void 0) {
      const defaultMinVersion = fioriElementsVersion === "v2" ? MIN_UI5_VERSION_V2_TEMPLATE : exports2.MIN_UI5_VERSION_V4_TEMPLATE;
      let results = [];
      try {
        const runner = new commandRunner_1.CommandRunner();
        const npm = process.platform === "win32" ? "npm.cmd" : "npm";
        const npmVersions = await runner.run(npm, ["show", "@sapui5/distribution-metadata", "versions", "--no-color"]);
        results = npmVersions.replace(/[\r?\n|\r[\] ']/g, "").trim().split(",");
      } catch (e) {
        results = DEFAULT_UI5_VERSIONS.slice();
      }
      const sortedUI5Versions = sortUI5Versions(results);
      const versions = filterNewerEqual(sortedUI5Versions, defaultMinVersion);
      let latestVersions = versions.length ? versions.filter((ele) => ele && /^\d+(\.\d+)*$/.test(ele)) : [defaultMinVersion];
      if (ui5SelectedVersion && ui5SelectedVersion.length) {
        const latestMinIdx = latestVersions.findIndex((v) => v === ui5SelectedVersion);
        if (latestMinIdx === -1) {
          if (ui5SelectedVersion < latestVersions.slice(-1)[0]) {
            latestVersions = latestVersions.slice(-1);
          }
        } else {
          latestVersions = latestVersions.slice(latestMinIdx);
        }
      }
      return latestVersions;
    }
    async function getSapSystemUI5Version(sapSystemHost, rejectUnauthorized = false) {
      if (!sapSystemHost) {
        return void 0;
      }
      const url = new URL("/sap/public/bc/ui5_ui5/bootstrap_info.json", sapSystemHost).toString();
      let version = "";
      try {
        const response = await axios_1.default.get(url, {
          httpsAgent: new https_1.default.Agent({
            rejectUnauthorized
          })
        });
        if (response.status === 200) {
          const versionInfo = response.data;
          version = versionInfo.Version;
        }
      } catch {
      }
      return version;
    }
    exports2.getSapSystemUI5Version = getSapSystemUI5Version;
    async function getLatestSapui5Version() {
      var _a2;
      let version = void 0;
      try {
        const requestUrl = `${"https://ui5.sap.com"}/${"version.json"}`;
        const response = await axios_1.default.get(requestUrl);
        if (response.status === 200) {
          const ui5Versions = response.data;
          version = (_a2 = ui5Versions == null ? void 0 : ui5Versions.latest) == null ? void 0 : _a2.version;
        }
      } catch {
        version = void 0;
      }
      return version;
    }
    exports2.getLatestSapui5Version = getLatestSapui5Version;
    function getSpecTagVersion(ui5Version) {
      if (ui5Version) {
        if (semver_1.valid(ui5Version)) {
          return `UI5-${semver_1.major(ui5Version)}.${semver_1.minor(ui5Version)}`;
        } else if (ui5Version.includes("snapshot") && ui5Version.includes(".")) {
          const snapshotVersion = ui5Version.split("snapshot-")[1];
          return `UI5-${snapshotVersion}`;
        }
      }
      return "latest";
    }
    exports2.getSpecTagVersion = getSpecTagVersion;
  }
});

// ../lib/ui5-info/core/dist/index.js
var require_dist6 = __commonJS({
  "../lib/ui5-info/core/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UI5Info = exports2.minUI5VersionForLocalDev = exports2.FioriElementsVersion = exports2.getSpecTagVersion = exports2.getLatestSapui5Version = exports2.parseUI5VersionsOverview = exports2.getUI5VersionsEnhanced = exports2.getSapSystemUI5Version = exports2.parseUI5Versions = exports2.uI5VersionsWithCodeAssist = exports2.getManifestVersion = exports2.getDefaultTheme = exports2.getUi5Themes = exports2.retrieveUI5Versions = exports2.MIN_UI5_VERSION_FPM_TEMPLATE = exports2.MIN_UI5_VERSION_OVERVIEW_V4_TEMPLATE = exports2.MIN_UI5_VERSION_WORKLIST_V4_TEMPLATE = exports2.MIN_UI5_VERSION_FORM_ENTRY_TEMPLATE = exports2.MIN_UI5_VERSION_ALP_V4_TEMPLATE = exports2.MIN_UI5_VERSION = exports2.MIN_UI5_VERSION_V4_TEMPLATE = exports2.CommandRunner = void 0;
    var commandRunner_1 = require_commandRunner();
    Object.defineProperty(exports2, "CommandRunner", { enumerable: true, get: function() {
      return commandRunner_1.CommandRunner;
    } });
    var ui5_info_1 = require_ui5_info();
    Object.defineProperty(exports2, "MIN_UI5_VERSION_V4_TEMPLATE", { enumerable: true, get: function() {
      return ui5_info_1.MIN_UI5_VERSION_V4_TEMPLATE;
    } });
    Object.defineProperty(exports2, "MIN_UI5_VERSION", { enumerable: true, get: function() {
      return ui5_info_1.MIN_UI5_VERSION;
    } });
    Object.defineProperty(exports2, "MIN_UI5_VERSION_ALP_V4_TEMPLATE", { enumerable: true, get: function() {
      return ui5_info_1.MIN_UI5_VERSION_ALP_V4_TEMPLATE;
    } });
    Object.defineProperty(exports2, "MIN_UI5_VERSION_FORM_ENTRY_TEMPLATE", { enumerable: true, get: function() {
      return ui5_info_1.MIN_UI5_VERSION_FORM_ENTRY_TEMPLATE;
    } });
    Object.defineProperty(exports2, "MIN_UI5_VERSION_WORKLIST_V4_TEMPLATE", { enumerable: true, get: function() {
      return ui5_info_1.MIN_UI5_VERSION_WORKLIST_V4_TEMPLATE;
    } });
    Object.defineProperty(exports2, "MIN_UI5_VERSION_OVERVIEW_V4_TEMPLATE", { enumerable: true, get: function() {
      return ui5_info_1.MIN_UI5_VERSION_OVERVIEW_V4_TEMPLATE;
    } });
    Object.defineProperty(exports2, "MIN_UI5_VERSION_FPM_TEMPLATE", { enumerable: true, get: function() {
      return ui5_info_1.MIN_UI5_VERSION_FPM_TEMPLATE;
    } });
    Object.defineProperty(exports2, "retrieveUI5Versions", { enumerable: true, get: function() {
      return ui5_info_1.retrieveUI5Versions;
    } });
    Object.defineProperty(exports2, "getUi5Themes", { enumerable: true, get: function() {
      return ui5_info_1.getUi5Themes;
    } });
    Object.defineProperty(exports2, "getDefaultTheme", { enumerable: true, get: function() {
      return ui5_info_1.getDefaultTheme;
    } });
    Object.defineProperty(exports2, "getManifestVersion", { enumerable: true, get: function() {
      return ui5_info_1.getManifestVersion;
    } });
    Object.defineProperty(exports2, "uI5VersionsWithCodeAssist", { enumerable: true, get: function() {
      return ui5_info_1.uI5VersionsWithCodeAssist;
    } });
    Object.defineProperty(exports2, "parseUI5Versions", { enumerable: true, get: function() {
      return ui5_info_1.parseUI5Versions;
    } });
    Object.defineProperty(exports2, "getSapSystemUI5Version", { enumerable: true, get: function() {
      return ui5_info_1.getSapSystemUI5Version;
    } });
    Object.defineProperty(exports2, "getUI5VersionsEnhanced", { enumerable: true, get: function() {
      return ui5_info_1.getUI5VersionsEnhanced;
    } });
    Object.defineProperty(exports2, "parseUI5VersionsOverview", { enumerable: true, get: function() {
      return ui5_info_1.parseUI5VersionsOverview;
    } });
    Object.defineProperty(exports2, "getLatestSapui5Version", { enumerable: true, get: function() {
      return ui5_info_1.getLatestSapui5Version;
    } });
    Object.defineProperty(exports2, "getSpecTagVersion", { enumerable: true, get: function() {
      return ui5_info_1.getSpecTagVersion;
    } });
    var types_1 = require_types4();
    Object.defineProperty(exports2, "FioriElementsVersion", { enumerable: true, get: function() {
      return types_1.FioriElementsVersion;
    } });
    Object.defineProperty(exports2, "minUI5VersionForLocalDev", { enumerable: true, get: function() {
      return types_1.minUI5VersionForLocalDev;
    } });
    Object.defineProperty(exports2, "UI5Info", { enumerable: true, get: function() {
      return types_1.UI5Info;
    } });
  }
});

// ../lib/project-access/core/dist/project/ui5Config/yamlFile.js
var require_yamlFile = __commonJS({
  "../lib/project-access/core/dist/project/ui5Config/yamlFile.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getParsedUi5YamlConfig = exports2.readUi5YamlConfig = void 0;
    var path_1 = require("path");
    var yaml = __importStar(require_Yaml());
    var file_1 = require_file2();
    var i18n_1 = require_i18n2();
    async function readUi5YamlConfig(dirPath, filename) {
      const filePath = path_1.join(dirPath, filename);
      if (await file_1.fileExists(filePath)) {
        return file_1.readFile(filePath);
      }
      return null;
    }
    exports2.readUi5YamlConfig = readUi5YamlConfig;
    async function getParsedUi5YamlConfig(dirPath, filename) {
      var _a2;
      const contents = await readUi5YamlConfig(dirPath, filename);
      if (contents) {
        try {
          const parsed = yaml.parse(contents);
          if (((_a2 = parsed == null ? void 0 : parsed.server) == null ? void 0 : _a2.customMiddleware) && Array.isArray(parsed.server.customMiddleware)) {
            for (const middleware of parsed.server.customMiddleware) {
              const configuration = middleware == null ? void 0 : middleware.configuration;
              const services = [];
              if (Array.isArray(configuration == null ? void 0 : configuration.service)) {
                services.push(...configuration.service);
              } else if (configuration == null ? void 0 : configuration.service) {
                services.push(configuration.service);
              }
              if (Array.isArray(configuration == null ? void 0 : configuration.services)) {
                services.push(...configuration.services);
              } else if (configuration == null ? void 0 : configuration.services) {
                services.push(configuration.services);
              }
              for (const service of services) {
                if (service.mockdataRootPath) {
                  service.mockdataPath = service.mockdataRootPath;
                }
                if (service.metadataXmlPath) {
                  service.metadataPath = service.metadataXmlPath;
                }
              }
            }
          }
          return parsed;
        } catch (e) {
          throw new Error(i18n_1.i18n.t("ERROR_UI5_YAML_PARSING", { filePath: path_1.join(dirPath, filename), parsingError: e.message }));
        }
      }
      return null;
    }
    exports2.getParsedUi5YamlConfig = getParsedUi5YamlConfig;
  }
});

// ../lib/project-access/core/dist/project/ui5Config/mockServer.js
var require_mockServer = __commonJS({
  "../lib/project-access/core/dist/project/ui5Config/mockServer.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.findMockServiceByMetadataPath = exports2.matchMockServiceByMetadataPath = exports2.getMockServicesConfiguration = exports2.getMockServerConfig = void 0;
    var path_1 = require("path");
    var project_spec_1 = require_dist3();
    var yamlFile_1 = require_yamlFile();
    var i18n_1 = require_i18n2();
    var file_1 = require_file2();
    async function getMockServerConfig(cfgFileDir, cfgFileName = project_spec_1.FileName.Ui5MockYaml) {
      var _a2;
      const ui5Config = await yamlFile_1.getParsedUi5YamlConfig(cfgFileDir, cfgFileName);
      const middlewares = (_a2 = ui5Config == null ? void 0 : ui5Config.server) == null ? void 0 : _a2.customMiddleware;
      if (middlewares) {
        let mockMW;
        const mockMWName = "sap-fe-mockserver";
        if (Array.isArray(middlewares)) {
          mockMW = middlewares.find((mw) => mw.name === mockMWName);
          return (mockMW == null ? void 0 : mockMW.configuration) || null;
        }
        const middleware = middlewares;
        if (middleware.name === mockMWName) {
          mockMW = middleware;
        }
        return (mockMW == null ? void 0 : mockMW.configuration) || null;
      }
      return null;
    }
    exports2.getMockServerConfig = getMockServerConfig;
    async function getMockServicesConfiguration(ui5CfgFileDir, mockServerConfig) {
      const { mockFolder } = mockServerConfig;
      if (mockFolder) {
        const services2 = await readDynamicMockServerConfig(ui5CfgFileDir, mockFolder);
        return {
          services: services2,
          mockFolder
        };
      }
      const staticConfig = mockServerConfig;
      const services = staticConfig.service ? staticConfig.service : staticConfig.services;
      return { services };
    }
    exports2.getMockServicesConfiguration = getMockServicesConfiguration;
    async function readDynamicMockServerConfig(yamlCfgDirPath, mockFolderPath) {
      const configDirPath = path_1.resolve(yamlCfgDirPath, mockFolderPath);
      const jsonConfigPath = path_1.join(configDirPath, "config.json");
      const moduleConfigPath = path_1.join(configDirPath, "config.js");
      const isJSON = await file_1.fileExists(jsonConfigPath);
      let services;
      try {
        if (isJSON) {
          services = await file_1.readJSON(jsonConfigPath);
        } else {
          const dynamicConfig = await Promise.resolve().then(() => __importStar(require(moduleConfigPath)));
          services = dynamicConfig == null ? void 0 : dynamicConfig.default;
        }
      } catch (e) {
        throw new Error(i18n_1.i18n.t("ERROR_UI5_YAML_DYNAMIC_CFG_IMPORT", {
          filePath: isJSON ? jsonConfigPath : moduleConfigPath,
          yamlFile: path_1.join(yamlCfgDirPath, project_spec_1.FileName.Ui5MockYaml)
        }));
      }
      return (services == null ? void 0 : services.length) ? services : null;
    }
    function matchMockServiceByMetadataPath(mockService, path) {
      const { metadataPath } = mockService;
      if (metadataPath) {
        return path.endsWith(path_1.normalize(metadataPath));
      }
      return false;
    }
    exports2.matchMockServiceByMetadataPath = matchMockServiceByMetadataPath;
    function findMockServiceByMetadataPath(services, metadataPath) {
      if (Array.isArray(services)) {
        for (const service of services) {
          if (matchMockServiceByMetadataPath(service, metadataPath)) {
            return service;
          }
        }
        return null;
      }
      if (services && matchMockServiceByMetadataPath(services, metadataPath)) {
        return services;
      }
      return null;
    }
    exports2.findMockServiceByMetadataPath = findMockServiceByMetadataPath;
  }
});

// ../lib/project-access/core/dist/project/ui5Config/index.js
var require_ui5Config = __commonJS({
  "../lib/project-access/core/dist/project/ui5Config/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getMockServicesConfiguration = exports2.getMockServerConfig = exports2.findMockServiceByMetadataPath = void 0;
    var mockServer_1 = require_mockServer();
    Object.defineProperty(exports2, "findMockServiceByMetadataPath", { enumerable: true, get: function() {
      return mockServer_1.findMockServiceByMetadataPath;
    } });
    Object.defineProperty(exports2, "getMockServerConfig", { enumerable: true, get: function() {
      return mockServer_1.getMockServerConfig;
    } });
    Object.defineProperty(exports2, "getMockServicesConfiguration", { enumerable: true, get: function() {
      return mockServer_1.getMockServicesConfiguration;
    } });
  }
});

// ../lib/project-access/core/dist/project/utils.js
var require_utils9 = __commonJS({
  "../lib/project-access/core/dist/project/utils.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.tryGetEdmxAppMockServiceMockdataDir = exports2.getEdmxAppDefaultMockdataDirPath = exports2.getCapAppMockdataDirPath = exports2.getApplicationId = exports2.deleteCapApp = exports2.isOVPProject = exports2.getAppIdForFile = exports2.checkServeLocalConfig = exports2.getUI5Version = exports2.getLocalUI5Version = exports2.getUi5CustomMiddleware = exports2.getVersionFromManifest = exports2.getProjectType = exports2.getProjectTypeFromProjectFiles = exports2.findI18nProperty = exports2.updateI18nProperties = exports2.updateI18nProperty = exports2.getI18nProperties = exports2.mergeI18nProperties = exports2.getI18nPath = exports2.readAppJson = exports2.getAppConfig = exports2.fillServiceSpecificationForApp = exports2.createApplicationStructureConfig = exports2.getMainService = exports2.findProjectRootsByDependency = exports2.isFioriToolsProject = exports2.checkPackageJson = exports2.findRunnableProjects = exports2.findAllApps = exports2.findRootsForPath = exports2.getDetailedProjectType = exports2.getAppType = exports2.findAllProjectRoots = exports2.hasDependency = exports2.findExtensionFiles = exports2.findLibrary = exports2.findProjectRoot = exports2.scriptsRegEx = void 0;
    var fs_1 = require("fs");
    var findit2_1 = __importDefault(require_findit2());
    var fast_xml_parser_1 = __importDefault(require_parser2());
    var project_spec_1 = require_dist3();
    var page_1 = require_page2();
    var find_up_1 = __importDefault(require_find_up());
    var path_1 = require("path");
    var i18n_1 = require_i18n2();
    var file_1 = require_file2();
    var yaml = __importStar(require_Yaml());
    var os_1 = __importDefault(require("os"));
    var capProject_1 = require_capProject();
    var webapp_1 = require_webapp2();
    var ux_ui5_info_1 = require_dist6();
    var ui5Config_1 = require_ui5Config();
    exports2.scriptsRegEx = /fiori run|cds watch|cds run|ui5 serve|mvn spring-boot:run/;
    async function findProjectRoot(path, sapuxRequired = true) {
      const pckgJson = await find_up_1.default(project_spec_1.FileName.Package, { cwd: path });
      if (!pckgJson) {
        throw new Error(`Could not find any project root. Parameter 'sapuxRequired' was ${sapuxRequired ? "true" : "false"}`);
      }
      let root = path_1.dirname(pckgJson);
      if (sapuxRequired) {
        const sapux = (await file_1.readJSON(pckgJson)).sapux;
        if (!sapux) {
          root = await findProjectRoot(path_1.dirname(root), sapuxRequired);
        }
      }
      return root;
    }
    exports2.findProjectRoot = findProjectRoot;
    async function findProject(wsRoot, projects) {
      return findAll(wsRoot, project_spec_1.FileName.Package, projects, [
        ".git",
        "node_modules",
        "dist",
        project_spec_1.DirName.Sapux,
        project_spec_1.DirName.Webapp,
        "MDKModule"
      ]);
    }
    async function findLibrary(wsRoot, libs) {
      return findAll(wsRoot, ".library", libs, [".git", "node_modules", "dist"]);
    }
    exports2.findLibrary = findLibrary;
    async function findAll(root, filename, results, stopFolders) {
      return new Promise((doResolve, reject) => {
        const finder = findit2_1.default(root);
        finder.on("directory", (dir, stat, stop) => {
          const base = path_1.basename(dir);
          if (stopFolders.indexOf(base) !== -1) {
            stop();
          }
        });
        finder.on("file", (file) => {
          if (file.endsWith(filename)) {
            results.push(path_1.dirname(file));
          }
        });
        finder.on("end", () => {
          doResolve();
        });
        finder.on("error", (error3) => {
          reject(error3);
        });
      });
    }
    async function findExtensionFiles(root, targetFileName = project_spec_1.FileName.Fragment) {
      const extensionFiles = [];
      return new Promise((doResolve, reject) => {
        const finder = findit2_1.default(root);
        finder.on("directory", (dir, stat, stop) => {
          const base = path_1.basename(dir);
          if (base === ".git" || base === "node_modules" || base === "dist" || base === project_spec_1.DirName.Sapux) {
            stop();
          }
        });
        finder.on("file", (file) => {
          if (file.endsWith(targetFileName)) {
            extensionFiles.push(file);
          }
        });
        finder.on("end", () => {
          doResolve(extensionFiles);
        });
        finder.on("error", (error3) => {
          reject(error3);
        });
      });
    }
    exports2.findExtensionFiles = findExtensionFiles;
    function isWorkspaceFolder(value) {
      return value && value.length > 0 && value[0].uri !== void 0;
    }
    var hasDependency = (packageJson, dependency) => packageJson.dependencies && packageJson.dependencies[dependency] !== void 0 || packageJson.devDependencies && packageJson.devDependencies[dependency] !== void 0;
    exports2.hasDependency = hasDependency;
    var hasScript = (packageJson) => {
      if (packageJson.scripts) {
        let scriptExists = false;
        for (const script in packageJson.scripts) {
          const result2 = packageJson.scripts[script].match(exports2.scriptsRegEx);
          if (result2) {
            scriptExists = true;
            break;
          }
        }
        return scriptExists;
      }
    };
    async function findAllManifest(wsFolders) {
      let wsRoots;
      if (isWorkspaceFolder(wsFolders)) {
        wsRoots = [];
        wsFolders.filter((each) => each.uri.scheme === "file").forEach((folder) => {
          wsRoots.push(folder.uri.fsPath);
        });
      } else {
        wsRoots = wsFolders || [];
      }
      const manifests = [];
      for (const root of wsRoots) {
        try {
          await findAll(root, project_spec_1.FileName.Manifest, manifests, [".git", "node_modules", "dist"]);
        } catch (error3) {
          const errorMessage = i18n_1.i18n.t("ERROR_PROJECT_ROOT_WORKSPACE", {
            root,
            error: error3.message
          });
          console.error(errorMessage);
        }
      }
      return manifests;
    }
    async function findAllPackageJsonFolders(wsFolders, logger) {
      let wsRoots;
      if (isWorkspaceFolder(wsFolders)) {
        wsRoots = [];
        wsFolders.filter((each) => each.uri.scheme === "file").forEach((folder) => {
          wsRoots.push(folder.uri.fsPath);
        });
      } else {
        wsRoots = wsFolders || [];
      }
      const projects = [];
      for (const root of wsRoots) {
        try {
          await findProject(root, projects);
        } catch (error3) {
          const errorMessage = i18n_1.i18n.t("ERROR_PROJECT_ROOT_WORKSPACE", {
            root,
            error: error3.message
          });
          if (logger) {
            logger.error(errorMessage);
          } else {
            console.error(errorMessage);
          }
        }
      }
      return projects;
    }
    async function findAllProjectRoots(wsFolders, sapuxRequired = true, logger) {
      const projects = await findAllPackageJsonFolders(wsFolders, logger);
      if (sapuxRequired) {
        const sapuxProjects = [];
        for (const root of projects) {
          try {
            if ((await file_1.readJSON(path_1.join(root, project_spec_1.FileName.Package))).sapux) {
              sapuxProjects.push(root);
            }
          } catch (error3) {
            const errorMessage = i18n_1.i18n.t("ERROR_INVALID_PACKAGE_JSON", {
              error: error3.message
            });
            if (logger) {
              logger.error(errorMessage);
            } else {
              console.error(errorMessage);
            }
          }
        }
        return sapuxProjects;
      } else {
        return projects;
      }
    }
    exports2.findAllProjectRoots = findAllProjectRoots;
    async function getAppType(appRoot, projectRoot) {
      if (appRoot === projectRoot) {
        const appPckJson = await file_1.readJSON(path_1.join(appRoot, project_spec_1.FileName.Package));
        if (appPckJson.sapux === true) {
          return "SAP Fiori elements";
        } else {
          return "SAPUI5 freestyle";
        }
      }
      try {
        const projectPckJson = await file_1.readJSON(path_1.join(projectRoot, project_spec_1.FileName.Package));
        if (!projectPckJson.sapux) {
          return "SAPUI5 freestyle";
        } else if (Array.isArray(projectPckJson.sapux)) {
          return projectPckJson.sapux.find((relAppPath) => path_1.join(projectRoot, ...relAppPath.split(/\\|\//)) === appRoot) ? "SAP Fiori elements" : "SAPUI5 freestyle";
        }
      } catch {
        return "SAPUI5 freestyle";
      }
    }
    exports2.getAppType = getAppType;
    async function getDetailedProjectType(appRoot, projectRoot) {
      if (appRoot === projectRoot) {
        return "EDMX Backend";
      }
      if (await capProject_1.isCapJavaProject(projectRoot)) {
        return "CAP Java";
      }
      if (await capProject_1.isCapNodeJsProject(projectRoot)) {
        return "CAP Node.js";
      }
      throw new Error(i18n_1.i18n.t("ERROR_DETAIL_PROJECT_TYPE", { appRoot, projectRoot }));
    }
    exports2.getDetailedProjectType = getDetailedProjectType;
    async function findRootsForPath(path) {
      try {
        const appRoot = await findProjectRoot(path, false);
        if (!appRoot) {
          return null;
        }
        const appPckJson = await file_1.readJSON(path_1.join(appRoot, project_spec_1.FileName.Package));
        if (appPckJson == null ? void 0 : appPckJson.sapux) {
          if (typeof appPckJson.sapux === "boolean" && appPckJson.sapux === true) {
            return {
              appRoot,
              projectRoot: appRoot
            };
          } else if (Array.isArray(appPckJson.sapux)) {
            const relAppPaths = appPckJson.sapux.map((a) => path_1.join(...a.split(/\\|\//)));
            const relApp = relAppPaths.find((app) => path.startsWith(path_1.join(appRoot, app) + path_1.sep));
            if (relApp) {
              return {
                appRoot: path_1.join(appRoot, relApp),
                projectRoot: appRoot
              };
            }
          }
          return null;
        }
        if (await capProject_1.isCapProject(appRoot, appPckJson)) {
          return null;
        }
        if (fs_1.existsSync(path_1.join(appRoot, project_spec_1.FileName.Ui5LocalYaml)) && exports2.hasDependency(appPckJson, "@sap/ux-ui5-tooling")) {
          return {
            appRoot,
            projectRoot: appRoot
          };
        }
        try {
          const { root } = path_1.parse(appRoot);
          let projectRoot = path_1.dirname(appRoot);
          while (projectRoot !== root) {
            if (await capProject_1.isCapProject(projectRoot)) {
              if (path_1.join(projectRoot, "app") !== appRoot) {
                return {
                  appRoot,
                  projectRoot
                };
              }
            }
            projectRoot = path_1.dirname(projectRoot);
          }
        } catch (e) {
        }
      } catch (error3) {
        console.error(error3);
      }
      return null;
    }
    exports2.findRootsForPath = findRootsForPath;
    async function findAllApps(wsFolders) {
      const result2 = [];
      const manifestPaths = await findAllManifest(wsFolders);
      for (const manifestPath of manifestPaths) {
        try {
          const manifest = await file_1.readJSON(path_1.join(manifestPath, project_spec_1.FileName.Manifest));
          if (!manifest["sap.app"] || !manifest["sap.app"].id || manifest["sap.app"].type !== "application") {
            continue;
          }
          const roots = await findRootsForPath(manifestPath);
          if (roots) {
            result2.push({ appRoot: roots.appRoot, projectRoot: roots.projectRoot, manifest, manifestPath });
          }
        } catch (error3) {
          console.info(`Couldn't check app with manifest.json located  in '${manifestPath}' for valid SAP Fiori tools project. Error was: ${error3.message}`);
        }
      }
      return result2;
    }
    exports2.findAllApps = findAllApps;
    var findRunnableProjects = async (workspaceRoots, logger) => {
      const result2 = [];
      const roots = await findAllProjectRoots(workspaceRoots, false);
      for (const root of roots) {
        try {
          const packageJson = await file_1.readJSON(path_1.join(root, project_spec_1.FileName.Package));
          if ((exports2.hasDependency(packageJson, "@sap/ux-ui5-tooling") || await capProject_1.isCapProject(root, packageJson)) && hasScript(packageJson)) {
            result2.push(root);
          }
        } catch (error3) {
          logger == null ? void 0 : logger.info(`Invalid JSON ${path_1.join(root, project_spec_1.FileName.Package)}. Application Modeler will skip this project.`);
          continue;
        }
      }
      return result2;
    };
    exports2.findRunnableProjects = findRunnableProjects;
    async function checkPackageJson(root, dependency, sapux) {
      const packageJson = await file_1.readJSON(path_1.join(root, project_spec_1.FileName.Package));
      if (packageJson.dependencies && packageJson.dependencies[dependency] !== void 0 || packageJson.devDependencies && packageJson.devDependencies[dependency] !== void 0) {
        return true;
      }
      return sapux === true && packageJson.sapux === true;
    }
    exports2.checkPackageJson = checkPackageJson;
    async function isFioriToolsProject(root, dependency, sapux) {
      try {
        return await checkPackageJson(root, dependency, sapux);
      } catch (e) {
        return false;
      }
    }
    exports2.isFioriToolsProject = isFioriToolsProject;
    async function findProjectRootsByDependency(wsFolders, dependency, logger) {
      const result2 = [];
      const roots = await findAllPackageJsonFolders(wsFolders, logger);
      for (const root of roots) {
        try {
          if (await checkPackageJson(root, dependency, false)) {
            result2.push(root);
          }
        } catch (error3) {
          const errorMessage = i18n_1.i18n.t("ERROR_INVALIND_PACKAGE_JSON_FOR_APP", {
            root
          });
          if (logger) {
            logger.error(errorMessage);
          } else {
            console.error(errorMessage);
          }
        }
      }
      return result2;
    }
    exports2.findProjectRootsByDependency = findProjectRootsByDependency;
    function getMainService(manifest) {
      const model = manifest["sap.ovp"] ? manifest["sap.ovp"].globalFilterModel : "";
      return manifest["sap.ui5"] && manifest["sap.ui5"].models && manifest["sap.ui5"].models[model] ? manifest["sap.ui5"].models[model].dataSource : void 0;
    }
    exports2.getMainService = getMainService;
    function createApplicationStructureConfig(appFolder, manifest, sync) {
      return {
        manifest: path_1.join(appFolder, project_spec_1.DirName.Webapp, project_spec_1.FileName.Manifest),
        changes: path_1.join(appFolder, project_spec_1.DirName.Webapp, project_spec_1.DirName.Changes),
        app: sync ? path_1.join(appFolder, project_spec_1.DirName.Sapux, project_spec_1.FileName.App) : void 0,
        i18n: getI18nPath(path_1.join(appFolder, project_spec_1.DirName.Webapp), manifest),
        mainService: getMainService(manifest),
        services: {},
        annotations: {},
        ext: path_1.join(appFolder, project_spec_1.DirName.Webapp, project_spec_1.DirName.Ext),
        controller: path_1.join(appFolder, project_spec_1.DirName.Webapp, project_spec_1.DirName.Ext, project_spec_1.DirName.Controller),
        view: path_1.join(appFolder, project_spec_1.DirName.Webapp, project_spec_1.DirName.Ext, project_spec_1.DirName.View),
        fragment: path_1.join(appFolder, project_spec_1.DirName.Webapp, project_spec_1.DirName.Ext, project_spec_1.DirName.Fragment)
      };
    }
    exports2.createApplicationStructureConfig = createApplicationStructureConfig;
    function fillServiceSpecificationForApp(project, appFolder, manifest) {
      var _a2;
      const services = manifest["sap.app"].dataSources;
      for (const name in services) {
        if (services[name].type === project_spec_1.DataSourceType.OData) {
          project.apps[appFolder].services[name] = {
            uri: services[name].uri
          };
          const appServices = project.apps[appFolder].services;
          if (services[name].settings) {
            appServices[name].local = ((_a2 = services[name].settings) == null ? void 0 : _a2.localUri) ? path_1.join(appFolder, project_spec_1.DirName.Webapp, services[name].settings.localUri) : "";
            if (services[name].settings.annotations) {
              project.apps[appFolder].annotations[name] = project.apps[appFolder].annotations[name] || [];
              for (const id of services[name].settings.annotations) {
                const annotation = services[id];
                if (annotation) {
                  if (!annotation.uri || annotation.settings && annotation.uri === annotation.settings.localUri) {
                    project.apps[appFolder].annotations[name].push(path_1.join(appFolder, project_spec_1.DirName.Webapp, annotation.settings.localUri));
                  } else {
                    appServices[name].annotations = {
                      uri: annotation.uri,
                      local: annotation.settings && annotation.settings.localUri ? path_1.join(appFolder, project_spec_1.DirName.Webapp, annotation.settings.localUri) : void 0
                    };
                    if (appServices[name].annotations.local) {
                      project.apps[appFolder].annotations[name].push(appServices[name].annotations.local);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    exports2.fillServiceSpecificationForApp = fillServiceSpecificationForApp;
    function getAppConfig(project, appId) {
      let errorMessage;
      if (appId === void 0) {
        const appIds = Object.keys(project.apps);
        if (appIds.length > 1) {
          errorMessage = i18n_1.i18n.t("ERROR_REQUIRED_APP");
          throw new Error(errorMessage);
        } else {
          return project.apps[appIds[0]];
        }
      } else {
        const app = project.apps[appId];
        if (!app) {
          errorMessage = i18n_1.i18n.t("ERROR_INVALID_APP_ID");
          throw new Error(errorMessage);
        }
        return app;
      }
    }
    exports2.getAppConfig = getAppConfig;
    async function readAppJson(path, includePageConfigs = true) {
      const app = await file_1.readJSON(path);
      if (includePageConfigs) {
        const pagesDirectory = path.replace(project_spec_1.FileName.App, project_spec_1.DirName.Pages);
        const pageFiles = await file_1.readDirectory(pagesDirectory);
        for (const file of pageFiles) {
          const id = file.replace(".json", "");
          if (app.pages[id]) {
            app.pages[id].config = await file_1.readJSON(path_1.join(pagesDirectory, file));
          }
        }
      }
      return app;
    }
    exports2.readAppJson = readAppJson;
    function getI18nPath(manifestFolder, manifest) {
      var _a2, _b, _c;
      let relativePath;
      const i18nModel = ((_b = (_a2 = manifest == null ? void 0 : manifest["sap.ui5"]) == null ? void 0 : _a2.models) == null ? void 0 : _b["i18n"]) || {};
      if ("uri" in i18nModel && typeof i18nModel.uri === "string") {
        relativePath = i18nModel.uri;
      } else if ("settings" in i18nModel && typeof i18nModel.settings === "object" && "bundleUrl" in i18nModel.settings && typeof i18nModel.settings.bundleUrl === "string") {
        relativePath = i18nModel.settings.bundleUrl;
      } else if ("settings" in i18nModel && typeof i18nModel.settings === "object" && "bundleName" in i18nModel.settings && typeof i18nModel.settings.bundleName === "string") {
        const relBundleString = i18nModel.settings.bundleName.replace(manifest["sap.app"].id, "");
        relativePath = `${path_1.join(...relBundleString.split("."))}.properties`;
      } else if (typeof ((_c = manifest == null ? void 0 : manifest["sap.app"]) == null ? void 0 : _c.i18n) === "string") {
        relativePath = manifest["sap.app"].i18n;
      }
      return relativePath ? path_1.join(manifestFolder, relativePath) : void 0;
    }
    exports2.getI18nPath = getI18nPath;
    async function traverseI18nProperties(path, fnCallback) {
      const i18nFile = await file_1.readFile(path);
      const lines = i18nFile.split(/\r\n|\n/);
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        if (!line.startsWith("#")) {
          const [key, value] = line.includes("=") ? line.split("=") : line.split(":");
          fnCallback(line, i, key ? key.trim() : key, value ? value.trim() : value);
        } else {
          fnCallback(line, i);
        }
      }
      return lines;
    }
    async function mergeI18nProperties(i18n, path) {
      await traverseI18nProperties(path, (line, index, key, value) => {
        if (key && value) {
          i18n[key] = value;
        }
      });
      return i18n;
    }
    exports2.mergeI18nProperties = mergeI18nProperties;
    async function getI18nProperties(path, locale) {
      let i18n = {};
      i18n = await mergeI18nProperties(i18n, path);
      if (locale) {
        i18n = await mergeI18nProperties(i18n, path.replace("i18n.", `i18n_${locale}.`));
      }
      return i18n;
    }
    exports2.getI18nProperties = getI18nProperties;
    async function updateI18nProperty(path, key, value, comment) {
      await updateI18nProperties(path, [{ key, value, comment }]);
    }
    exports2.updateI18nProperty = updateI18nProperty;
    async function updateI18nProperties(path, entries) {
      if (entries.length === 0) {
        return;
      }
      const output3 = [];
      const updatedEntries = {};
      const lines = await traverseI18nProperties(path, (line, index, keyTemp, valueTemp) => {
        const existingIndex = valueTemp !== void 0 ? entries.findIndex((entry) => entry.key === keyTemp) : -1;
        if (existingIndex !== -1) {
          const { key, value } = entries[existingIndex];
          line = `${key}=${value}`;
          updatedEntries[existingIndex] = true;
        }
        output3.push(line);
      });
      if (lines.length > 0 && lines[lines.length - 1].trim() && entries.length) {
        output3.push("");
      }
      for (const index in entries) {
        if (!updatedEntries[index]) {
          const { comment, key, value } = entries[index];
          if (comment) {
            output3.push(`#${comment}`);
          }
          output3.push(`${key}=${value}${os_1.default.EOL}`);
        }
      }
      await file_1.updateFile(path, output3.join(os_1.default.EOL));
    }
    exports2.updateI18nProperties = updateI18nProperties;
    async function findI18nProperty(path, key) {
      let i18nProperty = void 0;
      await traverseI18nProperties(path, (line, index, keyTemp, value) => {
        if (key && value && key === keyTemp) {
          i18nProperty = {
            key,
            value,
            lineIndex: index
          };
        }
      });
      return i18nProperty;
    }
    exports2.findI18nProperty = findI18nProperty;
    async function getProjectTypeFromProjectFiles(projectRoot, packageJson) {
      return await capProject_1.isCapProject(projectRoot, packageJson) ? "Cap" : "Edmx";
    }
    exports2.getProjectTypeFromProjectFiles = getProjectTypeFromProjectFiles;
    async function getProjectType(root) {
      const packageJson = await file_1.readJSON(path_1.join(root, project_spec_1.FileName.Package));
      return getProjectTypeFromProjectFiles(root, packageJson);
    }
    exports2.getProjectType = getProjectType;
    function getVersionFromManifest(manifest) {
      var _a2, _b, _c, _d;
      if (manifest["sap.ui.generic.app"] || manifest["sap.ovp"]) {
        return page_1.FioriElementsVersion.v2;
      } else if ((_b = (_a2 = manifest["sap.ui5"]) == null ? void 0 : _a2.routing) == null ? void 0 : _b.targets) {
        let hasV4pPages = false;
        Object.keys((_d = (_c = manifest["sap.ui5"]) == null ? void 0 : _c.routing) == null ? void 0 : _d.targets).forEach((target) => {
          var _a3, _b2, _c2, _d2;
          const ui5RoutingTarget = (_b2 = (_a3 = manifest["sap.ui5"]) == null ? void 0 : _a3.routing) == null ? void 0 : _b2.targets[target];
          if (((_c2 = ui5RoutingTarget.name) == null ? void 0 : _c2.startsWith("sap.fe.templates.")) || ((_d2 = ui5RoutingTarget.name) == null ? void 0 : _d2.startsWith("sap.fe.core.fpm"))) {
            hasV4pPages = true;
          }
        });
        if (hasV4pPages) {
          return page_1.FioriElementsVersion.v4;
        } else {
          return void 0;
        }
      } else {
        return page_1.FioriElementsVersion.v4;
      }
    }
    exports2.getVersionFromManifest = getVersionFromManifest;
    async function getUi5CustomMiddleware(root) {
      var _a2, _b;
      const yamlContent = await file_1.readFile(path_1.join(root, project_spec_1.FileName.Ui5Yaml));
      const middlewares = (_b = (_a2 = yaml.parse(yamlContent)) == null ? void 0 : _a2.server) == null ? void 0 : _b.customMiddleware;
      return middlewares == null ? void 0 : middlewares.find((element) => element.name === "fiori-tools-proxy");
    }
    exports2.getUi5CustomMiddleware = getUi5CustomMiddleware;
    async function getLocalUI5Version(root) {
      const yamlFile = path_1.join(root, project_spec_1.FileName.Ui5LocalYaml);
      if (await file_1.fileExists(yamlFile)) {
        const yamlContent = yaml.parse(await file_1.readFile(yamlFile));
        return yamlContent.framework && yamlContent.framework.version;
      }
    }
    exports2.getLocalUI5Version = getLocalUI5Version;
    var latestSapui5Version = void 0;
    async function getUI5Version(root) {
      var _a2, _b;
      try {
        let ui5Version = "latest";
        const webappPath = await webapp_1.getUi5CustomWebappPath(root);
        const manifestFile = path_1.join(root, webappPath, project_spec_1.FileName.Manifest);
        if (await file_1.fileExists(manifestFile)) {
          const manifest = await file_1.readJSON(manifestFile);
          ui5Version = (_b = (_a2 = manifest["sap.ui5"]) == null ? void 0 : _a2.dependencies) == null ? void 0 : _b.minUI5Version;
          if (isNaN(parseFloat(ui5Version))) {
            if (latestSapui5Version === void 0) {
              latestSapui5Version = await ux_ui5_info_1.getLatestSapui5Version();
            }
            ui5Version = latestSapui5Version;
          }
        }
        return ui5Version;
      } catch (error3) {
        return "latest";
      }
    }
    exports2.getUI5Version = getUI5Version;
    async function checkServeLocalConfig(root) {
      const yamlFile = path_1.join(root, project_spec_1.FileName.Ui5LocalYaml);
      if (await file_1.fileExists(yamlFile)) {
        const yamlContent = yaml.parse(await file_1.readFile(yamlFile));
        const middlewares = yamlContent.server.customMiddleware;
        const serveLocal = middlewares.find((element) => element.name === "fiori-tools-servestatic");
        if (serveLocal) {
          if (serveLocal.mountPath && serveLocal.mountPath === "/resources|/test-resources" && serveLocal.configuration && serveLocal.configuration.path) {
            return true;
          }
        }
        return false;
      }
      return false;
    }
    exports2.checkServeLocalConfig = checkServeLocalConfig;
    function getAppIdForFile(filepath, projectRoot, appIds) {
      let appId = "";
      appIds.forEach((appIdTmp) => {
        const relativeStr = path_1.relative(path_1.join(projectRoot, appIdTmp), filepath);
        if (relativeStr && !relativeStr.startsWith("..") && !path_1.isAbsolute(relativeStr)) {
          appId = appIdTmp;
        }
      });
      appId = os_1.default.platform() === "win32" ? appId.replace(/\/\//g, "/") : appId;
      return appId;
    }
    exports2.getAppIdForFile = getAppIdForFile;
    function isOVPProject(manifest) {
      return !!manifest["sap.ovp"];
    }
    exports2.isOVPProject = isOVPProject;
    async function deleteCapApp(appPath, logger) {
      var _a2;
      const appName = path_1.basename(appPath);
      const projectRoot = await findProjectRoot(appPath);
      const packageJsonPath = path_1.join(projectRoot, project_spec_1.FileName.Package);
      const packageJson = await file_1.readJSON(packageJsonPath);
      const cdsFilePaths = [path_1.join(path_1.dirname(appPath), project_spec_1.FileName.ServiceCds), path_1.join(path_1.dirname(appPath), project_spec_1.FileName.IndexCds)];
      if (!Array.isArray(packageJson.sapux)) {
        logger == null ? void 0 : logger.error(i18n_1.i18n.t("ERROR_DEL_CAP_APP_SAPUX", { packageJsonPath }));
        throw Error(i18n_1.i18n.t("ERROR_DEL_CAP_APP_SAPUX", { packageJsonPath }));
      }
      logger == null ? void 0 : logger.info(i18n_1.i18n.t("INFO_DEL_CAP_APP", { appName, projectRoot }));
      const posixAppPath = appPath.replace(/\\/g, "/");
      packageJson.sapux = packageJson.sapux.filter((a) => !posixAppPath.endsWith(a));
      if (packageJson.sapux.length === 0) {
        logger == null ? void 0 : logger.info(i18n_1.i18n.t("INFO_DEL_LAST_CAP_APP", { packageJsonPath }));
        delete packageJson.sapux;
      }
      if ((_a2 = packageJson.scripts) == null ? void 0 : _a2[`watch-${appName}`]) {
        delete packageJson.scripts[`watch-${appName}`];
      }
      await file_1.updateJSON(packageJsonPath, packageJson);
      logger == null ? void 0 : logger.info(i18n_1.i18n.t("INFO_DEL_CAP_APP_FILE_UPDATED", { packageJsonPath }));
      await file_1.deleteDirectory(appPath);
      logger == null ? void 0 : logger.info(i18n_1.i18n.t("INFO_DEL_CAP_APP_DIR_DELETED", { appPath }));
      const usingEntry = `using from './${appName}/annotations';`;
      for (const cdsFilePath of cdsFilePaths) {
        if (await file_1.fileExists(cdsFilePath)) {
          try {
            let cdsFile = await file_1.readFile(cdsFilePath);
            if (cdsFile.indexOf(usingEntry) !== -1) {
              logger == null ? void 0 : logger.info(i18n_1.i18n.t("INFO_DEL_CAP_APP_DELETE_USING", { appName, cdsFilePath }));
              cdsFile = cdsFile.replace(usingEntry, "");
              if (cdsFile.replace(/\n/g, "").trim() === "") {
                logger == null ? void 0 : logger.info(i18n_1.i18n.t("INFO_DEL_CAP_APP_DEL_CDS", { cdsFilePath }));
                await file_1.deleteFile(cdsFilePath);
              } else {
                await file_1.updateFile(cdsFilePath, cdsFile);
              }
            }
          } catch (error3) {
            logger == null ? void 0 : logger.error(i18n_1.i18n.t("ERROR_DEL_CAP_APP_MODIFY_CDS", { cdsFilePath }));
          }
        }
      }
      if ((await file_1.readDirectory(path_1.dirname(appPath))).length === 0) {
        logger == null ? void 0 : logger.info(i18n_1.i18n.t("INFO_DEL_CAP_APP_FOLDER_EMPTY", { appPath: path_1.dirname(appPath) }));
        await file_1.deleteDirectory(path_1.dirname(appPath));
      }
    }
    exports2.deleteCapApp = deleteCapApp;
    async function getApplicationId(manifest, projectRoot) {
      var _a2;
      let appId = manifest["sap.app"].id;
      if (appId === project_spec_1.AppPomXmlArtifactIdPlaceholder) {
        try {
          const pomFile = await file_1.readFile(path_1.join(projectRoot, "pom.xml"));
          const pomXml = fast_xml_parser_1.default.parse(pomFile);
          if ((_a2 = pomXml.project) == null ? void 0 : _a2.artifactId) {
            appId = pomXml.project.artifactId;
          } else {
            throw new Error();
          }
        } catch (error3) {
          appId = path_1.basename(projectRoot);
        }
      }
      return appId;
    }
    exports2.getApplicationId = getApplicationId;
    function getCapAppMockdataDirPath(projectRoot) {
      const capMockdataDirPaths = [
        path_1.join(projectRoot, project_spec_1.DirName.Db, project_spec_1.DirName.Csv),
        path_1.join(projectRoot, project_spec_1.DirName.Db, project_spec_1.DirName.Sapux, project_spec_1.DirName.Csv)
      ];
      for (const path of capMockdataDirPaths) {
        if (fs_1.existsSync(path)) {
          return path;
        }
      }
      return path_1.join(projectRoot, project_spec_1.DirName.Db, project_spec_1.DirName.Data);
    }
    exports2.getCapAppMockdataDirPath = getCapAppMockdataDirPath;
    function getEdmxAppDefaultMockdataDirPath(appRoot) {
      return path_1.join(appRoot, project_spec_1.DirName.Webapp, project_spec_1.DirName.LocalService, project_spec_1.DirName.Mockdata);
    }
    exports2.getEdmxAppDefaultMockdataDirPath = getEdmxAppDefaultMockdataDirPath;
    async function tryGetEdmxAppMockServiceMockdataDir(configDir, serviceMetadataPath) {
      const config = await ui5Config_1.getMockServerConfig(configDir);
      if (config) {
        const { services, mockFolder } = await ui5Config_1.getMockServicesConfiguration(configDir, config);
        if (services) {
          const mockService = ui5Config_1.findMockServiceByMetadataPath(services, serviceMetadataPath);
          if (mockService == null ? void 0 : mockService.mockdataPath) {
            const servicesConfigFilePath = mockFolder ? path_1.resolve(configDir, mockFolder) : configDir;
            return path_1.resolve(servicesConfigFilePath, mockService.mockdataPath);
          }
        }
      }
    }
    exports2.tryGetEdmxAppMockServiceMockdataDir = tryGetEdmxAppMockServiceMockdataDir;
  }
});

// ../lib/telemetry/dist/src/toolsSuiteTelemetry/types.js
var require_types5 = __commonJS({
  "../lib/telemetry/dist/src/toolsSuiteTelemetry/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CommonProperties = exports2.DeployTarget = exports2.ODataSource = exports2.ToolsId = void 0;
    var ToolsId;
    (function(ToolsId2) {
      ToolsId2["UNKNOWN"] = "UNKNOWN";
      ToolsId2["NO_TOOLS_ID"] = "NO_TOOLS_ID";
    })(ToolsId = exports2.ToolsId || (exports2.ToolsId = {}));
    var ODataSource;
    (function(ODataSource2) {
      ODataSource2["CAPJava"] = "CAPJava";
      ODataSource2["CAPNode"] = "CAPNode";
      ODataSource2["ABAP"] = "ABAP";
      ODataSource2["UNKNOWN"] = "UNKNOWN";
    })(ODataSource = exports2.ODataSource || (exports2.ODataSource = {}));
    var DeployTarget;
    (function(DeployTarget2) {
      DeployTarget2["CF"] = "CF";
      DeployTarget2["ABAP"] = "ABAP";
      DeployTarget2["UNKNOWN_DEPLOY_CONFIG"] = "UNKNOWN_DEPLOY_CONFIG";
      DeployTarget2["NO_DEPLOY_CONFIG"] = "NO_DEPLOY_CONFIG";
    })(DeployTarget = exports2.DeployTarget || (exports2.DeployTarget = {}));
    var CommonProperties;
    (function(CommonProperties2) {
      CommonProperties2["DevSpace"] = "cmn.devspace";
      CommonProperties2["AppStudio"] = "cmn.appstudio";
      CommonProperties2["AppStudioBackwardCompatible"] = "appstudio";
      CommonProperties2["InternlVsExternal"] = "cmn.internalFeatures";
      CommonProperties2["InternlVsExternalBackwardCompatible"] = "internalVsExternal";
      CommonProperties2["TemplateType"] = "cmn.template";
      CommonProperties2["DeployTargetType"] = "cmn.deployTarget";
      CommonProperties2["ODataSourceType"] = "cmn.odataSource";
      CommonProperties2["AppToolsId"] = "cmn.toolsId";
    })(CommonProperties = exports2.CommonProperties || (exports2.CommonProperties = {}));
  }
});

// ../lib/feature-toggle/dist/featureToggle.js
var require_featureToggle = __commonJS({
  "../lib/feature-toggle/dist/featureToggle.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isInternalFeaturesSettingEnabled = exports2.isFeatureEnabled = exports2.enableFeature = exports2.FeatureToggleAccess = exports2.ExperimentalFeatures = exports2.FeatureToggleKey = void 0;
    var vscode = void 0;
    try {
      vscode = require("vscode");
    } catch (e) {
    }
    var extensionConfigKeys = {
      AnnotationModeler: "sap.ux.annotationModeler",
      AppGenerator: "sap.ux.appGenerator",
      ApplicationModeler: "sap.ux.applicationModeler",
      Help: "sap.ux.help",
      RequirementsGathering: "sap.ux.requirementsGathering",
      ServiceModeler: "sap.ux.serviceModeler",
      Internal: "sap.ux.internal"
    };
    var tokenToggleGuid = {
      "dummy.test.testBetaFeatures.someTokenFeature": "77e0469d-1448-42bf-8d47-0944896dd9ed",
      "sap.ux.help.testBetaFeatures.enableAppStudioGDContribution": "c8c52f0b-0d7d-4697-997a-d6f29814f42e",
      "sap.ux.help.testBetaFeatures.enableAbapCdsSupport": "794cae98-3456-491a-ae20-3215a98b56df",
      "sap.ux.help.testBetaFeatures.showTestGuides": "fbb03f42-0a86-4fd5-9fc4-8c9b38a4d1a3"
    };
    exports2.FeatureToggleKey = "testBetaFeatures";
    exports2.ExperimentalFeatures = "sap.ux.applicationModeler.enableExperimentalFeatures";
    var FeatureToggleAccess = class {
      static getFeatureToggle(feature) {
        var _a2;
        let toggleConfigValue;
        if ((feature.includes(exports2.FeatureToggleKey) || feature === exports2.ExperimentalFeatures) && FeatureToggleAccess.vscode) {
          const toggleKey = feature.slice(0, feature.lastIndexOf("."));
          const toggleId = feature.slice(feature.lastIndexOf(".") + 1, feature.length);
          toggleConfigValue = (_a2 = FeatureToggleAccess.vscode.workspace.getConfiguration(toggleKey)) == null ? void 0 : _a2.get(toggleId);
        } else {
          toggleConfigValue = false;
        }
        if (process.env.TOOLSUITE_FEATURES) {
          const envFeatures = process.env.TOOLSUITE_FEATURES.split(",");
          toggleConfigValue = envFeatures.includes(feature) ? true : toggleConfigValue;
        }
        if (tokenToggleGuid[feature]) {
          if (tokenToggleGuid[feature] === toggleConfigValue) {
            toggleConfigValue = true;
          } else {
            toggleConfigValue = false;
          }
        }
        const featureToggle = {
          feature,
          isEnabled: toggleConfigValue === true ? toggleConfigValue : false
        };
        return featureToggle;
      }
      static getAllFeatureToggles() {
        const definedToggles = [];
        if (FeatureToggleAccess.vscode) {
          Object.keys(extensionConfigKeys).forEach((toggleConfigKey) => {
            const toggleKey = `${extensionConfigKeys[toggleConfigKey]}.${exports2.FeatureToggleKey}`;
            let toggles = {};
            try {
              toggles = JSON.parse(JSON.stringify(FeatureToggleAccess.vscode.workspace.getConfiguration(toggleKey)));
            } catch (e) {
            }
            Object.keys(toggles).forEach((toggleId) => {
              const toggleConfigValue = FeatureToggleAccess.vscode.workspace.getConfiguration(`${toggleKey}`).get(`${toggleId}`);
              const toggle = {
                feature: `${toggleKey}.${toggleId}`,
                isEnabled: toggleConfigValue ? toggleConfigValue : false
              };
              definedToggles.push(toggle);
            });
          });
        }
        return definedToggles;
      }
    };
    exports2.FeatureToggleAccess = FeatureToggleAccess;
    FeatureToggleAccess.vscode = vscode;
    function enableFeature(feature) {
      let envFeatures = [];
      if (process.env.TOOLSUITE_FEATURES) {
        envFeatures = process.env.TOOLSUITE_FEATURES.split(",");
        if (!envFeatures.includes(feature)) {
          envFeatures.push(feature);
        }
      } else {
        envFeatures.push(feature);
      }
      process.env.TOOLSUITE_FEATURES = envFeatures.join();
    }
    exports2.enableFeature = enableFeature;
    function isFeatureEnabled(feature) {
      return FeatureToggleAccess.getFeatureToggle(feature).isEnabled;
    }
    exports2.isFeatureEnabled = isFeatureEnabled;
    function isInternalFeaturesSettingEnabled() {
      var _a2;
      const enableInternalFeaturesSetting = "sap.ux.internal.enableInternalFeatures";
      let internalEnabled = false;
      if (FeatureToggleAccess.vscode) {
        const internalSetting = FeatureToggleAccess.vscode.workspace ? (_a2 = FeatureToggleAccess.vscode.workspace.getConfiguration()) == null ? void 0 : _a2.get(enableInternalFeaturesSetting) : false;
        internalEnabled = internalSetting === true ? true : false;
      }
      if (process.env.TOOLSUITE_INTERNAL && process.env.TOOLSUITE_INTERNAL === "true") {
        internalEnabled = true;
      }
      return internalEnabled;
    }
    exports2.isInternalFeaturesSettingEnabled = isInternalFeaturesSettingEnabled;
  }
});

// ../lib/feature-toggle/dist/index.js
var require_dist7 = __commonJS({
  "../lib/feature-toggle/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExperimentalFeatures = exports2.enableFeature = exports2.isInternalFeaturesSettingEnabled = exports2.isFeatureEnabled = exports2.FeatureToggleKey = exports2.FeatureToggleAccess = void 0;
    var featureToggle_1 = require_featureToggle();
    Object.defineProperty(exports2, "FeatureToggleAccess", { enumerable: true, get: function() {
      return featureToggle_1.FeatureToggleAccess;
    } });
    Object.defineProperty(exports2, "FeatureToggleKey", { enumerable: true, get: function() {
      return featureToggle_1.FeatureToggleKey;
    } });
    Object.defineProperty(exports2, "isFeatureEnabled", { enumerable: true, get: function() {
      return featureToggle_1.isFeatureEnabled;
    } });
    Object.defineProperty(exports2, "isInternalFeaturesSettingEnabled", { enumerable: true, get: function() {
      return featureToggle_1.isInternalFeaturesSettingEnabled;
    } });
    Object.defineProperty(exports2, "enableFeature", { enumerable: true, get: function() {
      return featureToggle_1.enableFeature;
    } });
    Object.defineProperty(exports2, "ExperimentalFeatures", { enumerable: true, get: function() {
      return featureToggle_1.ExperimentalFeatures;
    } });
  }
});

// ../lib/telemetry/dist/src/toolsSuiteTelemetry/toolsSuiteTelemetryDataProcessor.js
var require_toolsSuiteTelemetryDataProcessor = __commonJS({
  "../lib/telemetry/dist/src/toolsSuiteTelemetry/toolsSuiteTelemetryDataProcessor.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getCommonProperties = exports2.processToolsSuiteTelemetry = void 0;
    var ux_common_utils_1 = require_dist();
    var axios_1 = __importDefault(require_axios2());
    var fs_1 = __importDefault(require("fs"));
    var path_1 = __importDefault(require("path"));
    var yaml_1 = __importDefault(require_dist2());
    var utils_1 = require_utils9();
    var capProject_1 = require_capProject();
    var types_1 = require_types5();
    var ux_feature_toggle_1 = require_dist7();
    async function processToolsSuiteTelemetry(telemetryHelperProperties) {
      const commonProperties = await getCommonProperties();
      let appProperties = {};
      if (telemetryHelperProperties) {
        appProperties = await getAppProperties(telemetryHelperProperties["appPath"]);
      }
      return { ...commonProperties, ...appProperties };
    }
    exports2.processToolsSuiteTelemetry = processToolsSuiteTelemetry;
    async function getCommonProperties() {
      const commonProperties = {};
      commonProperties[types_1.CommonProperties.DevSpace] = await getSbasDevspace();
      commonProperties[types_1.CommonProperties.AppStudio] = ux_common_utils_1.isAppStudio();
      commonProperties[types_1.CommonProperties.AppStudioBackwardCompatible] = commonProperties[types_1.CommonProperties.AppStudio];
      commonProperties[types_1.CommonProperties.InternlVsExternal] = getInternalVsExternal();
      commonProperties[types_1.CommonProperties.InternlVsExternalBackwardCompatible] = commonProperties[types_1.CommonProperties.InternlVsExternal];
      return commonProperties;
    }
    exports2.getCommonProperties = getCommonProperties;
    async function getSbasDevspace() {
      var _a2, _b;
      if (ux_common_utils_1.isAppStudio()) {
        try {
          const h20Url = process.env.H2O_URL;
          const workspaceId = process.env.WORKSPACE_ID.replace("workspaces-", "");
          const url = `${h20Url}/ws-manager/api/v1/workspace/${workspaceId}`;
          const response = await axios_1.default.get(url);
          if (response.data) {
            const workspaceConfig = response.data;
            const devspace = (_b = (_a2 = workspaceConfig == null ? void 0 : workspaceConfig.config) == null ? void 0 : _a2.annotations) == null ? void 0 : _b.pack;
            return devspace ? devspace : "";
          }
        } catch (error3) {
        }
      }
      return "";
    }
    async function getAppProperties(appPath) {
      if (!appPath) {
        return {};
      }
      const templateType = await getTemplateType(appPath);
      const deployTarget = await getDeployTarget(appPath);
      const odataSource = await getODataSource(appPath);
      const toolsId = await getToolsId(appPath);
      const output3 = {};
      output3[types_1.CommonProperties.TemplateType] = templateType;
      output3[types_1.CommonProperties.DeployTargetType] = deployTarget;
      output3[types_1.CommonProperties.ODataSourceType] = odataSource;
      output3[types_1.CommonProperties.AppToolsId] = toolsId;
      return output3;
    }
    async function getTemplateType(appPath) {
      const readmeFilePath = path_1.default.join(appPath, "README.md");
      if (fs_1.default.existsSync(readmeFilePath)) {
        const readmeContent = await fs_1.default.promises.readFile(readmeFilePath, "utf-8");
        if (readmeContent) {
          let templateType = "";
          const lines = readmeContent.split(/\r?\n/);
          for (const line of lines) {
            const match = line.match(/\|\*\*Floorplan Used\*\*<br>.*\|/g);
            if (match && match.length > 0) {
              templateType = line.replace("|**Floorplan Used**<br>", "").replace("|", "").trim();
              break;
            }
          }
          return templateType;
        }
      }
      return "";
    }
    async function getODataSource(appPath) {
      try {
        let projectRoot;
        try {
          projectRoot = await utils_1.findProjectRoot(appPath);
        } catch {
        }
        if (!projectRoot) {
          try {
            const appParentFolder = path_1.default.dirname(appPath);
            projectRoot = await utils_1.findProjectRoot(appParentFolder, false);
          } catch (e) {
          }
        }
        let isCapJavaWithoutPackageJson = false;
        if (!projectRoot) {
          const directParentFolder = path_1.default.dirname(appPath);
          const twoLevelUpParentFolder = path_1.default.dirname(directParentFolder);
          isCapJavaWithoutPackageJson = await capProject_1.isCapJavaProject(twoLevelUpParentFolder);
          projectRoot = isCapJavaWithoutPackageJson ? twoLevelUpParentFolder : appPath;
        }
        if (isCapJavaWithoutPackageJson) {
          return types_1.ODataSource.CAPJava;
        }
        const projectType = await utils_1.getProjectType(projectRoot);
        if (projectType === "Cap") {
          if (await capProject_1.isCapJavaProject(projectRoot)) {
            return types_1.ODataSource.CAPJava;
          } else if (await capProject_1.isCapNodeJsProject(projectRoot)) {
            return types_1.ODataSource.CAPNode;
          }
        } else if (projectType === "Edmx") {
          return types_1.ODataSource.ABAP;
        }
      } catch (e) {
        return types_1.ODataSource.UNKNOWN;
      }
    }
    async function getDeployTarget(appPath) {
      var _a2;
      const deployConfigPath = path_1.default.join(appPath, "ui5-deploy.yaml");
      if (fs_1.default.existsSync(deployConfigPath)) {
        const deployConfigContent = await fs_1.default.promises.readFile(deployConfigPath, "utf-8");
        const deployConfig = yaml_1.default.parse(deployConfigContent);
        const customTasks = (_a2 = deployConfig == null ? void 0 : deployConfig.builder) == null ? void 0 : _a2.customTasks;
        let isAbapReployTarget = false;
        if (customTasks) {
          for (const customTask of customTasks) {
            if (customTask.name === "deploy-to-abap") {
              isAbapReployTarget = true;
              break;
            }
          }
          return isAbapReployTarget ? types_1.DeployTarget.ABAP : types_1.DeployTarget.CF;
        } else {
          return types_1.DeployTarget.UNKNOWN_DEPLOY_CONFIG;
        }
      }
      return types_1.DeployTarget.NO_DEPLOY_CONFIG;
    }
    function getInternalVsExternal() {
      return ux_feature_toggle_1.isInternalFeaturesSettingEnabled() ? "internal" : "external";
    }
    async function getToolsId(appPath) {
      var _a2, _b, _c;
      try {
        const manifestPath = path_1.default.join(appPath, "webapp", "manifest.json");
        if (fs_1.default.existsSync(manifestPath)) {
          const manifest = JSON.parse(fs_1.default.readFileSync(manifestPath, "utf-8"));
          return (_c = (_b = (_a2 = manifest["sap.app"]) == null ? void 0 : _a2.sourceTemplate) == null ? void 0 : _b.toolsId) != null ? _c : types_1.ToolsId.NO_TOOLS_ID;
        }
        return types_1.ToolsId.NO_TOOLS_ID;
      } catch (err) {
        console.log(`[Telemetry]: ${err.message}`);
        return types_1.ToolsId.NO_TOOLS_ID;
      }
    }
  }
});

// ../../node_modules/@sap-ux/store/dist/constants.js
var require_constants5 = __commonJS({
  "../../node_modules/@sap-ux/store/dist/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Entity = void 0;
    var Entity;
    (function(Entity2) {
      Entity2["BackendSystem"] = "system";
      Entity2["TelemetrySetting"] = "telemetrySetting";
    })(Entity = exports2.Entity || (exports2.Entity = {}));
  }
});

// ../../node_modules/@sap-ux/store/node_modules/i18next/dist/esm/i18next.js
var i18next_exports2 = {};
__export(i18next_exports2, {
  default: () => i18next_default2
});
function defer2() {
  var res;
  var rej;
  var promise = new Promise(function(resolve, reject) {
    res = resolve;
    rej = reject;
  });
  promise.resolve = res;
  promise.reject = rej;
  return promise;
}
function makeString2(object) {
  if (object == null)
    return "";
  return "" + object;
}
function copy2(a, s, t) {
  a.forEach(function(m) {
    if (s[m])
      t[m] = s[m];
  });
}
function getLastOfPath2(object, path, Empty) {
  function cleanKey(key2) {
    return key2 && key2.indexOf("###") > -1 ? key2.replace(/###/g, ".") : key2;
  }
  function canNotTraverseDeeper() {
    return !object || typeof object === "string";
  }
  var stack = typeof path !== "string" ? [].concat(path) : path.split(".");
  while (stack.length > 1) {
    if (canNotTraverseDeeper())
      return {};
    var key = cleanKey(stack.shift());
    if (!object[key] && Empty)
      object[key] = new Empty();
    if (Object.prototype.hasOwnProperty.call(object, key)) {
      object = object[key];
    } else {
      object = {};
    }
  }
  if (canNotTraverseDeeper())
    return {};
  return {
    obj: object,
    k: cleanKey(stack.shift())
  };
}
function setPath2(object, path, newValue) {
  var _getLastOfPath = getLastOfPath2(object, path, Object), obj = _getLastOfPath.obj, k = _getLastOfPath.k;
  obj[k] = newValue;
}
function pushPath2(object, path, newValue, concat) {
  var _getLastOfPath2 = getLastOfPath2(object, path, Object), obj = _getLastOfPath2.obj, k = _getLastOfPath2.k;
  obj[k] = obj[k] || [];
  if (concat)
    obj[k] = obj[k].concat(newValue);
  if (!concat)
    obj[k].push(newValue);
}
function getPath2(object, path) {
  var _getLastOfPath3 = getLastOfPath2(object, path), obj = _getLastOfPath3.obj, k = _getLastOfPath3.k;
  if (!obj)
    return void 0;
  return obj[k];
}
function getPathWithDefaults2(data2, defaultData, key) {
  var value = getPath2(data2, key);
  if (value !== void 0) {
    return value;
  }
  return getPath2(defaultData, key);
}
function deepExtend2(target, source, overwrite) {
  for (var prop in source) {
    if (prop !== "__proto__" && prop !== "constructor") {
      if (prop in target) {
        if (typeof target[prop] === "string" || target[prop] instanceof String || typeof source[prop] === "string" || source[prop] instanceof String) {
          if (overwrite)
            target[prop] = source[prop];
        } else {
          deepExtend2(target[prop], source[prop], overwrite);
        }
      } else {
        target[prop] = source[prop];
      }
    }
  }
  return target;
}
function regexEscape2(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
function escape3(data2) {
  if (typeof data2 === "string") {
    return data2.replace(/[&<>"'\/]/g, function(s) {
      return _entityMap2[s];
    });
  }
  return data2;
}
function deepFind(obj, path) {
  var keySeparator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!obj)
    return void 0;
  if (obj[path])
    return obj[path];
  var paths = path.split(keySeparator);
  var current = obj;
  for (var i = 0; i < paths.length; ++i) {
    if (typeof current[paths[i]] === "string" && i + 1 < paths.length) {
      return void 0;
    }
    if (current[paths[i]] === void 0) {
      var j = 2;
      var p = paths.slice(i, i + j).join(keySeparator);
      var mix = current[p];
      while (mix === void 0 && paths.length > i + j) {
        j++;
        p = paths.slice(i, i + j).join(keySeparator);
        mix = current[p];
      }
      if (mix === void 0)
        return void 0;
      if (typeof mix === "string")
        return mix;
      if (p && typeof mix[p] === "string")
        return mix[p];
      var joinedPath = paths.slice(i + j).join(keySeparator);
      if (joinedPath)
        return deepFind(mix, joinedPath, keySeparator);
      return void 0;
    }
    current = current[paths[i]];
  }
  return current;
}
function capitalize2(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}
function createRules2() {
  var rules = {};
  sets2.forEach(function(set) {
    set.lngs.forEach(function(l) {
      rules[l] = {
        numbers: set.nr,
        plurals: _rulesPluralsTypes2[set.fc]
      };
    });
  });
  return rules;
}
function remove2(arr, what) {
  var found = arr.indexOf(what);
  while (found !== -1) {
    arr.splice(found, 1);
    found = arr.indexOf(what);
  }
}
function get2() {
  return {
    debug: false,
    initImmediate: true,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: false,
    whitelist: false,
    nonExplicitWhitelist: false,
    supportedLngs: false,
    nonExplicitSupportedLngs: false,
    load: "all",
    preload: false,
    simplifyPluralSuffix: true,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: false,
    saveMissing: false,
    updateMissing: false,
    saveMissingTo: "fallback",
    saveMissingPlurals: true,
    missingKeyHandler: false,
    missingInterpolationHandler: false,
    postProcess: false,
    postProcessPassResolved: false,
    returnNull: true,
    returnEmptyString: true,
    returnObjects: false,
    joinArrays: false,
    returnedObjectHandler: false,
    parseMissingKeyHandler: false,
    appendNamespaceToMissingKey: false,
    appendNamespaceToCIMode: false,
    overloadTranslationOptionHandler: function handle3(args) {
      var ret = {};
      if (_typeof2(args[1]) === "object")
        ret = args[1];
      if (typeof args[1] === "string")
        ret.defaultValue = args[1];
      if (typeof args[2] === "string")
        ret.tDescription = args[2];
      if (_typeof2(args[2]) === "object" || _typeof2(args[3]) === "object") {
        var options2 = args[3] || args[2];
        Object.keys(options2).forEach(function(key) {
          ret[key] = options2[key];
        });
      }
      return ret;
    },
    interpolation: {
      escapeValue: true,
      format: function format2(value, _format, lng, options2) {
        return value;
      },
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      nestingOptionsSeparator: ",",
      maxReplaces: 1e3,
      skipOnVariables: false
    }
  };
}
function transformOptions2(options2) {
  if (typeof options2.ns === "string")
    options2.ns = [options2.ns];
  if (typeof options2.fallbackLng === "string")
    options2.fallbackLng = [options2.fallbackLng];
  if (typeof options2.fallbackNS === "string")
    options2.fallbackNS = [options2.fallbackNS];
  if (options2.whitelist) {
    if (options2.whitelist && options2.whitelist.indexOf("cimode") < 0) {
      options2.whitelist = options2.whitelist.concat(["cimode"]);
    }
    options2.supportedLngs = options2.whitelist;
  }
  if (options2.nonExplicitWhitelist) {
    options2.nonExplicitSupportedLngs = options2.nonExplicitWhitelist;
  }
  if (options2.supportedLngs && options2.supportedLngs.indexOf("cimode") < 0) {
    options2.supportedLngs = options2.supportedLngs.concat(["cimode"]);
  }
  return options2;
}
function noop2() {
}
var consoleLogger2, Logger2, baseLogger2, EventEmitter2, _entityMap2, isIE10, ResourceStore2, postProcessor2, checkedLoadedFor2, Translator2, LanguageUtil2, sets2, _rulesPluralsTypes2, PluralResolver2, Interpolator2, Connector2, I18n2, i18next2, i18next_default2;
var init_i18next2 = __esm({
  "../../node_modules/@sap-ux/store/node_modules/i18next/dist/esm/i18next.js"() {
    init_typeof();
    init_objectSpread();
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_assertThisInitialized();
    init_inherits();
    consoleLogger2 = {
      type: "logger",
      log: function log2(args) {
        this.output("log", args);
      },
      warn: function warn2(args) {
        this.output("warn", args);
      },
      error: function error2(args) {
        this.output("error", args);
      },
      output: function output2(type, args) {
        if (console && console[type])
          console[type].apply(console, args);
      }
    };
    Logger2 = function() {
      function Logger3(concreteLogger) {
        var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        _classCallCheck(this, Logger3);
        this.init(concreteLogger, options2);
      }
      _createClass(Logger3, [{
        key: "init",
        value: function init(concreteLogger) {
          var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          this.prefix = options2.prefix || "i18next:";
          this.logger = concreteLogger || consoleLogger2;
          this.options = options2;
          this.debug = options2.debug;
        }
      }, {
        key: "setDebug",
        value: function setDebug(bool) {
          this.debug = bool;
        }
      }, {
        key: "log",
        value: function log4() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return this.forward(args, "log", "", true);
        }
      }, {
        key: "warn",
        value: function warn3() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          return this.forward(args, "warn", "", true);
        }
      }, {
        key: "error",
        value: function error3() {
          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }
          return this.forward(args, "error", "");
        }
      }, {
        key: "deprecate",
        value: function deprecate() {
          for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            args[_key4] = arguments[_key4];
          }
          return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
        }
      }, {
        key: "forward",
        value: function forward(args, lvl, prefix, debugOnly) {
          if (debugOnly && !this.debug)
            return null;
          if (typeof args[0] === "string")
            args[0] = "".concat(prefix).concat(this.prefix, " ").concat(args[0]);
          return this.logger[lvl](args);
        }
      }, {
        key: "create",
        value: function create(moduleName) {
          return new Logger3(this.logger, _objectSpread({}, {
            prefix: "".concat(this.prefix, ":").concat(moduleName, ":")
          }, this.options));
        }
      }]);
      return Logger3;
    }();
    baseLogger2 = new Logger2();
    EventEmitter2 = function() {
      function EventEmitter3() {
        _classCallCheck(this, EventEmitter3);
        this.observers = {};
      }
      _createClass(EventEmitter3, [{
        key: "on",
        value: function on(events, listener) {
          var _this = this;
          events.split(" ").forEach(function(event) {
            _this.observers[event] = _this.observers[event] || [];
            _this.observers[event].push(listener);
          });
          return this;
        }
      }, {
        key: "off",
        value: function off(event, listener) {
          if (!this.observers[event])
            return;
          if (!listener) {
            delete this.observers[event];
            return;
          }
          this.observers[event] = this.observers[event].filter(function(l) {
            return l !== listener;
          });
        }
      }, {
        key: "emit",
        value: function emit(event) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          if (this.observers[event]) {
            var cloned = [].concat(this.observers[event]);
            cloned.forEach(function(observer) {
              observer.apply(void 0, args);
            });
          }
          if (this.observers["*"]) {
            var _cloned = [].concat(this.observers["*"]);
            _cloned.forEach(function(observer) {
              observer.apply(observer, [event].concat(args));
            });
          }
        }
      }]);
      return EventEmitter3;
    }();
    _entityMap2 = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;",
      "/": "&#x2F;"
    };
    isIE10 = typeof window !== "undefined" && window.navigator && window.navigator.userAgent && window.navigator.userAgent.indexOf("MSIE") > -1;
    ResourceStore2 = function(_EventEmitter) {
      _inherits(ResourceStore3, _EventEmitter);
      function ResourceStore3(data2) {
        var _this;
        var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
          ns: ["translation"],
          defaultNS: "translation"
        };
        _classCallCheck(this, ResourceStore3);
        _this = _possibleConstructorReturn(this, _getPrototypeOf(ResourceStore3).call(this));
        if (isIE10) {
          EventEmitter2.call(_assertThisInitialized(_this));
        }
        _this.data = data2 || {};
        _this.options = options2;
        if (_this.options.keySeparator === void 0) {
          _this.options.keySeparator = ".";
        }
        if (_this.options.ignoreJSONStructure === void 0) {
          _this.options.ignoreJSONStructure = true;
        }
        return _this;
      }
      _createClass(ResourceStore3, [{
        key: "addNamespaces",
        value: function addNamespaces(ns) {
          if (this.options.ns.indexOf(ns) < 0) {
            this.options.ns.push(ns);
          }
        }
      }, {
        key: "removeNamespaces",
        value: function removeNamespaces(ns) {
          var index = this.options.ns.indexOf(ns);
          if (index > -1) {
            this.options.ns.splice(index, 1);
          }
        }
      }, {
        key: "getResource",
        value: function getResource(lng, ns, key) {
          var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
          var keySeparator = options2.keySeparator !== void 0 ? options2.keySeparator : this.options.keySeparator;
          var ignoreJSONStructure = options2.ignoreJSONStructure !== void 0 ? options2.ignoreJSONStructure : this.options.ignoreJSONStructure;
          var path = [lng, ns];
          if (key && typeof key !== "string")
            path = path.concat(key);
          if (key && typeof key === "string")
            path = path.concat(keySeparator ? key.split(keySeparator) : key);
          if (lng.indexOf(".") > -1) {
            path = lng.split(".");
          }
          var result2 = getPath2(this.data, path);
          if (result2 || !ignoreJSONStructure || typeof key !== "string")
            return result2;
          return deepFind(this.data && this.data[lng] && this.data[lng][ns], key, keySeparator);
        }
      }, {
        key: "addResource",
        value: function addResource(lng, ns, key, value) {
          var options2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
            silent: false
          };
          var keySeparator = this.options.keySeparator;
          if (keySeparator === void 0)
            keySeparator = ".";
          var path = [lng, ns];
          if (key)
            path = path.concat(keySeparator ? key.split(keySeparator) : key);
          if (lng.indexOf(".") > -1) {
            path = lng.split(".");
            value = ns;
            ns = path[1];
          }
          this.addNamespaces(ns);
          setPath2(this.data, path, value);
          if (!options2.silent)
            this.emit("added", lng, ns, key, value);
        }
      }, {
        key: "addResources",
        value: function addResources(lng, ns, resources) {
          var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
            silent: false
          };
          for (var m in resources) {
            if (typeof resources[m] === "string" || Object.prototype.toString.apply(resources[m]) === "[object Array]")
              this.addResource(lng, ns, m, resources[m], {
                silent: true
              });
          }
          if (!options2.silent)
            this.emit("added", lng, ns, resources);
        }
      }, {
        key: "addResourceBundle",
        value: function addResourceBundle(lng, ns, resources, deep, overwrite) {
          var options2 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
            silent: false
          };
          var path = [lng, ns];
          if (lng.indexOf(".") > -1) {
            path = lng.split(".");
            deep = resources;
            resources = ns;
            ns = path[1];
          }
          this.addNamespaces(ns);
          var pack = getPath2(this.data, path) || {};
          if (deep) {
            deepExtend2(pack, resources, overwrite);
          } else {
            pack = _objectSpread({}, pack, resources);
          }
          setPath2(this.data, path, pack);
          if (!options2.silent)
            this.emit("added", lng, ns, resources);
        }
      }, {
        key: "removeResourceBundle",
        value: function removeResourceBundle(lng, ns) {
          if (this.hasResourceBundle(lng, ns)) {
            delete this.data[lng][ns];
          }
          this.removeNamespaces(ns);
          this.emit("removed", lng, ns);
        }
      }, {
        key: "hasResourceBundle",
        value: function hasResourceBundle(lng, ns) {
          return this.getResource(lng, ns) !== void 0;
        }
      }, {
        key: "getResourceBundle",
        value: function getResourceBundle(lng, ns) {
          if (!ns)
            ns = this.options.defaultNS;
          if (this.options.compatibilityAPI === "v1")
            return _objectSpread({}, {}, this.getResource(lng, ns));
          return this.getResource(lng, ns);
        }
      }, {
        key: "getDataByLanguage",
        value: function getDataByLanguage(lng) {
          return this.data[lng];
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          return this.data;
        }
      }]);
      return ResourceStore3;
    }(EventEmitter2);
    postProcessor2 = {
      processors: {},
      addPostProcessor: function addPostProcessor2(module2) {
        this.processors[module2.name] = module2;
      },
      handle: function handle2(processors, value, key, options2, translator) {
        var _this = this;
        processors.forEach(function(processor) {
          if (_this.processors[processor])
            value = _this.processors[processor].process(value, key, options2, translator);
        });
        return value;
      }
    };
    checkedLoadedFor2 = {};
    Translator2 = function(_EventEmitter) {
      _inherits(Translator3, _EventEmitter);
      function Translator3(services) {
        var _this;
        var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        _classCallCheck(this, Translator3);
        _this = _possibleConstructorReturn(this, _getPrototypeOf(Translator3).call(this));
        if (isIE10) {
          EventEmitter2.call(_assertThisInitialized(_this));
        }
        copy2(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, _assertThisInitialized(_this));
        _this.options = options2;
        if (_this.options.keySeparator === void 0) {
          _this.options.keySeparator = ".";
        }
        _this.logger = baseLogger2.create("translator");
        return _this;
      }
      _createClass(Translator3, [{
        key: "changeLanguage",
        value: function changeLanguage(lng) {
          if (lng)
            this.language = lng;
        }
      }, {
        key: "exists",
        value: function exists(key) {
          var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
            interpolation: {}
          };
          var resolved = this.resolve(key, options2);
          return resolved && resolved.res !== void 0;
        }
      }, {
        key: "extractFromKey",
        value: function extractFromKey(key, options2) {
          var nsSeparator = options2.nsSeparator !== void 0 ? options2.nsSeparator : this.options.nsSeparator;
          if (nsSeparator === void 0)
            nsSeparator = ":";
          var keySeparator = options2.keySeparator !== void 0 ? options2.keySeparator : this.options.keySeparator;
          var namespaces = options2.ns || this.options.defaultNS;
          if (nsSeparator && key.indexOf(nsSeparator) > -1) {
            var m = key.match(this.interpolator.nestingRegexp);
            if (m && m.length > 0) {
              return {
                key,
                namespaces
              };
            }
            var parts = key.split(nsSeparator);
            if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1)
              namespaces = parts.shift();
            key = parts.join(keySeparator);
          }
          if (typeof namespaces === "string")
            namespaces = [namespaces];
          return {
            key,
            namespaces
          };
        }
      }, {
        key: "translate",
        value: function translate(keys, options2, lastKey) {
          var _this2 = this;
          if (_typeof2(options2) !== "object" && this.options.overloadTranslationOptionHandler) {
            options2 = this.options.overloadTranslationOptionHandler(arguments);
          }
          if (!options2)
            options2 = {};
          if (keys === void 0 || keys === null)
            return "";
          if (!Array.isArray(keys))
            keys = [String(keys)];
          var keySeparator = options2.keySeparator !== void 0 ? options2.keySeparator : this.options.keySeparator;
          var _this$extractFromKey = this.extractFromKey(keys[keys.length - 1], options2), key = _this$extractFromKey.key, namespaces = _this$extractFromKey.namespaces;
          var namespace = namespaces[namespaces.length - 1];
          var lng = options2.lng || this.language;
          var appendNamespaceToCIMode = options2.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
          if (lng && lng.toLowerCase() === "cimode") {
            if (appendNamespaceToCIMode) {
              var nsSeparator = options2.nsSeparator || this.options.nsSeparator;
              return namespace + nsSeparator + key;
            }
            return key;
          }
          var resolved = this.resolve(keys, options2);
          var res = resolved && resolved.res;
          var resUsedKey = resolved && resolved.usedKey || key;
          var resExactUsedKey = resolved && resolved.exactUsedKey || key;
          var resType = Object.prototype.toString.apply(res);
          var noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
          var joinArrays = options2.joinArrays !== void 0 ? options2.joinArrays : this.options.joinArrays;
          var handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
          var handleAsObject = typeof res !== "string" && typeof res !== "boolean" && typeof res !== "number";
          if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === "string" && resType === "[object Array]")) {
            if (!options2.returnObjects && !this.options.returnObjects) {
              if (!this.options.returnedObjectHandler) {
                this.logger.warn("accessing an object - but returnObjects options is not enabled!");
              }
              return this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, _objectSpread({}, options2, {
                ns: namespaces
              })) : "key '".concat(key, " (").concat(this.language, ")' returned an object instead of string.");
            }
            if (keySeparator) {
              var resTypeIsArray = resType === "[object Array]";
              var copy3 = resTypeIsArray ? [] : {};
              var newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
              for (var m in res) {
                if (Object.prototype.hasOwnProperty.call(res, m)) {
                  var deepKey = "".concat(newKeyToUse).concat(keySeparator).concat(m);
                  copy3[m] = this.translate(deepKey, _objectSpread({}, options2, {
                    joinArrays: false,
                    ns: namespaces
                  }));
                  if (copy3[m] === deepKey)
                    copy3[m] = res[m];
                }
              }
              res = copy3;
            }
          } else if (handleAsObjectInI18nFormat && typeof joinArrays === "string" && resType === "[object Array]") {
            res = res.join(joinArrays);
            if (res)
              res = this.extendTranslation(res, keys, options2, lastKey);
          } else {
            var usedDefault = false;
            var usedKey = false;
            var needsPluralHandling = options2.count !== void 0 && typeof options2.count !== "string";
            var hasDefaultValue = Translator3.hasDefaultValue(options2);
            var defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options2.count) : "";
            var defaultValue = options2["defaultValue".concat(defaultValueSuffix)] || options2.defaultValue;
            if (!this.isValidLookup(res) && hasDefaultValue) {
              usedDefault = true;
              res = defaultValue;
            }
            if (!this.isValidLookup(res)) {
              usedKey = true;
              res = key;
            }
            var updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
            if (usedKey || usedDefault || updateMissing) {
              this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key, updateMissing ? defaultValue : res);
              if (keySeparator) {
                var fk = this.resolve(key, _objectSpread({}, options2, {
                  keySeparator: false
                }));
                if (fk && fk.res)
                  this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
              }
              var lngs = [];
              var fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options2.lng || this.language);
              if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
                for (var i = 0; i < fallbackLngs.length; i++) {
                  lngs.push(fallbackLngs[i]);
                }
              } else if (this.options.saveMissingTo === "all") {
                lngs = this.languageUtils.toResolveHierarchy(options2.lng || this.language);
              } else {
                lngs.push(options2.lng || this.language);
              }
              var send = function send2(l, k, fallbackValue) {
                if (_this2.options.missingKeyHandler) {
                  _this2.options.missingKeyHandler(l, namespace, k, updateMissing ? fallbackValue : res, updateMissing, options2);
                } else if (_this2.backendConnector && _this2.backendConnector.saveMissing) {
                  _this2.backendConnector.saveMissing(l, namespace, k, updateMissing ? fallbackValue : res, updateMissing, options2);
                }
                _this2.emit("missingKey", l, namespace, k, res);
              };
              if (this.options.saveMissing) {
                if (this.options.saveMissingPlurals && needsPluralHandling) {
                  lngs.forEach(function(language) {
                    _this2.pluralResolver.getSuffixes(language).forEach(function(suffix) {
                      send([language], key + suffix, options2["defaultValue".concat(suffix)] || defaultValue);
                    });
                  });
                } else {
                  send(lngs, key, defaultValue);
                }
              }
            }
            res = this.extendTranslation(res, keys, options2, resolved, lastKey);
            if (usedKey && res === key && this.options.appendNamespaceToMissingKey)
              res = "".concat(namespace, ":").concat(key);
            if (usedKey && this.options.parseMissingKeyHandler)
              res = this.options.parseMissingKeyHandler(res);
          }
          return res;
        }
      }, {
        key: "extendTranslation",
        value: function extendTranslation(res, key, options2, resolved, lastKey) {
          var _this3 = this;
          if (this.i18nFormat && this.i18nFormat.parse) {
            res = this.i18nFormat.parse(res, options2, resolved.usedLng, resolved.usedNS, resolved.usedKey, {
              resolved
            });
          } else if (!options2.skipInterpolation) {
            if (options2.interpolation)
              this.interpolator.init(_objectSpread({}, options2, {
                interpolation: _objectSpread({}, this.options.interpolation, options2.interpolation)
              }));
            var skipOnVariables = options2.interpolation && options2.interpolation.skipOnVariables || this.options.interpolation.skipOnVariables;
            var nestBef;
            if (skipOnVariables) {
              var nb = res.match(this.interpolator.nestingRegexp);
              nestBef = nb && nb.length;
            }
            var data2 = options2.replace && typeof options2.replace !== "string" ? options2.replace : options2;
            if (this.options.interpolation.defaultVariables)
              data2 = _objectSpread({}, this.options.interpolation.defaultVariables, data2);
            res = this.interpolator.interpolate(res, data2, options2.lng || this.language, options2);
            if (skipOnVariables) {
              var na = res.match(this.interpolator.nestingRegexp);
              var nestAft = na && na.length;
              if (nestBef < nestAft)
                options2.nest = false;
            }
            if (options2.nest !== false)
              res = this.interpolator.nest(res, function() {
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                if (lastKey && lastKey[0] === args[0] && !options2.context) {
                  _this3.logger.warn("It seems you are nesting recursively key: ".concat(args[0], " in key: ").concat(key[0]));
                  return null;
                }
                return _this3.translate.apply(_this3, args.concat([key]));
              }, options2);
            if (options2.interpolation)
              this.interpolator.reset();
          }
          var postProcess = options2.postProcess || this.options.postProcess;
          var postProcessorNames = typeof postProcess === "string" ? [postProcess] : postProcess;
          if (res !== void 0 && res !== null && postProcessorNames && postProcessorNames.length && options2.applyPostProcessor !== false) {
            res = postProcessor2.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? _objectSpread({
              i18nResolved: resolved
            }, options2) : options2, this);
          }
          return res;
        }
      }, {
        key: "resolve",
        value: function resolve(keys) {
          var _this4 = this;
          var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var found;
          var usedKey;
          var exactUsedKey;
          var usedLng;
          var usedNS;
          if (typeof keys === "string")
            keys = [keys];
          keys.forEach(function(k) {
            if (_this4.isValidLookup(found))
              return;
            var extracted = _this4.extractFromKey(k, options2);
            var key = extracted.key;
            usedKey = key;
            var namespaces = extracted.namespaces;
            if (_this4.options.fallbackNS)
              namespaces = namespaces.concat(_this4.options.fallbackNS);
            var needsPluralHandling = options2.count !== void 0 && typeof options2.count !== "string";
            var needsContextHandling = options2.context !== void 0 && (typeof options2.context === "string" || typeof options2.context === "number") && options2.context !== "";
            var codes = options2.lngs ? options2.lngs : _this4.languageUtils.toResolveHierarchy(options2.lng || _this4.language, options2.fallbackLng);
            namespaces.forEach(function(ns) {
              if (_this4.isValidLookup(found))
                return;
              usedNS = ns;
              if (!checkedLoadedFor2["".concat(codes[0], "-").concat(ns)] && _this4.utils && _this4.utils.hasLoadedNamespace && !_this4.utils.hasLoadedNamespace(usedNS)) {
                checkedLoadedFor2["".concat(codes[0], "-").concat(ns)] = true;
                _this4.logger.warn('key "'.concat(usedKey, '" for languages "').concat(codes.join(", "), `" won't get resolved as namespace "`).concat(usedNS, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
              }
              codes.forEach(function(code) {
                if (_this4.isValidLookup(found))
                  return;
                usedLng = code;
                var finalKey = key;
                var finalKeys = [finalKey];
                if (_this4.i18nFormat && _this4.i18nFormat.addLookupKeys) {
                  _this4.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options2);
                } else {
                  var pluralSuffix;
                  if (needsPluralHandling)
                    pluralSuffix = _this4.pluralResolver.getSuffix(code, options2.count);
                  if (needsPluralHandling && needsContextHandling)
                    finalKeys.push(finalKey + pluralSuffix);
                  if (needsContextHandling)
                    finalKeys.push(finalKey += "".concat(_this4.options.contextSeparator).concat(options2.context));
                  if (needsPluralHandling)
                    finalKeys.push(finalKey += pluralSuffix);
                }
                var possibleKey;
                while (possibleKey = finalKeys.pop()) {
                  if (!_this4.isValidLookup(found)) {
                    exactUsedKey = possibleKey;
                    found = _this4.getResource(code, ns, possibleKey, options2);
                  }
                }
              });
            });
          });
          return {
            res: found,
            usedKey,
            exactUsedKey,
            usedLng,
            usedNS
          };
        }
      }, {
        key: "isValidLookup",
        value: function isValidLookup(res) {
          return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
        }
      }, {
        key: "getResource",
        value: function getResource(code, ns, key) {
          var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
          if (this.i18nFormat && this.i18nFormat.getResource)
            return this.i18nFormat.getResource(code, ns, key, options2);
          return this.resourceStore.getResource(code, ns, key, options2);
        }
      }], [{
        key: "hasDefaultValue",
        value: function hasDefaultValue(options2) {
          var prefix = "defaultValue";
          for (var option in options2) {
            if (Object.prototype.hasOwnProperty.call(options2, option) && prefix === option.substring(0, prefix.length) && void 0 !== options2[option]) {
              return true;
            }
          }
          return false;
        }
      }]);
      return Translator3;
    }(EventEmitter2);
    LanguageUtil2 = function() {
      function LanguageUtil3(options2) {
        _classCallCheck(this, LanguageUtil3);
        this.options = options2;
        this.whitelist = this.options.supportedLngs || false;
        this.supportedLngs = this.options.supportedLngs || false;
        this.logger = baseLogger2.create("languageUtils");
      }
      _createClass(LanguageUtil3, [{
        key: "getScriptPartFromCode",
        value: function getScriptPartFromCode(code) {
          if (!code || code.indexOf("-") < 0)
            return null;
          var p = code.split("-");
          if (p.length === 2)
            return null;
          p.pop();
          if (p[p.length - 1].toLowerCase() === "x")
            return null;
          return this.formatLanguageCode(p.join("-"));
        }
      }, {
        key: "getLanguagePartFromCode",
        value: function getLanguagePartFromCode(code) {
          if (!code || code.indexOf("-") < 0)
            return code;
          var p = code.split("-");
          return this.formatLanguageCode(p[0]);
        }
      }, {
        key: "formatLanguageCode",
        value: function formatLanguageCode(code) {
          if (typeof code === "string" && code.indexOf("-") > -1) {
            var specialCases = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
            var p = code.split("-");
            if (this.options.lowerCaseLng) {
              p = p.map(function(part) {
                return part.toLowerCase();
              });
            } else if (p.length === 2) {
              p[0] = p[0].toLowerCase();
              p[1] = p[1].toUpperCase();
              if (specialCases.indexOf(p[1].toLowerCase()) > -1)
                p[1] = capitalize2(p[1].toLowerCase());
            } else if (p.length === 3) {
              p[0] = p[0].toLowerCase();
              if (p[1].length === 2)
                p[1] = p[1].toUpperCase();
              if (p[0] !== "sgn" && p[2].length === 2)
                p[2] = p[2].toUpperCase();
              if (specialCases.indexOf(p[1].toLowerCase()) > -1)
                p[1] = capitalize2(p[1].toLowerCase());
              if (specialCases.indexOf(p[2].toLowerCase()) > -1)
                p[2] = capitalize2(p[2].toLowerCase());
            }
            return p.join("-");
          }
          return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
        }
      }, {
        key: "isWhitelisted",
        value: function isWhitelisted(code) {
          this.logger.deprecate("languageUtils.isWhitelisted", `function "isWhitelisted" will be renamed to "isSupportedCode" in the next major - please make sure to rename it's usage asap.`);
          return this.isSupportedCode(code);
        }
      }, {
        key: "isSupportedCode",
        value: function isSupportedCode(code) {
          if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) {
            code = this.getLanguagePartFromCode(code);
          }
          return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
        }
      }, {
        key: "getBestMatchFromCodes",
        value: function getBestMatchFromCodes(codes) {
          var _this = this;
          if (!codes)
            return null;
          var found;
          codes.forEach(function(code) {
            if (found)
              return;
            var cleanedLng = _this.formatLanguageCode(code);
            if (!_this.options.supportedLngs || _this.isSupportedCode(cleanedLng))
              found = cleanedLng;
          });
          if (!found && this.options.supportedLngs) {
            codes.forEach(function(code) {
              if (found)
                return;
              var lngOnly = _this.getLanguagePartFromCode(code);
              if (_this.isSupportedCode(lngOnly))
                return found = lngOnly;
              found = _this.options.supportedLngs.find(function(supportedLng) {
                if (supportedLng.indexOf(lngOnly) === 0)
                  return supportedLng;
              });
            });
          }
          if (!found)
            found = this.getFallbackCodes(this.options.fallbackLng)[0];
          return found;
        }
      }, {
        key: "getFallbackCodes",
        value: function getFallbackCodes(fallbacks, code) {
          if (!fallbacks)
            return [];
          if (typeof fallbacks === "function")
            fallbacks = fallbacks(code);
          if (typeof fallbacks === "string")
            fallbacks = [fallbacks];
          if (Object.prototype.toString.apply(fallbacks) === "[object Array]")
            return fallbacks;
          if (!code)
            return fallbacks["default"] || [];
          var found = fallbacks[code];
          if (!found)
            found = fallbacks[this.getScriptPartFromCode(code)];
          if (!found)
            found = fallbacks[this.formatLanguageCode(code)];
          if (!found)
            found = fallbacks[this.getLanguagePartFromCode(code)];
          if (!found)
            found = fallbacks["default"];
          return found || [];
        }
      }, {
        key: "toResolveHierarchy",
        value: function toResolveHierarchy(code, fallbackCode) {
          var _this2 = this;
          var fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
          var codes = [];
          var addCode = function addCode2(c) {
            if (!c)
              return;
            if (_this2.isSupportedCode(c)) {
              codes.push(c);
            } else {
              _this2.logger.warn("rejecting language code not found in supportedLngs: ".concat(c));
            }
          };
          if (typeof code === "string" && code.indexOf("-") > -1) {
            if (this.options.load !== "languageOnly")
              addCode(this.formatLanguageCode(code));
            if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly")
              addCode(this.getScriptPartFromCode(code));
            if (this.options.load !== "currentOnly")
              addCode(this.getLanguagePartFromCode(code));
          } else if (typeof code === "string") {
            addCode(this.formatLanguageCode(code));
          }
          fallbackCodes.forEach(function(fc) {
            if (codes.indexOf(fc) < 0)
              addCode(_this2.formatLanguageCode(fc));
          });
          return codes;
        }
      }]);
      return LanguageUtil3;
    }();
    sets2 = [{
      lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
      nr: [1, 2],
      fc: 1
    }, {
      lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
      nr: [1, 2],
      fc: 2
    }, {
      lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
      nr: [1],
      fc: 3
    }, {
      lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
      nr: [1, 2, 5],
      fc: 4
    }, {
      lngs: ["ar"],
      nr: [0, 1, 2, 3, 11, 100],
      fc: 5
    }, {
      lngs: ["cs", "sk"],
      nr: [1, 2, 5],
      fc: 6
    }, {
      lngs: ["csb", "pl"],
      nr: [1, 2, 5],
      fc: 7
    }, {
      lngs: ["cy"],
      nr: [1, 2, 3, 8],
      fc: 8
    }, {
      lngs: ["fr"],
      nr: [1, 2],
      fc: 9
    }, {
      lngs: ["ga"],
      nr: [1, 2, 3, 7, 11],
      fc: 10
    }, {
      lngs: ["gd"],
      nr: [1, 2, 3, 20],
      fc: 11
    }, {
      lngs: ["is"],
      nr: [1, 2],
      fc: 12
    }, {
      lngs: ["jv"],
      nr: [0, 1],
      fc: 13
    }, {
      lngs: ["kw"],
      nr: [1, 2, 3, 4],
      fc: 14
    }, {
      lngs: ["lt"],
      nr: [1, 2, 10],
      fc: 15
    }, {
      lngs: ["lv"],
      nr: [1, 2, 0],
      fc: 16
    }, {
      lngs: ["mk"],
      nr: [1, 2],
      fc: 17
    }, {
      lngs: ["mnk"],
      nr: [0, 1, 2],
      fc: 18
    }, {
      lngs: ["mt"],
      nr: [1, 2, 11, 20],
      fc: 19
    }, {
      lngs: ["or"],
      nr: [2, 1],
      fc: 2
    }, {
      lngs: ["ro"],
      nr: [1, 2, 20],
      fc: 20
    }, {
      lngs: ["sl"],
      nr: [5, 1, 2, 3],
      fc: 21
    }, {
      lngs: ["he", "iw"],
      nr: [1, 2, 20, 21],
      fc: 22
    }];
    _rulesPluralsTypes2 = {
      1: function _23(n) {
        return Number(n > 1);
      },
      2: function _24(n) {
        return Number(n != 1);
      },
      3: function _25(n) {
        return 0;
      },
      4: function _26(n) {
        return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
      },
      5: function _27(n) {
        return Number(n == 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5);
      },
      6: function _28(n) {
        return Number(n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2);
      },
      7: function _29(n) {
        return Number(n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
      },
      8: function _30(n) {
        return Number(n == 1 ? 0 : n == 2 ? 1 : n != 8 && n != 11 ? 2 : 3);
      },
      9: function _31(n) {
        return Number(n >= 2);
      },
      10: function _32(n) {
        return Number(n == 1 ? 0 : n == 2 ? 1 : n < 7 ? 2 : n < 11 ? 3 : 4);
      },
      11: function _33(n) {
        return Number(n == 1 || n == 11 ? 0 : n == 2 || n == 12 ? 1 : n > 2 && n < 20 ? 2 : 3);
      },
      12: function _34(n) {
        return Number(n % 10 != 1 || n % 100 == 11);
      },
      13: function _35(n) {
        return Number(n !== 0);
      },
      14: function _36(n) {
        return Number(n == 1 ? 0 : n == 2 ? 1 : n == 3 ? 2 : 3);
      },
      15: function _37(n) {
        return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
      },
      16: function _38(n) {
        return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n !== 0 ? 1 : 2);
      },
      17: function _39(n) {
        return Number(n == 1 || n % 10 == 1 && n % 100 != 11 ? 0 : 1);
      },
      18: function _40(n) {
        return Number(n == 0 ? 0 : n == 1 ? 1 : 2);
      },
      19: function _41(n) {
        return Number(n == 1 ? 0 : n == 0 || n % 100 > 1 && n % 100 < 11 ? 1 : n % 100 > 10 && n % 100 < 20 ? 2 : 3);
      },
      20: function _42(n) {
        return Number(n == 1 ? 0 : n == 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2);
      },
      21: function _43(n) {
        return Number(n % 100 == 1 ? 1 : n % 100 == 2 ? 2 : n % 100 == 3 || n % 100 == 4 ? 3 : 0);
      },
      22: function _44(n) {
        return Number(n == 1 ? 0 : n == 2 ? 1 : (n < 0 || n > 10) && n % 10 == 0 ? 2 : 3);
      }
    };
    PluralResolver2 = function() {
      function PluralResolver3(languageUtils) {
        var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        _classCallCheck(this, PluralResolver3);
        this.languageUtils = languageUtils;
        this.options = options2;
        this.logger = baseLogger2.create("pluralResolver");
        this.rules = createRules2();
      }
      _createClass(PluralResolver3, [{
        key: "addRule",
        value: function addRule(lng, obj) {
          this.rules[lng] = obj;
        }
      }, {
        key: "getRule",
        value: function getRule(code) {
          return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
        }
      }, {
        key: "needsPlural",
        value: function needsPlural(code) {
          var rule = this.getRule(code);
          return rule && rule.numbers.length > 1;
        }
      }, {
        key: "getPluralFormsOfKey",
        value: function getPluralFormsOfKey(code, key) {
          return this.getSuffixes(code).map(function(suffix) {
            return key + suffix;
          });
        }
      }, {
        key: "getSuffixes",
        value: function getSuffixes(code) {
          var _this = this;
          var rule = this.getRule(code);
          if (!rule) {
            return [];
          }
          return rule.numbers.map(function(number) {
            return _this.getSuffix(code, number);
          });
        }
      }, {
        key: "getSuffix",
        value: function getSuffix(code, count) {
          var _this2 = this;
          var rule = this.getRule(code);
          if (rule) {
            var idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
            var suffix = rule.numbers[idx];
            if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
              if (suffix === 2) {
                suffix = "plural";
              } else if (suffix === 1) {
                suffix = "";
              }
            }
            var returnSuffix = function returnSuffix2() {
              return _this2.options.prepend && suffix.toString() ? _this2.options.prepend + suffix.toString() : suffix.toString();
            };
            if (this.options.compatibilityJSON === "v1") {
              if (suffix === 1)
                return "";
              if (typeof suffix === "number")
                return "_plural_".concat(suffix.toString());
              return returnSuffix();
            } else if (this.options.compatibilityJSON === "v2") {
              return returnSuffix();
            } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
              return returnSuffix();
            }
            return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
          }
          this.logger.warn("no plural rule found for: ".concat(code));
          return "";
        }
      }]);
      return PluralResolver3;
    }();
    Interpolator2 = function() {
      function Interpolator3() {
        var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _classCallCheck(this, Interpolator3);
        this.logger = baseLogger2.create("interpolator");
        this.options = options2;
        this.format = options2.interpolation && options2.interpolation.format || function(value) {
          return value;
        };
        this.init(options2);
      }
      _createClass(Interpolator3, [{
        key: "init",
        value: function init() {
          var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          if (!options2.interpolation)
            options2.interpolation = {
              escapeValue: true
            };
          var iOpts = options2.interpolation;
          this.escape = iOpts.escape !== void 0 ? iOpts.escape : escape3;
          this.escapeValue = iOpts.escapeValue !== void 0 ? iOpts.escapeValue : true;
          this.useRawValueToEscape = iOpts.useRawValueToEscape !== void 0 ? iOpts.useRawValueToEscape : false;
          this.prefix = iOpts.prefix ? regexEscape2(iOpts.prefix) : iOpts.prefixEscaped || "{{";
          this.suffix = iOpts.suffix ? regexEscape2(iOpts.suffix) : iOpts.suffixEscaped || "}}";
          this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
          this.unescapePrefix = iOpts.unescapeSuffix ? "" : iOpts.unescapePrefix || "-";
          this.unescapeSuffix = this.unescapePrefix ? "" : iOpts.unescapeSuffix || "";
          this.nestingPrefix = iOpts.nestingPrefix ? regexEscape2(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape2("$t(");
          this.nestingSuffix = iOpts.nestingSuffix ? regexEscape2(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape2(")");
          this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || ",";
          this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1e3;
          this.alwaysFormat = iOpts.alwaysFormat !== void 0 ? iOpts.alwaysFormat : false;
          this.resetRegExp();
        }
      }, {
        key: "reset",
        value: function reset() {
          if (this.options)
            this.init(this.options);
        }
      }, {
        key: "resetRegExp",
        value: function resetRegExp() {
          var regexpStr = "".concat(this.prefix, "(.+?)").concat(this.suffix);
          this.regexp = new RegExp(regexpStr, "g");
          var regexpUnescapeStr = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
          this.regexpUnescape = new RegExp(regexpUnescapeStr, "g");
          var nestingRegexpStr = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
          this.nestingRegexp = new RegExp(nestingRegexpStr, "g");
        }
      }, {
        key: "interpolate",
        value: function interpolate(str, data2, lng, options2) {
          var _this = this;
          var match;
          var value;
          var replaces;
          var defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
          function regexSafe(val) {
            return val.replace(/\$/g, "$$$$");
          }
          var handleFormat = function handleFormat2(key) {
            if (key.indexOf(_this.formatSeparator) < 0) {
              var path = getPathWithDefaults2(data2, defaultData, key);
              return _this.alwaysFormat ? _this.format(path, void 0, lng, _objectSpread({}, options2, data2, {
                interpolationkey: key
              })) : path;
            }
            var p = key.split(_this.formatSeparator);
            var k = p.shift().trim();
            var f = p.join(_this.formatSeparator).trim();
            return _this.format(getPathWithDefaults2(data2, defaultData, k), f, lng, _objectSpread({}, options2, data2, {
              interpolationkey: k
            }));
          };
          this.resetRegExp();
          var missingInterpolationHandler = options2 && options2.missingInterpolationHandler || this.options.missingInterpolationHandler;
          var skipOnVariables = options2 && options2.interpolation && options2.interpolation.skipOnVariables || this.options.interpolation.skipOnVariables;
          var todos = [{
            regex: this.regexpUnescape,
            safeValue: function safeValue(val) {
              return regexSafe(val);
            }
          }, {
            regex: this.regexp,
            safeValue: function safeValue(val) {
              return _this.escapeValue ? regexSafe(_this.escape(val)) : regexSafe(val);
            }
          }];
          todos.forEach(function(todo) {
            replaces = 0;
            while (match = todo.regex.exec(str)) {
              value = handleFormat(match[1].trim());
              if (value === void 0) {
                if (typeof missingInterpolationHandler === "function") {
                  var temp = missingInterpolationHandler(str, match, options2);
                  value = typeof temp === "string" ? temp : "";
                } else if (skipOnVariables) {
                  value = match[0];
                  continue;
                } else {
                  _this.logger.warn("missed to pass in variable ".concat(match[1], " for interpolating ").concat(str));
                  value = "";
                }
              } else if (typeof value !== "string" && !_this.useRawValueToEscape) {
                value = makeString2(value);
              }
              var safeValue = todo.safeValue(value);
              str = str.replace(match[0], safeValue);
              if (skipOnVariables) {
                todo.regex.lastIndex += safeValue.length;
                todo.regex.lastIndex -= match[0].length;
              } else {
                todo.regex.lastIndex = 0;
              }
              replaces++;
              if (replaces >= _this.maxReplaces) {
                break;
              }
            }
          });
          return str;
        }
      }, {
        key: "nest",
        value: function nest(str, fc) {
          var _this2 = this;
          var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          var match;
          var value;
          var clonedOptions = _objectSpread({}, options2);
          clonedOptions.applyPostProcessor = false;
          delete clonedOptions.defaultValue;
          function handleHasOptions(key, inheritedOptions) {
            var sep = this.nestingOptionsSeparator;
            if (key.indexOf(sep) < 0)
              return key;
            var c = key.split(new RegExp("".concat(sep, "[ ]*{")));
            var optionsString = "{".concat(c[1]);
            key = c[0];
            optionsString = this.interpolate(optionsString, clonedOptions);
            optionsString = optionsString.replace(/'/g, '"');
            try {
              clonedOptions = JSON.parse(optionsString);
              if (inheritedOptions)
                clonedOptions = _objectSpread({}, inheritedOptions, clonedOptions);
            } catch (e) {
              this.logger.warn("failed parsing options string in nesting for key ".concat(key), e);
              return "".concat(key).concat(sep).concat(optionsString);
            }
            delete clonedOptions.defaultValue;
            return key;
          }
          while (match = this.nestingRegexp.exec(str)) {
            var formatters = [];
            var doReduce = false;
            if (match[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match[1])) {
              var r = match[1].split(this.formatSeparator).map(function(elem) {
                return elem.trim();
              });
              match[1] = r.shift();
              formatters = r;
              doReduce = true;
            }
            value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
            if (value && match[0] === str && typeof value !== "string")
              return value;
            if (typeof value !== "string")
              value = makeString2(value);
            if (!value) {
              this.logger.warn("missed to resolve ".concat(match[1], " for nesting ").concat(str));
              value = "";
            }
            if (doReduce) {
              value = formatters.reduce(function(v, f) {
                return _this2.format(v, f, options2.lng, _objectSpread({}, options2, {
                  interpolationkey: match[1].trim()
                }));
              }, value.trim());
            }
            str = str.replace(match[0], value);
            this.regexp.lastIndex = 0;
          }
          return str;
        }
      }]);
      return Interpolator3;
    }();
    Connector2 = function(_EventEmitter) {
      _inherits(Connector3, _EventEmitter);
      function Connector3(backend, store, services) {
        var _this;
        var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        _classCallCheck(this, Connector3);
        _this = _possibleConstructorReturn(this, _getPrototypeOf(Connector3).call(this));
        if (isIE10) {
          EventEmitter2.call(_assertThisInitialized(_this));
        }
        _this.backend = backend;
        _this.store = store;
        _this.services = services;
        _this.languageUtils = services.languageUtils;
        _this.options = options2;
        _this.logger = baseLogger2.create("backendConnector");
        _this.state = {};
        _this.queue = [];
        if (_this.backend && _this.backend.init) {
          _this.backend.init(services, options2.backend, options2);
        }
        return _this;
      }
      _createClass(Connector3, [{
        key: "queueLoad",
        value: function queueLoad(languages, namespaces, options2, callback) {
          var _this2 = this;
          var toLoad = [];
          var pending = [];
          var toLoadLanguages = [];
          var toLoadNamespaces = [];
          languages.forEach(function(lng) {
            var hasAllNamespaces = true;
            namespaces.forEach(function(ns) {
              var name = "".concat(lng, "|").concat(ns);
              if (!options2.reload && _this2.store.hasResourceBundle(lng, ns)) {
                _this2.state[name] = 2;
              } else if (_this2.state[name] < 0)
                ;
              else if (_this2.state[name] === 1) {
                if (pending.indexOf(name) < 0)
                  pending.push(name);
              } else {
                _this2.state[name] = 1;
                hasAllNamespaces = false;
                if (pending.indexOf(name) < 0)
                  pending.push(name);
                if (toLoad.indexOf(name) < 0)
                  toLoad.push(name);
                if (toLoadNamespaces.indexOf(ns) < 0)
                  toLoadNamespaces.push(ns);
              }
            });
            if (!hasAllNamespaces)
              toLoadLanguages.push(lng);
          });
          if (toLoad.length || pending.length) {
            this.queue.push({
              pending,
              loaded: {},
              errors: [],
              callback
            });
          }
          return {
            toLoad,
            pending,
            toLoadLanguages,
            toLoadNamespaces
          };
        }
      }, {
        key: "loaded",
        value: function loaded(name, err, data2) {
          var s = name.split("|");
          var lng = s[0];
          var ns = s[1];
          if (err)
            this.emit("failedLoading", lng, ns, err);
          if (data2) {
            this.store.addResourceBundle(lng, ns, data2);
          }
          this.state[name] = err ? -1 : 2;
          var loaded2 = {};
          this.queue.forEach(function(q) {
            pushPath2(q.loaded, [lng], ns);
            remove2(q.pending, name);
            if (err)
              q.errors.push(err);
            if (q.pending.length === 0 && !q.done) {
              Object.keys(q.loaded).forEach(function(l) {
                if (!loaded2[l])
                  loaded2[l] = [];
                if (q.loaded[l].length) {
                  q.loaded[l].forEach(function(ns2) {
                    if (loaded2[l].indexOf(ns2) < 0)
                      loaded2[l].push(ns2);
                  });
                }
              });
              q.done = true;
              if (q.errors.length) {
                q.callback(q.errors);
              } else {
                q.callback();
              }
            }
          });
          this.emit("loaded", loaded2);
          this.queue = this.queue.filter(function(q) {
            return !q.done;
          });
        }
      }, {
        key: "read",
        value: function read(lng, ns, fcName) {
          var _this3 = this;
          var tried = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
          var wait = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 350;
          var callback = arguments.length > 5 ? arguments[5] : void 0;
          if (!lng.length)
            return callback(null, {});
          return this.backend[fcName](lng, ns, function(err, data2) {
            if (err && data2 && tried < 5) {
              setTimeout(function() {
                _this3.read.call(_this3, lng, ns, fcName, tried + 1, wait * 2, callback);
              }, wait);
              return;
            }
            callback(err, data2);
          });
        }
      }, {
        key: "prepareLoading",
        value: function prepareLoading(languages, namespaces) {
          var _this4 = this;
          var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          var callback = arguments.length > 3 ? arguments[3] : void 0;
          if (!this.backend) {
            this.logger.warn("No backend was added via i18next.use. Will not load resources.");
            return callback && callback();
          }
          if (typeof languages === "string")
            languages = this.languageUtils.toResolveHierarchy(languages);
          if (typeof namespaces === "string")
            namespaces = [namespaces];
          var toLoad = this.queueLoad(languages, namespaces, options2, callback);
          if (!toLoad.toLoad.length) {
            if (!toLoad.pending.length)
              callback();
            return null;
          }
          toLoad.toLoad.forEach(function(name) {
            _this4.loadOne(name);
          });
        }
      }, {
        key: "load",
        value: function load(languages, namespaces, callback) {
          this.prepareLoading(languages, namespaces, {}, callback);
        }
      }, {
        key: "reload",
        value: function reload(languages, namespaces, callback) {
          this.prepareLoading(languages, namespaces, {
            reload: true
          }, callback);
        }
      }, {
        key: "loadOne",
        value: function loadOne(name) {
          var _this5 = this;
          var prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
          var s = name.split("|");
          var lng = s[0];
          var ns = s[1];
          this.read(lng, ns, "read", void 0, void 0, function(err, data2) {
            if (err)
              _this5.logger.warn("".concat(prefix, "loading namespace ").concat(ns, " for language ").concat(lng, " failed"), err);
            if (!err && data2)
              _this5.logger.log("".concat(prefix, "loaded namespace ").concat(ns, " for language ").concat(lng), data2);
            _this5.loaded(name, err, data2);
          });
        }
      }, {
        key: "saveMissing",
        value: function saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
          var options2 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
          if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
            this.logger.warn('did not save key "'.concat(key, '" as the namespace "').concat(namespace, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
            return;
          }
          if (key === void 0 || key === null || key === "")
            return;
          if (this.backend && this.backend.create) {
            this.backend.create(languages, namespace, key, fallbackValue, null, _objectSpread({}, options2, {
              isUpdate
            }));
          }
          if (!languages || !languages[0])
            return;
          this.store.addResource(languages[0], namespace, key, fallbackValue);
        }
      }]);
      return Connector3;
    }(EventEmitter2);
    I18n2 = function(_EventEmitter) {
      _inherits(I18n3, _EventEmitter);
      function I18n3() {
        var _this;
        var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var callback = arguments.length > 1 ? arguments[1] : void 0;
        _classCallCheck(this, I18n3);
        _this = _possibleConstructorReturn(this, _getPrototypeOf(I18n3).call(this));
        if (isIE10) {
          EventEmitter2.call(_assertThisInitialized(_this));
        }
        _this.options = transformOptions2(options2);
        _this.services = {};
        _this.logger = baseLogger2;
        _this.modules = {
          external: []
        };
        if (callback && !_this.isInitialized && !options2.isClone) {
          if (!_this.options.initImmediate) {
            _this.init(options2, callback);
            return _possibleConstructorReturn(_this, _assertThisInitialized(_this));
          }
          setTimeout(function() {
            _this.init(options2, callback);
          }, 0);
        }
        return _this;
      }
      _createClass(I18n3, [{
        key: "init",
        value: function init() {
          var _this2 = this;
          var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var callback = arguments.length > 1 ? arguments[1] : void 0;
          if (typeof options2 === "function") {
            callback = options2;
            options2 = {};
          }
          if (options2.whitelist && !options2.supportedLngs) {
            this.logger.deprecate("whitelist", 'option "whitelist" will be renamed to "supportedLngs" in the next major - please make sure to rename this option asap.');
          }
          if (options2.nonExplicitWhitelist && !options2.nonExplicitSupportedLngs) {
            this.logger.deprecate("whitelist", 'options "nonExplicitWhitelist" will be renamed to "nonExplicitSupportedLngs" in the next major - please make sure to rename this option asap.');
          }
          this.options = _objectSpread({}, get2(), this.options, transformOptions2(options2));
          this.format = this.options.interpolation.format;
          if (!callback)
            callback = noop2;
          function createClassOnDemand(ClassOrObject) {
            if (!ClassOrObject)
              return null;
            if (typeof ClassOrObject === "function")
              return new ClassOrObject();
            return ClassOrObject;
          }
          if (!this.options.isClone) {
            if (this.modules.logger) {
              baseLogger2.init(createClassOnDemand(this.modules.logger), this.options);
            } else {
              baseLogger2.init(null, this.options);
            }
            var lu = new LanguageUtil2(this.options);
            this.store = new ResourceStore2(this.options.resources, this.options);
            var s = this.services;
            s.logger = baseLogger2;
            s.resourceStore = this.store;
            s.languageUtils = lu;
            s.pluralResolver = new PluralResolver2(lu, {
              prepend: this.options.pluralSeparator,
              compatibilityJSON: this.options.compatibilityJSON,
              simplifyPluralSuffix: this.options.simplifyPluralSuffix
            });
            s.interpolator = new Interpolator2(this.options);
            s.utils = {
              hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
            };
            s.backendConnector = new Connector2(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);
            s.backendConnector.on("*", function(event) {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              _this2.emit.apply(_this2, [event].concat(args));
            });
            if (this.modules.languageDetector) {
              s.languageDetector = createClassOnDemand(this.modules.languageDetector);
              s.languageDetector.init(s, this.options.detection, this.options);
            }
            if (this.modules.i18nFormat) {
              s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
              if (s.i18nFormat.init)
                s.i18nFormat.init(this);
            }
            this.translator = new Translator2(this.services, this.options);
            this.translator.on("*", function(event) {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              _this2.emit.apply(_this2, [event].concat(args));
            });
            this.modules.external.forEach(function(m) {
              if (m.init)
                m.init(_this2);
            });
          }
          if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
            var codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
            if (codes.length > 0 && codes[0] !== "dev")
              this.options.lng = codes[0];
          }
          if (!this.services.languageDetector && !this.options.lng) {
            this.logger.warn("init: no languageDetector is used and no lng is defined");
          }
          var storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
          storeApi.forEach(function(fcName) {
            _this2[fcName] = function() {
              var _this2$store;
              return (_this2$store = _this2.store)[fcName].apply(_this2$store, arguments);
            };
          });
          var storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
          storeApiChained.forEach(function(fcName) {
            _this2[fcName] = function() {
              var _this2$store2;
              (_this2$store2 = _this2.store)[fcName].apply(_this2$store2, arguments);
              return _this2;
            };
          });
          var deferred = defer2();
          var load = function load2() {
            var finish = function finish2(err, t) {
              if (_this2.isInitialized)
                _this2.logger.warn("init: i18next is already initialized. You should call init just once!");
              _this2.isInitialized = true;
              if (!_this2.options.isClone)
                _this2.logger.log("initialized", _this2.options);
              _this2.emit("initialized", _this2.options);
              deferred.resolve(t);
              callback(err, t);
            };
            if (_this2.languages && _this2.options.compatibilityAPI !== "v1" && !_this2.isInitialized)
              return finish(null, _this2.t.bind(_this2));
            _this2.changeLanguage(_this2.options.lng, finish);
          };
          if (this.options.resources || !this.options.initImmediate) {
            load();
          } else {
            setTimeout(load, 0);
          }
          return deferred;
        }
      }, {
        key: "loadResources",
        value: function loadResources(language) {
          var _this3 = this;
          var callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop2;
          var usedCallback = callback;
          var usedLng = typeof language === "string" ? language : this.language;
          if (typeof language === "function")
            usedCallback = language;
          if (!this.options.resources || this.options.partialBundledLanguages) {
            if (usedLng && usedLng.toLowerCase() === "cimode")
              return usedCallback();
            var toLoad = [];
            var append = function append2(lng) {
              if (!lng)
                return;
              var lngs = _this3.services.languageUtils.toResolveHierarchy(lng);
              lngs.forEach(function(l) {
                if (toLoad.indexOf(l) < 0)
                  toLoad.push(l);
              });
            };
            if (!usedLng) {
              var fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
              fallbacks.forEach(function(l) {
                return append(l);
              });
            } else {
              append(usedLng);
            }
            if (this.options.preload) {
              this.options.preload.forEach(function(l) {
                return append(l);
              });
            }
            this.services.backendConnector.load(toLoad, this.options.ns, usedCallback);
          } else {
            usedCallback(null);
          }
        }
      }, {
        key: "reloadResources",
        value: function reloadResources(lngs, ns, callback) {
          var deferred = defer2();
          if (!lngs)
            lngs = this.languages;
          if (!ns)
            ns = this.options.ns;
          if (!callback)
            callback = noop2;
          this.services.backendConnector.reload(lngs, ns, function(err) {
            deferred.resolve();
            callback(err);
          });
          return deferred;
        }
      }, {
        key: "use",
        value: function use(module2) {
          if (!module2)
            throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
          if (!module2.type)
            throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
          if (module2.type === "backend") {
            this.modules.backend = module2;
          }
          if (module2.type === "logger" || module2.log && module2.warn && module2.error) {
            this.modules.logger = module2;
          }
          if (module2.type === "languageDetector") {
            this.modules.languageDetector = module2;
          }
          if (module2.type === "i18nFormat") {
            this.modules.i18nFormat = module2;
          }
          if (module2.type === "postProcessor") {
            postProcessor2.addPostProcessor(module2);
          }
          if (module2.type === "3rdParty") {
            this.modules.external.push(module2);
          }
          return this;
        }
      }, {
        key: "changeLanguage",
        value: function changeLanguage(lng, callback) {
          var _this4 = this;
          this.isLanguageChangingTo = lng;
          var deferred = defer2();
          this.emit("languageChanging", lng);
          var done = function done2(err, l) {
            if (l) {
              _this4.language = l;
              _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l);
              _this4.translator.changeLanguage(l);
              _this4.isLanguageChangingTo = void 0;
              _this4.emit("languageChanged", l);
              _this4.logger.log("languageChanged", l);
            } else {
              _this4.isLanguageChangingTo = void 0;
            }
            deferred.resolve(function() {
              return _this4.t.apply(_this4, arguments);
            });
            if (callback)
              callback(err, function() {
                return _this4.t.apply(_this4, arguments);
              });
          };
          var setLng = function setLng2(lngs) {
            if (!lng && !lngs && _this4.services.languageDetector)
              lngs = [];
            var l = typeof lngs === "string" ? lngs : _this4.services.languageUtils.getBestMatchFromCodes(lngs);
            if (l) {
              if (!_this4.language) {
                _this4.language = l;
                _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l);
              }
              if (!_this4.translator.language)
                _this4.translator.changeLanguage(l);
              if (_this4.services.languageDetector)
                _this4.services.languageDetector.cacheUserLanguage(l);
            }
            _this4.loadResources(l, function(err) {
              done(err, l);
            });
          };
          if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
            setLng(this.services.languageDetector.detect());
          } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
            this.services.languageDetector.detect(setLng);
          } else {
            setLng(lng);
          }
          return deferred;
        }
      }, {
        key: "getFixedT",
        value: function getFixedT(lng, ns) {
          var _this5 = this;
          var fixedT = function fixedT2(key, opts) {
            var options2;
            if (_typeof2(opts) !== "object") {
              for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
                rest[_key3 - 2] = arguments[_key3];
              }
              options2 = _this5.options.overloadTranslationOptionHandler([key, opts].concat(rest));
            } else {
              options2 = _objectSpread({}, opts);
            }
            options2.lng = options2.lng || fixedT2.lng;
            options2.lngs = options2.lngs || fixedT2.lngs;
            options2.ns = options2.ns || fixedT2.ns;
            return _this5.t(key, options2);
          };
          if (typeof lng === "string") {
            fixedT.lng = lng;
          } else {
            fixedT.lngs = lng;
          }
          fixedT.ns = ns;
          return fixedT;
        }
      }, {
        key: "t",
        value: function t() {
          var _this$translator;
          return this.translator && (_this$translator = this.translator).translate.apply(_this$translator, arguments);
        }
      }, {
        key: "exists",
        value: function exists() {
          var _this$translator2;
          return this.translator && (_this$translator2 = this.translator).exists.apply(_this$translator2, arguments);
        }
      }, {
        key: "setDefaultNamespace",
        value: function setDefaultNamespace(ns) {
          this.options.defaultNS = ns;
        }
      }, {
        key: "hasLoadedNamespace",
        value: function hasLoadedNamespace(ns) {
          var _this6 = this;
          var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          if (!this.isInitialized) {
            this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
            return false;
          }
          if (!this.languages || !this.languages.length) {
            this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
            return false;
          }
          var lng = this.languages[0];
          var fallbackLng = this.options ? this.options.fallbackLng : false;
          var lastLng = this.languages[this.languages.length - 1];
          if (lng.toLowerCase() === "cimode")
            return true;
          var loadNotPending = function loadNotPending2(l, n) {
            var loadState = _this6.services.backendConnector.state["".concat(l, "|").concat(n)];
            return loadState === -1 || loadState === 2;
          };
          if (options2.precheck) {
            var preResult = options2.precheck(this, loadNotPending);
            if (preResult !== void 0)
              return preResult;
          }
          if (this.hasResourceBundle(lng, ns))
            return true;
          if (!this.services.backendConnector.backend)
            return true;
          if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns)))
            return true;
          return false;
        }
      }, {
        key: "loadNamespaces",
        value: function loadNamespaces(ns, callback) {
          var _this7 = this;
          var deferred = defer2();
          if (!this.options.ns) {
            callback && callback();
            return Promise.resolve();
          }
          if (typeof ns === "string")
            ns = [ns];
          ns.forEach(function(n) {
            if (_this7.options.ns.indexOf(n) < 0)
              _this7.options.ns.push(n);
          });
          this.loadResources(function(err) {
            deferred.resolve();
            if (callback)
              callback(err);
          });
          return deferred;
        }
      }, {
        key: "loadLanguages",
        value: function loadLanguages(lngs, callback) {
          var deferred = defer2();
          if (typeof lngs === "string")
            lngs = [lngs];
          var preloaded = this.options.preload || [];
          var newLngs = lngs.filter(function(lng) {
            return preloaded.indexOf(lng) < 0;
          });
          if (!newLngs.length) {
            if (callback)
              callback();
            return Promise.resolve();
          }
          this.options.preload = preloaded.concat(newLngs);
          this.loadResources(function(err) {
            deferred.resolve();
            if (callback)
              callback(err);
          });
          return deferred;
        }
      }, {
        key: "dir",
        value: function dir(lng) {
          if (!lng)
            lng = this.languages && this.languages.length > 0 ? this.languages[0] : this.language;
          if (!lng)
            return "rtl";
          var rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam"];
          return rtlLngs.indexOf(this.services.languageUtils.getLanguagePartFromCode(lng)) >= 0 ? "rtl" : "ltr";
        }
      }, {
        key: "createInstance",
        value: function createInstance() {
          var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var callback = arguments.length > 1 ? arguments[1] : void 0;
          return new I18n3(options2, callback);
        }
      }, {
        key: "cloneInstance",
        value: function cloneInstance() {
          var _this8 = this;
          var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop2;
          var mergedOptions = _objectSpread({}, this.options, options2, {
            isClone: true
          });
          var clone = new I18n3(mergedOptions);
          var membersToCopy = ["store", "services", "language"];
          membersToCopy.forEach(function(m) {
            clone[m] = _this8[m];
          });
          clone.services = _objectSpread({}, this.services);
          clone.services.utils = {
            hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
          };
          clone.translator = new Translator2(clone.services, clone.options);
          clone.translator.on("*", function(event) {
            for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
              args[_key4 - 1] = arguments[_key4];
            }
            clone.emit.apply(clone, [event].concat(args));
          });
          clone.init(mergedOptions, callback);
          clone.translator.options = clone.options;
          clone.translator.backendConnector.services.utils = {
            hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
          };
          return clone;
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          return {
            options: this.options,
            store: this.store,
            language: this.language,
            languages: this.languages
          };
        }
      }]);
      return I18n3;
    }(EventEmitter2);
    i18next2 = new I18n2();
    i18next_default2 = i18next2;
  }
});

// ../../node_modules/@sap-ux/store/dist/i18n.js
var require_i18n4 = __commonJS({
  "../../node_modules/@sap-ux/store/dist/i18n.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.text = exports2.initI18n = void 0;
    var i18next_1 = __importDefault((init_i18next2(), __toCommonJS(i18next_exports2)));
    var i18next_fs_backend_1 = __importDefault(require_cjs());
    var path_1 = __importDefault(require("path"));
    var i18nInstance = i18next_1.default.createInstance();
    function initI18n() {
      return __awaiter(this, void 0, void 0, function* () {
        yield i18nInstance.use(i18next_fs_backend_1.default).init({
          initImmediate: false,
          fallbackLng: "en",
          fallbackNS: "default",
          interpolation: { escapeValue: false },
          ns: "ux-store",
          defaultNS: "ux-store",
          backend: {
            loadPath: path_1.default.join(__dirname, "./translations/{{lng}}.{{ns}}.json")
          }
        });
      });
    }
    exports2.initI18n = initI18n;
    function text(key, options2) {
      return i18nInstance.t(key, options2);
    }
    exports2.text = text;
  }
});

// ../../node_modules/@sap-ux/store/dist/utils/app-studio.js
var require_app_studio = __commonJS({
  "../../node_modules/@sap-ux/store/dist/utils/app-studio.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isAppStudio = exports2.ENV = void 0;
    var ENV;
    (function(ENV2) {
      ENV2["PROXY_URL"] = "HTTP_PROXY";
      ENV2["H2O_URL"] = "H2O_URL";
    })(ENV = exports2.ENV || (exports2.ENV = {}));
    function isAppStudio() {
      return !!process.env[ENV.H2O_URL];
    }
    exports2.isAppStudio = isAppStudio;
  }
});

// ../../node_modules/@sap-ux/store/dist/utils/index.js
var require_utils10 = __commonJS({
  "../../node_modules/@sap-ux/store/dist/utils/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getFioriToolsDirectory = exports2.FioriToolsSettings = exports2.errorString = exports2.errorInstance = exports2.pick = void 0;
    var os_1 = require("os");
    var path_1 = __importDefault(require("path"));
    exports2.pick = (target, ...props) => {
      return target && (props === null || props === void 0 ? void 0 : props.length) > 0 && props.reduce((o, k) => {
        o[k] = target[k];
        return o;
      }, {}) || void 0;
    };
    function errorInstance(e) {
      if (e instanceof Error) {
        return e;
      } else {
        return new Error(String(e));
      }
    }
    exports2.errorInstance = errorInstance;
    function errorString(e) {
      return e instanceof Error ? e.message : String(e);
    }
    exports2.errorString = errorString;
    var FioriToolsSettings;
    (function(FioriToolsSettings2) {
      FioriToolsSettings2["dir"] = ".fioritools";
    })(FioriToolsSettings = exports2.FioriToolsSettings || (exports2.FioriToolsSettings = {}));
    exports2.getFioriToolsDirectory = () => {
      return path_1.default.join(os_1.homedir(), FioriToolsSettings.dir);
    };
    __exportStar(require_app_studio(), exports2);
  }
});

// ../../node_modules/@sap-ux/store/dist/data-access/filesystem.js
var require_filesystem2 = __commonJS({
  "../../node_modules/@sap-ux/store/dist/data-access/filesystem.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getFilesystemStore = exports2.getFilesystemWatcherFor = exports2.basedir = void 0;
    var path_1 = __importDefault(require("path"));
    var fs_1 = __importStar(require("fs"));
    var pluralize_1 = require_pluralize();
    var utils_1 = require_utils10();
    var os_1 = __importDefault(require("os"));
    exports2.basedir = ({ baseDirectory } = {}) => {
      if (!baseDirectory) {
        return utils_1.getFioriToolsDirectory();
      } else if (path_1.default.isAbsolute(baseDirectory)) {
        return baseDirectory;
      } else {
        return path_1.default.join(os_1.default.homedir(), baseDirectory);
      }
    };
    var FilesystemStore = class {
      constructor(logger, options2 = {}) {
        this.logger = logger;
        this.storeDirectory = exports2.basedir(options2);
      }
      read({ entityName, id }) {
        return __awaiter(this, void 0, void 0, function* () {
          const name = toPersistenceName(entityName);
          if (!name) {
            this.logger.debug("read: Entity Type is falsy - " + entityName);
            return Promise.resolve(void 0);
          }
          const { entities, error: error3 } = this._readAll(name);
          if (error3) {
            if (error3.code === "ENOENT") {
              return Promise.resolve(void 0);
            } else {
              throw error3;
            }
          }
          if (!entities) {
            this.logger.debug(`read: After parsing, entities is falsy. Entity: ${name}, parsed value: ${entities}`);
            return void 0;
          }
          return Promise.resolve(entities[id]);
        });
      }
      getAll({ entityName }) {
        return __awaiter(this, void 0, void 0, function* () {
          const name = toPersistenceName(entityName);
          if (!name) {
            this.logger.debug("read: Entity Type is falsy - " + entityName);
            return Promise.resolve([]);
          }
          const { entities, error: error3 } = this._readAll(name);
          if (error3) {
            if (error3.code === "ENOENT") {
              return Promise.resolve([]);
            } else {
              throw error3;
            }
          }
          if (!entities) {
            this.logger.debug(`read: After parsing, entities is falsy. Entity: ${name}, parsed value: ${entities}`);
            return Promise.resolve([]);
          }
          return Promise.resolve(Object.values(entities));
        });
      }
      readAll({ entityName }) {
        return __awaiter(this, void 0, void 0, function* () {
          const name = toPersistenceName(entityName);
          if (!name) {
            this.logger.debug("read: Entity Type is falsy - " + entityName);
            return Promise.resolve({});
          }
          const { entities, error: error3 } = this._readAll(name);
          if (error3) {
            if (error3.code === "ENOENT") {
              return Promise.resolve({});
            } else {
              throw error3;
            }
          }
          if (!entities) {
            this.logger.debug(`read: After parsing, entities is falsy. Entity: ${name}, parsed value: ${entities}`);
            return Promise.resolve({});
          }
          return Promise.resolve(entities);
        });
      }
      write({ entityName, id, entity }) {
        return __awaiter(this, void 0, void 0, function* () {
          const name = toPersistenceName(entityName);
          if (!name) {
            this.logger.debug("write: Entity is falsy - " + name);
            return Promise.resolve(void 0);
          }
          const { entities = {}, error: error3 } = this._readAll(name);
          if (error3 && error3.code !== "ENOENT") {
            throw error3;
          }
          entities[id] = entity;
          this.writeToFile(name, entities);
          return Promise.resolve(entity);
        });
      }
      del({ entityName, id }) {
        return __awaiter(this, void 0, void 0, function* () {
          const name = toPersistenceName(entityName);
          if (!name) {
            this.logger.debug("delete: Entity is falsy - " + name);
            return Promise.resolve(false);
          }
          const { entities = {}, error: error3 } = this._readAll(name);
          if (error3) {
            if (error3.code !== "ENOENT") {
              throw error3;
            }
          }
          const exists = !!entities[id];
          if (exists) {
            this.logger.debug(`delete: entity found  for id - ${id}. Deleting`);
            delete entities[id];
            this.writeToFile(name, entities);
            return Promise.resolve(true);
          } else {
            this.logger.debug("delete: entity not found");
            return Promise.resolve(false);
          }
        });
      }
      _readAll(entityName) {
        var _a2;
        let rawContents;
        try {
          const configPath = path_1.default.join(this.storeDirectory, `${entityName}.json`);
          if (fs_1.existsSync(configPath)) {
            rawContents = fs_1.readFileSync(configPath).toString().trim();
          } else {
            rawContents = "";
          }
        } catch (e) {
          const err = utils_1.errorInstance(e);
          this.logger.debug(err.message);
          return { error: err };
        }
        if (!rawContents) {
          return { entities: void 0 };
        }
        let entities;
        try {
          entities = (_a2 = JSON.parse(rawContents)) === null || _a2 === void 0 ? void 0 : _a2[entityName];
        } catch (e) {
          return { error: utils_1.errorInstance(e) };
        }
        return { entities };
      }
      writeToFile(entityName, entities) {
        const data2 = JSON.stringify({ [entityName]: entities }, null, 2);
        const filename = getEntityFileName(entityName);
        try {
          fs_1.writeFileSync(path_1.default.join(this.storeDirectory, filename), data2);
        } catch (e) {
          const err = utils_1.errorInstance(e);
          if ((err === null || err === void 0 ? void 0 : err.code) === "ENOENT") {
            this.logger.debug(`Base directory [${this.storeDirectory}] does not exist, trying to create it`);
            fs_1.mkdirSync(this.storeDirectory, { recursive: true });
            fs_1.writeFileSync(path_1.default.join(this.storeDirectory, filename), data2);
          } else {
            throw e;
          }
        }
      }
    };
    function toPersistenceName(s) {
      const t = s === null || s === void 0 ? void 0 : s.trim().toLowerCase();
      return t && pluralize_1.plural(t);
    }
    function getEntityFileName(entityName) {
      return toPersistenceName(entityName) + ".json";
    }
    function getFilesystemWatcherFor(entityName, callback, options2 = {}) {
      const watchPath = path_1.default.join(exports2.basedir(options2), getEntityFileName(entityName));
      if (fs_1.existsSync(watchPath)) {
        return fs_1.default.watch(watchPath, void 0, () => {
          callback(entityName);
        });
      } else {
        console.warn(`File Not Found: ${watchPath}`);
        return void 0;
      }
    }
    exports2.getFilesystemWatcherFor = getFilesystemWatcherFor;
    function getFilesystemStore(logger, options2) {
      return new FilesystemStore(logger, options2);
    }
    exports2.getFilesystemStore = getFilesystemStore;
  }
});

// ../../node_modules/@sap-ux/store/dist/secure-store/dummy-store.js
var require_dummy_store2 = __commonJS({
  "../../node_modules/@sap-ux/store/dist/secure-store/dummy-store.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DummyStore = void 0;
    var DummyStore = class {
      constructor(log4) {
        this.log = log4;
      }
      save(service, key, _value) {
        return __awaiter(this, void 0, void 0, function* () {
          this.log.warn(`Dummy store. Trying to save for service: ${service}, key: ${key}`);
          return Promise.resolve(true);
        });
      }
      retrieve(service, key) {
        return __awaiter(this, void 0, void 0, function* () {
          this.log.warn(`Dummy store. Trying to retrieve for service: ${service}, key: ${key}`);
          return Promise.resolve(void 0);
        });
      }
      delete(service, key) {
        return __awaiter(this, void 0, void 0, function* () {
          this.log.warn(`Dummy store. Trying to delete for service: ${service}, key: ${key}`);
          return Promise.resolve(true);
        });
      }
      getAll(service) {
        return __awaiter(this, void 0, void 0, function* () {
          this.log.warn(`Dummy store. Trying to get all values for service: [${service}]`);
          return Promise.resolve({});
        });
      }
    };
    exports2.DummyStore = DummyStore;
  }
});

// ../../node_modules/@sap-ux/store/dist/secure-store/keytar-store.js
var require_keytar_store2 = __commonJS({
  "../../node_modules/@sap-ux/store/dist/secure-store/keytar-store.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KeytarStore = void 0;
    var utils_1 = require_utils10();
    var KeytarStore = class {
      constructor(log4, keytar) {
        this.log = log4;
        this.keytar = keytar;
      }
      save(service, key, value) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const serialized = JSON.stringify(value);
            yield this.keytar.setPassword(service, key, serialized);
            return true;
          } catch (e) {
            this.log.error(`Error saving to secure store. Service: [${service}], key: [${key}]`);
            this.log.error(utils_1.errorString(e));
            return false;
          }
        });
      }
      retrieve(service, key) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const serializedValue = yield this.keytar.getPassword(service, key);
            return serializedValue && JSON.parse(serializedValue);
          } catch (e) {
            this.log.error(`Error retrieving from secure store. Service: [${service}], key: [${key}]`);
            this.log.error(utils_1.errorString(e));
            return void 0;
          }
        });
      }
      delete(service, key) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            return yield this.keytar.deletePassword(service, key);
          } catch (e) {
            this.log.error(`Error deleting from secure store. Service: [${service}], key: [${key}]`);
            this.log.error(utils_1.errorString(e));
            return false;
          }
        });
      }
      getAll(service) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            return (yield this.keytar.findCredentials(service)).reduce((result2, entry) => {
              try {
                result2[String(entry.account)] = JSON.parse(entry.password);
              } catch (e) {
                this.log.error(`Error parsing credentials for [${entry.account}]`);
              }
              return result2;
            }, {});
          } catch (e) {
            this.log.error(`Error getting values for service: [${service}]`);
            this.log.error(utils_1.errorString(e));
            return {};
          }
        });
      }
    };
    exports2.KeytarStore = KeytarStore;
  }
});

// ../../node_modules/@sap-ux/store/dist/secure-store/types.js
var require_types6 = __commonJS({
  "../../node_modules/@sap-ux/store/dist/secure-store/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@sap-ux/store/dist/secure-store/index.js
var require_secure_store2 = __commonJS({
  "../../node_modules/@sap-ux/store/dist/secure-store/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getSecureStore = void 0;
    var utils_1 = require_utils10();
    var dummy_store_1 = require_dummy_store2();
    var keytar_store_1 = require_keytar_store2();
    function getKeytar(log4) {
      var _a2, _b;
      try {
        return require("keytar");
      } catch (err) {
        log4.warn(utils_1.errorString(err));
        log4.warn(`Could not "require('keytar')". Trying VSCode's copy`);
        let vscode;
        try {
          vscode = require("vscode");
        } catch (e) {
          log4.warn(utils_1.errorString(e));
          log4.warn("Could not get hold of vscode");
          return void 0;
        }
        try {
          return require(`${(_a2 = vscode === null || vscode === void 0 ? void 0 : vscode.env) === null || _a2 === void 0 ? void 0 : _a2.appRoot}/node_modules.asar/keytar`);
        } catch (e) {
          log4.warn(utils_1.errorString(e));
          log4.warn("Could not get keytar from vscode node_modules.asar");
        }
        try {
          return require(`${(_b = vscode === null || vscode === void 0 ? void 0 : vscode.env) === null || _b === void 0 ? void 0 : _b.appRoot}/node_modules/keytar`);
        } catch (e) {
          log4.warn(utils_1.errorString(e));
          log4.warn("Could not get keytar from vscode node_modules");
        }
        return void 0;
      }
    }
    exports2.getSecureStore = (log4) => {
      if (utils_1.isAppStudio()) {
        return new dummy_store_1.DummyStore(log4);
      } else {
        const keytar = getKeytar(log4);
        return keytar ? new keytar_store_1.KeytarStore(log4, keytar) : new dummy_store_1.DummyStore(log4);
      }
    };
    __exportStar(require_types6(), exports2);
  }
});

// ../../node_modules/@sap-ux/store/dist/decorators/index.js
var require_decorators2 = __commonJS({
  "../../node_modules/@sap-ux/store/dist/decorators/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getSensitiveDataProperties = exports2.sensitiveData = exports2.getSerializableProperties = exports2.serializable = void 0;
    require_Reflect();
    var SERIALIZABLE = Symbol("serializable");
    function serializable(target, key) {
      const serializableProperties = Reflect.getOwnMetadata(SERIALIZABLE, target.constructor) || /* @__PURE__ */ new Set();
      Reflect.defineMetadata(SERIALIZABLE, serializableProperties.add(key), target.constructor);
    }
    exports2.serializable = serializable;
    function getSerializableProperties(target) {
      const props = Reflect.getOwnMetadata(SERIALIZABLE, target.constructor);
      return props && Array.from(props.values()) || [];
    }
    exports2.getSerializableProperties = getSerializableProperties;
    var SENSITIVE = Symbol("sensitive");
    function sensitiveData(target, key) {
      const sensitiveProperties = Reflect.getOwnMetadata(SENSITIVE, target.constructor) || /* @__PURE__ */ new Set();
      Reflect.defineMetadata(SENSITIVE, sensitiveProperties.add(key), target.constructor);
    }
    exports2.sensitiveData = sensitiveData;
    function getSensitiveDataProperties(target) {
      const props = Reflect.getOwnMetadata(SENSITIVE, target.constructor);
      return props && Array.from(props.values()) || [];
    }
    exports2.getSensitiveDataProperties = getSensitiveDataProperties;
  }
});

// ../../node_modules/@sap-ux/store/dist/data-access/hybrid.js
var require_hybrid2 = __commonJS({
  "../../node_modules/@sap-ux/store/dist/data-access/hybrid.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getHybridStore = void 0;
    var filesystem_1 = require_filesystem2();
    var utils_1 = require_utils10();
    var secure_store_1 = require_secure_store2();
    var decorators_1 = require_decorators2();
    var util_1 = require("util");
    function getFullyQualifiedServiceName(name) {
      return "fiori/v2/" + name;
    }
    var HybridStore = class {
      constructor(logger, options2 = {}) {
        this.logger = logger;
        this.filesystem = filesystem_1.getFilesystemStore(this.logger, options2);
        this.secureStore = secure_store_1.getSecureStore(this.logger);
      }
      read({ entityName, id }) {
        return __awaiter(this, void 0, void 0, function* () {
          const serialized = yield this.filesystem.read({ entityName, id });
          if (!serialized) {
            this.logger.debug(`hybrid/read - id: [${id}], nothing on the filesystem`);
          } else {
            this.logger.debug(`hybrid/read - id: [${id}], filesystem: ${util_1.inspect(serialized)}`);
          }
          const sensitiveData = yield this.secureStore.retrieve(getFullyQualifiedServiceName(entityName), id);
          if (!sensitiveData) {
            this.logger.debug(`hybrid/read - id: [${id}], nothing in the secure store`);
          } else {
            this.logger.debug(`hybrid/read - id: [${id}]. Found sensitive data in secure store`);
          }
          if (serialized || sensitiveData) {
            return Object.assign(Object.assign({}, serialized), sensitiveData);
          } else {
            return void 0;
          }
        });
      }
      getAll({ entityName }) {
        return __awaiter(this, void 0, void 0, function* () {
          return Object.values(yield this.readAll({ entityName }));
        });
      }
      readAll({ entityName }) {
        return __awaiter(this, void 0, void 0, function* () {
          const result2 = {};
          const entitiesFs = (yield this.filesystem.readAll({ entityName })) || {};
          const entitiesInSecureStore = (yield this.secureStore.getAll(getFullyQualifiedServiceName(entityName))) || {};
          for (const key of /* @__PURE__ */ new Set([...Object.keys(entitiesFs), ...Object.keys(entitiesInSecureStore)])) {
            const entity = Object.assign(Object.assign({}, entitiesFs[key]), entitiesInSecureStore[key]);
            result2[key] = entity;
          }
          return result2;
        });
      }
      write({ entityName, id, entity }) {
        return __awaiter(this, void 0, void 0, function* () {
          const serializableProps = decorators_1.getSerializableProperties(entity);
          const sensitiveProps = decorators_1.getSensitiveDataProperties(entity);
          if (serializableProps.length > 0 && sensitiveProps.length > 0) {
            for (let i = 0; i < serializableProps.length; i = i + 1) {
              if (sensitiveProps.indexOf(serializableProps[i]) !== -1) {
                this.logger.debug(`hybrid/write - [${serializableProps[i]}] is also marked as sensitive. Not writing to filesystem`);
                serializableProps.splice(i, 1);
              }
            }
          }
          const serializable = utils_1.pick(entity, ...serializableProps);
          if (serializable) {
            this.logger.debug(`hybrid/write - writing serializable properties: ${util_1.inspect(serializable)}`);
            yield this.filesystem.write({ entityName, id, entity: serializable });
          } else {
            this.logger.debug(`hybrid/write - no serializable properties found in ${util_1.inspect(serializable)}`);
          }
          const sensitiveData = utils_1.pick(entity, ...sensitiveProps);
          if (sensitiveData) {
            this.logger.debug(`hybrid/write - writing sensitive properties to secure store. ID: [${id}]`);
            yield this.secureStore.save(getFullyQualifiedServiceName(entityName), id, sensitiveData);
          } else {
            this.logger.debug(`hybrid/write - no sensitive properties found in ${util_1.inspect(entity)}`);
          }
          return entity;
        });
      }
      del({ entityName, id }) {
        return __awaiter(this, void 0, void 0, function* () {
          const deletedinFs = yield this.filesystem.del({ entityName, id });
          this.logger.debug(`hybrid/del - delete result for id [${id}] on the filesystem: ${deletedinFs}`);
          const deletedInSecureStore = yield this.secureStore.delete(getFullyQualifiedServiceName(entityName), id);
          this.logger.debug(`hybrid/del - delete result for id [${id}] in the secure store: ${deletedInSecureStore}`);
          return deletedinFs || deletedInSecureStore;
        });
      }
    };
    function getHybridStore(logger, options2) {
      return new HybridStore(logger, options2);
    }
    exports2.getHybridStore = getHybridStore;
  }
});

// ../../node_modules/@sap-ux/store/dist/entities/backend-system.js
var require_backend_system4 = __commonJS({
  "../../node_modules/@sap-ux/store/dist/entities/backend-system.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports2 && exports2.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BackendSystemKey = exports2.BackendSystem = exports2.AuthenticationType = void 0;
    var decorators_1 = require_decorators2();
    var AuthenticationType;
    (function(AuthenticationType2) {
      AuthenticationType2["Basic"] = "basic";
      AuthenticationType2["ReentranceTicket"] = "reentranceTicket";
      AuthenticationType2["OAuth2RefreshToken"] = "oauth2";
      AuthenticationType2["OAuth2ClientCredential"] = "oauth2ClientCredential";
    })(AuthenticationType = exports2.AuthenticationType || (exports2.AuthenticationType = {}));
    var BackendSystem = class {
      constructor({ name, url, client, serviceKeys, refreshToken, username, password, userDisplayName, authenticationType }) {
        this.name = name;
        this.url = url;
        this.client = client;
        this.serviceKeys = serviceKeys;
        this.refreshToken = refreshToken;
        this.username = username;
        this.password = password;
        this.userDisplayName = userDisplayName;
        this.authenticationType = authenticationType;
      }
    };
    __decorate([
      decorators_1.serializable,
      __metadata("design:type", String)
    ], BackendSystem.prototype, "name", void 0);
    __decorate([
      decorators_1.serializable,
      __metadata("design:type", String)
    ], BackendSystem.prototype, "url", void 0);
    __decorate([
      decorators_1.serializable,
      __metadata("design:type", String)
    ], BackendSystem.prototype, "client", void 0);
    __decorate([
      decorators_1.serializable,
      __metadata("design:type", String)
    ], BackendSystem.prototype, "userDisplayName", void 0);
    __decorate([
      decorators_1.sensitiveData,
      __metadata("design:type", Object)
    ], BackendSystem.prototype, "serviceKeys", void 0);
    __decorate([
      decorators_1.sensitiveData,
      __metadata("design:type", String)
    ], BackendSystem.prototype, "refreshToken", void 0);
    __decorate([
      decorators_1.sensitiveData,
      __metadata("design:type", String)
    ], BackendSystem.prototype, "username", void 0);
    __decorate([
      decorators_1.sensitiveData,
      __metadata("design:type", String)
    ], BackendSystem.prototype, "password", void 0);
    __decorate([
      decorators_1.sensitiveData,
      __metadata("design:type", String)
    ], BackendSystem.prototype, "authenticationType", void 0);
    exports2.BackendSystem = BackendSystem;
    var BackendSystemKey = class {
      constructor({ url, client }) {
        this.url = url.trim().replace(/\/$/, "");
        this.client = client === null || client === void 0 ? void 0 : client.trim();
      }
      static from(system) {
        return new BackendSystemKey({ url: system.url, client: system.client });
      }
      getId() {
        return this.url + `${this.client ? "/" + this.client : ""}`;
      }
    };
    exports2.BackendSystemKey = BackendSystemKey;
  }
});

// ../../node_modules/@sap-ux/store/dist/data-provider/constants.js
var require_constants6 = __commonJS({
  "../../node_modules/@sap-ux/store/dist/data-provider/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Entities = void 0;
    var Entities;
    (function(Entities2) {
      Entities2["BackendSystem"] = "system";
      Entities2["SystemMigrationStatus"] = "systemMigrationStatus";
      Entities2["TelemetrySetting"] = "telemetrySetting";
      Entities2["ApiHub"] = "apiHub";
    })(Entities = exports2.Entities || (exports2.Entities = {}));
  }
});

// ../../node_modules/@sap-ux/store/dist/data-provider/backend-system.js
var require_backend_system5 = __commonJS({
  "../../node_modules/@sap-ux/store/dist/data-provider/backend-system.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SystemDataProvider = void 0;
    var hybrid_1 = require_hybrid2();
    var backend_system_1 = require_backend_system4();
    var constants_1 = require_constants6();
    exports2.SystemDataProvider = class {
      constructor(logger, options2 = {}) {
        this.entityName = constants_1.Entities.BackendSystem;
        this.logger = logger;
        this.dataAccessor = hybrid_1.getHybridStore(this.logger, options2);
      }
      read(key) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.dataAccessor.read({ entityName: this.entityName, id: key.getId() });
        });
      }
      write(entity) {
        return __awaiter(this, void 0, void 0, function* () {
          let e;
          if (!(entity instanceof backend_system_1.BackendSystem)) {
            e = new backend_system_1.BackendSystem(Object.assign({}, entity));
          } else {
            e = entity;
          }
          return this.dataAccessor.write({
            entityName: this.entityName,
            id: backend_system_1.BackendSystemKey.from(entity).getId(),
            entity: e
          });
        });
      }
      delete(entity) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.dataAccessor.del({
            entityName: this.entityName,
            id: backend_system_1.BackendSystemKey.from(entity).getId()
          });
        });
      }
      getAll() {
        var _a2;
        return __awaiter(this, void 0, void 0, function* () {
          const systems = yield this.dataAccessor.readAll({ entityName: this.entityName });
          for (const id of Object.keys(systems)) {
            const system = systems[id];
            if (!((_a2 = system === null || system === void 0 ? void 0 : system.url) === null || _a2 === void 0 ? void 0 : _a2.trim())) {
              this.logger.warn(`Filtering system with ID [${id}] as it seems corrupt. Run repair`);
              delete systems[id];
            }
          }
          return Object.values(systems);
        });
      }
    };
  }
});

// ../../node_modules/@sap-ux/store/dist/services/backend-system.js
var require_backend_system6 = __commonJS({
  "../../node_modules/@sap-ux/store/dist/services/backend-system.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getInstance = exports2.SystemService = void 0;
    var backend_system_1 = require_backend_system5();
    var backend_system_2 = require_backend_system4();
    var i18n_1 = require_i18n4();
    var SystemService = class {
      constructor(logger, options2 = {}) {
        this.logger = logger;
        this.dataProvider = new backend_system_1.SystemDataProvider(this.logger, options2);
      }
      partialUpdate(key, entity) {
        return __awaiter(this, void 0, void 0, function* () {
          this.validatePartialUpdateInput(entity);
          const existingSystem = yield this.readOrThrow(key);
          const updatedEntity = this.mergeProperties(entity, existingSystem);
          return this.write(updatedEntity);
        });
      }
      mergeProperties(update, existingSystem) {
        const patch = Object.assign({}, update);
        delete patch.url;
        delete patch.client;
        const updatedEntity = Object.assign(Object.assign({}, existingSystem), patch);
        return new backend_system_2.BackendSystem(Object.assign({}, updatedEntity));
      }
      readOrThrow(key) {
        return __awaiter(this, void 0, void 0, function* () {
          const existingSystem = yield this.read(key);
          if (!existingSystem) {
            throw new Error(i18n_1.text("error.systemDoesNotExist", { system: key }));
          }
          return existingSystem;
        });
      }
      validatePartialUpdateInput(entity) {
        if (!entity || !Object.keys(entity).length) {
          throw new Error(i18n_1.text("error.noPropertiesSpecified"));
        }
      }
      read(key) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.dataProvider.read(key);
        });
      }
      write(entity) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.dataProvider.write(entity);
        });
      }
      delete(entity) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.dataProvider.delete(entity);
        });
      }
      getAll() {
        return __awaiter(this, void 0, void 0, function* () {
          return this.dataProvider.getAll();
        });
      }
    };
    exports2.SystemService = SystemService;
    function getInstance(logger, options2 = {}) {
      return new SystemService(logger, options2);
    }
    exports2.getInstance = getInstance;
  }
});

// ../../node_modules/@sap-ux/store/dist/entities/telemetry-setting.js
var require_telemetry_setting = __commonJS({
  "../../node_modules/@sap-ux/store/dist/entities/telemetry-setting.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports2 && exports2.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TelemetrySettingKey = exports2.TelemetrySetting = void 0;
    var decorators_1 = require_decorators2();
    var TelemetrySetting = class {
      constructor({ enableTelemetry }) {
        this.enableTelemetry = enableTelemetry;
      }
    };
    __decorate([
      decorators_1.serializable,
      __metadata("design:type", Boolean)
    ], TelemetrySetting.prototype, "enableTelemetry", void 0);
    exports2.TelemetrySetting = TelemetrySetting;
    var TelemetrySettingKey = class {
      getId() {
        return "telemetrySetting";
      }
    };
    exports2.TelemetrySettingKey = TelemetrySettingKey;
  }
});

// ../../node_modules/@sap-ux/store/dist/data-provider/telemetry-setting.js
var require_telemetry_setting2 = __commonJS({
  "../../node_modules/@sap-ux/store/dist/data-provider/telemetry-setting.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TelemetryDataProvider = void 0;
    var filesystem_1 = require_filesystem2();
    var telemetry_setting_1 = require_telemetry_setting();
    var constants_1 = require_constants6();
    exports2.TelemetryDataProvider = class {
      constructor(logger) {
        this.entityName = constants_1.Entities.TelemetrySetting;
        this.logger = logger;
        this.dataAccessor = filesystem_1.getFilesystemStore(this.logger);
      }
      read(key) {
        return this.dataAccessor.read({ entityName: this.entityName, id: key.getId() });
      }
      write(entity) {
        return this.dataAccessor.write({
          entityName: this.entityName,
          id: new telemetry_setting_1.TelemetrySettingKey().getId(),
          entity
        });
      }
      delete(_entity) {
        return this.dataAccessor.del({
          entityName: this.entityName,
          id: new telemetry_setting_1.TelemetrySettingKey().getId()
        });
      }
      getAll() {
        return this.dataAccessor.getAll({ entityName: this.entityName });
      }
    };
  }
});

// ../../node_modules/@sap-ux/store/dist/services/telemetry-setting.js
var require_telemetry_setting3 = __commonJS({
  "../../node_modules/@sap-ux/store/dist/services/telemetry-setting.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getInstance = exports2.TelemetrySettingService = void 0;
    var telemetry_setting_1 = require_telemetry_setting2();
    var TelemetrySettingService = class {
      constructor(logger) {
        this.logger = logger;
        this.dataProvider = new telemetry_setting_1.TelemetryDataProvider(this.logger);
      }
      partialUpdate() {
        return __awaiter(this, void 0, void 0, function* () {
          throw new Error("NOT IMPLEMENTED");
        });
      }
      read(key) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.dataProvider.read(key);
        });
      }
      write(entity) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.dataProvider.write(entity);
        });
      }
      delete(entity) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.dataProvider.delete(entity);
        });
      }
      getAll() {
        return __awaiter(this, void 0, void 0, function* () {
          return this.dataProvider.getAll();
        });
      }
    };
    exports2.TelemetrySettingService = TelemetrySettingService;
    function getInstance(logger) {
      return new TelemetrySettingService(logger);
    }
    exports2.getInstance = getInstance;
  }
});

// ../../node_modules/@sap-ux/store/dist/entities/api-hub.js
var require_api_hub2 = __commonJS({
  "../../node_modules/@sap-ux/store/dist/entities/api-hub.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = exports2 && exports2.__metadata || function(k, v) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApiHubSettingsKey = exports2.ApiHubSettings = void 0;
    var decorators_1 = require_decorators2();
    var ApiHubSettings = class {
      constructor({ apiKey }) {
        this.apiKey = apiKey;
      }
    };
    __decorate([
      decorators_1.sensitiveData,
      __metadata("design:type", String)
    ], ApiHubSettings.prototype, "apiKey", void 0);
    exports2.ApiHubSettings = ApiHubSettings;
    var ApiHubSettingsKey = class {
      getId() {
        return ApiHubSettingsKey.SINGLETON;
      }
    };
    exports2.ApiHubSettingsKey = ApiHubSettingsKey;
    ApiHubSettingsKey.SINGLETON = "API_HUB_API_KEY";
  }
});

// ../../node_modules/@sap-ux/store/dist/data-provider/api-hub.js
var require_api_hub3 = __commonJS({
  "../../node_modules/@sap-ux/store/dist/data-provider/api-hub.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApiHubSettingsProvider = void 0;
    var hybrid_1 = require_hybrid2();
    var constants_1 = require_constants6();
    var api_hub_1 = require_api_hub2();
    exports2.ApiHubSettingsProvider = class {
      constructor(logger, options2 = {}) {
        this.entityName = constants_1.Entities.ApiHub;
        this.logger = logger;
        this.dataAccessor = hybrid_1.getHybridStore(this.logger, options2);
      }
      read(key) {
        return this.dataAccessor.read({ entityName: this.entityName, id: key.getId() });
      }
      write(entity) {
        return this.dataAccessor.write({
          entityName: this.entityName,
          id: api_hub_1.ApiHubSettingsKey.SINGLETON,
          entity
        });
      }
      delete(_entity) {
        return this.dataAccessor.del({
          entityName: this.entityName,
          id: api_hub_1.ApiHubSettingsKey.SINGLETON
        });
      }
      getAll() {
        return this.dataAccessor.getAll({ entityName: this.entityName });
      }
    };
  }
});

// ../../node_modules/@sap-ux/store/dist/services/api-hub/migration.js
var require_migration = __commonJS({
  "../../node_modules/@sap-ux/store/dist/services/api-hub/migration.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.migrateToLatestVersion = exports2.LEGACY_API_HUB_API_KEY = exports2.LEGACY_API_HUB_API_SERVICE = void 0;
    var i18n_1 = require_i18n4();
    var api_hub_1 = require_api_hub2();
    exports2.LEGACY_API_HUB_API_SERVICE = "fiori/system/apiHub";
    exports2.LEGACY_API_HUB_API_KEY = "API_HUB_API_KEY";
    function migrateToLatestVersion({ dataProvider, secureStore, logger }) {
      return __awaiter(this, void 0, void 0, function* () {
        const apiKey = yield secureStore.retrieve(exports2.LEGACY_API_HUB_API_SERVICE, exports2.LEGACY_API_HUB_API_KEY);
        if (!apiKey) {
          logger.debug(i18n_1.text("info.noLegacyApiHubKeyFound"));
          return;
        } else {
          logger.info(i18n_1.text("info.legacyApiHubKeyFound"));
        }
        const apiKeysNewFormat = yield dataProvider.read(new api_hub_1.ApiHubSettingsKey());
        if (!apiKeysNewFormat) {
          yield dataProvider.write(new api_hub_1.ApiHubSettings({ apiKey }));
          logger.info(i18n_1.text("info.legacyApiHubKeyMigrated"));
        } else {
          logger.info(i18n_1.text("info.legacyApiHubKeyNotMigrated"));
        }
        yield secureStore.delete(exports2.LEGACY_API_HUB_API_SERVICE, exports2.LEGACY_API_HUB_API_KEY);
        logger.info(i18n_1.text("info.legacyApiHubKeyDeleted"));
      });
    }
    exports2.migrateToLatestVersion = migrateToLatestVersion;
  }
});

// ../../node_modules/@sap-ux/store/dist/services/api-hub/service.js
var require_service = __commonJS({
  "../../node_modules/@sap-ux/store/dist/services/api-hub/service.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getInstance = exports2.ApiHubSettingsService = void 0;
    var secure_store_1 = require_secure_store2();
    var api_hub_1 = require_api_hub3();
    var api_hub_2 = require_api_hub2();
    var migration_1 = require_migration();
    var ApiHubSettingsService = class {
      constructor(logger) {
        this.migrationDone = false;
        this.key = new api_hub_2.ApiHubSettingsKey();
        this.logger = logger;
        this.dataProvider = new api_hub_1.ApiHubSettingsProvider(this.logger);
      }
      migrate() {
        return __awaiter(this, void 0, void 0, function* () {
          if (this.migrationDone) {
            return;
          }
          if (!this.secureStore) {
            this.secureStore = secure_store_1.getSecureStore(this.logger);
          }
          yield migration_1.migrateToLatestVersion({
            logger: this.logger,
            secureStore: this.secureStore,
            dataProvider: this.dataProvider
          });
          this.migrationDone = true;
        });
      }
      partialUpdate() {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.migrate();
          throw new Error("NOT IMPLEMENTED");
        });
      }
      read() {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.migrate();
          return this.dataProvider.read(this.key);
        });
      }
      write(entity) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.migrate();
          return this.dataProvider.write(entity);
        });
      }
      delete(entity) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.migrate();
          return this.dataProvider.delete(entity);
        });
      }
      getAll() {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.migrate();
          return this.dataProvider.getAll();
        });
      }
    };
    exports2.ApiHubSettingsService = ApiHubSettingsService;
    function getInstance(logger) {
      return new ApiHubSettingsService(logger);
    }
    exports2.getInstance = getInstance;
  }
});

// ../../node_modules/@sap-ux/store/dist/services/api-hub/index.js
var require_api_hub4 = __commonJS({
  "../../node_modules/@sap-ux/store/dist/services/api-hub/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_service(), exports2);
  }
});

// ../../node_modules/lodash/_listCacheClear.js
var require_listCacheClear = __commonJS({
  "../../node_modules/lodash/_listCacheClear.js"(exports2, module2) {
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    module2.exports = listCacheClear;
  }
});

// ../../node_modules/lodash/eq.js
var require_eq2 = __commonJS({
  "../../node_modules/lodash/eq.js"(exports2, module2) {
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    module2.exports = eq;
  }
});

// ../../node_modules/lodash/_assocIndexOf.js
var require_assocIndexOf = __commonJS({
  "../../node_modules/lodash/_assocIndexOf.js"(exports2, module2) {
    var eq = require_eq2();
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    module2.exports = assocIndexOf;
  }
});

// ../../node_modules/lodash/_listCacheDelete.js
var require_listCacheDelete = __commonJS({
  "../../node_modules/lodash/_listCacheDelete.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data2 = this.__data__, index = assocIndexOf(data2, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data2.length - 1;
      if (index == lastIndex) {
        data2.pop();
      } else {
        splice.call(data2, index, 1);
      }
      --this.size;
      return true;
    }
    module2.exports = listCacheDelete;
  }
});

// ../../node_modules/lodash/_listCacheGet.js
var require_listCacheGet = __commonJS({
  "../../node_modules/lodash/_listCacheGet.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheGet(key) {
      var data2 = this.__data__, index = assocIndexOf(data2, key);
      return index < 0 ? void 0 : data2[index][1];
    }
    module2.exports = listCacheGet;
  }
});

// ../../node_modules/lodash/_listCacheHas.js
var require_listCacheHas = __commonJS({
  "../../node_modules/lodash/_listCacheHas.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    module2.exports = listCacheHas;
  }
});

// ../../node_modules/lodash/_listCacheSet.js
var require_listCacheSet = __commonJS({
  "../../node_modules/lodash/_listCacheSet.js"(exports2, module2) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheSet(key, value) {
      var data2 = this.__data__, index = assocIndexOf(data2, key);
      if (index < 0) {
        ++this.size;
        data2.push([key, value]);
      } else {
        data2[index][1] = value;
      }
      return this;
    }
    module2.exports = listCacheSet;
  }
});

// ../../node_modules/lodash/_ListCache.js
var require_ListCache = __commonJS({
  "../../node_modules/lodash/_ListCache.js"(exports2, module2) {
    var listCacheClear = require_listCacheClear();
    var listCacheDelete = require_listCacheDelete();
    var listCacheGet = require_listCacheGet();
    var listCacheHas = require_listCacheHas();
    var listCacheSet = require_listCacheSet();
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    module2.exports = ListCache;
  }
});

// ../../node_modules/lodash/_stackClear.js
var require_stackClear = __commonJS({
  "../../node_modules/lodash/_stackClear.js"(exports2, module2) {
    var ListCache = require_ListCache();
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    module2.exports = stackClear;
  }
});

// ../../node_modules/lodash/_stackDelete.js
var require_stackDelete = __commonJS({
  "../../node_modules/lodash/_stackDelete.js"(exports2, module2) {
    function stackDelete(key) {
      var data2 = this.__data__, result2 = data2["delete"](key);
      this.size = data2.size;
      return result2;
    }
    module2.exports = stackDelete;
  }
});

// ../../node_modules/lodash/_stackGet.js
var require_stackGet = __commonJS({
  "../../node_modules/lodash/_stackGet.js"(exports2, module2) {
    function stackGet(key) {
      return this.__data__.get(key);
    }
    module2.exports = stackGet;
  }
});

// ../../node_modules/lodash/_stackHas.js
var require_stackHas = __commonJS({
  "../../node_modules/lodash/_stackHas.js"(exports2, module2) {
    function stackHas(key) {
      return this.__data__.has(key);
    }
    module2.exports = stackHas;
  }
});

// ../../node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "../../node_modules/lodash/_freeGlobal.js"(exports2, module2) {
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module2.exports = freeGlobal;
  }
});

// ../../node_modules/lodash/_root.js
var require_root = __commonJS({
  "../../node_modules/lodash/_root.js"(exports2, module2) {
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module2.exports = root;
  }
});

// ../../node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "../../node_modules/lodash/_Symbol.js"(exports2, module2) {
    var root = require_root();
    var Symbol2 = root.Symbol;
    module2.exports = Symbol2;
  }
});

// ../../node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "../../node_modules/lodash/_getRawTag.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result2 = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result2;
    }
    module2.exports = getRawTag;
  }
});

// ../../node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "../../node_modules/lodash/_objectToString.js"(exports2, module2) {
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module2.exports = objectToString;
  }
});

// ../../node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "../../node_modules/lodash/_baseGetTag.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module2.exports = baseGetTag;
  }
});

// ../../node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "../../node_modules/lodash/isObject.js"(exports2, module2) {
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    module2.exports = isObject;
  }
});

// ../../node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  "../../node_modules/lodash/isFunction.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObject = require_isObject();
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    module2.exports = isFunction;
  }
});

// ../../node_modules/lodash/_coreJsData.js
var require_coreJsData = __commonJS({
  "../../node_modules/lodash/_coreJsData.js"(exports2, module2) {
    var root = require_root();
    var coreJsData = root["__core-js_shared__"];
    module2.exports = coreJsData;
  }
});

// ../../node_modules/lodash/_isMasked.js
var require_isMasked = __commonJS({
  "../../node_modules/lodash/_isMasked.js"(exports2, module2) {
    var coreJsData = require_coreJsData();
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    module2.exports = isMasked;
  }
});

// ../../node_modules/lodash/_toSource.js
var require_toSource = __commonJS({
  "../../node_modules/lodash/_toSource.js"(exports2, module2) {
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    module2.exports = toSource;
  }
});

// ../../node_modules/lodash/_baseIsNative.js
var require_baseIsNative = __commonJS({
  "../../node_modules/lodash/_baseIsNative.js"(exports2, module2) {
    var isFunction = require_isFunction();
    var isMasked = require_isMasked();
    var isObject = require_isObject();
    var toSource = require_toSource();
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    module2.exports = baseIsNative;
  }
});

// ../../node_modules/lodash/_getValue.js
var require_getValue = __commonJS({
  "../../node_modules/lodash/_getValue.js"(exports2, module2) {
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    module2.exports = getValue;
  }
});

// ../../node_modules/lodash/_getNative.js
var require_getNative = __commonJS({
  "../../node_modules/lodash/_getNative.js"(exports2, module2) {
    var baseIsNative = require_baseIsNative();
    var getValue = require_getValue();
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    module2.exports = getNative;
  }
});

// ../../node_modules/lodash/_Map.js
var require_Map = __commonJS({
  "../../node_modules/lodash/_Map.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Map2 = getNative(root, "Map");
    module2.exports = Map2;
  }
});

// ../../node_modules/lodash/_nativeCreate.js
var require_nativeCreate = __commonJS({
  "../../node_modules/lodash/_nativeCreate.js"(exports2, module2) {
    var getNative = require_getNative();
    var nativeCreate = getNative(Object, "create");
    module2.exports = nativeCreate;
  }
});

// ../../node_modules/lodash/_hashClear.js
var require_hashClear = __commonJS({
  "../../node_modules/lodash/_hashClear.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    module2.exports = hashClear;
  }
});

// ../../node_modules/lodash/_hashDelete.js
var require_hashDelete = __commonJS({
  "../../node_modules/lodash/_hashDelete.js"(exports2, module2) {
    function hashDelete(key) {
      var result2 = this.has(key) && delete this.__data__[key];
      this.size -= result2 ? 1 : 0;
      return result2;
    }
    module2.exports = hashDelete;
  }
});

// ../../node_modules/lodash/_hashGet.js
var require_hashGet = __commonJS({
  "../../node_modules/lodash/_hashGet.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashGet(key) {
      var data2 = this.__data__;
      if (nativeCreate) {
        var result2 = data2[key];
        return result2 === HASH_UNDEFINED ? void 0 : result2;
      }
      return hasOwnProperty.call(data2, key) ? data2[key] : void 0;
    }
    module2.exports = hashGet;
  }
});

// ../../node_modules/lodash/_hashHas.js
var require_hashHas = __commonJS({
  "../../node_modules/lodash/_hashHas.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashHas(key) {
      var data2 = this.__data__;
      return nativeCreate ? data2[key] !== void 0 : hasOwnProperty.call(data2, key);
    }
    module2.exports = hashHas;
  }
});

// ../../node_modules/lodash/_hashSet.js
var require_hashSet = __commonJS({
  "../../node_modules/lodash/_hashSet.js"(exports2, module2) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data2 = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data2[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    module2.exports = hashSet;
  }
});

// ../../node_modules/lodash/_Hash.js
var require_Hash = __commonJS({
  "../../node_modules/lodash/_Hash.js"(exports2, module2) {
    var hashClear = require_hashClear();
    var hashDelete = require_hashDelete();
    var hashGet = require_hashGet();
    var hashHas = require_hashHas();
    var hashSet = require_hashSet();
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    module2.exports = Hash;
  }
});

// ../../node_modules/lodash/_mapCacheClear.js
var require_mapCacheClear = __commonJS({
  "../../node_modules/lodash/_mapCacheClear.js"(exports2, module2) {
    var Hash = require_Hash();
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    module2.exports = mapCacheClear;
  }
});

// ../../node_modules/lodash/_isKeyable.js
var require_isKeyable = __commonJS({
  "../../node_modules/lodash/_isKeyable.js"(exports2, module2) {
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    module2.exports = isKeyable;
  }
});

// ../../node_modules/lodash/_getMapData.js
var require_getMapData = __commonJS({
  "../../node_modules/lodash/_getMapData.js"(exports2, module2) {
    var isKeyable = require_isKeyable();
    function getMapData(map, key) {
      var data2 = map.__data__;
      return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
    }
    module2.exports = getMapData;
  }
});

// ../../node_modules/lodash/_mapCacheDelete.js
var require_mapCacheDelete = __commonJS({
  "../../node_modules/lodash/_mapCacheDelete.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheDelete(key) {
      var result2 = getMapData(this, key)["delete"](key);
      this.size -= result2 ? 1 : 0;
      return result2;
    }
    module2.exports = mapCacheDelete;
  }
});

// ../../node_modules/lodash/_mapCacheGet.js
var require_mapCacheGet = __commonJS({
  "../../node_modules/lodash/_mapCacheGet.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    module2.exports = mapCacheGet;
  }
});

// ../../node_modules/lodash/_mapCacheHas.js
var require_mapCacheHas = __commonJS({
  "../../node_modules/lodash/_mapCacheHas.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    module2.exports = mapCacheHas;
  }
});

// ../../node_modules/lodash/_mapCacheSet.js
var require_mapCacheSet = __commonJS({
  "../../node_modules/lodash/_mapCacheSet.js"(exports2, module2) {
    var getMapData = require_getMapData();
    function mapCacheSet(key, value) {
      var data2 = getMapData(this, key), size = data2.size;
      data2.set(key, value);
      this.size += data2.size == size ? 0 : 1;
      return this;
    }
    module2.exports = mapCacheSet;
  }
});

// ../../node_modules/lodash/_MapCache.js
var require_MapCache = __commonJS({
  "../../node_modules/lodash/_MapCache.js"(exports2, module2) {
    var mapCacheClear = require_mapCacheClear();
    var mapCacheDelete = require_mapCacheDelete();
    var mapCacheGet = require_mapCacheGet();
    var mapCacheHas = require_mapCacheHas();
    var mapCacheSet = require_mapCacheSet();
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    module2.exports = MapCache;
  }
});

// ../../node_modules/lodash/_stackSet.js
var require_stackSet = __commonJS({
  "../../node_modules/lodash/_stackSet.js"(exports2, module2) {
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    var MapCache = require_MapCache();
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value) {
      var data2 = this.__data__;
      if (data2 instanceof ListCache) {
        var pairs = data2.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data2.size;
          return this;
        }
        data2 = this.__data__ = new MapCache(pairs);
      }
      data2.set(key, value);
      this.size = data2.size;
      return this;
    }
    module2.exports = stackSet;
  }
});

// ../../node_modules/lodash/_Stack.js
var require_Stack = __commonJS({
  "../../node_modules/lodash/_Stack.js"(exports2, module2) {
    var ListCache = require_ListCache();
    var stackClear = require_stackClear();
    var stackDelete = require_stackDelete();
    var stackGet = require_stackGet();
    var stackHas = require_stackHas();
    var stackSet = require_stackSet();
    function Stack(entries) {
      var data2 = this.__data__ = new ListCache(entries);
      this.size = data2.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    module2.exports = Stack;
  }
});

// ../../node_modules/lodash/_arrayEach.js
var require_arrayEach = __commonJS({
  "../../node_modules/lodash/_arrayEach.js"(exports2, module2) {
    function arrayEach(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    module2.exports = arrayEach;
  }
});

// ../../node_modules/lodash/_defineProperty.js
var require_defineProperty = __commonJS({
  "../../node_modules/lodash/_defineProperty.js"(exports2, module2) {
    var getNative = require_getNative();
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    module2.exports = defineProperty;
  }
});

// ../../node_modules/lodash/_baseAssignValue.js
var require_baseAssignValue = __commonJS({
  "../../node_modules/lodash/_baseAssignValue.js"(exports2, module2) {
    var defineProperty = require_defineProperty();
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key] = value;
      }
    }
    module2.exports = baseAssignValue;
  }
});

// ../../node_modules/lodash/_assignValue.js
var require_assignValue = __commonJS({
  "../../node_modules/lodash/_assignValue.js"(exports2, module2) {
    var baseAssignValue = require_baseAssignValue();
    var eq = require_eq2();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    module2.exports = assignValue;
  }
});

// ../../node_modules/lodash/_copyObject.js
var require_copyObject = __commonJS({
  "../../node_modules/lodash/_copyObject.js"(exports2, module2) {
    var assignValue = require_assignValue();
    var baseAssignValue = require_baseAssignValue();
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    module2.exports = copyObject;
  }
});

// ../../node_modules/lodash/_baseTimes.js
var require_baseTimes = __commonJS({
  "../../node_modules/lodash/_baseTimes.js"(exports2, module2) {
    function baseTimes(n, iteratee) {
      var index = -1, result2 = Array(n);
      while (++index < n) {
        result2[index] = iteratee(index);
      }
      return result2;
    }
    module2.exports = baseTimes;
  }
});

// ../../node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "../../node_modules/lodash/isObjectLike.js"(exports2, module2) {
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    module2.exports = isObjectLike;
  }
});

// ../../node_modules/lodash/_baseIsArguments.js
var require_baseIsArguments = __commonJS({
  "../../node_modules/lodash/_baseIsArguments.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    module2.exports = baseIsArguments;
  }
});

// ../../node_modules/lodash/isArguments.js
var require_isArguments = __commonJS({
  "../../node_modules/lodash/isArguments.js"(exports2, module2) {
    var baseIsArguments = require_baseIsArguments();
    var isObjectLike = require_isObjectLike();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    module2.exports = isArguments;
  }
});

// ../../node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "../../node_modules/lodash/isArray.js"(exports2, module2) {
    var isArray = Array.isArray;
    module2.exports = isArray;
  }
});

// ../../node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS({
  "../../node_modules/lodash/stubFalse.js"(exports2, module2) {
    function stubFalse() {
      return false;
    }
    module2.exports = stubFalse;
  }
});

// ../../node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS({
  "../../node_modules/lodash/isBuffer.js"(exports2, module2) {
    var root = require_root();
    var stubFalse = require_stubFalse();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    module2.exports = isBuffer;
  }
});

// ../../node_modules/lodash/_isIndex.js
var require_isIndex = __commonJS({
  "../../node_modules/lodash/_isIndex.js"(exports2, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    module2.exports = isIndex;
  }
});

// ../../node_modules/lodash/isLength.js
var require_isLength = __commonJS({
  "../../node_modules/lodash/isLength.js"(exports2, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    module2.exports = isLength;
  }
});

// ../../node_modules/lodash/_baseIsTypedArray.js
var require_baseIsTypedArray = __commonJS({
  "../../node_modules/lodash/_baseIsTypedArray.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isLength = require_isLength();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    module2.exports = baseIsTypedArray;
  }
});

// ../../node_modules/lodash/_baseUnary.js
var require_baseUnary = __commonJS({
  "../../node_modules/lodash/_baseUnary.js"(exports2, module2) {
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    module2.exports = baseUnary;
  }
});

// ../../node_modules/lodash/_nodeUtil.js
var require_nodeUtil = __commonJS({
  "../../node_modules/lodash/_nodeUtil.js"(exports2, module2) {
    var freeGlobal = require_freeGlobal();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    module2.exports = nodeUtil;
  }
});

// ../../node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS({
  "../../node_modules/lodash/isTypedArray.js"(exports2, module2) {
    var baseIsTypedArray = require_baseIsTypedArray();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    module2.exports = isTypedArray;
  }
});

// ../../node_modules/lodash/_arrayLikeKeys.js
var require_arrayLikeKeys = __commonJS({
  "../../node_modules/lodash/_arrayLikeKeys.js"(exports2, module2) {
    var baseTimes = require_baseTimes();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isIndex = require_isIndex();
    var isTypedArray = require_isTypedArray();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String) : [], length = result2.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
          result2.push(key);
        }
      }
      return result2;
    }
    module2.exports = arrayLikeKeys;
  }
});

// ../../node_modules/lodash/_isPrototype.js
var require_isPrototype = __commonJS({
  "../../node_modules/lodash/_isPrototype.js"(exports2, module2) {
    var objectProto = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    module2.exports = isPrototype;
  }
});

// ../../node_modules/lodash/_overArg.js
var require_overArg = __commonJS({
  "../../node_modules/lodash/_overArg.js"(exports2, module2) {
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    module2.exports = overArg;
  }
});

// ../../node_modules/lodash/_nativeKeys.js
var require_nativeKeys = __commonJS({
  "../../node_modules/lodash/_nativeKeys.js"(exports2, module2) {
    var overArg = require_overArg();
    var nativeKeys = overArg(Object.keys, Object);
    module2.exports = nativeKeys;
  }
});

// ../../node_modules/lodash/_baseKeys.js
var require_baseKeys = __commonJS({
  "../../node_modules/lodash/_baseKeys.js"(exports2, module2) {
    var isPrototype = require_isPrototype();
    var nativeKeys = require_nativeKeys();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result2 = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result2.push(key);
        }
      }
      return result2;
    }
    module2.exports = baseKeys;
  }
});

// ../../node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS({
  "../../node_modules/lodash/isArrayLike.js"(exports2, module2) {
    var isFunction = require_isFunction();
    var isLength = require_isLength();
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    module2.exports = isArrayLike;
  }
});

// ../../node_modules/lodash/keys.js
var require_keys = __commonJS({
  "../../node_modules/lodash/keys.js"(exports2, module2) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeys = require_baseKeys();
    var isArrayLike = require_isArrayLike();
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    module2.exports = keys;
  }
});

// ../../node_modules/lodash/_baseAssign.js
var require_baseAssign = __commonJS({
  "../../node_modules/lodash/_baseAssign.js"(exports2, module2) {
    var copyObject = require_copyObject();
    var keys = require_keys();
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    module2.exports = baseAssign;
  }
});

// ../../node_modules/lodash/_nativeKeysIn.js
var require_nativeKeysIn = __commonJS({
  "../../node_modules/lodash/_nativeKeysIn.js"(exports2, module2) {
    function nativeKeysIn(object) {
      var result2 = [];
      if (object != null) {
        for (var key in Object(object)) {
          result2.push(key);
        }
      }
      return result2;
    }
    module2.exports = nativeKeysIn;
  }
});

// ../../node_modules/lodash/_baseKeysIn.js
var require_baseKeysIn = __commonJS({
  "../../node_modules/lodash/_baseKeysIn.js"(exports2, module2) {
    var isObject = require_isObject();
    var isPrototype = require_isPrototype();
    var nativeKeysIn = require_nativeKeysIn();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result2 = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
          result2.push(key);
        }
      }
      return result2;
    }
    module2.exports = baseKeysIn;
  }
});

// ../../node_modules/lodash/keysIn.js
var require_keysIn = __commonJS({
  "../../node_modules/lodash/keysIn.js"(exports2, module2) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeysIn = require_baseKeysIn();
    var isArrayLike = require_isArrayLike();
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    module2.exports = keysIn;
  }
});

// ../../node_modules/lodash/_baseAssignIn.js
var require_baseAssignIn = __commonJS({
  "../../node_modules/lodash/_baseAssignIn.js"(exports2, module2) {
    var copyObject = require_copyObject();
    var keysIn = require_keysIn();
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }
    module2.exports = baseAssignIn;
  }
});

// ../../node_modules/lodash/_cloneBuffer.js
var require_cloneBuffer = __commonJS({
  "../../node_modules/lodash/_cloneBuffer.js"(exports2, module2) {
    var root = require_root();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      buffer.copy(result2);
      return result2;
    }
    module2.exports = cloneBuffer;
  }
});

// ../../node_modules/lodash/_copyArray.js
var require_copyArray = __commonJS({
  "../../node_modules/lodash/_copyArray.js"(exports2, module2) {
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    module2.exports = copyArray;
  }
});

// ../../node_modules/lodash/_arrayFilter.js
var require_arrayFilter = __commonJS({
  "../../node_modules/lodash/_arrayFilter.js"(exports2, module2) {
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result2[resIndex++] = value;
        }
      }
      return result2;
    }
    module2.exports = arrayFilter;
  }
});

// ../../node_modules/lodash/stubArray.js
var require_stubArray = __commonJS({
  "../../node_modules/lodash/stubArray.js"(exports2, module2) {
    function stubArray() {
      return [];
    }
    module2.exports = stubArray;
  }
});

// ../../node_modules/lodash/_getSymbols.js
var require_getSymbols = __commonJS({
  "../../node_modules/lodash/_getSymbols.js"(exports2, module2) {
    var arrayFilter = require_arrayFilter();
    var stubArray = require_stubArray();
    var objectProto = Object.prototype;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    module2.exports = getSymbols;
  }
});

// ../../node_modules/lodash/_copySymbols.js
var require_copySymbols = __commonJS({
  "../../node_modules/lodash/_copySymbols.js"(exports2, module2) {
    var copyObject = require_copyObject();
    var getSymbols = require_getSymbols();
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    module2.exports = copySymbols;
  }
});

// ../../node_modules/lodash/_arrayPush.js
var require_arrayPush = __commonJS({
  "../../node_modules/lodash/_arrayPush.js"(exports2, module2) {
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    module2.exports = arrayPush;
  }
});

// ../../node_modules/lodash/_getPrototype.js
var require_getPrototype = __commonJS({
  "../../node_modules/lodash/_getPrototype.js"(exports2, module2) {
    var overArg = require_overArg();
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    module2.exports = getPrototype;
  }
});

// ../../node_modules/lodash/_getSymbolsIn.js
var require_getSymbolsIn = __commonJS({
  "../../node_modules/lodash/_getSymbolsIn.js"(exports2, module2) {
    var arrayPush = require_arrayPush();
    var getPrototype = require_getPrototype();
    var getSymbols = require_getSymbols();
    var stubArray = require_stubArray();
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result2 = [];
      while (object) {
        arrayPush(result2, getSymbols(object));
        object = getPrototype(object);
      }
      return result2;
    };
    module2.exports = getSymbolsIn;
  }
});

// ../../node_modules/lodash/_copySymbolsIn.js
var require_copySymbolsIn = __commonJS({
  "../../node_modules/lodash/_copySymbolsIn.js"(exports2, module2) {
    var copyObject = require_copyObject();
    var getSymbolsIn = require_getSymbolsIn();
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }
    module2.exports = copySymbolsIn;
  }
});

// ../../node_modules/lodash/_baseGetAllKeys.js
var require_baseGetAllKeys = __commonJS({
  "../../node_modules/lodash/_baseGetAllKeys.js"(exports2, module2) {
    var arrayPush = require_arrayPush();
    var isArray = require_isArray();
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result2 = keysFunc(object);
      return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
    }
    module2.exports = baseGetAllKeys;
  }
});

// ../../node_modules/lodash/_getAllKeys.js
var require_getAllKeys = __commonJS({
  "../../node_modules/lodash/_getAllKeys.js"(exports2, module2) {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbols = require_getSymbols();
    var keys = require_keys();
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    module2.exports = getAllKeys;
  }
});

// ../../node_modules/lodash/_getAllKeysIn.js
var require_getAllKeysIn = __commonJS({
  "../../node_modules/lodash/_getAllKeysIn.js"(exports2, module2) {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbolsIn = require_getSymbolsIn();
    var keysIn = require_keysIn();
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }
    module2.exports = getAllKeysIn;
  }
});

// ../../node_modules/lodash/_DataView.js
var require_DataView = __commonJS({
  "../../node_modules/lodash/_DataView.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var DataView = getNative(root, "DataView");
    module2.exports = DataView;
  }
});

// ../../node_modules/lodash/_Promise.js
var require_Promise = __commonJS({
  "../../node_modules/lodash/_Promise.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Promise2 = getNative(root, "Promise");
    module2.exports = Promise2;
  }
});

// ../../node_modules/lodash/_Set.js
var require_Set = __commonJS({
  "../../node_modules/lodash/_Set.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Set2 = getNative(root, "Set");
    module2.exports = Set2;
  }
});

// ../../node_modules/lodash/_WeakMap.js
var require_WeakMap = __commonJS({
  "../../node_modules/lodash/_WeakMap.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var WeakMap2 = getNative(root, "WeakMap");
    module2.exports = WeakMap2;
  }
});

// ../../node_modules/lodash/_getTag.js
var require_getTag = __commonJS({
  "../../node_modules/lodash/_getTag.js"(exports2, module2) {
    var DataView = require_DataView();
    var Map2 = require_Map();
    var Promise2 = require_Promise();
    var Set2 = require_Set();
    var WeakMap2 = require_WeakMap();
    var baseGetTag = require_baseGetTag();
    var toSource = require_toSource();
    var mapTag = "[object Map]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var setTag = "[object Set]";
    var weakMapTag = "[object WeakMap]";
    var dataViewTag = "[object DataView]";
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result2;
      };
    }
    module2.exports = getTag;
  }
});

// ../../node_modules/lodash/_initCloneArray.js
var require_initCloneArray = __commonJS({
  "../../node_modules/lodash/_initCloneArray.js"(exports2, module2) {
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function initCloneArray(array) {
      var length = array.length, result2 = new array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
        result2.index = array.index;
        result2.input = array.input;
      }
      return result2;
    }
    module2.exports = initCloneArray;
  }
});

// ../../node_modules/lodash/_Uint8Array.js
var require_Uint8Array = __commonJS({
  "../../node_modules/lodash/_Uint8Array.js"(exports2, module2) {
    var root = require_root();
    var Uint8Array2 = root.Uint8Array;
    module2.exports = Uint8Array2;
  }
});

// ../../node_modules/lodash/_cloneArrayBuffer.js
var require_cloneArrayBuffer = __commonJS({
  "../../node_modules/lodash/_cloneArrayBuffer.js"(exports2, module2) {
    var Uint8Array2 = require_Uint8Array();
    function cloneArrayBuffer(arrayBuffer) {
      var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
      return result2;
    }
    module2.exports = cloneArrayBuffer;
  }
});

// ../../node_modules/lodash/_cloneDataView.js
var require_cloneDataView = __commonJS({
  "../../node_modules/lodash/_cloneDataView.js"(exports2, module2) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    module2.exports = cloneDataView;
  }
});

// ../../node_modules/lodash/_cloneRegExp.js
var require_cloneRegExp = __commonJS({
  "../../node_modules/lodash/_cloneRegExp.js"(exports2, module2) {
    var reFlags = /\w*$/;
    function cloneRegExp(regexp) {
      var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result2.lastIndex = regexp.lastIndex;
      return result2;
    }
    module2.exports = cloneRegExp;
  }
});

// ../../node_modules/lodash/_cloneSymbol.js
var require_cloneSymbol = __commonJS({
  "../../node_modules/lodash/_cloneSymbol.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    module2.exports = cloneSymbol;
  }
});

// ../../node_modules/lodash/_cloneTypedArray.js
var require_cloneTypedArray = __commonJS({
  "../../node_modules/lodash/_cloneTypedArray.js"(exports2, module2) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    module2.exports = cloneTypedArray;
  }
});

// ../../node_modules/lodash/_initCloneByTag.js
var require_initCloneByTag = __commonJS({
  "../../node_modules/lodash/_initCloneByTag.js"(exports2, module2) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    var cloneDataView = require_cloneDataView();
    var cloneRegExp = require_cloneRegExp();
    var cloneSymbol = require_cloneSymbol();
    var cloneTypedArray = require_cloneTypedArray();
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return new Ctor();
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return new Ctor();
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    module2.exports = initCloneByTag;
  }
});

// ../../node_modules/lodash/_baseCreate.js
var require_baseCreate = __commonJS({
  "../../node_modules/lodash/_baseCreate.js"(exports2, module2) {
    var isObject = require_isObject();
    var objectCreate = Object.create;
    var baseCreate = function() {
      function object() {
      }
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result2 = new object();
        object.prototype = void 0;
        return result2;
      };
    }();
    module2.exports = baseCreate;
  }
});

// ../../node_modules/lodash/_initCloneObject.js
var require_initCloneObject = __commonJS({
  "../../node_modules/lodash/_initCloneObject.js"(exports2, module2) {
    var baseCreate = require_baseCreate();
    var getPrototype = require_getPrototype();
    var isPrototype = require_isPrototype();
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    module2.exports = initCloneObject;
  }
});

// ../../node_modules/lodash/_baseIsMap.js
var require_baseIsMap = __commonJS({
  "../../node_modules/lodash/_baseIsMap.js"(exports2, module2) {
    var getTag = require_getTag();
    var isObjectLike = require_isObjectLike();
    var mapTag = "[object Map]";
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }
    module2.exports = baseIsMap;
  }
});

// ../../node_modules/lodash/isMap.js
var require_isMap = __commonJS({
  "../../node_modules/lodash/isMap.js"(exports2, module2) {
    var baseIsMap = require_baseIsMap();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsMap = nodeUtil && nodeUtil.isMap;
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
    module2.exports = isMap;
  }
});

// ../../node_modules/lodash/_baseIsSet.js
var require_baseIsSet = __commonJS({
  "../../node_modules/lodash/_baseIsSet.js"(exports2, module2) {
    var getTag = require_getTag();
    var isObjectLike = require_isObjectLike();
    var setTag = "[object Set]";
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }
    module2.exports = baseIsSet;
  }
});

// ../../node_modules/lodash/isSet.js
var require_isSet = __commonJS({
  "../../node_modules/lodash/isSet.js"(exports2, module2) {
    var baseIsSet = require_baseIsSet();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsSet = nodeUtil && nodeUtil.isSet;
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
    module2.exports = isSet;
  }
});

// ../../node_modules/lodash/_baseClone.js
var require_baseClone = __commonJS({
  "../../node_modules/lodash/_baseClone.js"(exports2, module2) {
    var Stack = require_Stack();
    var arrayEach = require_arrayEach();
    var assignValue = require_assignValue();
    var baseAssign = require_baseAssign();
    var baseAssignIn = require_baseAssignIn();
    var cloneBuffer = require_cloneBuffer();
    var copyArray = require_copyArray();
    var copySymbols = require_copySymbols();
    var copySymbolsIn = require_copySymbolsIn();
    var getAllKeys = require_getAllKeys();
    var getAllKeysIn = require_getAllKeysIn();
    var getTag = require_getTag();
    var initCloneArray = require_initCloneArray();
    var initCloneByTag = require_initCloneByTag();
    var initCloneObject = require_initCloneObject();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isMap = require_isMap();
    var isObject = require_isObject();
    var isSet = require_isSet();
    var keys = require_keys();
    var keysIn = require_keysIn();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_FLAT_FLAG = 2;
    var CLONE_SYMBOLS_FLAG = 4;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
      if (customizer) {
        result2 = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result2 !== void 0) {
        return result2;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result2 = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result2);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          result2 = isFlat || isFunc ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result2 = initCloneByTag(value, tag, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result2);
      if (isSet(value)) {
        value.forEach(function(subValue) {
          result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key2) {
          result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
      }
      var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
      var props = isArr ? void 0 : keysFunc(value);
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
      });
      return result2;
    }
    module2.exports = baseClone;
  }
});

// ../../node_modules/lodash/cloneDeep.js
var require_cloneDeep = __commonJS({
  "../../node_modules/lodash/cloneDeep.js"(exports2, module2) {
    var baseClone = require_baseClone();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_SYMBOLS_FLAG = 4;
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }
    module2.exports = cloneDeep;
  }
});

// ../../node_modules/@sap-ux/store/node_modules/@sap-ux/logger/dist/types.js
var require_types7 = __commonJS({
  "../../node_modules/@sap-ux/store/node_modules/@sap-ux/logger/dist/types.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Transport = exports2.LogLevel = void 0;
    var cloneDeep_1 = __importDefault(require_cloneDeep());
    var LogLevel;
    (function(LogLevel2) {
      LogLevel2[LogLevel2["Error"] = 0] = "Error";
      LogLevel2[LogLevel2["Warn"] = 1] = "Warn";
      LogLevel2[LogLevel2["Info"] = 2] = "Info";
      LogLevel2[LogLevel2["Verbose"] = 3] = "Verbose";
      LogLevel2[LogLevel2["Debug"] = 4] = "Debug";
      LogLevel2[LogLevel2["Silly"] = 5] = "Silly";
    })(LogLevel = exports2.LogLevel || (exports2.LogLevel = {}));
    var Transport = class {
      copy(obj) {
        return Object.freeze(cloneDeep_1.default(obj));
      }
    };
    exports2.Transport = Transport;
  }
});

// ../../node_modules/@sap-ux/store/node_modules/@sap-ux/logger/dist/transports/transport.js
var require_transport = __commonJS({
  "../../node_modules/@sap-ux/store/node_modules/@sap-ux/logger/dist/transports/transport.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VSCodeTransport = exports2.StringArrayTransport = exports2.FileTransport = exports2.NullTransport = exports2.UI5ToolingTransport = exports2.ConsoleTransport = void 0;
    var types_1 = require_types7();
    var ConsoleTransport = class extends types_1.Transport {
      constructor(opts = {}) {
        super();
        if (!ConsoleTransport.singletonInstance) {
          ConsoleTransport.singletonInstance = this;
          this.options = this.copy(opts);
        }
        return ConsoleTransport.singletonInstance;
      }
    };
    exports2.ConsoleTransport = ConsoleTransport;
    var UI5ToolingTransport = class extends types_1.Transport {
      constructor(opts) {
        super();
        const instance = UI5ToolingTransport.instances.get(opts.moduleName);
        if (!instance) {
          this.options = this.copy(opts);
          UI5ToolingTransport.instances.set(opts.moduleName, this);
          return this;
        } else {
          return instance;
        }
      }
    };
    exports2.UI5ToolingTransport = UI5ToolingTransport;
    UI5ToolingTransport.instances = /* @__PURE__ */ new Map();
    var NullTransport = class extends types_1.Transport {
      constructor() {
        super();
        if (!NullTransport.singletonInstance) {
          NullTransport.singletonInstance = this;
        }
        return NullTransport.singletonInstance;
      }
    };
    exports2.NullTransport = NullTransport;
    var FileTransport = class extends types_1.Transport {
      constructor(opts) {
        super();
        this.options = this.copy(opts);
      }
    };
    exports2.FileTransport = FileTransport;
    var StringArrayTransport = class extends types_1.Transport {
    };
    exports2.StringArrayTransport = StringArrayTransport;
    var VSCodeTransport = class extends types_1.Transport {
      constructor(opts) {
        super();
        const instance = VSCodeTransport.instances.get(opts.channelName);
        if (!instance) {
          this.options = this.copy(opts);
          VSCodeTransport.instances.set(opts.channelName, this);
          return this;
        } else {
          return instance;
        }
      }
    };
    exports2.VSCodeTransport = VSCodeTransport;
    VSCodeTransport.instances = /* @__PURE__ */ new Map();
  }
});

// ../../node_modules/@sap-ux/store/node_modules/@sap-ux/logger/dist/transports/index.js
var require_transports = __commonJS({
  "../../node_modules/@sap-ux/store/node_modules/@sap-ux/logger/dist/transports/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_transport(), exports2);
  }
});

// ../../node_modules/logform/format.js
var require_format2 = __commonJS({
  "../../node_modules/logform/format.js"(exports2, module2) {
    "use strict";
    var InvalidFormatError = class extends Error {
      constructor(formatFn) {
        super(`Format functions must be synchronous taking a two arguments: (info, opts)
Found: ${formatFn.toString().split("\n")[0]}
`);
        Error.captureStackTrace(this, InvalidFormatError);
      }
    };
    module2.exports = (formatFn) => {
      if (formatFn.length > 2) {
        throw new InvalidFormatError(formatFn);
      }
      function Format(options2 = {}) {
        this.options = options2;
      }
      Format.prototype.transform = formatFn;
      function createFormatWrap(opts) {
        return new Format(opts);
      }
      createFormatWrap.Format = Format;
      return createFormatWrap;
    };
  }
});

// ../../node_modules/@colors/colors/lib/styles.js
var require_styles = __commonJS({
  "../../node_modules/@colors/colors/lib/styles.js"(exports2, module2) {
    var styles = {};
    module2["exports"] = styles;
    var codes = {
      reset: [0, 0],
      bold: [1, 22],
      dim: [2, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29],
      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      gray: [90, 39],
      grey: [90, 39],
      brightRed: [91, 39],
      brightGreen: [92, 39],
      brightYellow: [93, 39],
      brightBlue: [94, 39],
      brightMagenta: [95, 39],
      brightCyan: [96, 39],
      brightWhite: [97, 39],
      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],
      bgGray: [100, 49],
      bgGrey: [100, 49],
      bgBrightRed: [101, 49],
      bgBrightGreen: [102, 49],
      bgBrightYellow: [103, 49],
      bgBrightBlue: [104, 49],
      bgBrightMagenta: [105, 49],
      bgBrightCyan: [106, 49],
      bgBrightWhite: [107, 49],
      blackBG: [40, 49],
      redBG: [41, 49],
      greenBG: [42, 49],
      yellowBG: [43, 49],
      blueBG: [44, 49],
      magentaBG: [45, 49],
      cyanBG: [46, 49],
      whiteBG: [47, 49]
    };
    Object.keys(codes).forEach(function(key) {
      var val = codes[key];
      var style = styles[key] = [];
      style.open = "\x1B[" + val[0] + "m";
      style.close = "\x1B[" + val[1] + "m";
    });
  }
});

// ../../node_modules/@colors/colors/lib/system/has-flag.js
var require_has_flag2 = __commonJS({
  "../../node_modules/@colors/colors/lib/system/has-flag.js"(exports2, module2) {
    "use strict";
    module2.exports = function(flag, argv) {
      argv = argv || process.argv;
      var terminatorPos = argv.indexOf("--");
      var prefix = /^-{1,2}/.test(flag) ? "" : "--";
      var pos = argv.indexOf(prefix + flag);
      return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
    };
  }
});

// ../../node_modules/@colors/colors/lib/system/supports-colors.js
var require_supports_colors = __commonJS({
  "../../node_modules/@colors/colors/lib/system/supports-colors.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var hasFlag = require_has_flag2();
    var env = process.env;
    var forceColor = void 0;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
      forceColor = false;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = true;
    }
    if ("FORCE_COLOR" in env) {
      forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(stream) {
      if (forceColor === false) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (stream && !stream.isTTY && forceColor !== true) {
        return 0;
      }
      var min = forceColor ? 1 : 0;
      if (process.platform === "win32") {
        var osRelease = os.release().split(".");
        if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some(function(sign) {
          return sign in env;
        }) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if ("TERM_PROGRAM" in env) {
        var version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Hyper":
            return 3;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      if (env.TERM === "dumb") {
        return min;
      }
      return min;
    }
    function getSupportLevel(stream) {
      var level = supportsColor(stream);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel(process.stdout),
      stderr: getSupportLevel(process.stderr)
    };
  }
});

// ../../node_modules/@colors/colors/lib/custom/trap.js
var require_trap = __commonJS({
  "../../node_modules/@colors/colors/lib/custom/trap.js"(exports2, module2) {
    module2["exports"] = function runTheTrap(text, options2) {
      var result2 = "";
      text = text || "Run the trap, drop the bass";
      text = text.split("");
      var trap = {
        a: ["@", "\u0104", "\u023A", "\u0245", "\u0394", "\u039B", "\u0414"],
        b: ["\xDF", "\u0181", "\u0243", "\u026E", "\u03B2", "\u0E3F"],
        c: ["\xA9", "\u023B", "\u03FE"],
        d: ["\xD0", "\u018A", "\u0500", "\u0501", "\u0502", "\u0503"],
        e: [
          "\xCB",
          "\u0115",
          "\u018E",
          "\u0258",
          "\u03A3",
          "\u03BE",
          "\u04BC",
          "\u0A6C"
        ],
        f: ["\u04FA"],
        g: ["\u0262"],
        h: ["\u0126", "\u0195", "\u04A2", "\u04BA", "\u04C7", "\u050A"],
        i: ["\u0F0F"],
        j: ["\u0134"],
        k: ["\u0138", "\u04A0", "\u04C3", "\u051E"],
        l: ["\u0139"],
        m: ["\u028D", "\u04CD", "\u04CE", "\u0520", "\u0521", "\u0D69"],
        n: ["\xD1", "\u014B", "\u019D", "\u0376", "\u03A0", "\u048A"],
        o: [
          "\xD8",
          "\xF5",
          "\xF8",
          "\u01FE",
          "\u0298",
          "\u047A",
          "\u05DD",
          "\u06DD",
          "\u0E4F"
        ],
        p: ["\u01F7", "\u048E"],
        q: ["\u09CD"],
        r: ["\xAE", "\u01A6", "\u0210", "\u024C", "\u0280", "\u042F"],
        s: ["\xA7", "\u03DE", "\u03DF", "\u03E8"],
        t: ["\u0141", "\u0166", "\u0373"],
        u: ["\u01B1", "\u054D"],
        v: ["\u05D8"],
        w: ["\u0428", "\u0460", "\u047C", "\u0D70"],
        x: ["\u04B2", "\u04FE", "\u04FC", "\u04FD"],
        y: ["\xA5", "\u04B0", "\u04CB"],
        z: ["\u01B5", "\u0240"]
      };
      text.forEach(function(c) {
        c = c.toLowerCase();
        var chars = trap[c] || [" "];
        var rand = Math.floor(Math.random() * chars.length);
        if (typeof trap[c] !== "undefined") {
          result2 += trap[c][rand];
        } else {
          result2 += c;
        }
      });
      return result2;
    };
  }
});

// ../../node_modules/@colors/colors/lib/custom/zalgo.js
var require_zalgo = __commonJS({
  "../../node_modules/@colors/colors/lib/custom/zalgo.js"(exports2, module2) {
    module2["exports"] = function zalgo(text, options2) {
      text = text || "   he is here   ";
      var soul = {
        "up": [
          "\u030D",
          "\u030E",
          "\u0304",
          "\u0305",
          "\u033F",
          "\u0311",
          "\u0306",
          "\u0310",
          "\u0352",
          "\u0357",
          "\u0351",
          "\u0307",
          "\u0308",
          "\u030A",
          "\u0342",
          "\u0313",
          "\u0308",
          "\u034A",
          "\u034B",
          "\u034C",
          "\u0303",
          "\u0302",
          "\u030C",
          "\u0350",
          "\u0300",
          "\u0301",
          "\u030B",
          "\u030F",
          "\u0312",
          "\u0313",
          "\u0314",
          "\u033D",
          "\u0309",
          "\u0363",
          "\u0364",
          "\u0365",
          "\u0366",
          "\u0367",
          "\u0368",
          "\u0369",
          "\u036A",
          "\u036B",
          "\u036C",
          "\u036D",
          "\u036E",
          "\u036F",
          "\u033E",
          "\u035B",
          "\u0346",
          "\u031A"
        ],
        "down": [
          "\u0316",
          "\u0317",
          "\u0318",
          "\u0319",
          "\u031C",
          "\u031D",
          "\u031E",
          "\u031F",
          "\u0320",
          "\u0324",
          "\u0325",
          "\u0326",
          "\u0329",
          "\u032A",
          "\u032B",
          "\u032C",
          "\u032D",
          "\u032E",
          "\u032F",
          "\u0330",
          "\u0331",
          "\u0332",
          "\u0333",
          "\u0339",
          "\u033A",
          "\u033B",
          "\u033C",
          "\u0345",
          "\u0347",
          "\u0348",
          "\u0349",
          "\u034D",
          "\u034E",
          "\u0353",
          "\u0354",
          "\u0355",
          "\u0356",
          "\u0359",
          "\u035A",
          "\u0323"
        ],
        "mid": [
          "\u0315",
          "\u031B",
          "\u0300",
          "\u0301",
          "\u0358",
          "\u0321",
          "\u0322",
          "\u0327",
          "\u0328",
          "\u0334",
          "\u0335",
          "\u0336",
          "\u035C",
          "\u035D",
          "\u035E",
          "\u035F",
          "\u0360",
          "\u0362",
          "\u0338",
          "\u0337",
          "\u0361",
          " \u0489"
        ]
      };
      var all = [].concat(soul.up, soul.down, soul.mid);
      function randomNumber(range) {
        var r = Math.floor(Math.random() * range);
        return r;
      }
      function isChar(character) {
        var bool = false;
        all.filter(function(i) {
          bool = i === character;
        });
        return bool;
      }
      function heComes(text2, options3) {
        var result2 = "";
        var counts;
        var l;
        options3 = options3 || {};
        options3["up"] = typeof options3["up"] !== "undefined" ? options3["up"] : true;
        options3["mid"] = typeof options3["mid"] !== "undefined" ? options3["mid"] : true;
        options3["down"] = typeof options3["down"] !== "undefined" ? options3["down"] : true;
        options3["size"] = typeof options3["size"] !== "undefined" ? options3["size"] : "maxi";
        text2 = text2.split("");
        for (l in text2) {
          if (isChar(l)) {
            continue;
          }
          result2 = result2 + text2[l];
          counts = { "up": 0, "down": 0, "mid": 0 };
          switch (options3.size) {
            case "mini":
              counts.up = randomNumber(8);
              counts.mid = randomNumber(2);
              counts.down = randomNumber(8);
              break;
            case "maxi":
              counts.up = randomNumber(16) + 3;
              counts.mid = randomNumber(4) + 1;
              counts.down = randomNumber(64) + 3;
              break;
            default:
              counts.up = randomNumber(8) + 1;
              counts.mid = randomNumber(6) / 2;
              counts.down = randomNumber(8) + 1;
              break;
          }
          var arr = ["up", "mid", "down"];
          for (var d in arr) {
            var index = arr[d];
            for (var i = 0; i <= counts[index]; i++) {
              if (options3[index]) {
                result2 = result2 + soul[index][randomNumber(soul[index].length)];
              }
            }
          }
        }
        return result2;
      }
      return heComes(text, options2);
    };
  }
});

// ../../node_modules/@colors/colors/lib/maps/america.js
var require_america = __commonJS({
  "../../node_modules/@colors/colors/lib/maps/america.js"(exports2, module2) {
    module2["exports"] = function(colors) {
      return function(letter, i, exploded) {
        if (letter === " ")
          return letter;
        switch (i % 3) {
          case 0:
            return colors.red(letter);
          case 1:
            return colors.white(letter);
          case 2:
            return colors.blue(letter);
        }
      };
    };
  }
});

// ../../node_modules/@colors/colors/lib/maps/zebra.js
var require_zebra = __commonJS({
  "../../node_modules/@colors/colors/lib/maps/zebra.js"(exports2, module2) {
    module2["exports"] = function(colors) {
      return function(letter, i, exploded) {
        return i % 2 === 0 ? letter : colors.inverse(letter);
      };
    };
  }
});

// ../../node_modules/@colors/colors/lib/maps/rainbow.js
var require_rainbow = __commonJS({
  "../../node_modules/@colors/colors/lib/maps/rainbow.js"(exports2, module2) {
    module2["exports"] = function(colors) {
      var rainbowColors = ["red", "yellow", "green", "blue", "magenta"];
      return function(letter, i, exploded) {
        if (letter === " ") {
          return letter;
        } else {
          return colors[rainbowColors[i++ % rainbowColors.length]](letter);
        }
      };
    };
  }
});

// ../../node_modules/@colors/colors/lib/maps/random.js
var require_random = __commonJS({
  "../../node_modules/@colors/colors/lib/maps/random.js"(exports2, module2) {
    module2["exports"] = function(colors) {
      var available = [
        "underline",
        "inverse",
        "grey",
        "yellow",
        "red",
        "green",
        "blue",
        "white",
        "cyan",
        "magenta",
        "brightYellow",
        "brightRed",
        "brightGreen",
        "brightBlue",
        "brightWhite",
        "brightCyan",
        "brightMagenta"
      ];
      return function(letter, i, exploded) {
        return letter === " " ? letter : colors[available[Math.round(Math.random() * (available.length - 2))]](letter);
      };
    };
  }
});

// ../../node_modules/@colors/colors/lib/colors.js
var require_colors = __commonJS({
  "../../node_modules/@colors/colors/lib/colors.js"(exports2, module2) {
    var colors = {};
    module2["exports"] = colors;
    colors.themes = {};
    var util = require("util");
    var ansiStyles = colors.styles = require_styles();
    var defineProps = Object.defineProperties;
    var newLineRegex = new RegExp(/[\r\n]+/g);
    colors.supportsColor = require_supports_colors().supportsColor;
    if (typeof colors.enabled === "undefined") {
      colors.enabled = colors.supportsColor() !== false;
    }
    colors.enable = function() {
      colors.enabled = true;
    };
    colors.disable = function() {
      colors.enabled = false;
    };
    colors.stripColors = colors.strip = function(str) {
      return ("" + str).replace(/\x1B\[\d+m/g, "");
    };
    var stylize = colors.stylize = function stylize2(str, style) {
      if (!colors.enabled) {
        return str + "";
      }
      var styleMap = ansiStyles[style];
      if (!styleMap && style in colors) {
        return colors[style](str);
      }
      return styleMap.open + str + styleMap.close;
    };
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    var escapeStringRegexp = function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(matchOperatorsRe, "\\$&");
    };
    function build(_styles) {
      var builder = function builder2() {
        return applyStyle.apply(builder2, arguments);
      };
      builder._styles = _styles;
      builder.__proto__ = proto;
      return builder;
    }
    var styles = function() {
      var ret = {};
      ansiStyles.grey = ansiStyles.gray;
      Object.keys(ansiStyles).forEach(function(key) {
        ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
        ret[key] = {
          get: function() {
            return build(this._styles.concat(key));
          }
        };
      });
      return ret;
    }();
    var proto = defineProps(function colors2() {
    }, styles);
    function applyStyle() {
      var args = Array.prototype.slice.call(arguments);
      var str = args.map(function(arg) {
        if (arg != null && arg.constructor === String) {
          return arg;
        } else {
          return util.inspect(arg);
        }
      }).join(" ");
      if (!colors.enabled || !str) {
        return str;
      }
      var newLinesPresent = str.indexOf("\n") != -1;
      var nestedStyles = this._styles;
      var i = nestedStyles.length;
      while (i--) {
        var code = ansiStyles[nestedStyles[i]];
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
        if (newLinesPresent) {
          str = str.replace(newLineRegex, function(match) {
            return code.close + match + code.open;
          });
        }
      }
      return str;
    }
    colors.setTheme = function(theme) {
      if (typeof theme === "string") {
        console.log("colors.setTheme now only accepts an object, not a string.  If you are trying to set a theme from a file, it is now your (the caller's) responsibility to require the file.  The old syntax looked like colors.setTheme(__dirname + '/../themes/generic-logging.js'); The new syntax looks like colors.setTheme(require(__dirname + '/../themes/generic-logging.js'));");
        return;
      }
      for (var style in theme) {
        (function(style2) {
          colors[style2] = function(str) {
            if (typeof theme[style2] === "object") {
              var out = str;
              for (var i in theme[style2]) {
                out = colors[theme[style2][i]](out);
              }
              return out;
            }
            return colors[theme[style2]](str);
          };
        })(style);
      }
    };
    function init() {
      var ret = {};
      Object.keys(styles).forEach(function(name) {
        ret[name] = {
          get: function() {
            return build([name]);
          }
        };
      });
      return ret;
    }
    var sequencer = function sequencer2(map2, str) {
      var exploded = str.split("");
      exploded = exploded.map(map2);
      return exploded.join("");
    };
    colors.trap = require_trap();
    colors.zalgo = require_zalgo();
    colors.maps = {};
    colors.maps.america = require_america()(colors);
    colors.maps.zebra = require_zebra()(colors);
    colors.maps.rainbow = require_rainbow()(colors);
    colors.maps.random = require_random()(colors);
    for (map in colors.maps) {
      (function(map2) {
        colors[map2] = function(str) {
          return sequencer(colors.maps[map2], str);
        };
      })(map);
    }
    var map;
    defineProps(colors, init());
  }
});

// ../../node_modules/@colors/colors/safe.js
var require_safe = __commonJS({
  "../../node_modules/@colors/colors/safe.js"(exports2, module2) {
    var colors = require_colors();
    module2["exports"] = colors;
  }
});

// ../../node_modules/triple-beam/config/cli.js
var require_cli2 = __commonJS({
  "../../node_modules/triple-beam/config/cli.js"(exports2) {
    "use strict";
    exports2.levels = {
      error: 0,
      warn: 1,
      help: 2,
      data: 3,
      info: 4,
      debug: 5,
      prompt: 6,
      verbose: 7,
      input: 8,
      silly: 9
    };
    exports2.colors = {
      error: "red",
      warn: "yellow",
      help: "cyan",
      data: "grey",
      info: "green",
      debug: "blue",
      prompt: "grey",
      verbose: "cyan",
      input: "grey",
      silly: "magenta"
    };
  }
});

// ../../node_modules/triple-beam/config/npm.js
var require_npm = __commonJS({
  "../../node_modules/triple-beam/config/npm.js"(exports2) {
    "use strict";
    exports2.levels = {
      error: 0,
      warn: 1,
      info: 2,
      http: 3,
      verbose: 4,
      debug: 5,
      silly: 6
    };
    exports2.colors = {
      error: "red",
      warn: "yellow",
      info: "green",
      http: "green",
      verbose: "cyan",
      debug: "blue",
      silly: "magenta"
    };
  }
});

// ../../node_modules/triple-beam/config/syslog.js
var require_syslog = __commonJS({
  "../../node_modules/triple-beam/config/syslog.js"(exports2) {
    "use strict";
    exports2.levels = {
      emerg: 0,
      alert: 1,
      crit: 2,
      error: 3,
      warning: 4,
      notice: 5,
      info: 6,
      debug: 7
    };
    exports2.colors = {
      emerg: "red",
      alert: "yellow",
      crit: "red",
      error: "red",
      warning: "red",
      notice: "yellow",
      info: "green",
      debug: "blue"
    };
  }
});

// ../../node_modules/triple-beam/config/index.js
var require_config2 = __commonJS({
  "../../node_modules/triple-beam/config/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "cli", {
      value: require_cli2()
    });
    Object.defineProperty(exports2, "npm", {
      value: require_npm()
    });
    Object.defineProperty(exports2, "syslog", {
      value: require_syslog()
    });
  }
});

// ../../node_modules/triple-beam/index.js
var require_triple_beam = __commonJS({
  "../../node_modules/triple-beam/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "LEVEL", {
      value: Symbol.for("level")
    });
    Object.defineProperty(exports2, "MESSAGE", {
      value: Symbol.for("message")
    });
    Object.defineProperty(exports2, "SPLAT", {
      value: Symbol.for("splat")
    });
    Object.defineProperty(exports2, "configs", {
      value: require_config2()
    });
  }
});

// ../../node_modules/logform/colorize.js
var require_colorize = __commonJS({
  "../../node_modules/logform/colorize.js"(exports2, module2) {
    "use strict";
    var colors = require_safe();
    var { LEVEL, MESSAGE } = require_triple_beam();
    colors.enabled = true;
    var hasSpace = /\s+/;
    var Colorizer = class {
      constructor(opts = {}) {
        if (opts.colors) {
          this.addColors(opts.colors);
        }
        this.options = opts;
      }
      static addColors(clrs) {
        const nextColors = Object.keys(clrs).reduce((acc, level) => {
          acc[level] = hasSpace.test(clrs[level]) ? clrs[level].split(hasSpace) : clrs[level];
          return acc;
        }, {});
        Colorizer.allColors = Object.assign({}, Colorizer.allColors || {}, nextColors);
        return Colorizer.allColors;
      }
      addColors(clrs) {
        return Colorizer.addColors(clrs);
      }
      colorize(lookup, level, message) {
        if (typeof message === "undefined") {
          message = level;
        }
        if (!Array.isArray(Colorizer.allColors[lookup])) {
          return colors[Colorizer.allColors[lookup]](message);
        }
        for (let i = 0, len = Colorizer.allColors[lookup].length; i < len; i++) {
          message = colors[Colorizer.allColors[lookup][i]](message);
        }
        return message;
      }
      transform(info, opts) {
        if (opts.all && typeof info[MESSAGE] === "string") {
          info[MESSAGE] = this.colorize(info[LEVEL], info.level, info[MESSAGE]);
        }
        if (opts.level || opts.all || !opts.message) {
          info.level = this.colorize(info[LEVEL], info.level);
        }
        if (opts.all || opts.message) {
          info.message = this.colorize(info[LEVEL], info.level, info.message);
        }
        return info;
      }
    };
    module2.exports = (opts) => new Colorizer(opts);
    module2.exports.Colorizer = module2.exports.Format = Colorizer;
  }
});

// ../../node_modules/logform/levels.js
var require_levels = __commonJS({
  "../../node_modules/logform/levels.js"(exports2, module2) {
    "use strict";
    var { Colorizer } = require_colorize();
    module2.exports = (config) => {
      Colorizer.addColors(config.colors || config);
      return config;
    };
  }
});

// ../../node_modules/logform/align.js
var require_align = __commonJS({
  "../../node_modules/logform/align.js"(exports2, module2) {
    "use strict";
    var format2 = require_format2();
    module2.exports = format2((info) => {
      info.message = `	${info.message}`;
      return info;
    });
  }
});

// ../../node_modules/logform/errors.js
var require_errors2 = __commonJS({
  "../../node_modules/logform/errors.js"(exports2, module2) {
    "use strict";
    var format2 = require_format2();
    var { LEVEL, MESSAGE } = require_triple_beam();
    module2.exports = format2((einfo, { stack }) => {
      if (einfo instanceof Error) {
        const info = Object.assign({}, einfo, {
          level: einfo.level,
          [LEVEL]: einfo[LEVEL] || einfo.level,
          message: einfo.message,
          [MESSAGE]: einfo[MESSAGE] || einfo.message
        });
        if (stack)
          info.stack = einfo.stack;
        return info;
      }
      if (!(einfo.message instanceof Error))
        return einfo;
      const err = einfo.message;
      Object.assign(einfo, err);
      einfo.message = err.message;
      einfo[MESSAGE] = err.message;
      if (stack)
        einfo.stack = err.stack;
      return einfo;
    });
  }
});

// ../../node_modules/logform/pad-levels.js
var require_pad_levels = __commonJS({
  "../../node_modules/logform/pad-levels.js"(exports2, module2) {
    "use strict";
    var { configs, LEVEL, MESSAGE } = require_triple_beam();
    var Padder = class {
      constructor(opts = { levels: configs.npm.levels }) {
        this.paddings = Padder.paddingForLevels(opts.levels, opts.filler);
        this.options = opts;
      }
      static getLongestLevel(levels) {
        const lvls = Object.keys(levels).map((level) => level.length);
        return Math.max(...lvls);
      }
      static paddingForLevel(level, filler, maxLength) {
        const targetLen = maxLength + 1 - level.length;
        const rep = Math.floor(targetLen / filler.length);
        const padding = `${filler}${filler.repeat(rep)}`;
        return padding.slice(0, targetLen);
      }
      static paddingForLevels(levels, filler = " ") {
        const maxLength = Padder.getLongestLevel(levels);
        return Object.keys(levels).reduce((acc, level) => {
          acc[level] = Padder.paddingForLevel(level, filler, maxLength);
          return acc;
        }, {});
      }
      transform(info, opts) {
        info.message = `${this.paddings[info[LEVEL]]}${info.message}`;
        if (info[MESSAGE]) {
          info[MESSAGE] = `${this.paddings[info[LEVEL]]}${info[MESSAGE]}`;
        }
        return info;
      }
    };
    module2.exports = (opts) => new Padder(opts);
    module2.exports.Padder = module2.exports.Format = Padder;
  }
});

// ../../node_modules/logform/cli.js
var require_cli3 = __commonJS({
  "../../node_modules/logform/cli.js"(exports2, module2) {
    "use strict";
    var { Colorizer } = require_colorize();
    var { Padder } = require_pad_levels();
    var { configs, MESSAGE } = require_triple_beam();
    var CliFormat = class {
      constructor(opts = {}) {
        if (!opts.levels) {
          opts.levels = configs.cli.levels;
        }
        this.colorizer = new Colorizer(opts);
        this.padder = new Padder(opts);
        this.options = opts;
      }
      transform(info, opts) {
        this.colorizer.transform(this.padder.transform(info, opts), opts);
        info[MESSAGE] = `${info.level}:${info.message}`;
        return info;
      }
    };
    module2.exports = (opts) => new CliFormat(opts);
    module2.exports.Format = CliFormat;
  }
});

// ../../node_modules/logform/combine.js
var require_combine = __commonJS({
  "../../node_modules/logform/combine.js"(exports2, module2) {
    "use strict";
    var format2 = require_format2();
    function cascade(formats) {
      if (!formats.every(isValidFormat)) {
        return;
      }
      return (info) => {
        let obj = info;
        for (let i = 0; i < formats.length; i++) {
          obj = formats[i].transform(obj, formats[i].options);
          if (!obj) {
            return false;
          }
        }
        return obj;
      };
    }
    function isValidFormat(fmt) {
      if (typeof fmt.transform !== "function") {
        throw new Error([
          "No transform function found on format. Did you create a format instance?",
          "const myFormat = format(formatFn);",
          "const instance = myFormat();"
        ].join("\n"));
      }
      return true;
    }
    module2.exports = (...formats) => {
      const combinedFormat = format2(cascade(formats));
      const instance = combinedFormat();
      instance.Format = combinedFormat.Format;
      return instance;
    };
    module2.exports.cascade = cascade;
  }
});

// ../../node_modules/safe-stable-stringify/index.js
var require_safe_stable_stringify = __commonJS({
  "../../node_modules/safe-stable-stringify/index.js"(exports2, module2) {
    "use strict";
    var stringify = configure();
    stringify.configure = configure;
    stringify.stringify = stringify;
    stringify.default = stringify;
    exports2.stringify = stringify;
    exports2.configure = configure;
    module2.exports = stringify;
    var strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]|[\ud800-\udbff](?![\udc00-\udfff])|(?:[^\ud800-\udbff]|^)[\udc00-\udfff]/;
    var strEscapeSequencesReplacer = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]|[\ud800-\udbff](?![\udc00-\udfff])|(?:[^\ud800-\udbff]|^)[\udc00-\udfff]/g;
    var meta = [
      "\\u0000",
      "\\u0001",
      "\\u0002",
      "\\u0003",
      "\\u0004",
      "\\u0005",
      "\\u0006",
      "\\u0007",
      "\\b",
      "\\t",
      "\\n",
      "\\u000b",
      "\\f",
      "\\r",
      "\\u000e",
      "\\u000f",
      "\\u0010",
      "\\u0011",
      "\\u0012",
      "\\u0013",
      "\\u0014",
      "\\u0015",
      "\\u0016",
      "\\u0017",
      "\\u0018",
      "\\u0019",
      "\\u001a",
      "\\u001b",
      "\\u001c",
      "\\u001d",
      "\\u001e",
      "\\u001f",
      "",
      "",
      '\\"',
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "\\\\"
    ];
    function escapeFn(str) {
      if (str.length === 2) {
        const charCode2 = str.charCodeAt(1);
        return `${str[0]}\\u${charCode2.toString(16)}`;
      }
      const charCode = str.charCodeAt(0);
      return meta.length > charCode ? meta[charCode] : `\\u${charCode.toString(16)}`;
    }
    function strEscape(str) {
      if (str.length < 5e3 && !strEscapeSequencesRegExp.test(str)) {
        return str;
      }
      if (str.length > 100) {
        return str.replace(strEscapeSequencesReplacer, escapeFn);
      }
      let result2 = "";
      let last = 0;
      for (let i = 0; i < str.length; i++) {
        const point = str.charCodeAt(i);
        if (point === 34 || point === 92 || point < 32) {
          result2 += `${str.slice(last, i)}${meta[point]}`;
          last = i + 1;
        } else if (point >= 55296 && point <= 57343) {
          if (point <= 56319 && i + 1 < str.length) {
            const point2 = str.charCodeAt(i + 1);
            if (point2 >= 56320 && point2 <= 57343) {
              i++;
              continue;
            }
          }
          result2 += `${str.slice(last, i)}${`\\u${point.toString(16)}`}`;
          last = i + 1;
        }
      }
      result2 += str.slice(last);
      return result2;
    }
    function insertSort(array) {
      if (array.length > 200) {
        return array.sort();
      }
      for (let i = 1; i < array.length; i++) {
        const currentValue = array[i];
        let position = i;
        while (position !== 0 && array[position - 1] > currentValue) {
          array[position] = array[position - 1];
          position--;
        }
        array[position] = currentValue;
      }
      return array;
    }
    var typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())), Symbol.toStringTag).get;
    function isTypedArrayWithEntries(value) {
      return typedArrayPrototypeGetSymbolToStringTag.call(value) !== void 0 && value.length !== 0;
    }
    function stringifyTypedArray(array, separator, maximumBreadth) {
      if (array.length < maximumBreadth) {
        maximumBreadth = array.length;
      }
      const whitespace = separator === "," ? "" : " ";
      let res = `"0":${whitespace}${array[0]}`;
      for (let i = 1; i < maximumBreadth; i++) {
        res += `${separator}"${i}":${whitespace}${array[i]}`;
      }
      return res;
    }
    function getCircularValueOption(options2) {
      if (options2 && Object.prototype.hasOwnProperty.call(options2, "circularValue")) {
        var circularValue = options2.circularValue;
        if (typeof circularValue === "string") {
          return `"${circularValue}"`;
        }
        if (circularValue == null) {
          return circularValue;
        }
        if (circularValue === Error || circularValue === TypeError) {
          return {
            toString() {
              throw new TypeError("Converting circular structure to JSON");
            }
          };
        }
        throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
      }
      return '"[Circular]"';
    }
    function getBooleanOption(options2, key) {
      if (options2 && Object.prototype.hasOwnProperty.call(options2, key)) {
        var value = options2[key];
        if (typeof value !== "boolean") {
          throw new TypeError(`The "${key}" argument must be of type boolean`);
        }
      }
      return value === void 0 ? true : value;
    }
    function getPositiveIntegerOption(options2, key) {
      if (options2 && Object.prototype.hasOwnProperty.call(options2, key)) {
        var value = options2[key];
        if (typeof value !== "number") {
          throw new TypeError(`The "${key}" argument must be of type number`);
        }
        if (!Number.isInteger(value)) {
          throw new TypeError(`The "${key}" argument must be an integer`);
        }
        if (value < 1) {
          throw new RangeError(`The "${key}" argument must be >= 1`);
        }
      }
      return value === void 0 ? Infinity : value;
    }
    function getItemCount(number) {
      if (number === 1) {
        return "1 item";
      }
      return `${number} items`;
    }
    function getUniqueReplacerSet(replacerArray) {
      const replacerSet = /* @__PURE__ */ new Set();
      for (const value of replacerArray) {
        if (typeof value === "string") {
          replacerSet.add(value);
        } else if (typeof value === "number") {
          replacerSet.add(String(value));
        }
      }
      return replacerSet;
    }
    function configure(options2) {
      const circularValue = getCircularValueOption(options2);
      const bigint = getBooleanOption(options2, "bigint");
      const deterministic = getBooleanOption(options2, "deterministic");
      const maximumDepth = getPositiveIntegerOption(options2, "maximumDepth");
      const maximumBreadth = getPositiveIntegerOption(options2, "maximumBreadth");
      function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {
        let value = parent[key];
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        value = replacer.call(parent, key, value);
        switch (typeof value) {
          case "string":
            return `"${strEscape(value)}"`;
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res = "";
            let join2 = ",";
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res += `
${indentation}`;
                join2 = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyFnReplacer(i, value, stack, replacer, spacer, indentation);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += join2;
              }
              const tmp = stringifyFnReplacer(i, value, stack, replacer, spacer, indentation);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `${join2}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let whitespace = "";
            let separator = "";
            if (spacer !== "") {
              indentation += spacer;
              join2 = `,
${indentation}`;
              whitespace = " ";
            }
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (isTypedArrayWithEntries(value)) {
              res += stringifyTypedArray(value, join2, maximumBreadth);
              keys = keys.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = join2;
            }
            if (deterministic) {
              keys = insertSort(keys);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifyFnReplacer(key2, value, stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}"${strEscape(key2)}":${whitespace}${tmp}`;
                separator = join2;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`;
              separator = join2;
            }
            if (spacer !== "" && separator.length > 1) {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "bigint":
            return bigint ? String(value) : void 0;
        }
      }
      function stringifyArrayReplacer(key, value, stack, replacer, spacer, indentation) {
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        switch (typeof value) {
          case "string":
            return `"${strEscape(value)}"`;
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            let res = "";
            let join2 = ",";
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res += `
${indentation}`;
                join2 = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyArrayReplacer(i, value[i], stack, replacer, spacer, indentation);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += join2;
              }
              const tmp = stringifyArrayReplacer(i, value[i], stack, replacer, spacer, indentation);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `${join2}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res}]`;
            }
            if (replacer.size === 0) {
              return "{}";
            }
            stack.push(value);
            let whitespace = "";
            if (spacer !== "") {
              indentation += spacer;
              join2 = `,
${indentation}`;
              whitespace = " ";
            }
            let separator = "";
            for (const key2 of replacer) {
              const tmp = stringifyArrayReplacer(key2, value[key2], stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}"${strEscape(key2)}":${whitespace}${tmp}`;
                separator = join2;
              }
            }
            if (spacer !== "" && separator.length > 1) {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "bigint":
            return bigint ? String(value) : void 0;
        }
      }
      function stringifyIndent(key, value, stack, spacer, indentation) {
        switch (typeof value) {
          case "string":
            return `"${strEscape(value)}"`;
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifyIndent(key, value, stack, spacer, indentation);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              indentation += spacer;
              let res2 = `
${indentation}`;
              const join3 = `,
${indentation}`;
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyIndent(i, value[i], stack, spacer, indentation);
                res2 += tmp2 !== void 0 ? tmp2 : "null";
                res2 += join3;
              }
              const tmp = stringifyIndent(i, value[i], stack, spacer, indentation);
              res2 += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res2 += `${join3}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              res2 += `
${originalIndentation}`;
              stack.pop();
              return `[${res2}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            indentation += spacer;
            const join2 = `,
${indentation}`;
            let res = "";
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (isTypedArrayWithEntries(value)) {
              res += stringifyTypedArray(value, join2, maximumBreadth);
              keys = keys.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = join2;
            }
            if (deterministic) {
              keys = insertSort(keys);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifyIndent(key2, value[key2], stack, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}"${strEscape(key2)}": ${tmp}`;
                separator = join2;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
              separator = join2;
            }
            if (separator !== "") {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "bigint":
            return bigint ? String(value) : void 0;
        }
      }
      function stringifySimple(key, value, stack) {
        switch (typeof value) {
          case "string":
            return `"${strEscape(value)}"`;
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifySimple(key, value, stack);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res = "";
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifySimple(i, value[i], stack);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += ",";
              }
              const tmp = stringifySimple(i, value[i], stack);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `,"... ${getItemCount(removedKeys)} not stringified"`;
              }
              stack.pop();
              return `[${res}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (isTypedArrayWithEntries(value)) {
              res += stringifyTypedArray(value, ",", maximumBreadth);
              keys = keys.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = ",";
            }
            if (deterministic) {
              keys = insertSort(keys);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifySimple(key2, value[key2], stack);
              if (tmp !== void 0) {
                res += `${separator}"${strEscape(key2)}":${tmp}`;
                separator = ",";
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "bigint":
            return bigint ? String(value) : void 0;
        }
      }
      function stringify2(value, replacer, space) {
        if (arguments.length > 1) {
          let spacer = "";
          if (typeof space === "number") {
            spacer = " ".repeat(Math.min(space, 10));
          } else if (typeof space === "string") {
            spacer = space.slice(0, 10);
          }
          if (replacer != null) {
            if (typeof replacer === "function") {
              return stringifyFnReplacer("", { "": value }, [], replacer, spacer, "");
            }
            if (Array.isArray(replacer)) {
              return stringifyArrayReplacer("", value, [], getUniqueReplacerSet(replacer), spacer, "");
            }
          }
          if (spacer.length !== 0) {
            return stringifyIndent("", value, [], spacer, "");
          }
        }
        return stringifySimple("", value, []);
      }
      return stringify2;
    }
  }
});

// ../../node_modules/logform/json.js
var require_json = __commonJS({
  "../../node_modules/logform/json.js"(exports2, module2) {
    "use strict";
    var format2 = require_format2();
    var { MESSAGE } = require_triple_beam();
    var stringify = require_safe_stable_stringify();
    function replacer(key, value) {
      if (typeof value === "bigint")
        return value.toString();
      return value;
    }
    module2.exports = format2((info, opts) => {
      const jsonStringify = stringify.configure(opts);
      info[MESSAGE] = jsonStringify(info, opts.replacer || replacer, opts.space);
      return info;
    });
  }
});

// ../../node_modules/logform/label.js
var require_label = __commonJS({
  "../../node_modules/logform/label.js"(exports2, module2) {
    "use strict";
    var format2 = require_format2();
    module2.exports = format2((info, opts) => {
      if (opts.message) {
        info.message = `[${opts.label}] ${info.message}`;
        return info;
      }
      info.label = opts.label;
      return info;
    });
  }
});

// ../../node_modules/logform/logstash.js
var require_logstash = __commonJS({
  "../../node_modules/logform/logstash.js"(exports2, module2) {
    "use strict";
    var format2 = require_format2();
    var { MESSAGE } = require_triple_beam();
    var jsonStringify = require_safe_stable_stringify();
    module2.exports = format2((info) => {
      const logstash = {};
      if (info.message) {
        logstash["@message"] = info.message;
        delete info.message;
      }
      if (info.timestamp) {
        logstash["@timestamp"] = info.timestamp;
        delete info.timestamp;
      }
      logstash["@fields"] = info;
      info[MESSAGE] = jsonStringify(logstash);
      return info;
    });
  }
});

// ../../node_modules/logform/metadata.js
var require_metadata2 = __commonJS({
  "../../node_modules/logform/metadata.js"(exports2, module2) {
    "use strict";
    var format2 = require_format2();
    function fillExcept(info, fillExceptKeys, metadataKey) {
      const savedKeys = fillExceptKeys.reduce((acc, key) => {
        acc[key] = info[key];
        delete info[key];
        return acc;
      }, {});
      const metadata = Object.keys(info).reduce((acc, key) => {
        acc[key] = info[key];
        delete info[key];
        return acc;
      }, {});
      Object.assign(info, savedKeys, {
        [metadataKey]: metadata
      });
      return info;
    }
    function fillWith(info, fillWithKeys, metadataKey) {
      info[metadataKey] = fillWithKeys.reduce((acc, key) => {
        acc[key] = info[key];
        delete info[key];
        return acc;
      }, {});
      return info;
    }
    module2.exports = format2((info, opts = {}) => {
      let metadataKey = "metadata";
      if (opts.key) {
        metadataKey = opts.key;
      }
      let fillExceptKeys = [];
      if (!opts.fillExcept && !opts.fillWith) {
        fillExceptKeys.push("level");
        fillExceptKeys.push("message");
      }
      if (opts.fillExcept) {
        fillExceptKeys = opts.fillExcept;
      }
      if (fillExceptKeys.length > 0) {
        return fillExcept(info, fillExceptKeys, metadataKey);
      }
      if (opts.fillWith) {
        return fillWith(info, opts.fillWith, metadataKey);
      }
      return info;
    });
  }
});

// ../../node_modules/logform/ms.js
var require_ms2 = __commonJS({
  "../../node_modules/logform/ms.js"(exports2, module2) {
    "use strict";
    var format2 = require_format2();
    var ms = require_ms();
    module2.exports = format2((info) => {
      const curr = +new Date();
      exports2.diff = curr - (exports2.prevTime || curr);
      exports2.prevTime = curr;
      info.ms = `+${ms(exports2.diff)}`;
      return info;
    });
  }
});

// ../../node_modules/logform/pretty-print.js
var require_pretty_print = __commonJS({
  "../../node_modules/logform/pretty-print.js"(exports2, module2) {
    "use strict";
    var inspect = require("util").inspect;
    var format2 = require_format2();
    var { LEVEL, MESSAGE, SPLAT } = require_triple_beam();
    module2.exports = format2((info, opts = {}) => {
      const stripped = Object.assign({}, info);
      delete stripped[LEVEL];
      delete stripped[MESSAGE];
      delete stripped[SPLAT];
      info[MESSAGE] = inspect(stripped, false, opts.depth || null, opts.colorize);
      return info;
    });
  }
});

// ../../node_modules/logform/printf.js
var require_printf = __commonJS({
  "../../node_modules/logform/printf.js"(exports2, module2) {
    "use strict";
    var { MESSAGE } = require_triple_beam();
    var Printf = class {
      constructor(templateFn) {
        this.template = templateFn;
      }
      transform(info) {
        info[MESSAGE] = this.template(info);
        return info;
      }
    };
    module2.exports = (opts) => new Printf(opts);
    module2.exports.Printf = module2.exports.Format = Printf;
  }
});

// ../../node_modules/logform/simple.js
var require_simple = __commonJS({
  "../../node_modules/logform/simple.js"(exports2, module2) {
    "use strict";
    var format2 = require_format2();
    var { MESSAGE } = require_triple_beam();
    var jsonStringify = require_safe_stable_stringify();
    module2.exports = format2((info) => {
      const stringifiedRest = jsonStringify(Object.assign({}, info, {
        level: void 0,
        message: void 0,
        splat: void 0
      }));
      const padding = info.padding && info.padding[info.level] || "";
      if (stringifiedRest !== "{}") {
        info[MESSAGE] = `${info.level}:${padding} ${info.message} ${stringifiedRest}`;
      } else {
        info[MESSAGE] = `${info.level}:${padding} ${info.message}`;
      }
      return info;
    });
  }
});

// ../../node_modules/logform/splat.js
var require_splat = __commonJS({
  "../../node_modules/logform/splat.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var { SPLAT } = require_triple_beam();
    var formatRegExp = /%[scdjifoO%]/g;
    var escapedPercent = /%%/g;
    var Splatter = class {
      constructor(opts) {
        this.options = opts;
      }
      _splat(info, tokens) {
        const msg = info.message;
        const splat = info[SPLAT] || info.splat || [];
        const percents = msg.match(escapedPercent);
        const escapes = percents && percents.length || 0;
        const expectedSplat = tokens.length - escapes;
        const extraSplat = expectedSplat - splat.length;
        const metas = extraSplat < 0 ? splat.splice(extraSplat, -1 * extraSplat) : [];
        const metalen = metas.length;
        if (metalen) {
          for (let i = 0; i < metalen; i++) {
            Object.assign(info, metas[i]);
          }
        }
        info.message = util.format(msg, ...splat);
        return info;
      }
      transform(info) {
        const msg = info.message;
        const splat = info[SPLAT] || info.splat;
        if (!splat || !splat.length) {
          return info;
        }
        const tokens = msg && msg.match && msg.match(formatRegExp);
        if (!tokens && (splat || splat.length)) {
          const metas = splat.length > 1 ? splat.splice(0) : splat;
          const metalen = metas.length;
          if (metalen) {
            for (let i = 0; i < metalen; i++) {
              Object.assign(info, metas[i]);
            }
          }
          return info;
        }
        if (tokens) {
          return this._splat(info, tokens);
        }
        return info;
      }
    };
    module2.exports = (opts) => new Splatter(opts);
  }
});

// ../../node_modules/fecha/lib/fecha.js
var fecha_exports = {};
__export(fecha_exports, {
  assign: () => assign,
  default: () => fecha_default,
  defaultI18n: () => defaultI18n,
  format: () => format,
  parse: () => parse,
  setGlobalDateI18n: () => setGlobalDateI18n,
  setGlobalDateMasks: () => setGlobalDateMasks
});
function shorten(arr, sLen) {
  var newArr = [];
  for (var i = 0, len = arr.length; i < len; i++) {
    newArr.push(arr[i].substr(0, sLen));
  }
  return newArr;
}
function assign(origObj) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  for (var _a2 = 0, args_1 = args; _a2 < args_1.length; _a2++) {
    var obj = args_1[_a2];
    for (var key in obj) {
      origObj[key] = obj[key];
    }
  }
  return origObj;
}
function parse(dateStr, format2, i18n) {
  if (i18n === void 0) {
    i18n = {};
  }
  if (typeof format2 !== "string") {
    throw new Error("Invalid format in fecha parse");
  }
  format2 = globalMasks[format2] || format2;
  if (dateStr.length > 1e3) {
    return null;
  }
  var today = new Date();
  var dateInfo = {
    year: today.getFullYear(),
    month: 0,
    day: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0,
    isPm: null,
    timezoneOffset: null
  };
  var parseInfo = [];
  var literals = [];
  var newFormat = format2.replace(literal, function($0, $1) {
    literals.push(regexEscape3($1));
    return "@@@";
  });
  var specifiedFields = {};
  var requiredFields = {};
  newFormat = regexEscape3(newFormat).replace(token, function($0) {
    var info = parseFlags[$0];
    var field2 = info[0], regex = info[1], requiredField = info[3];
    if (specifiedFields[field2]) {
      throw new Error("Invalid format. " + field2 + " specified twice in format");
    }
    specifiedFields[field2] = true;
    if (requiredField) {
      requiredFields[requiredField] = true;
    }
    parseInfo.push(info);
    return "(" + regex + ")";
  });
  Object.keys(requiredFields).forEach(function(field2) {
    if (!specifiedFields[field2]) {
      throw new Error("Invalid format. " + field2 + " is required in specified format");
    }
  });
  newFormat = newFormat.replace(/@@@/g, function() {
    return literals.shift();
  });
  var matches = dateStr.match(new RegExp(newFormat, "i"));
  if (!matches) {
    return null;
  }
  var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
  for (var i = 1; i < matches.length; i++) {
    var _a2 = parseInfo[i - 1], field = _a2[0], parser = _a2[2];
    var value = parser ? parser(matches[i], combinedI18nSettings) : +matches[i];
    if (value == null) {
      return null;
    }
    dateInfo[field] = value;
  }
  if (dateInfo.isPm === 1 && dateInfo.hour != null && +dateInfo.hour !== 12) {
    dateInfo.hour = +dateInfo.hour + 12;
  } else if (dateInfo.isPm === 0 && +dateInfo.hour === 12) {
    dateInfo.hour = 0;
  }
  var dateWithoutTZ = new Date(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute, dateInfo.second, dateInfo.millisecond);
  var validateFields = [
    ["month", "getMonth"],
    ["day", "getDate"],
    ["hour", "getHours"],
    ["minute", "getMinutes"],
    ["second", "getSeconds"]
  ];
  for (var i = 0, len = validateFields.length; i < len; i++) {
    if (specifiedFields[validateFields[i][0]] && dateInfo[validateFields[i][0]] !== dateWithoutTZ[validateFields[i][1]]()) {
      return null;
    }
  }
  if (dateInfo.timezoneOffset == null) {
    return dateWithoutTZ;
  }
  return new Date(Date.UTC(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute - dateInfo.timezoneOffset, dateInfo.second, dateInfo.millisecond));
}
var token, twoDigitsOptional, twoDigits, threeDigits, fourDigits, word, literal, monthUpdate, dayNames, monthNames, monthNamesShort, dayNamesShort, defaultI18n, globalI18n, setGlobalDateI18n, regexEscape3, pad, formatFlags, monthParse, emptyDigits, emptyWord, amPm, timezoneOffset, parseFlags, globalMasks, setGlobalDateMasks, format, fecha, fecha_default;
var init_fecha = __esm({
  "../../node_modules/fecha/lib/fecha.js"() {
    token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
    twoDigitsOptional = "[1-9]\\d?";
    twoDigits = "\\d\\d";
    threeDigits = "\\d{3}";
    fourDigits = "\\d{4}";
    word = "[^\\s]+";
    literal = /\[([^]*?)\]/gm;
    monthUpdate = function(arrName) {
      return function(v, i18n) {
        var lowerCaseArr = i18n[arrName].map(function(v2) {
          return v2.toLowerCase();
        });
        var index = lowerCaseArr.indexOf(v.toLowerCase());
        if (index > -1) {
          return index;
        }
        return null;
      };
    };
    dayNames = [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday"
    ];
    monthNames = [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ];
    monthNamesShort = shorten(monthNames, 3);
    dayNamesShort = shorten(dayNames, 3);
    defaultI18n = {
      dayNamesShort,
      dayNames,
      monthNamesShort,
      monthNames,
      amPm: ["am", "pm"],
      DoFn: function(dayOfMonth) {
        return dayOfMonth + ["th", "st", "nd", "rd"][dayOfMonth % 10 > 3 ? 0 : (dayOfMonth - dayOfMonth % 10 !== 10 ? 1 : 0) * dayOfMonth % 10];
      }
    };
    globalI18n = assign({}, defaultI18n);
    setGlobalDateI18n = function(i18n) {
      return globalI18n = assign(globalI18n, i18n);
    };
    regexEscape3 = function(str) {
      return str.replace(/[|\\{()[^$+*?.-]/g, "\\$&");
    };
    pad = function(val, len) {
      if (len === void 0) {
        len = 2;
      }
      val = String(val);
      while (val.length < len) {
        val = "0" + val;
      }
      return val;
    };
    formatFlags = {
      D: function(dateObj) {
        return String(dateObj.getDate());
      },
      DD: function(dateObj) {
        return pad(dateObj.getDate());
      },
      Do: function(dateObj, i18n) {
        return i18n.DoFn(dateObj.getDate());
      },
      d: function(dateObj) {
        return String(dateObj.getDay());
      },
      dd: function(dateObj) {
        return pad(dateObj.getDay());
      },
      ddd: function(dateObj, i18n) {
        return i18n.dayNamesShort[dateObj.getDay()];
      },
      dddd: function(dateObj, i18n) {
        return i18n.dayNames[dateObj.getDay()];
      },
      M: function(dateObj) {
        return String(dateObj.getMonth() + 1);
      },
      MM: function(dateObj) {
        return pad(dateObj.getMonth() + 1);
      },
      MMM: function(dateObj, i18n) {
        return i18n.monthNamesShort[dateObj.getMonth()];
      },
      MMMM: function(dateObj, i18n) {
        return i18n.monthNames[dateObj.getMonth()];
      },
      YY: function(dateObj) {
        return pad(String(dateObj.getFullYear()), 4).substr(2);
      },
      YYYY: function(dateObj) {
        return pad(dateObj.getFullYear(), 4);
      },
      h: function(dateObj) {
        return String(dateObj.getHours() % 12 || 12);
      },
      hh: function(dateObj) {
        return pad(dateObj.getHours() % 12 || 12);
      },
      H: function(dateObj) {
        return String(dateObj.getHours());
      },
      HH: function(dateObj) {
        return pad(dateObj.getHours());
      },
      m: function(dateObj) {
        return String(dateObj.getMinutes());
      },
      mm: function(dateObj) {
        return pad(dateObj.getMinutes());
      },
      s: function(dateObj) {
        return String(dateObj.getSeconds());
      },
      ss: function(dateObj) {
        return pad(dateObj.getSeconds());
      },
      S: function(dateObj) {
        return String(Math.round(dateObj.getMilliseconds() / 100));
      },
      SS: function(dateObj) {
        return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
      },
      SSS: function(dateObj) {
        return pad(dateObj.getMilliseconds(), 3);
      },
      a: function(dateObj, i18n) {
        return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
      },
      A: function(dateObj, i18n) {
        return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
      },
      ZZ: function(dateObj) {
        var offset = dateObj.getTimezoneOffset();
        return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60) * 100 + Math.abs(offset) % 60, 4);
      },
      Z: function(dateObj) {
        var offset = dateObj.getTimezoneOffset();
        return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60), 2) + ":" + pad(Math.abs(offset) % 60, 2);
      }
    };
    monthParse = function(v) {
      return +v - 1;
    };
    emptyDigits = [null, twoDigitsOptional];
    emptyWord = [null, word];
    amPm = [
      "isPm",
      word,
      function(v, i18n) {
        var val = v.toLowerCase();
        if (val === i18n.amPm[0]) {
          return 0;
        } else if (val === i18n.amPm[1]) {
          return 1;
        }
        return null;
      }
    ];
    timezoneOffset = [
      "timezoneOffset",
      "[^\\s]*?[\\+\\-]\\d\\d:?\\d\\d|[^\\s]*?Z?",
      function(v) {
        var parts = (v + "").match(/([+-]|\d\d)/gi);
        if (parts) {
          var minutes = +parts[1] * 60 + parseInt(parts[2], 10);
          return parts[0] === "+" ? minutes : -minutes;
        }
        return 0;
      }
    ];
    parseFlags = {
      D: ["day", twoDigitsOptional],
      DD: ["day", twoDigits],
      Do: ["day", twoDigitsOptional + word, function(v) {
        return parseInt(v, 10);
      }],
      M: ["month", twoDigitsOptional, monthParse],
      MM: ["month", twoDigits, monthParse],
      YY: [
        "year",
        twoDigits,
        function(v) {
          var now = new Date();
          var cent = +("" + now.getFullYear()).substr(0, 2);
          return +("" + (+v > 68 ? cent - 1 : cent) + v);
        }
      ],
      h: ["hour", twoDigitsOptional, void 0, "isPm"],
      hh: ["hour", twoDigits, void 0, "isPm"],
      H: ["hour", twoDigitsOptional],
      HH: ["hour", twoDigits],
      m: ["minute", twoDigitsOptional],
      mm: ["minute", twoDigits],
      s: ["second", twoDigitsOptional],
      ss: ["second", twoDigits],
      YYYY: ["year", fourDigits],
      S: ["millisecond", "\\d", function(v) {
        return +v * 100;
      }],
      SS: ["millisecond", twoDigits, function(v) {
        return +v * 10;
      }],
      SSS: ["millisecond", threeDigits],
      d: emptyDigits,
      dd: emptyDigits,
      ddd: emptyWord,
      dddd: emptyWord,
      MMM: ["month", word, monthUpdate("monthNamesShort")],
      MMMM: ["month", word, monthUpdate("monthNames")],
      a: amPm,
      A: amPm,
      ZZ: timezoneOffset,
      Z: timezoneOffset
    };
    globalMasks = {
      default: "ddd MMM DD YYYY HH:mm:ss",
      shortDate: "M/D/YY",
      mediumDate: "MMM D, YYYY",
      longDate: "MMMM D, YYYY",
      fullDate: "dddd, MMMM D, YYYY",
      isoDate: "YYYY-MM-DD",
      isoDateTime: "YYYY-MM-DDTHH:mm:ssZ",
      shortTime: "HH:mm",
      mediumTime: "HH:mm:ss",
      longTime: "HH:mm:ss.SSS"
    };
    setGlobalDateMasks = function(masks) {
      return assign(globalMasks, masks);
    };
    format = function(dateObj, mask, i18n) {
      if (mask === void 0) {
        mask = globalMasks["default"];
      }
      if (i18n === void 0) {
        i18n = {};
      }
      if (typeof dateObj === "number") {
        dateObj = new Date(dateObj);
      }
      if (Object.prototype.toString.call(dateObj) !== "[object Date]" || isNaN(dateObj.getTime())) {
        throw new Error("Invalid Date pass to format");
      }
      mask = globalMasks[mask] || mask;
      var literals = [];
      mask = mask.replace(literal, function($0, $1) {
        literals.push($1);
        return "@@@";
      });
      var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
      mask = mask.replace(token, function($0) {
        return formatFlags[$0](dateObj, combinedI18nSettings);
      });
      return mask.replace(/@@@/g, function() {
        return literals.shift();
      });
    };
    fecha = {
      format,
      parse,
      defaultI18n,
      setGlobalDateI18n,
      setGlobalDateMasks
    };
    fecha_default = fecha;
  }
});

// ../../node_modules/logform/timestamp.js
var require_timestamp2 = __commonJS({
  "../../node_modules/logform/timestamp.js"(exports2, module2) {
    "use strict";
    var fecha2 = (init_fecha(), __toCommonJS(fecha_exports));
    var format2 = require_format2();
    module2.exports = format2((info, opts = {}) => {
      if (opts.format) {
        info.timestamp = typeof opts.format === "function" ? opts.format() : fecha2.format(new Date(), opts.format);
      }
      if (!info.timestamp) {
        info.timestamp = new Date().toISOString();
      }
      if (opts.alias) {
        info[opts.alias] = info.timestamp;
      }
      return info;
    });
  }
});

// ../../node_modules/logform/uncolorize.js
var require_uncolorize = __commonJS({
  "../../node_modules/logform/uncolorize.js"(exports2, module2) {
    "use strict";
    var colors = require_safe();
    var format2 = require_format2();
    var { MESSAGE } = require_triple_beam();
    module2.exports = format2((info, opts) => {
      if (opts.level !== false) {
        info.level = colors.strip(info.level);
      }
      if (opts.message !== false) {
        info.message = colors.strip(info.message);
      }
      if (opts.raw !== false && info[MESSAGE]) {
        info[MESSAGE] = colors.strip(info[MESSAGE]);
      }
      return info;
    });
  }
});

// ../../node_modules/logform/index.js
var require_logform = __commonJS({
  "../../node_modules/logform/index.js"(exports2) {
    "use strict";
    var format2 = exports2.format = require_format2();
    exports2.levels = require_levels();
    function exposeFormat(name, requireFormat) {
      Object.defineProperty(format2, name, {
        get() {
          return requireFormat();
        },
        configurable: true
      });
    }
    exposeFormat("align", function() {
      return require_align();
    });
    exposeFormat("errors", function() {
      return require_errors2();
    });
    exposeFormat("cli", function() {
      return require_cli3();
    });
    exposeFormat("combine", function() {
      return require_combine();
    });
    exposeFormat("colorize", function() {
      return require_colorize();
    });
    exposeFormat("json", function() {
      return require_json();
    });
    exposeFormat("label", function() {
      return require_label();
    });
    exposeFormat("logstash", function() {
      return require_logstash();
    });
    exposeFormat("metadata", function() {
      return require_metadata2();
    });
    exposeFormat("ms", function() {
      return require_ms2();
    });
    exposeFormat("padLevels", function() {
      return require_pad_levels();
    });
    exposeFormat("prettyPrint", function() {
      return require_pretty_print();
    });
    exposeFormat("printf", function() {
      return require_printf();
    });
    exposeFormat("simple", function() {
      return require_simple();
    });
    exposeFormat("splat", function() {
      return require_splat();
    });
    exposeFormat("timestamp", function() {
      return require_timestamp2();
    });
    exposeFormat("uncolorize", function() {
      return require_uncolorize();
    });
  }
});

// ../../node_modules/winston/lib/winston/common.js
var require_common6 = __commonJS({
  "../../node_modules/winston/lib/winston/common.js"(exports2) {
    "use strict";
    var { format: format2 } = require("util");
    exports2.warn = {
      deprecated(prop) {
        return () => {
          throw new Error(format2("{ %s } was removed in winston@3.0.0.", prop));
        };
      },
      useFormat(prop) {
        return () => {
          throw new Error([
            format2("{ %s } was removed in winston@3.0.0.", prop),
            "Use a custom winston.format = winston.format(function) instead."
          ].join("\n"));
        };
      },
      forFunctions(obj, type, props) {
        props.forEach((prop) => {
          obj[prop] = exports2.warn[type](prop);
        });
      },
      moved(obj, movedTo, prop) {
        function movedNotice() {
          return () => {
            throw new Error([
              format2("winston.%s was moved in winston@3.0.0.", prop),
              format2("Use a winston.%s instead.", movedTo)
            ].join("\n"));
          };
        }
        Object.defineProperty(obj, prop, {
          get: movedNotice,
          set: movedNotice
        });
      },
      forProperties(obj, type, props) {
        props.forEach((prop) => {
          const notice = exports2.warn[type](prop);
          Object.defineProperty(obj, prop, {
            get: notice,
            set: notice
          });
        });
      }
    };
  }
});

// ../../node_modules/winston/package.json
var require_package6 = __commonJS({
  "../../node_modules/winston/package.json"(exports2, module2) {
    module2.exports = {
      name: "winston",
      description: "A logger for just about everything.",
      version: "3.3.3",
      author: "Charlie Robbins <charlie.robbins@gmail.com>",
      maintainers: [
        "Jarrett Cruger <jcrugzz@gmail.com>",
        "Chris Alderson <chrisalderson@protonmail.com>",
        "David Hyde <dabh@stanford.edu>"
      ],
      repository: {
        type: "git",
        url: "https://github.com/winstonjs/winston.git"
      },
      keywords: [
        "winston",
        "logger",
        "logging",
        "logs",
        "sysadmin",
        "bunyan",
        "pino",
        "loglevel",
        "tools",
        "json",
        "stream"
      ],
      dependencies: {
        async: "^3.1.0",
        "@dabh/diagnostics": "^2.0.2",
        "is-stream": "^2.0.0",
        logform: "^2.2.0",
        "one-time": "^1.0.0",
        "readable-stream": "^3.4.0",
        "stack-trace": "0.0.x",
        "triple-beam": "^1.3.0",
        "winston-transport": "^4.4.0"
      },
      devDependencies: {
        "@babel/cli": "^7.10.3",
        "@babel/core": "^7.10.3",
        "@babel/preset-env": "^7.10.3",
        "@types/node": "^14.0.13",
        "abstract-winston-transport": "^0.5.1",
        assume: "^2.2.0",
        colors: "^1.4.0",
        "cross-spawn-async": "^2.2.5",
        "eslint-config-populist": "^4.2.0",
        hock: "^1.4.1",
        mocha: "^8.0.1",
        nyc: "^15.1.0",
        rimraf: "^3.0.2",
        split2: "^3.1.1",
        "std-mocks": "^1.0.1",
        through2: "^3.0.1",
        "winston-compat": "^0.1.5"
      },
      main: "./lib/winston",
      browser: "./dist/winston",
      types: "./index.d.ts",
      scripts: {
        lint: "populist lib/*.js lib/winston/*.js lib/winston/**/*.js",
        pretest: "npm run lint",
        test: "nyc --reporter=text --reporter lcov npm run test:mocha",
        "test:mocha": "mocha test/*.test.js test/**/*.test.js --exit",
        build: "./node_modules/.bin/rimraf dist && babel lib -d dist",
        prepublishOnly: "npm run build"
      },
      engines: {
        node: ">= 6.4.0"
      },
      license: "MIT"
    };
  }
});

// ../../node_modules/process-nextick-args/index.js
var require_process_nextick_args = __commonJS({
  "../../node_modules/process-nextick-args/index.js"(exports2, module2) {
    "use strict";
    if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
      module2.exports = { nextTick };
    } else {
      module2.exports = process;
    }
    function nextTick(fn, arg1, arg2, arg3) {
      if (typeof fn !== "function") {
        throw new TypeError('"callback" argument must be a function');
      }
      var len = arguments.length;
      var args, i;
      switch (len) {
        case 0:
        case 1:
          return process.nextTick(fn);
        case 2:
          return process.nextTick(function afterTickOne() {
            fn.call(null, arg1);
          });
        case 3:
          return process.nextTick(function afterTickTwo() {
            fn.call(null, arg1, arg2);
          });
        case 4:
          return process.nextTick(function afterTickThree() {
            fn.call(null, arg1, arg2, arg3);
          });
        default:
          args = new Array(len - 1);
          i = 0;
          while (i < args.length) {
            args[i++] = arguments[i];
          }
          return process.nextTick(function afterTick() {
            fn.apply(null, args);
          });
      }
    }
  }
});

// ../../node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "../../node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// ../../node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "../../node_modules/inherits/inherits.js"(exports2, module2) {
    try {
      util = require("util");
      if (typeof util.inherits !== "function")
        throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// ../../node_modules/util-deprecate/node.js
var require_node3 = __commonJS({
  "../../node_modules/util-deprecate/node.js"(exports2, module2) {
    module2.exports = require("util").deprecate;
  }
});

// ../../node_modules/winston/node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream = __commonJS({
  "../../node_modules/winston/node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    module2.exports = require("stream");
  }
});

// ../../node_modules/winston/node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "../../node_modules/winston/node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// ../../node_modules/winston/node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "../../node_modules/winston/node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
          pna.nextTick(emitErrorNT, this, err);
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          pna.nextTick(emitErrorNT, _this, err2);
          if (_this._writableState) {
            _this._writableState.errorEmitted = true;
          }
        } else if (cb) {
          cb(err2);
        }
      });
      return this;
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy
    };
  }
});

// ../../node_modules/winston/node_modules/isarray/index.js
var require_isarray = __commonJS({
  "../../node_modules/winston/node_modules/isarray/index.js"(exports2, module2) {
    var toString = {}.toString;
    module2.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// ../../node_modules/winston/node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList = __commonJS({
  "../../node_modules/winston/node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/BufferList.js"(exports2, module2) {
    "use strict";
    function _classCallCheck2(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = require_safe_buffer().Buffer;
    var util = require("util");
    function copyBuffer(src, target, offset) {
      src.copy(target, offset);
    }
    module2.exports = function() {
      function BufferList() {
        _classCallCheck2(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList.prototype.push = function push(v) {
        var entry = { data: v, next: null };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList.prototype.unshift = function unshift(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList.prototype.shift = function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList.prototype.join = function join2(s) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      };
      BufferList.prototype.concat = function concat(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        if (this.length === 1)
          return this.head.data;
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };
      return BufferList;
    }();
    if (util && util.inspect && util.inspect.custom) {
      module2.exports.prototype[util.inspect.custom] = function() {
        var obj = util.inspect({ length: this.length });
        return this.constructor.name + " " + obj;
      };
    }
  }
});

// ../../node_modules/winston/node_modules/winston-transport/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "../../node_modules/winston/node_modules/winston-transport/node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// ../../node_modules/winston/node_modules/winston-transport/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "../../node_modules/winston/node_modules/winston-transport/node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Readable;
    var isArray = require_isarray();
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream();
    var Buffer2 = require_safe_buffer().Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var util = Object.create(require_util2());
    util.inherits = require_inherits();
    var debugUtil = require("util");
    var debug = void 0;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function() {
      };
    }
    var BufferList = require_BufferList();
    var destroyImpl = require_destroy();
    var StringDecoder;
    util.inherits(Readable, Stream);
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options2, stream) {
      Duplex = Duplex || require_stream_duplex();
      options2 = options2 || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options2.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options2.readableObjectMode;
      var hwm = options2.highWaterMark;
      var readableHwm = options2.readableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (readableHwm || readableHwm === 0))
        this.highWaterMark = readableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.destroyed = false;
      this.defaultEncoding = options2.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options2.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options2.encoding);
        this.encoding = options2.encoding;
      }
    }
    function Readable(options2) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable))
        return new Readable(options2);
      this._readableState = new ReadableState(options2, this);
      this.readable = true;
      if (options2) {
        if (typeof options2.read === "function")
          this._read = options2.read;
        if (typeof options2.destroy === "function")
          this._destroy = options2.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      this.push(null);
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          stream.emit("error", er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              stream.emit("error", new Error("stream.unshift() after end event"));
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            stream.emit("error", new Error("stream.push() after EOF"));
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
        }
      }
      return needMoreData(state);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit("data", chunk);
        stream.read(0);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      return er;
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 8388608;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      emitReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        if (state.sync)
          pna.nextTick(emitReadable_, stream);
        else
          emitReadable_(stream);
      }
    }
    function emitReadable_(stream) {
      debug("emit readable");
      stream.emit("readable");
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        pna.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      this.emit("error", new Error("_read() is not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        pna.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      var increasedAwaitDrain = false;
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (false === ret && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", src._readableState.awaitDrain);
            src._readableState.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          dest.emit("error", er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = { hasUnpiped: false };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) {
          dests[i].emit("unpipe", this, unpipeInfo);
        }
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            pna.nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        pna.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      if (!state.reading) {
        debug("resume read 0");
        stream.read(0);
      }
      state.resumeScheduled = false;
      state.awaitDrain = 0;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
      }
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      enumerable: false,
      get: function() {
        return this._readableState.highWaterMark;
      }
    });
    Readable._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.head.data;
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = fromListPartial(n, state.buffer, state.decoder);
      }
      return ret;
    }
    function fromListPartial(n, list, hasStrings) {
      var ret;
      if (n < list.head.data.length) {
        ret = list.head.data.slice(0, n);
        list.head.data = list.head.data.slice(n);
      } else if (n === list.head.data.length) {
        ret = list.shift();
      } else {
        ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
      }
      return ret;
    }
    function copyFromBufferString(n, list) {
      var p = list.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length)
          ret += str;
        else
          ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function copyFromBuffer(n, list) {
      var ret = Buffer2.allocUnsafe(n);
      var p = list.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0)
        throw new Error('"endReadable()" called on non-empty stream');
      if (!state.endEmitted) {
        state.ended = true;
        pna.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
      }
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// ../../node_modules/winston/node_modules/winston-transport/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "../../node_modules/winston/node_modules/winston-transport/node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) {
        keys2.push(key);
      }
      return keys2;
    };
    module2.exports = Duplex;
    var util = Object.create(require_util2());
    util.inherits = require_inherits();
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    util.inherits(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options2) {
      if (!(this instanceof Duplex))
        return new Duplex(options2);
      Readable.call(this, options2);
      Writable.call(this, options2);
      if (options2 && options2.readable === false)
        this.readable = false;
      if (options2 && options2.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options2 && options2.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once("end", onend);
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return;
      pna.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
    Duplex.prototype._destroy = function(err, cb) {
      this.push(null);
      this.end();
      pna.nextTick(cb, err);
    };
  }
});

// ../../node_modules/winston/node_modules/winston-transport/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "../../node_modules/winston/node_modules/winston-transport/node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
    var Duplex;
    Writable.WritableState = WritableState;
    var util = Object.create(require_util2());
    util.inherits = require_inherits();
    var internalUtil = {
      deprecate: require_node3()
    };
    var Stream = require_stream();
    var Buffer2 = require_safe_buffer().Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    util.inherits(Writable, Stream);
    function nop() {
    }
    function WritableState(options2, stream) {
      Duplex = Duplex || require_stream_duplex();
      options2 = options2 || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options2.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options2.writableObjectMode;
      var hwm = options2.highWaterMark;
      var writableHwm = options2.writableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (writableHwm || writableHwm === 0))
        this.highWaterMark = writableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options2.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options2.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_45) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function(object) {
        return object instanceof this;
      };
    }
    function Writable(options2) {
      Duplex = Duplex || require_stream_duplex();
      if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
        return new Writable(options2);
      }
      this._writableState = new WritableState(options2, this);
      this.writable = true;
      if (options2) {
        if (typeof options2.write === "function")
          this._write = options2.write;
        if (typeof options2.writev === "function")
          this._writev = options2.writev;
        if (typeof options2.destroy === "function")
          this._destroy = options2.destroy;
        if (typeof options2.final === "function")
          this._final = options2.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    function writeAfterEnd(stream, cb) {
      var er = new Error("write after end");
      stream.emit("error", er);
      pna.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      var er = false;
      if (chunk === null) {
        er = new TypeError("May not write null values to stream");
      } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      if (er) {
        stream.emit("error", er);
        pna.nextTick(cb, er);
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ended)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        pna.nextTick(cb, er);
        pna.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state);
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          asyncWrite(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("_write() is not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          stream.emit("error", err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function") {
          state.pendingcb++;
          state.finalCalled = true;
          pna.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          pna.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      if (state.corkedRequestsFree) {
        state.corkedRequestsFree.next = corkReq;
      } else {
        state.corkedRequestsFree = corkReq;
      }
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      get: function() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      this.end();
      cb(err);
    };
  }
});

// ../../node_modules/winston/node_modules/winston-transport/node_modules/readable-stream/writable.js
var require_writable = __commonJS({
  "../../node_modules/winston/node_modules/winston-transport/node_modules/readable-stream/writable.js"(exports2, module2) {
    var Stream = require("stream");
    var Writable = require_stream_writable();
    if (process.env.READABLE_STREAM === "disable") {
      module2.exports = Stream && Stream.Writable || Writable;
    } else {
      module2.exports = Writable;
    }
  }
});

// ../../node_modules/winston/node_modules/winston-transport/legacy.js
var require_legacy = __commonJS({
  "../../node_modules/winston/node_modules/winston-transport/legacy.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var { LEVEL } = require_triple_beam();
    var TransportStream = require_winston_transport();
    var LegacyTransportStream = module2.exports = function LegacyTransportStream2(options2 = {}) {
      TransportStream.call(this, options2);
      if (!options2.transport || typeof options2.transport.log !== "function") {
        throw new Error("Invalid transport, must be an object with a log method.");
      }
      this.transport = options2.transport;
      this.level = this.level || options2.transport.level;
      this.handleExceptions = this.handleExceptions || options2.transport.handleExceptions;
      this._deprecated();
      function transportError(err) {
        this.emit("error", err, this.transport);
      }
      if (!this.transport.__winstonError) {
        this.transport.__winstonError = transportError.bind(this);
        this.transport.on("error", this.transport.__winstonError);
      }
    };
    util.inherits(LegacyTransportStream, TransportStream);
    LegacyTransportStream.prototype._write = function _write(info, enc, callback) {
      if (this.silent || info.exception === true && !this.handleExceptions) {
        return callback(null);
      }
      if (!this.level || this.levels[this.level] >= this.levels[info[LEVEL]]) {
        this.transport.log(info[LEVEL], info.message, info, this._nop);
      }
      callback(null);
    };
    LegacyTransportStream.prototype._writev = function _writev(chunks, callback) {
      for (let i = 0; i < chunks.length; i++) {
        if (this._accept(chunks[i])) {
          this.transport.log(chunks[i].chunk[LEVEL], chunks[i].chunk.message, chunks[i].chunk, this._nop);
          chunks[i].callback();
        }
      }
      return callback(null);
    };
    LegacyTransportStream.prototype._deprecated = function _deprecated() {
      console.error([
        `${this.transport.name} is a legacy winston transport. Consider upgrading: `,
        "- Upgrade docs: https://github.com/winstonjs/winston/blob/master/UPGRADE-3.0.md"
      ].join("\n"));
    };
    LegacyTransportStream.prototype.close = function close() {
      if (this.transport.close) {
        this.transport.close();
      }
      if (this.transport.__winstonError) {
        this.transport.removeListener("error", this.transport.__winstonError);
        this.transport.__winstonError = null;
      }
    };
  }
});

// ../../node_modules/winston/node_modules/winston-transport/index.js
var require_winston_transport = __commonJS({
  "../../node_modules/winston/node_modules/winston-transport/index.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var Writable = require_writable();
    var { LEVEL } = require_triple_beam();
    var TransportStream = module2.exports = function TransportStream2(options2 = {}) {
      Writable.call(this, { objectMode: true, highWaterMark: options2.highWaterMark });
      this.format = options2.format;
      this.level = options2.level;
      this.handleExceptions = options2.handleExceptions;
      this.handleRejections = options2.handleRejections;
      this.silent = options2.silent;
      if (options2.log)
        this.log = options2.log;
      if (options2.logv)
        this.logv = options2.logv;
      if (options2.close)
        this.close = options2.close;
      this.once("pipe", (logger) => {
        this.levels = logger.levels;
        this.parent = logger;
      });
      this.once("unpipe", (src) => {
        if (src === this.parent) {
          this.parent = null;
          if (this.close) {
            this.close();
          }
        }
      });
    };
    util.inherits(TransportStream, Writable);
    TransportStream.prototype._write = function _write(info, enc, callback) {
      if (this.silent || info.exception === true && !this.handleExceptions) {
        return callback(null);
      }
      const level = this.level || this.parent && this.parent.level;
      if (!level || this.levels[level] >= this.levels[info[LEVEL]]) {
        if (info && !this.format) {
          return this.log(info, callback);
        }
        let errState;
        let transformed;
        try {
          transformed = this.format.transform(Object.assign({}, info), this.format.options);
        } catch (err) {
          errState = err;
        }
        if (errState || !transformed) {
          callback();
          if (errState)
            throw errState;
          return;
        }
        return this.log(transformed, callback);
      }
      return callback(null);
    };
    TransportStream.prototype._writev = function _writev(chunks, callback) {
      if (this.logv) {
        const infos = chunks.filter(this._accept, this);
        if (!infos.length) {
          return callback(null);
        }
        return this.logv(infos, callback);
      }
      for (let i = 0; i < chunks.length; i++) {
        if (!this._accept(chunks[i]))
          continue;
        if (chunks[i].chunk && !this.format) {
          this.log(chunks[i].chunk, chunks[i].callback);
          continue;
        }
        let errState;
        let transformed;
        try {
          transformed = this.format.transform(Object.assign({}, chunks[i].chunk), this.format.options);
        } catch (err) {
          errState = err;
        }
        if (errState || !transformed) {
          chunks[i].callback();
          if (errState) {
            callback(null);
            throw errState;
          }
        } else {
          this.log(transformed, chunks[i].callback);
        }
      }
      return callback(null);
    };
    TransportStream.prototype._accept = function _accept(write) {
      const info = write.chunk;
      if (this.silent) {
        return false;
      }
      const level = this.level || this.parent && this.parent.level;
      if (info.exception === true || !level || this.levels[level] >= this.levels[info[LEVEL]]) {
        if (this.handleExceptions || info.exception !== true) {
          return true;
        }
      }
      return false;
    };
    TransportStream.prototype._nop = function _nop() {
      return void 0;
    };
    module2.exports.LegacyTransportStream = require_legacy();
  }
});

// ../../node_modules/winston/lib/winston/transports/console.js
var require_console = __commonJS({
  "../../node_modules/winston/lib/winston/transports/console.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var { LEVEL, MESSAGE } = require_triple_beam();
    var TransportStream = require_winston_transport();
    module2.exports = class Console extends TransportStream {
      constructor(options2 = {}) {
        super(options2);
        this.name = options2.name || "console";
        this.stderrLevels = this._stringArrayToSet(options2.stderrLevels);
        this.consoleWarnLevels = this._stringArrayToSet(options2.consoleWarnLevels);
        this.eol = options2.eol || os.EOL;
        this.setMaxListeners(30);
      }
      log(info, callback) {
        setImmediate(() => this.emit("logged", info));
        if (this.stderrLevels[info[LEVEL]]) {
          if (console._stderr) {
            console._stderr.write(`${info[MESSAGE]}${this.eol}`);
          } else {
            console.error(info[MESSAGE]);
          }
          if (callback) {
            callback();
          }
          return;
        } else if (this.consoleWarnLevels[info[LEVEL]]) {
          if (console._stderr) {
            console._stderr.write(`${info[MESSAGE]}${this.eol}`);
          } else {
            console.warn(info[MESSAGE]);
          }
          if (callback) {
            callback();
          }
          return;
        }
        if (console._stdout) {
          console._stdout.write(`${info[MESSAGE]}${this.eol}`);
        } else {
          console.log(info[MESSAGE]);
        }
        if (callback) {
          callback();
        }
      }
      _stringArrayToSet(strArray, errMsg) {
        if (!strArray)
          return {};
        errMsg = errMsg || "Cannot make set from type other than Array of string elements";
        if (!Array.isArray(strArray)) {
          throw new Error(errMsg);
        }
        return strArray.reduce((set, el) => {
          if (typeof el !== "string") {
            throw new Error(errMsg);
          }
          set[el] = true;
          return set;
        }, {});
      }
    };
  }
});

// ../../node_modules/winston/node_modules/async/internal/isArrayLike.js
var require_isArrayLike2 = __commonJS({
  "../../node_modules/winston/node_modules/async/internal/isArrayLike.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isArrayLike;
    function isArrayLike(value) {
      return value && typeof value.length === "number" && value.length >= 0 && value.length % 1 === 0;
    }
    module2.exports = exports2["default"];
  }
});

// ../../node_modules/winston/node_modules/async/internal/initialParams.js
var require_initialParams = __commonJS({
  "../../node_modules/winston/node_modules/async/internal/initialParams.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = function(fn) {
      return function(...args) {
        var callback = args.pop();
        return fn.call(this, args, callback);
      };
    };
    module2.exports = exports2["default"];
  }
});

// ../../node_modules/winston/node_modules/async/internal/setImmediate.js
var require_setImmediate = __commonJS({
  "../../node_modules/winston/node_modules/async/internal/setImmediate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.fallback = fallback;
    exports2.wrap = wrap;
    var hasQueueMicrotask = exports2.hasQueueMicrotask = typeof queueMicrotask === "function" && queueMicrotask;
    var hasSetImmediate = exports2.hasSetImmediate = typeof setImmediate === "function" && setImmediate;
    var hasNextTick = exports2.hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
    function fallback(fn) {
      setTimeout(fn, 0);
    }
    function wrap(defer3) {
      return (fn, ...args) => defer3(() => fn(...args));
    }
    var _defer;
    if (hasQueueMicrotask) {
      _defer = queueMicrotask;
    } else if (hasSetImmediate) {
      _defer = setImmediate;
    } else if (hasNextTick) {
      _defer = process.nextTick;
    } else {
      _defer = fallback;
    }
    exports2.default = wrap(_defer);
  }
});

// ../../node_modules/winston/node_modules/async/asyncify.js
var require_asyncify = __commonJS({
  "../../node_modules/winston/node_modules/async/asyncify.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = asyncify;
    var _initialParams = require_initialParams();
    var _initialParams2 = _interopRequireDefault2(_initialParams);
    var _setImmediate = require_setImmediate();
    var _setImmediate2 = _interopRequireDefault2(_setImmediate);
    var _wrapAsync = require_wrapAsync();
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function asyncify(func) {
      if ((0, _wrapAsync.isAsync)(func)) {
        return function(...args) {
          const callback = args.pop();
          const promise = func.apply(this, args);
          return handlePromise(promise, callback);
        };
      }
      return (0, _initialParams2.default)(function(args, callback) {
        var result2;
        try {
          result2 = func.apply(this, args);
        } catch (e) {
          return callback(e);
        }
        if (result2 && typeof result2.then === "function") {
          return handlePromise(result2, callback);
        } else {
          callback(null, result2);
        }
      });
    }
    function handlePromise(promise, callback) {
      return promise.then((value) => {
        invokeCallback(callback, null, value);
      }, (err) => {
        invokeCallback(callback, err && err.message ? err : new Error(err));
      });
    }
    function invokeCallback(callback, error3, value) {
      try {
        callback(error3, value);
      } catch (err) {
        (0, _setImmediate2.default)((e) => {
          throw e;
        }, err);
      }
    }
    module2.exports = exports2["default"];
  }
});

// ../../node_modules/winston/node_modules/async/internal/wrapAsync.js
var require_wrapAsync = __commonJS({
  "../../node_modules/winston/node_modules/async/internal/wrapAsync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isAsyncIterable = exports2.isAsyncGenerator = exports2.isAsync = void 0;
    var _asyncify = require_asyncify();
    var _asyncify2 = _interopRequireDefault2(_asyncify);
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function isAsync(fn) {
      return fn[Symbol.toStringTag] === "AsyncFunction";
    }
    function isAsyncGenerator(fn) {
      return fn[Symbol.toStringTag] === "AsyncGenerator";
    }
    function isAsyncIterable(obj) {
      return typeof obj[Symbol.asyncIterator] === "function";
    }
    function wrapAsync(asyncFn) {
      if (typeof asyncFn !== "function")
        throw new Error("expected a function");
      return isAsync(asyncFn) ? (0, _asyncify2.default)(asyncFn) : asyncFn;
    }
    exports2.default = wrapAsync;
    exports2.isAsync = isAsync;
    exports2.isAsyncGenerator = isAsyncGenerator;
    exports2.isAsyncIterable = isAsyncIterable;
  }
});

// ../../node_modules/winston/node_modules/async/internal/awaitify.js
var require_awaitify = __commonJS({
  "../../node_modules/winston/node_modules/async/internal/awaitify.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = awaitify;
    function awaitify(asyncFn, arity = asyncFn.length) {
      if (!arity)
        throw new Error("arity is undefined");
      function awaitable(...args) {
        if (typeof args[arity - 1] === "function") {
          return asyncFn.apply(this, args);
        }
        return new Promise((resolve, reject) => {
          args[arity - 1] = (err, ...cbArgs) => {
            if (err)
              return reject(err);
            resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
          };
          asyncFn.apply(this, args);
        });
      }
      return awaitable;
    }
    module2.exports = exports2["default"];
  }
});

// ../../node_modules/winston/node_modules/async/internal/parallel.js
var require_parallel = __commonJS({
  "../../node_modules/winston/node_modules/async/internal/parallel.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _isArrayLike = require_isArrayLike2();
    var _isArrayLike2 = _interopRequireDefault2(_isArrayLike);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault2(_wrapAsync);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault2(_awaitify);
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports2.default = (0, _awaitify2.default)((eachfn, tasks, callback) => {
      var results = (0, _isArrayLike2.default)(tasks) ? [] : {};
      eachfn(tasks, (task2, key, taskCb) => {
        (0, _wrapAsync2.default)(task2)((err, ...result2) => {
          if (result2.length < 2) {
            [result2] = result2;
          }
          results[key] = result2;
          taskCb(err);
        });
      }, (err) => callback(err, results));
    }, 3);
    module2.exports = exports2["default"];
  }
});

// ../../node_modules/winston/node_modules/async/internal/once.js
var require_once = __commonJS({
  "../../node_modules/winston/node_modules/async/internal/once.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = once;
    function once(fn) {
      function wrapper(...args) {
        if (fn === null)
          return;
        var callFn = fn;
        fn = null;
        callFn.apply(this, args);
      }
      Object.assign(wrapper, fn);
      return wrapper;
    }
    module2.exports = exports2["default"];
  }
});

// ../../node_modules/winston/node_modules/async/internal/getIterator.js
var require_getIterator = __commonJS({
  "../../node_modules/winston/node_modules/async/internal/getIterator.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = function(coll) {
      return coll[Symbol.iterator] && coll[Symbol.iterator]();
    };
    module2.exports = exports2["default"];
  }
});

// ../../node_modules/winston/node_modules/async/internal/iterator.js
var require_iterator2 = __commonJS({
  "../../node_modules/winston/node_modules/async/internal/iterator.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = createIterator;
    var _isArrayLike = require_isArrayLike2();
    var _isArrayLike2 = _interopRequireDefault2(_isArrayLike);
    var _getIterator = require_getIterator();
    var _getIterator2 = _interopRequireDefault2(_getIterator);
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function createArrayIterator(coll) {
      var i = -1;
      var len = coll.length;
      return function next() {
        return ++i < len ? { value: coll[i], key: i } : null;
      };
    }
    function createES2015Iterator(iterator) {
      var i = -1;
      return function next() {
        var item = iterator.next();
        if (item.done)
          return null;
        i++;
        return { value: item.value, key: i };
      };
    }
    function createObjectIterator(obj) {
      var okeys = obj ? Object.keys(obj) : [];
      var i = -1;
      var len = okeys.length;
      return function next() {
        var key = okeys[++i];
        if (key === "__proto__") {
          return next();
        }
        return i < len ? { value: obj[key], key } : null;
      };
    }
    function createIterator(coll) {
      if ((0, _isArrayLike2.default)(coll)) {
        return createArrayIterator(coll);
      }
      var iterator = (0, _getIterator2.default)(coll);
      return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
    }
    module2.exports = exports2["default"];
  }
});

// ../../node_modules/winston/node_modules/async/internal/onlyOnce.js
var require_onlyOnce = __commonJS({
  "../../node_modules/winston/node_modules/async/internal/onlyOnce.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = onlyOnce;
    function onlyOnce(fn) {
      return function(...args) {
        if (fn === null)
          throw new Error("Callback was already called.");
        var callFn = fn;
        fn = null;
        callFn.apply(this, args);
      };
    }
    module2.exports = exports2["default"];
  }
});

// ../../node_modules/winston/node_modules/async/internal/breakLoop.js
var require_breakLoop = __commonJS({
  "../../node_modules/winston/node_modules/async/internal/breakLoop.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var breakLoop = {};
    exports2.default = breakLoop;
    module2.exports = exports2["default"];
  }
});

// ../../node_modules/winston/node_modules/async/internal/asyncEachOfLimit.js
var require_asyncEachOfLimit = __commonJS({
  "../../node_modules/winston/node_modules/async/internal/asyncEachOfLimit.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = asyncEachOfLimit;
    var _breakLoop = require_breakLoop();
    var _breakLoop2 = _interopRequireDefault2(_breakLoop);
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function asyncEachOfLimit(generator, limit, iteratee, callback) {
      let done = false;
      let canceled = false;
      let awaiting = false;
      let running = 0;
      let idx = 0;
      function replenish() {
        if (running >= limit || awaiting || done)
          return;
        awaiting = true;
        generator.next().then(({ value, done: iterDone }) => {
          if (canceled || done)
            return;
          awaiting = false;
          if (iterDone) {
            done = true;
            if (running <= 0) {
              callback(null);
            }
            return;
          }
          running++;
          iteratee(value, idx, iterateeCallback);
          idx++;
          replenish();
        }).catch(handleError);
      }
      function iterateeCallback(err, result2) {
        running -= 1;
        if (canceled)
          return;
        if (err)
          return handleError(err);
        if (err === false) {
          done = true;
          canceled = true;
          return;
        }
        if (result2 === _breakLoop2.default || done && running <= 0) {
          done = true;
          return callback(null);
        }
        replenish();
      }
      function handleError(err) {
        if (canceled)
          return;
        awaiting = false;
        done = true;
        callback(err);
      }
      replenish();
    }
    module2.exports = exports2["default"];
  }
});

// ../../node_modules/winston/node_modules/async/internal/eachOfLimit.js
var require_eachOfLimit = __commonJS({
  "../../node_modules/winston/node_modules/async/internal/eachOfLimit.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _once = require_once();
    var _once2 = _interopRequireDefault2(_once);
    var _iterator = require_iterator2();
    var _iterator2 = _interopRequireDefault2(_iterator);
    var _onlyOnce = require_onlyOnce();
    var _onlyOnce2 = _interopRequireDefault2(_onlyOnce);
    var _wrapAsync = require_wrapAsync();
    var _asyncEachOfLimit = require_asyncEachOfLimit();
    var _asyncEachOfLimit2 = _interopRequireDefault2(_asyncEachOfLimit);
    var _breakLoop = require_breakLoop();
    var _breakLoop2 = _interopRequireDefault2(_breakLoop);
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports2.default = (limit) => {
      return (obj, iteratee, callback) => {
        callback = (0, _once2.default)(callback);
        if (limit <= 0) {
          throw new RangeError("concurrency limit cannot be less than 1");
        }
        if (!obj) {
          return callback(null);
        }
        if ((0, _wrapAsync.isAsyncGenerator)(obj)) {
          return (0, _asyncEachOfLimit2.default)(obj, limit, iteratee, callback);
        }
        if ((0, _wrapAsync.isAsyncIterable)(obj)) {
          return (0, _asyncEachOfLimit2.default)(obj[Symbol.asyncIterator](), limit, iteratee, callback);
        }
        var nextElem = (0, _iterator2.default)(obj);
        var done = false;
        var canceled = false;
        var running = 0;
        var looping = false;
        function iterateeCallback(err, value) {
          if (canceled)
            return;
          running -= 1;
          if (err) {
            done = true;
            callback(err);
          } else if (err === false) {
            done = true;
            canceled = true;
          } else if (value === _breakLoop2.default || done && running <= 0) {
            done = true;
            return callback(null);
          } else if (!looping) {
            replenish();
          }
        }
        function replenish() {
          looping = true;
          while (running < limit && !done) {
            var elem = nextElem();
            if (elem === null) {
              done = true;
              if (running <= 0) {
                callback(null);
              }
              return;
            }
            running += 1;
            iteratee(elem.value, elem.key, (0, _onlyOnce2.default)(iterateeCallback));
          }
          looping = false;
        }
        replenish();
      };
    };
    module2.exports = exports2["default"];
  }
});

// ../../node_modules/winston/node_modules/async/eachOfLimit.js
var require_eachOfLimit2 = __commonJS({
  "../../node_modules/winston/node_modules/async/eachOfLimit.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _eachOfLimit2 = require_eachOfLimit();
    var _eachOfLimit3 = _interopRequireDefault2(_eachOfLimit2);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault2(_wrapAsync);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault2(_awaitify);
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachOfLimit(coll, limit, iteratee, callback) {
      return (0, _eachOfLimit3.default)(limit)(coll, (0, _wrapAsync2.default)(iteratee), callback);
    }
    exports2.default = (0, _awaitify2.default)(eachOfLimit, 4);
    module2.exports = exports2["default"];
  }
});

// ../../node_modules/winston/node_modules/async/eachOfSeries.js
var require_eachOfSeries = __commonJS({
  "../../node_modules/winston/node_modules/async/eachOfSeries.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _eachOfLimit = require_eachOfLimit2();
    var _eachOfLimit2 = _interopRequireDefault2(_eachOfLimit);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault2(_awaitify);
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachOfSeries(coll, iteratee, callback) {
      return (0, _eachOfLimit2.default)(coll, 1, iteratee, callback);
    }
    exports2.default = (0, _awaitify2.default)(eachOfSeries, 3);
    module2.exports = exports2["default"];
  }
});

// ../../node_modules/winston/node_modules/async/series.js
var require_series = __commonJS({
  "../../node_modules/winston/node_modules/async/series.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = series;
    var _parallel2 = require_parallel();
    var _parallel3 = _interopRequireDefault2(_parallel2);
    var _eachOfSeries = require_eachOfSeries();
    var _eachOfSeries2 = _interopRequireDefault2(_eachOfSeries);
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function series(tasks, callback) {
      return (0, _parallel3.default)(_eachOfSeries2.default, tasks, callback);
    }
    module2.exports = exports2["default"];
  }
});

// ../../node_modules/winston/node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream2 = __commonJS({
  "../../node_modules/winston/node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    module2.exports = require("stream");
  }
});

// ../../node_modules/winston/node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "../../node_modules/winston/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports2, module2) {
    "use strict";
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread2(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty2(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty2(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck2(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties2(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass2(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties2(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties2(Constructor, staticProps);
      return Constructor;
    }
    var _require = require("buffer");
    var Buffer2 = _require.Buffer;
    var _require2 = require("util");
    var inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer2.prototype.copy.call(src, target, offset);
    }
    module2.exports = /* @__PURE__ */ function() {
      function BufferList() {
        _classCallCheck2(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass2(BufferList, [{
        key: "push",
        value: function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join2(s) {
          if (this.length === 0)
            return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next) {
            ret += s + p.data;
          }
          return ret;
        }
      }, {
        key: "concat",
        value: function concat(n) {
          if (this.length === 0)
            return Buffer2.alloc(0);
          var ret = Buffer2.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        }
      }, {
        key: "consume",
        value: function consume(n, hasStrings) {
          var ret;
          if (n < this.head.data.length) {
            ret = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
      }, {
        key: "_getString",
        value: function _getString(n) {
          var p = this.head;
          var c = 1;
          var ret = p.data;
          n -= ret.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length)
              ret += str;
            else
              ret += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n) {
          var ret = Buffer2.allocUnsafe(n);
          var p = this.head;
          var c = 1;
          p.data.copy(ret);
          n -= p.data.length;
          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret, ret.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
      }, {
        key: custom,
        value: function value(_45, options2) {
          return inspect(this, _objectSpread2({}, options2, {
            depth: 0,
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
  }
});

// ../../node_modules/winston/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy2 = __commonJS({
  "../../node_modules/winston/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err);
      else
        stream.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// ../../node_modules/winston/node_modules/readable-stream/errors.js
var require_errors3 = __commonJS({
  "../../node_modules/winston/node_modules/readable-stream/errors.js"(exports2, module2) {
    "use strict";
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      class NodeError extends Base {
        constructor(arg1, arg2, arg3) {
          super(getMessage(arg1, arg2, arg3));
        }
      }
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        const len = expected.length;
        expected = expected.map((i) => String(i));
        if (len > 2) {
          return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
        } else if (len === 2) {
          return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        } else {
          return `of ${thing} ${expected[0]}`;
        }
      } else {
        return `of ${thing} ${String(expected)}`;
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      let determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      let msg;
      if (endsWith(name, " argument")) {
        msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
      } else {
        const type = includes(name, ".") ? "property" : "argument";
        msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
      }
      msg += `. Received type ${typeof actual}`;
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module2.exports.codes = codes;
  }
});

// ../../node_modules/winston/node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "../../node_modules/winston/node_modules/readable-stream/lib/internal/streams/state.js"(exports2, module2) {
    "use strict";
    var ERR_INVALID_OPT_VALUE = require_errors3().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options2, isDuplex, duplexKey) {
      return options2.highWaterMark != null ? options2.highWaterMark : isDuplex ? options2[duplexKey] : null;
    }
    function getHighWaterMark(state, options2, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options2, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module2.exports = {
      getHighWaterMark
    };
  }
});

// ../../node_modules/winston/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable2 = __commonJS({
  "../../node_modules/winston/node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_node3()
    };
    var Stream = require_stream2();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy2();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors3().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits()(Writable, Stream);
    function nop() {
    }
    function WritableState(options2, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex2();
      options2 = options2 || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options2.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options2.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options2, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options2.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options2.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options2.emitClose !== false;
      this.autoDestroy = !!options2.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_45) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable(options2) {
      Duplex = Duplex || require_stream_duplex2();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this))
        return new Writable(options2);
      this._writableState = new WritableState(options2, this, isDuplex);
      this.writable = true;
      if (options2) {
        if (typeof options2.write === "function")
          this._write = options2.write;
        if (typeof options2.writev === "function")
          this._writev = options2.writev;
        if (typeof options2.destroy === "function")
          this._destroy = options2.destroy;
        if (typeof options2.final === "function")
          this._final = options2.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      enumerable: false,
      get: function get3() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function get3() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      enumerable: false,
      get: function get3() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      enumerable: false,
      get: function get3() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// ../../node_modules/winston/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex2 = __commonJS({
  "../../node_modules/winston/node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) {
        keys2.push(key);
      }
      return keys2;
    };
    module2.exports = Duplex;
    var Readable = require_stream_readable2();
    var Writable = require_stream_writable2();
    require_inherits()(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options2) {
      if (!(this instanceof Duplex))
        return new Duplex(options2);
      Readable.call(this, options2);
      Writable.call(this, options2);
      this.allowHalfOpen = true;
      if (options2) {
        if (options2.readable === false)
          this.readable = false;
        if (options2.writable === false)
          this.writable = false;
        if (options2.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function get3() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      enumerable: false,
      get: function get3() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      enumerable: false,
      get: function get3() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended)
        return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      enumerable: false,
      get: function get3() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// ../../node_modules/winston/node_modules/string_decoder/node_modules/safe-buffer/index.js
var require_safe_buffer2 = __commonJS({
  "../../node_modules/winston/node_modules/string_decoder/node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// ../../node_modules/winston/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder2 = __commonJS({
  "../../node_modules/winston/node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer2().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// ../../node_modules/winston/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "../../node_modules/winston/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports2, module2) {
    "use strict";
    var ERR_STREAM_PREMATURE_CLOSE = require_errors3().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop3() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop3);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable)
          onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module2.exports = eos;
  }
});

// ../../node_modules/winston/node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "../../node_modules/winston/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports2, module2) {
    "use strict";
    var _Object$setPrototypeO;
    function _defineProperty2(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var finished = require_end_of_stream();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data2 = iter[kStream].read();
        if (data2 !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data2, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error3 = this[kError];
        if (error3 !== null) {
          return Promise.reject(error3);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data2 = this[kStream].read();
          if (data2 !== null) {
            return Promise.resolve(createIterResult(data2, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty2(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty2(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty2(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty2(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty2(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty2(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty2(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty2(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
          var data2 = iterator[kStream].read();
          if (data2) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(data2, false));
          } else {
            iterator[kLastResolve] = resolve;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module2.exports = createReadableStreamAsyncIterator;
  }
});

// ../../node_modules/winston/node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS({
  "../../node_modules/winston/node_modules/readable-stream/lib/internal/streams/from.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error3) {
        reject(error3);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread2(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty2(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty2(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var ERR_INVALID_ARG_TYPE = require_errors3().codes.ERR_INVALID_ARG_TYPE;
    function from(Readable, iterable, opts) {
      var iterator;
      if (iterable && typeof iterable.next === "function") {
        iterator = iterable;
      } else if (iterable && iterable[Symbol.asyncIterator])
        iterator = iterable[Symbol.asyncIterator]();
      else if (iterable && iterable[Symbol.iterator])
        iterator = iterable[Symbol.iterator]();
      else
        throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
      var readable = new Readable(_objectSpread2({
        objectMode: true
      }, opts));
      var reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      function next() {
        return _next2.apply(this, arguments);
      }
      function _next2() {
        _next2 = _asyncToGenerator(function* () {
          try {
            var _ref = yield iterator.next(), value = _ref.value, done = _ref.done;
            if (done) {
              readable.push(null);
            } else if (readable.push(yield value)) {
              next();
            } else {
              reading = false;
            }
          } catch (err) {
            readable.destroy(err);
          }
        });
        return _next2.apply(this, arguments);
      }
      return readable;
    }
    module2.exports = from;
  }
});

// ../../node_modules/winston/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable2 = __commonJS({
  "../../node_modules/winston/node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    module2.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream2();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require("util");
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy2();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors3().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    require_inherits()(Readable, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options2, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex2();
      options2 = options2 || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options2.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options2.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options2, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options2.emitClose !== false;
      this.autoDestroy = !!options2.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options2.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options2.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder2().StringDecoder;
        this.decoder = new StringDecoder(options2.encoding);
        this.encoding = options2.encoding;
      }
    }
    function Readable(options2) {
      Duplex = Duplex || require_stream_duplex2();
      if (!(this instanceof Readable))
        return new Readable(options2);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options2, this, isDuplex);
      this.readable = true;
      if (options2) {
        if (typeof options2.read === "function")
          this._read = options2.read;
        if (typeof options2.destroy === "function")
          this._destroy = options2.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      enumerable: false,
      get: function get3() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder2().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) {
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        }
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      var res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
        ;
      }
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      enumerable: false,
      get: function get3() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      enumerable: false,
      get: function get3() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      enumerable: false,
      get: function get3() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      enumerable: false,
      get: function get3() {
        return this._readableState.length;
      }
    });
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from === void 0) {
          from = require_from();
        }
        return from(Readable, iterable, opts);
      };
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// ../../node_modules/winston/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "../../node_modules/winston/node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform;
    var _require$codes = require_errors3().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex2();
    require_inherits()(Transform, Duplex);
    function afterTransform(er, data2) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data2 != null)
        this.push(data2);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options2) {
      if (!(this instanceof Transform))
        return new Transform(options2);
      Duplex.call(this, options2);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options2) {
        if (typeof options2.transform === "function")
          this._transform = options2.transform;
        if (typeof options2.flush === "function")
          this._flush = options2.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data2) {
          done(_this, er, data2);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data2) {
      if (er)
        return stream.emit("error", er);
      if (data2 != null)
        stream.push(data2);
      if (stream._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// ../../node_modules/winston/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "../../node_modules/winston/node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform();
    require_inherits()(PassThrough, Transform);
    function PassThrough(options2) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options2);
      Transform.call(this, options2);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// ../../node_modules/winston/node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "../../node_modules/winston/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports2, module2) {
    "use strict";
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors3().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop3(err) {
      if (err)
        throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0)
        eos = require_end_of_stream();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream))
          return stream.abort();
        if (typeof stream.destroy === "function")
          return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe(from, to) {
      return from.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop3;
      if (typeof streams[streams.length - 1] !== "function")
        return noop3;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error3;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error3)
            error3 = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error3);
        });
      });
      return streams.reduce(pipe);
    }
    module2.exports = pipeline;
  }
});

// ../../node_modules/winston/node_modules/readable-stream/readable.js
var require_readable = __commonJS({
  "../../node_modules/winston/node_modules/readable-stream/readable.js"(exports2, module2) {
    var Stream = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream.Readable;
      Object.assign(module2.exports, Stream);
      module2.exports.Stream = Stream;
    } else {
      exports2 = module2.exports = require_stream_readable2();
      exports2.Stream = Stream || exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable2();
      exports2.Duplex = require_stream_duplex2();
      exports2.Transform = require_stream_transform();
      exports2.PassThrough = require_stream_passthrough();
      exports2.finished = require_end_of_stream();
      exports2.pipeline = require_pipeline();
    }
  }
});

// ../../node_modules/@dabh/diagnostics/diagnostics.js
var require_diagnostics = __commonJS({
  "../../node_modules/@dabh/diagnostics/diagnostics.js"(exports2, module2) {
    var adapters = [];
    var modifiers = [];
    var logger = function devnull() {
    };
    function use(adapter) {
      if (~adapters.indexOf(adapter))
        return false;
      adapters.push(adapter);
      return true;
    }
    function set(custom) {
      logger = custom;
    }
    function enabled(namespace) {
      var async = [];
      for (var i = 0; i < adapters.length; i++) {
        if (adapters[i].async) {
          async.push(adapters[i]);
          continue;
        }
        if (adapters[i](namespace))
          return true;
      }
      if (!async.length)
        return false;
      return new Promise(function pinky(resolve) {
        Promise.all(async.map(function prebind(fn) {
          return fn(namespace);
        })).then(function resolved(values) {
          resolve(values.some(Boolean));
        });
      });
    }
    function modify(fn) {
      if (~modifiers.indexOf(fn))
        return false;
      modifiers.push(fn);
      return true;
    }
    function write() {
      logger.apply(logger, arguments);
    }
    function process2(message) {
      for (var i = 0; i < modifiers.length; i++) {
        message = modifiers[i].apply(modifiers[i], arguments);
      }
      return message;
    }
    function introduce(fn, options2) {
      var has = Object.prototype.hasOwnProperty;
      for (var key in options2) {
        if (has.call(options2, key)) {
          fn[key] = options2[key];
        }
      }
      return fn;
    }
    function nope(options2) {
      options2.enabled = false;
      options2.modify = modify;
      options2.set = set;
      options2.use = use;
      return introduce(function diagnopes() {
        return false;
      }, options2);
    }
    function yep(options2) {
      function diagnostics() {
        var args = Array.prototype.slice.call(arguments, 0);
        write.call(write, options2, process2(args, options2));
        return true;
      }
      options2.enabled = true;
      options2.modify = modify;
      options2.set = set;
      options2.use = use;
      return introduce(diagnostics, options2);
    }
    module2.exports = function create(diagnostics) {
      diagnostics.introduce = introduce;
      diagnostics.enabled = enabled;
      diagnostics.process = process2;
      diagnostics.modify = modify;
      diagnostics.write = write;
      diagnostics.nope = nope;
      diagnostics.yep = yep;
      diagnostics.set = set;
      diagnostics.use = use;
      return diagnostics;
    };
  }
});

// ../../node_modules/@dabh/diagnostics/node/production.js
var require_production = __commonJS({
  "../../node_modules/@dabh/diagnostics/node/production.js"(exports2, module2) {
    var create = require_diagnostics();
    var diagnostics = create(function prod(namespace, options2) {
      options2 = options2 || {};
      options2.namespace = namespace;
      options2.prod = true;
      options2.dev = false;
      if (!(options2.force || prod.force))
        return prod.nope(options2);
      return prod.yep(options2);
    });
    module2.exports = diagnostics;
  }
});

// ../../node_modules/simple-swizzle/node_modules/is-arrayish/index.js
var require_is_arrayish = __commonJS({
  "../../node_modules/simple-swizzle/node_modules/is-arrayish/index.js"(exports2, module2) {
    module2.exports = function isArrayish(obj) {
      if (!obj || typeof obj === "string") {
        return false;
      }
      return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
    };
  }
});

// ../../node_modules/simple-swizzle/index.js
var require_simple_swizzle = __commonJS({
  "../../node_modules/simple-swizzle/index.js"(exports2, module2) {
    "use strict";
    var isArrayish = require_is_arrayish();
    var concat = Array.prototype.concat;
    var slice = Array.prototype.slice;
    var swizzle = module2.exports = function swizzle2(args) {
      var results = [];
      for (var i = 0, len = args.length; i < len; i++) {
        var arg = args[i];
        if (isArrayish(arg)) {
          results = concat.call(results, slice.call(arg));
        } else {
          results.push(arg);
        }
      }
      return results;
    };
    swizzle.wrap = function(fn) {
      return function() {
        return fn(swizzle(arguments));
      };
    };
  }
});

// ../../node_modules/color-string/index.js
var require_color_string = __commonJS({
  "../../node_modules/color-string/index.js"(exports2, module2) {
    var colorNames = require_color_name();
    var swizzle = require_simple_swizzle();
    var reverseNames = {};
    for (name in colorNames) {
      if (colorNames.hasOwnProperty(name)) {
        reverseNames[colorNames[name]] = name;
      }
    }
    var name;
    var cs = module2.exports = {
      to: {},
      get: {}
    };
    cs.get = function(string) {
      var prefix = string.substring(0, 3).toLowerCase();
      var val;
      var model;
      switch (prefix) {
        case "hsl":
          val = cs.get.hsl(string);
          model = "hsl";
          break;
        case "hwb":
          val = cs.get.hwb(string);
          model = "hwb";
          break;
        default:
          val = cs.get.rgb(string);
          model = "rgb";
          break;
      }
      if (!val) {
        return null;
      }
      return { model, value: val };
    };
    cs.get.rgb = function(string) {
      if (!string) {
        return null;
      }
      var abbr = /^#([a-f0-9]{3,4})$/i;
      var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
      var rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
      var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
      var keyword = /(\D+)/;
      var rgb = [0, 0, 0, 1];
      var match;
      var i;
      var hexAlpha;
      if (match = string.match(hex)) {
        hexAlpha = match[2];
        match = match[1];
        for (i = 0; i < 3; i++) {
          var i2 = i * 2;
          rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
        }
        if (hexAlpha) {
          rgb[3] = parseInt(hexAlpha, 16) / 255;
        }
      } else if (match = string.match(abbr)) {
        match = match[1];
        hexAlpha = match[3];
        for (i = 0; i < 3; i++) {
          rgb[i] = parseInt(match[i] + match[i], 16);
        }
        if (hexAlpha) {
          rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
        }
      } else if (match = string.match(rgba)) {
        for (i = 0; i < 3; i++) {
          rgb[i] = parseInt(match[i + 1], 0);
        }
        if (match[4]) {
          rgb[3] = parseFloat(match[4]);
        }
      } else if (match = string.match(per)) {
        for (i = 0; i < 3; i++) {
          rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
        }
        if (match[4]) {
          rgb[3] = parseFloat(match[4]);
        }
      } else if (match = string.match(keyword)) {
        if (match[1] === "transparent") {
          return [0, 0, 0, 0];
        }
        rgb = colorNames[match[1]];
        if (!rgb) {
          return null;
        }
        rgb[3] = 1;
        return rgb;
      } else {
        return null;
      }
      for (i = 0; i < 3; i++) {
        rgb[i] = clamp(rgb[i], 0, 255);
      }
      rgb[3] = clamp(rgb[3], 0, 1);
      return rgb;
    };
    cs.get.hsl = function(string) {
      if (!string) {
        return null;
      }
      var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
      var match = string.match(hsl);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h = (parseFloat(match[1]) + 360) % 360;
        var s = clamp(parseFloat(match[2]), 0, 100);
        var l = clamp(parseFloat(match[3]), 0, 100);
        var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, s, l, a];
      }
      return null;
    };
    cs.get.hwb = function(string) {
      if (!string) {
        return null;
      }
      var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
      var match = string.match(hwb);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h = (parseFloat(match[1]) % 360 + 360) % 360;
        var w = clamp(parseFloat(match[2]), 0, 100);
        var b = clamp(parseFloat(match[3]), 0, 100);
        var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h, w, b, a];
      }
      return null;
    };
    cs.to.hex = function() {
      var rgba = swizzle(arguments);
      return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : "");
    };
    cs.to.rgb = function() {
      var rgba = swizzle(arguments);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
    };
    cs.to.rgb.percent = function() {
      var rgba = swizzle(arguments);
      var r = Math.round(rgba[0] / 255 * 100);
      var g = Math.round(rgba[1] / 255 * 100);
      var b = Math.round(rgba[2] / 255 * 100);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + r + "%, " + g + "%, " + b + "%)" : "rgba(" + r + "%, " + g + "%, " + b + "%, " + rgba[3] + ")";
    };
    cs.to.hsl = function() {
      var hsla = swizzle(arguments);
      return hsla.length < 4 || hsla[3] === 1 ? "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)" : "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + hsla[3] + ")";
    };
    cs.to.hwb = function() {
      var hwba = swizzle(arguments);
      var a = "";
      if (hwba.length >= 4 && hwba[3] !== 1) {
        a = ", " + hwba[3];
      }
      return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a + ")";
    };
    cs.to.keyword = function(rgb) {
      return reverseNames[rgb.slice(0, 3)];
    };
    function clamp(num, min, max) {
      return Math.min(Math.max(min, num), max);
    }
    function hexDouble(num) {
      var str = num.toString(16).toUpperCase();
      return str.length < 2 ? "0" + str : str;
    }
  }
});

// ../../node_modules/color-convert/node_modules/color-name/index.js
var require_color_name2 = __commonJS({
  "../../node_modules/color-convert/node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// ../../node_modules/color-convert/conversions.js
var require_conversions2 = __commonJS({
  "../../node_modules/color-convert/conversions.js"(exports2, module2) {
    var cssKeywords = require_color_name2();
    var reverseKeywords = {};
    for (key in cssKeywords) {
      if (cssKeywords.hasOwnProperty(key)) {
        reverseKeywords[cssKeywords[key]] = key;
      }
    }
    var key;
    var convert = module2.exports = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    for (model in convert) {
      if (convert.hasOwnProperty(model)) {
        if (!("channels" in convert[model])) {
          throw new Error("missing channels property: " + model);
        }
        if (!("labels" in convert[model])) {
          throw new Error("missing channel labels property: " + model);
        }
        if (convert[model].labels.length !== convert[model].channels) {
          throw new Error("channel and label counts mismatch: " + model);
        }
        channels = convert[model].channels;
        labels = convert[model].labels;
        delete convert[model].channels;
        delete convert[model].labels;
        Object.defineProperty(convert[model], "channels", { value: channels });
        Object.defineProperty(convert[model], "labels", { value: labels });
      }
    }
    var channels;
    var labels;
    var model;
    convert.rgb.hsl = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var min = Math.min(r, g, b);
      var max = Math.max(r, g, b);
      var delta = max - min;
      var h;
      var s;
      var l;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      var rdif;
      var gdif;
      var bdif;
      var h;
      var s;
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var v = Math.max(r, g, b);
      var diff = v - Math.min(r, g, b);
      var diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      var r = rgb[0];
      var g = rgb[1];
      var b = rgb[2];
      var h = convert.rgb.hsl(rgb)[0];
      var w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var c;
      var m;
      var y;
      var k;
      k = Math.min(1 - r, 1 - g, 1 - b);
      c = (1 - r - k) / (1 - k) || 0;
      m = (1 - g - k) / (1 - k) || 0;
      y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
    }
    convert.rgb.keyword = function(rgb) {
      var reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      var currentClosestDistance = Infinity;
      var currentClosestKeyword;
      for (var keyword in cssKeywords) {
        if (cssKeywords.hasOwnProperty(keyword)) {
          var value = cssKeywords[keyword];
          var distance = comparativeDistance(rgb, value);
          if (distance < currentClosestDistance) {
            currentClosestDistance = distance;
            currentClosestKeyword = keyword;
          }
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      var xyz = convert.rgb.xyz(rgb);
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      var h = hsl[0] / 360;
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var t1;
      var t2;
      var t3;
      var rgb;
      var val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      t1 = 2 * l - t2;
      rgb = [0, 0, 0];
      for (var i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      var h = hsl[0];
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var smin = s;
      var lmin = Math.max(l, 0.01);
      var sv;
      var v;
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      v = (l + s) / 2;
      sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      var h = hsv[0] / 60;
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var hi = Math.floor(h) % 6;
      var f = h - Math.floor(h);
      var p = 255 * v * (1 - s);
      var q = 255 * v * (1 - s * f);
      var t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      var h = hsv[0];
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var vmin = Math.max(v, 0.01);
      var lmin;
      var sl;
      var l;
      l = (2 - s) * v;
      lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      var h = hwb[0] / 360;
      var wh = hwb[1] / 100;
      var bl = hwb[2] / 100;
      var ratio = wh + bl;
      var i;
      var v;
      var f;
      var n;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      i = Math.floor(6 * h);
      v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      n = wh + f * (v - wh);
      var r;
      var g;
      var b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      var c = cmyk[0] / 100;
      var m = cmyk[1] / 100;
      var y = cmyk[2] / 100;
      var k = cmyk[3] / 100;
      var r;
      var g;
      var b;
      r = 1 - Math.min(1, c * (1 - k) + k);
      g = 1 - Math.min(1, m * (1 - k) + k);
      b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      var x = xyz[0] / 100;
      var y = xyz[1] / 100;
      var z = xyz[2] / 100;
      var r;
      var g;
      var b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var x;
      var y;
      var z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      var y2 = Math.pow(y, 3);
      var x2 = Math.pow(x, 3);
      var z2 = Math.pow(z, 3);
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var hr;
      var h;
      var c;
      hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      var l = lch[0];
      var c = lch[1];
      var h = lch[2];
      var a;
      var b;
      var hr;
      hr = h / 360 * 2 * Math.PI;
      a = c * Math.cos(hr);
      b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      var color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      var mult = (~~(args > 50) + 1) * 0.5;
      var r = (color & 1) * mult * 255;
      var g = (color >> 1 & 1) * mult * 255;
      var b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        var c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      var rem;
      var r = Math.floor(args / 36) / 5 * 255;
      var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      var b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      var colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map(function(char) {
          return char + char;
        }).join("");
      }
      var integer = parseInt(colorString, 16);
      var r = integer >> 16 & 255;
      var g = integer >> 8 & 255;
      var b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var max = Math.max(Math.max(r, g), b);
      var min = Math.min(Math.min(r, g), b);
      var chroma = max - min;
      var grayscale;
      var hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma + 4;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var c = 1;
      var f = 0;
      if (l < 0.5) {
        c = 2 * s * l;
      } else {
        c = 2 * s * (1 - l);
      }
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var c = s * v;
      var f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      var h = hcg[0] / 360;
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      var pure = [0, 0, 0];
      var hi = h % 1 * 6;
      var v = hi % 1;
      var w = 1 - v;
      var mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1 - c);
      var f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var l = g * (1 - c) + 0.5 * c;
      var s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      var w = hwb[1] / 100;
      var b = hwb[2] / 100;
      var v = 1 - b;
      var c = v - w;
      var g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = convert.gray.hsv = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      var val = Math.round(gray[0] / 100 * 255) & 255;
      var integer = (val << 16) + (val << 8) + val;
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// ../../node_modules/color-convert/route.js
var require_route2 = __commonJS({
  "../../node_modules/color-convert/route.js"(exports2, module2) {
    var conversions = require_conversions2();
    function buildGraph() {
      var graph = {};
      var models = Object.keys(conversions);
      for (var len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      var graph = buildGraph();
      var queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        var current = queue.pop();
        var adjacents = Object.keys(conversions[current]);
        for (var len = adjacents.length, i = 0; i < len; i++) {
          var adjacent = adjacents[i];
          var node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      var path = [graph[toModel].parent, toModel];
      var fn = conversions[graph[toModel].parent][toModel];
      var cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    module2.exports = function(fromModel) {
      var graph = deriveBFS(fromModel);
      var conversion = {};
      var models = Object.keys(graph);
      for (var len = models.length, i = 0; i < len; i++) {
        var toModel = models[i];
        var node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// ../../node_modules/color-convert/index.js
var require_color_convert2 = __commonJS({
  "../../node_modules/color-convert/index.js"(exports2, module2) {
    var conversions = require_conversions2();
    var route = require_route2();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        var result2 = fn(args);
        if (typeof result2 === "object") {
          for (var len = result2.length, i = 0; i < len; i++) {
            result2[i] = Math.round(result2[i]);
          }
        }
        return result2;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach(function(fromModel) {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      var routes = route(fromModel);
      var routeModels = Object.keys(routes);
      routeModels.forEach(function(toModel) {
        var fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});

// ../../node_modules/color/index.js
var require_color = __commonJS({
  "../../node_modules/color/index.js"(exports2, module2) {
    "use strict";
    var colorString = require_color_string();
    var convert = require_color_convert2();
    var _slice = [].slice;
    var skippedModels = [
      "keyword",
      "gray",
      "hex"
    ];
    var hashedModelKeys = {};
    Object.keys(convert).forEach(function(model) {
      hashedModelKeys[_slice.call(convert[model].labels).sort().join("")] = model;
    });
    var limiters = {};
    function Color(obj, model) {
      if (!(this instanceof Color)) {
        return new Color(obj, model);
      }
      if (model && model in skippedModels) {
        model = null;
      }
      if (model && !(model in convert)) {
        throw new Error("Unknown model: " + model);
      }
      var i;
      var channels;
      if (!obj) {
        this.model = "rgb";
        this.color = [0, 0, 0];
        this.valpha = 1;
      } else if (obj instanceof Color) {
        this.model = obj.model;
        this.color = obj.color.slice();
        this.valpha = obj.valpha;
      } else if (typeof obj === "string") {
        var result2 = colorString.get(obj);
        if (result2 === null) {
          throw new Error("Unable to parse color from string: " + obj);
        }
        this.model = result2.model;
        channels = convert[this.model].channels;
        this.color = result2.value.slice(0, channels);
        this.valpha = typeof result2.value[channels] === "number" ? result2.value[channels] : 1;
      } else if (obj.length) {
        this.model = model || "rgb";
        channels = convert[this.model].channels;
        var newArr = _slice.call(obj, 0, channels);
        this.color = zeroArray(newArr, channels);
        this.valpha = typeof obj[channels] === "number" ? obj[channels] : 1;
      } else if (typeof obj === "number") {
        obj &= 16777215;
        this.model = "rgb";
        this.color = [
          obj >> 16 & 255,
          obj >> 8 & 255,
          obj & 255
        ];
        this.valpha = 1;
      } else {
        this.valpha = 1;
        var keys = Object.keys(obj);
        if ("alpha" in obj) {
          keys.splice(keys.indexOf("alpha"), 1);
          this.valpha = typeof obj.alpha === "number" ? obj.alpha : 0;
        }
        var hashedKeys = keys.sort().join("");
        if (!(hashedKeys in hashedModelKeys)) {
          throw new Error("Unable to parse color from object: " + JSON.stringify(obj));
        }
        this.model = hashedModelKeys[hashedKeys];
        var labels = convert[this.model].labels;
        var color = [];
        for (i = 0; i < labels.length; i++) {
          color.push(obj[labels[i]]);
        }
        this.color = zeroArray(color);
      }
      if (limiters[this.model]) {
        channels = convert[this.model].channels;
        for (i = 0; i < channels; i++) {
          var limit = limiters[this.model][i];
          if (limit) {
            this.color[i] = limit(this.color[i]);
          }
        }
      }
      this.valpha = Math.max(0, Math.min(1, this.valpha));
      if (Object.freeze) {
        Object.freeze(this);
      }
    }
    Color.prototype = {
      toString: function() {
        return this.string();
      },
      toJSON: function() {
        return this[this.model]();
      },
      string: function(places) {
        var self2 = this.model in colorString.to ? this : this.rgb();
        self2 = self2.round(typeof places === "number" ? places : 1);
        var args = self2.valpha === 1 ? self2.color : self2.color.concat(this.valpha);
        return colorString.to[self2.model](args);
      },
      percentString: function(places) {
        var self2 = this.rgb().round(typeof places === "number" ? places : 1);
        var args = self2.valpha === 1 ? self2.color : self2.color.concat(this.valpha);
        return colorString.to.rgb.percent(args);
      },
      array: function() {
        return this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);
      },
      object: function() {
        var result2 = {};
        var channels = convert[this.model].channels;
        var labels = convert[this.model].labels;
        for (var i = 0; i < channels; i++) {
          result2[labels[i]] = this.color[i];
        }
        if (this.valpha !== 1) {
          result2.alpha = this.valpha;
        }
        return result2;
      },
      unitArray: function() {
        var rgb = this.rgb().color;
        rgb[0] /= 255;
        rgb[1] /= 255;
        rgb[2] /= 255;
        if (this.valpha !== 1) {
          rgb.push(this.valpha);
        }
        return rgb;
      },
      unitObject: function() {
        var rgb = this.rgb().object();
        rgb.r /= 255;
        rgb.g /= 255;
        rgb.b /= 255;
        if (this.valpha !== 1) {
          rgb.alpha = this.valpha;
        }
        return rgb;
      },
      round: function(places) {
        places = Math.max(places || 0, 0);
        return new Color(this.color.map(roundToPlace(places)).concat(this.valpha), this.model);
      },
      alpha: function(val) {
        if (arguments.length) {
          return new Color(this.color.concat(Math.max(0, Math.min(1, val))), this.model);
        }
        return this.valpha;
      },
      red: getset("rgb", 0, maxfn(255)),
      green: getset("rgb", 1, maxfn(255)),
      blue: getset("rgb", 2, maxfn(255)),
      hue: getset(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, function(val) {
        return (val % 360 + 360) % 360;
      }),
      saturationl: getset("hsl", 1, maxfn(100)),
      lightness: getset("hsl", 2, maxfn(100)),
      saturationv: getset("hsv", 1, maxfn(100)),
      value: getset("hsv", 2, maxfn(100)),
      chroma: getset("hcg", 1, maxfn(100)),
      gray: getset("hcg", 2, maxfn(100)),
      white: getset("hwb", 1, maxfn(100)),
      wblack: getset("hwb", 2, maxfn(100)),
      cyan: getset("cmyk", 0, maxfn(100)),
      magenta: getset("cmyk", 1, maxfn(100)),
      yellow: getset("cmyk", 2, maxfn(100)),
      black: getset("cmyk", 3, maxfn(100)),
      x: getset("xyz", 0, maxfn(100)),
      y: getset("xyz", 1, maxfn(100)),
      z: getset("xyz", 2, maxfn(100)),
      l: getset("lab", 0, maxfn(100)),
      a: getset("lab", 1),
      b: getset("lab", 2),
      keyword: function(val) {
        if (arguments.length) {
          return new Color(val);
        }
        return convert[this.model].keyword(this.color);
      },
      hex: function(val) {
        if (arguments.length) {
          return new Color(val);
        }
        return colorString.to.hex(this.rgb().round().color);
      },
      rgbNumber: function() {
        var rgb = this.rgb().color;
        return (rgb[0] & 255) << 16 | (rgb[1] & 255) << 8 | rgb[2] & 255;
      },
      luminosity: function() {
        var rgb = this.rgb().color;
        var lum = [];
        for (var i = 0; i < rgb.length; i++) {
          var chan = rgb[i] / 255;
          lum[i] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
        }
        return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
      },
      contrast: function(color2) {
        var lum1 = this.luminosity();
        var lum2 = color2.luminosity();
        if (lum1 > lum2) {
          return (lum1 + 0.05) / (lum2 + 0.05);
        }
        return (lum2 + 0.05) / (lum1 + 0.05);
      },
      level: function(color2) {
        var contrastRatio = this.contrast(color2);
        if (contrastRatio >= 7.1) {
          return "AAA";
        }
        return contrastRatio >= 4.5 ? "AA" : "";
      },
      isDark: function() {
        var rgb = this.rgb().color;
        var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1e3;
        return yiq < 128;
      },
      isLight: function() {
        return !this.isDark();
      },
      negate: function() {
        var rgb = this.rgb();
        for (var i = 0; i < 3; i++) {
          rgb.color[i] = 255 - rgb.color[i];
        }
        return rgb;
      },
      lighten: function(ratio) {
        var hsl = this.hsl();
        hsl.color[2] += hsl.color[2] * ratio;
        return hsl;
      },
      darken: function(ratio) {
        var hsl = this.hsl();
        hsl.color[2] -= hsl.color[2] * ratio;
        return hsl;
      },
      saturate: function(ratio) {
        var hsl = this.hsl();
        hsl.color[1] += hsl.color[1] * ratio;
        return hsl;
      },
      desaturate: function(ratio) {
        var hsl = this.hsl();
        hsl.color[1] -= hsl.color[1] * ratio;
        return hsl;
      },
      whiten: function(ratio) {
        var hwb = this.hwb();
        hwb.color[1] += hwb.color[1] * ratio;
        return hwb;
      },
      blacken: function(ratio) {
        var hwb = this.hwb();
        hwb.color[2] += hwb.color[2] * ratio;
        return hwb;
      },
      grayscale: function() {
        var rgb = this.rgb().color;
        var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
        return Color.rgb(val, val, val);
      },
      fade: function(ratio) {
        return this.alpha(this.valpha - this.valpha * ratio);
      },
      opaquer: function(ratio) {
        return this.alpha(this.valpha + this.valpha * ratio);
      },
      rotate: function(degrees) {
        var hsl = this.hsl();
        var hue = hsl.color[0];
        hue = (hue + degrees) % 360;
        hue = hue < 0 ? 360 + hue : hue;
        hsl.color[0] = hue;
        return hsl;
      },
      mix: function(mixinColor, weight) {
        var color1 = mixinColor.rgb();
        var color2 = this.rgb();
        var p = weight === void 0 ? 0.5 : weight;
        var w = 2 * p - 1;
        var a = color1.alpha() - color2.alpha();
        var w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
        var w2 = 1 - w1;
        return Color.rgb(w1 * color1.red() + w2 * color2.red(), w1 * color1.green() + w2 * color2.green(), w1 * color1.blue() + w2 * color2.blue(), color1.alpha() * p + color2.alpha() * (1 - p));
      }
    };
    Object.keys(convert).forEach(function(model) {
      if (skippedModels.indexOf(model) !== -1) {
        return;
      }
      var channels = convert[model].channels;
      Color.prototype[model] = function() {
        if (this.model === model) {
          return new Color(this);
        }
        if (arguments.length) {
          return new Color(arguments, model);
        }
        var newAlpha = typeof arguments[channels] === "number" ? channels : this.valpha;
        return new Color(assertArray(convert[this.model][model].raw(this.color)).concat(newAlpha), model);
      };
      Color[model] = function(color) {
        if (typeof color === "number") {
          color = zeroArray(_slice.call(arguments), channels);
        }
        return new Color(color, model);
      };
    });
    function roundTo(num, places) {
      return Number(num.toFixed(places));
    }
    function roundToPlace(places) {
      return function(num) {
        return roundTo(num, places);
      };
    }
    function getset(model, channel, modifier) {
      model = Array.isArray(model) ? model : [model];
      model.forEach(function(m) {
        (limiters[m] || (limiters[m] = []))[channel] = modifier;
      });
      model = model[0];
      return function(val) {
        var result2;
        if (arguments.length) {
          if (modifier) {
            val = modifier(val);
          }
          result2 = this[model]();
          result2.color[channel] = val;
          return result2;
        }
        result2 = this[model]().color[channel];
        if (modifier) {
          result2 = modifier(result2);
        }
        return result2;
      };
    }
    function maxfn(max) {
      return function(v) {
        return Math.max(0, Math.min(max, v));
      };
    }
    function assertArray(val) {
      return Array.isArray(val) ? val : [val];
    }
    function zeroArray(arr, length) {
      for (var i = 0; i < length; i++) {
        if (typeof arr[i] !== "number") {
          arr[i] = 0;
        }
      }
      return arr;
    }
    module2.exports = Color;
  }
});

// ../../node_modules/text-hex/index.js
var require_text_hex = __commonJS({
  "../../node_modules/text-hex/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function hex(str) {
      for (var i = 0, hash = 0; i < str.length; hash = str.charCodeAt(i++) + ((hash << 5) - hash))
        ;
      var color = Math.floor(Math.abs(Math.sin(hash) * 1e4 % 1 * 16777216)).toString(16);
      return "#" + Array(6 - color.length + 1).join("0") + color;
    };
  }
});

// ../../node_modules/colorspace/index.js
var require_colorspace = __commonJS({
  "../../node_modules/colorspace/index.js"(exports2, module2) {
    "use strict";
    var color = require_color();
    var hex = require_text_hex();
    module2.exports = function colorspace(namespace, delimiter) {
      var split = namespace.split(delimiter || ":");
      var base = hex(split[0]);
      if (!split.length)
        return base;
      for (var i = 0, l = split.length - 1; i < l; i++) {
        base = color(base).mix(color(hex(split[i + 1]))).saturate(1).hex();
      }
      return base;
    };
  }
});

// ../../node_modules/kuler/index.js
var require_kuler = __commonJS({
  "../../node_modules/kuler/index.js"(exports2, module2) {
    "use strict";
    function Kuler(text, color) {
      if (color)
        return new Kuler(text).style(color);
      if (!(this instanceof Kuler))
        return new Kuler(text);
      this.text = text;
    }
    Kuler.prototype.prefix = "\x1B[";
    Kuler.prototype.suffix = "m";
    Kuler.prototype.hex = function hex(color) {
      color = color[0] === "#" ? color.substring(1) : color;
      if (color.length === 3) {
        color = color.split("");
        color[5] = color[2];
        color[4] = color[2];
        color[3] = color[1];
        color[2] = color[1];
        color[1] = color[0];
        color = color.join("");
      }
      var r = color.substring(0, 2), g = color.substring(2, 4), b = color.substring(4, 6);
      return [parseInt(r, 16), parseInt(g, 16), parseInt(b, 16)];
    };
    Kuler.prototype.rgb = function rgb(r, g, b) {
      var red = r / 255 * 5, green = g / 255 * 5, blue = b / 255 * 5;
      return this.ansi(red, green, blue);
    };
    Kuler.prototype.ansi = function ansi(r, g, b) {
      var red = Math.round(r), green = Math.round(g), blue = Math.round(b);
      return 16 + red * 36 + green * 6 + blue;
    };
    Kuler.prototype.reset = function reset() {
      return this.prefix + "39;49" + this.suffix;
    };
    Kuler.prototype.style = function style(color) {
      return this.prefix + "38;5;" + this.rgb.apply(this, this.hex(color)) + this.suffix + this.text + this.reset();
    };
    module2.exports = Kuler;
  }
});

// ../../node_modules/@dabh/diagnostics/modifiers/namespace-ansi.js
var require_namespace_ansi = __commonJS({
  "../../node_modules/@dabh/diagnostics/modifiers/namespace-ansi.js"(exports2, module2) {
    var colorspace = require_colorspace();
    var kuler = require_kuler();
    module2.exports = function ansiModifier(args, options2) {
      var namespace = options2.namespace;
      var ansi = options2.colors !== false ? kuler(namespace + ":", colorspace(namespace)) : namespace + ":";
      args[0] = ansi + " " + args[0];
      return args;
    };
  }
});

// ../../node_modules/enabled/index.js
var require_enabled = __commonJS({
  "../../node_modules/enabled/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function enabled(name, variable) {
      if (!variable)
        return false;
      var variables = variable.split(/[\s,]+/), i = 0;
      for (; i < variables.length; i++) {
        variable = variables[i].replace("*", ".*?");
        if ("-" === variable.charAt(0)) {
          if (new RegExp("^" + variable.substr(1) + "$").test(name)) {
            return false;
          }
          continue;
        }
        if (new RegExp("^" + variable + "$").test(name)) {
          return true;
        }
      }
      return false;
    };
  }
});

// ../../node_modules/@dabh/diagnostics/adapters/index.js
var require_adapters = __commonJS({
  "../../node_modules/@dabh/diagnostics/adapters/index.js"(exports2, module2) {
    var enabled = require_enabled();
    module2.exports = function create(fn) {
      return function adapter(namespace) {
        try {
          return enabled(namespace, fn());
        } catch (e) {
        }
        return false;
      };
    };
  }
});

// ../../node_modules/@dabh/diagnostics/adapters/process.env.js
var require_process_env = __commonJS({
  "../../node_modules/@dabh/diagnostics/adapters/process.env.js"(exports2, module2) {
    var adapter = require_adapters();
    module2.exports = adapter(function processenv() {
      return process.env.DEBUG || process.env.DIAGNOSTICS;
    });
  }
});

// ../../node_modules/@dabh/diagnostics/logger/console.js
var require_console2 = __commonJS({
  "../../node_modules/@dabh/diagnostics/logger/console.js"(exports2, module2) {
    module2.exports = function(meta, messages) {
      try {
        Function.prototype.apply.call(console.log, console, messages);
      } catch (e) {
      }
    };
  }
});

// ../../node_modules/@dabh/diagnostics/node/development.js
var require_development = __commonJS({
  "../../node_modules/@dabh/diagnostics/node/development.js"(exports2, module2) {
    var create = require_diagnostics();
    var tty = require("tty").isatty(1);
    var diagnostics = create(function dev(namespace, options2) {
      options2 = options2 || {};
      options2.colors = "colors" in options2 ? options2.colors : tty;
      options2.namespace = namespace;
      options2.prod = false;
      options2.dev = true;
      if (!dev.enabled(namespace) && !(options2.force || dev.force)) {
        return dev.nope(options2);
      }
      return dev.yep(options2);
    });
    diagnostics.modify(require_namespace_ansi());
    diagnostics.use(require_process_env());
    diagnostics.set(require_console2());
    module2.exports = diagnostics;
  }
});

// ../../node_modules/@dabh/diagnostics/node/index.js
var require_node4 = __commonJS({
  "../../node_modules/@dabh/diagnostics/node/index.js"(exports2, module2) {
    if (process.env.NODE_ENV === "production") {
      module2.exports = require_production();
    } else {
      module2.exports = require_development();
    }
  }
});

// ../../node_modules/winston/lib/winston/tail-file.js
var require_tail_file = __commonJS({
  "../../node_modules/winston/lib/winston/tail-file.js"(exports2, module2) {
    "use strict";
    var fs2 = require("fs");
    var { StringDecoder } = require("string_decoder");
    var { Stream } = require_readable();
    function noop3() {
    }
    module2.exports = (options2, iter) => {
      const buffer = Buffer.alloc(64 * 1024);
      const decode = new StringDecoder("utf8");
      const stream = new Stream();
      let buff = "";
      let pos = 0;
      let row = 0;
      if (options2.start === -1) {
        delete options2.start;
      }
      stream.readable = true;
      stream.destroy = () => {
        stream.destroyed = true;
        stream.emit("end");
        stream.emit("close");
      };
      fs2.open(options2.file, "a+", "0644", (err, fd) => {
        if (err) {
          if (!iter) {
            stream.emit("error", err);
          } else {
            iter(err);
          }
          stream.destroy();
          return;
        }
        (function read() {
          if (stream.destroyed) {
            fs2.close(fd, noop3);
            return;
          }
          return fs2.read(fd, buffer, 0, buffer.length, pos, (error3, bytes) => {
            if (error3) {
              if (!iter) {
                stream.emit("error", error3);
              } else {
                iter(error3);
              }
              stream.destroy();
              return;
            }
            if (!bytes) {
              if (buff) {
                if (options2.start == null || row > options2.start) {
                  if (!iter) {
                    stream.emit("line", buff);
                  } else {
                    iter(null, buff);
                  }
                }
                row++;
                buff = "";
              }
              return setTimeout(read, 1e3);
            }
            let data2 = decode.write(buffer.slice(0, bytes));
            if (!iter) {
              stream.emit("data", data2);
            }
            data2 = (buff + data2).split(/\n+/);
            const l = data2.length - 1;
            let i = 0;
            for (; i < l; i++) {
              if (options2.start == null || row > options2.start) {
                if (!iter) {
                  stream.emit("line", data2[i]);
                } else {
                  iter(null, data2[i]);
                }
              }
              row++;
            }
            buff = data2[l];
            pos += bytes;
            return read();
          });
        })();
      });
      if (!iter) {
        return stream;
      }
      return stream.destroy;
    };
  }
});

// ../../node_modules/winston/lib/winston/transports/file.js
var require_file4 = __commonJS({
  "../../node_modules/winston/lib/winston/transports/file.js"(exports2, module2) {
    "use strict";
    var fs2 = require("fs");
    var path = require("path");
    var asyncSeries = require_series();
    var zlib = require("zlib");
    var { MESSAGE } = require_triple_beam();
    var { Stream, PassThrough } = require_readable();
    var TransportStream = require_winston_transport();
    var debug = require_node4()("winston:file");
    var os = require("os");
    var tailFile = require_tail_file();
    module2.exports = class File extends TransportStream {
      constructor(options2 = {}) {
        super(options2);
        this.name = options2.name || "file";
        function throwIf(target, ...args) {
          args.slice(1).forEach((name) => {
            if (options2[name]) {
              throw new Error(`Cannot set ${name} and ${target} together`);
            }
          });
        }
        this._stream = new PassThrough();
        this._stream.setMaxListeners(30);
        this._onError = this._onError.bind(this);
        if (options2.filename || options2.dirname) {
          throwIf("filename or dirname", "stream");
          this._basename = this.filename = options2.filename ? path.basename(options2.filename) : "winston.log";
          this.dirname = options2.dirname || path.dirname(options2.filename);
          this.options = options2.options || { flags: "a" };
        } else if (options2.stream) {
          console.warn("options.stream will be removed in winston@4. Use winston.transports.Stream");
          throwIf("stream", "filename", "maxsize");
          this._dest = this._stream.pipe(this._setupStream(options2.stream));
          this.dirname = path.dirname(this._dest.path);
        } else {
          throw new Error("Cannot log to file without filename or stream.");
        }
        this.maxsize = options2.maxsize || null;
        this.rotationFormat = options2.rotationFormat || false;
        this.zippedArchive = options2.zippedArchive || false;
        this.maxFiles = options2.maxFiles || null;
        this.eol = options2.eol || os.EOL;
        this.tailable = options2.tailable || false;
        this._size = 0;
        this._pendingSize = 0;
        this._created = 0;
        this._drain = false;
        this._opening = false;
        this._ending = false;
        if (this.dirname)
          this._createLogDirIfNotExist(this.dirname);
        this.open();
      }
      finishIfEnding() {
        if (this._ending) {
          if (this._opening) {
            this.once("open", () => {
              this._stream.once("finish", () => this.emit("finish"));
              setImmediate(() => this._stream.end());
            });
          } else {
            this._stream.once("finish", () => this.emit("finish"));
            setImmediate(() => this._stream.end());
          }
        }
      }
      log(info, callback = () => {
      }) {
        if (this.silent) {
          callback();
          return true;
        }
        if (this._drain) {
          this._stream.once("drain", () => {
            this._drain = false;
            this.log(info, callback);
          });
          return;
        }
        if (this._rotate) {
          this._stream.once("rotate", () => {
            this._rotate = false;
            this.log(info, callback);
          });
          return;
        }
        const output3 = `${info[MESSAGE]}${this.eol}`;
        const bytes = Buffer.byteLength(output3);
        function logged() {
          this._size += bytes;
          this._pendingSize -= bytes;
          debug("logged %s %s", this._size, output3);
          this.emit("logged", info);
          if (this._opening) {
            return;
          }
          if (!this._needsNewFile()) {
            return;
          }
          this._rotate = true;
          this._endStream(() => this._rotateFile());
        }
        this._pendingSize += bytes;
        if (this._opening && !this.rotatedWhileOpening && this._needsNewFile(this._size + this._pendingSize)) {
          this.rotatedWhileOpening = true;
        }
        const written = this._stream.write(output3, logged.bind(this));
        if (!written) {
          this._drain = true;
          this._stream.once("drain", () => {
            this._drain = false;
            callback();
          });
        } else {
          callback();
        }
        debug("written", written, this._drain);
        this.finishIfEnding();
        return written;
      }
      query(options2, callback) {
        if (typeof options2 === "function") {
          callback = options2;
          options2 = {};
        }
        options2 = normalizeQuery(options2);
        const file = path.join(this.dirname, this.filename);
        let buff = "";
        let results = [];
        let row = 0;
        const stream = fs2.createReadStream(file, {
          encoding: "utf8"
        });
        stream.on("error", (err) => {
          if (stream.readable) {
            stream.destroy();
          }
          if (!callback) {
            return;
          }
          return err.code !== "ENOENT" ? callback(err) : callback(null, results);
        });
        stream.on("data", (data2) => {
          data2 = (buff + data2).split(/\n+/);
          const l = data2.length - 1;
          let i = 0;
          for (; i < l; i++) {
            if (!options2.start || row >= options2.start) {
              add(data2[i]);
            }
            row++;
          }
          buff = data2[l];
        });
        stream.on("close", () => {
          if (buff) {
            add(buff, true);
          }
          if (options2.order === "desc") {
            results = results.reverse();
          }
          if (callback)
            callback(null, results);
        });
        function add(buff2, attempt) {
          try {
            const log4 = JSON.parse(buff2);
            if (check(log4)) {
              push(log4);
            }
          } catch (e) {
            if (!attempt) {
              stream.emit("error", e);
            }
          }
        }
        function push(log4) {
          if (options2.rows && results.length >= options2.rows && options2.order !== "desc") {
            if (stream.readable) {
              stream.destroy();
            }
            return;
          }
          if (options2.fields) {
            log4 = options2.fields.reduce((obj, key) => {
              obj[key] = log4[key];
              return obj;
            }, {});
          }
          if (options2.order === "desc") {
            if (results.length >= options2.rows) {
              results.shift();
            }
          }
          results.push(log4);
        }
        function check(log4) {
          if (!log4) {
            return;
          }
          if (typeof log4 !== "object") {
            return;
          }
          const time = new Date(log4.timestamp);
          if (options2.from && time < options2.from || options2.until && time > options2.until || options2.level && options2.level !== log4.level) {
            return;
          }
          return true;
        }
        function normalizeQuery(options3) {
          options3 = options3 || {};
          options3.rows = options3.rows || options3.limit || 10;
          options3.start = options3.start || 0;
          options3.until = options3.until || new Date();
          if (typeof options3.until !== "object") {
            options3.until = new Date(options3.until);
          }
          options3.from = options3.from || options3.until - 24 * 60 * 60 * 1e3;
          if (typeof options3.from !== "object") {
            options3.from = new Date(options3.from);
          }
          options3.order = options3.order || "desc";
          return options3;
        }
      }
      stream(options2 = {}) {
        const file = path.join(this.dirname, this.filename);
        const stream = new Stream();
        const tail = {
          file,
          start: options2.start
        };
        stream.destroy = tailFile(tail, (err, line) => {
          if (err) {
            return stream.emit("error", err);
          }
          try {
            stream.emit("data", line);
            line = JSON.parse(line);
            stream.emit("log", line);
          } catch (e) {
            stream.emit("error", e);
          }
        });
        return stream;
      }
      open() {
        if (!this.filename)
          return;
        if (this._opening)
          return;
        this._opening = true;
        this.stat((err, size) => {
          if (err) {
            return this.emit("error", err);
          }
          debug("stat done: %s { size: %s }", this.filename, size);
          this._size = size;
          this._dest = this._createStream(this._stream);
          this._opening = false;
          this.once("open", () => {
            if (this._stream.eventNames().includes("rotate")) {
              this._stream.emit("rotate");
            } else {
              this._rotate = false;
            }
          });
        });
      }
      stat(callback) {
        const target = this._getFile();
        const fullpath = path.join(this.dirname, target);
        fs2.stat(fullpath, (err, stat) => {
          if (err && err.code === "ENOENT") {
            debug("ENOENT\xA0ok", fullpath);
            this.filename = target;
            return callback(null, 0);
          }
          if (err) {
            debug(`err ${err.code} ${fullpath}`);
            return callback(err);
          }
          if (!stat || this._needsNewFile(stat.size)) {
            return this._incFile(() => this.stat(callback));
          }
          this.filename = target;
          callback(null, stat.size);
        });
      }
      close(cb) {
        if (!this._stream) {
          return;
        }
        this._stream.end(() => {
          if (cb) {
            cb();
          }
          this.emit("flush");
          this.emit("closed");
        });
      }
      _needsNewFile(size) {
        size = size || this._size;
        return this.maxsize && size >= this.maxsize;
      }
      _onError(err) {
        this.emit("error", err);
      }
      _setupStream(stream) {
        stream.on("error", this._onError);
        return stream;
      }
      _cleanupStream(stream) {
        stream.removeListener("error", this._onError);
        return stream;
      }
      _rotateFile() {
        this._incFile(() => this.open());
      }
      _endStream(callback = () => {
      }) {
        if (this._dest) {
          this._stream.unpipe(this._dest);
          this._dest.end(() => {
            this._cleanupStream(this._dest);
            callback();
          });
        } else {
          callback();
        }
      }
      _createStream(source) {
        const fullpath = path.join(this.dirname, this.filename);
        debug("create stream start", fullpath, this.options);
        const dest = fs2.createWriteStream(fullpath, this.options).on("error", (err) => debug(err)).on("close", () => debug("close", dest.path, dest.bytesWritten)).on("open", () => {
          debug("file open ok", fullpath);
          this.emit("open", fullpath);
          source.pipe(dest);
          if (this.rotatedWhileOpening) {
            this._stream = new PassThrough();
            this._stream.setMaxListeners(30);
            this._rotateFile();
            this.rotatedWhileOpening = false;
            this._cleanupStream(dest);
            source.end();
          }
        });
        debug("create stream ok", fullpath);
        if (this.zippedArchive) {
          const gzip = zlib.createGzip();
          gzip.pipe(dest);
          return gzip;
        }
        return dest;
      }
      _incFile(callback) {
        debug("_incFile", this.filename);
        const ext = path.extname(this._basename);
        const basename = path.basename(this._basename, ext);
        if (!this.tailable) {
          this._created += 1;
          this._checkMaxFilesIncrementing(ext, basename, callback);
        } else {
          this._checkMaxFilesTailable(ext, basename, callback);
        }
      }
      _getFile() {
        const ext = path.extname(this._basename);
        const basename = path.basename(this._basename, ext);
        const isRotation = this.rotationFormat ? this.rotationFormat() : this._created;
        const target = !this.tailable && this._created ? `${basename}${isRotation}${ext}` : `${basename}${ext}`;
        return this.zippedArchive && !this.tailable ? `${target}.gz` : target;
      }
      _checkMaxFilesIncrementing(ext, basename, callback) {
        if (!this.maxFiles || this._created < this.maxFiles) {
          return setImmediate(callback);
        }
        const oldest = this._created - this.maxFiles;
        const isOldest = oldest !== 0 ? oldest : "";
        const isZipped = this.zippedArchive ? ".gz" : "";
        const filePath = `${basename}${isOldest}${ext}${isZipped}`;
        const target = path.join(this.dirname, filePath);
        fs2.unlink(target, callback);
      }
      _checkMaxFilesTailable(ext, basename, callback) {
        const tasks = [];
        if (!this.maxFiles) {
          return;
        }
        const isZipped = this.zippedArchive ? ".gz" : "";
        for (let x = this.maxFiles - 1; x > 1; x--) {
          tasks.push(function(i, cb) {
            let fileName = `${basename}${i - 1}${ext}${isZipped}`;
            const tmppath = path.join(this.dirname, fileName);
            fs2.exists(tmppath, (exists) => {
              if (!exists) {
                return cb(null);
              }
              fileName = `${basename}${i}${ext}${isZipped}`;
              fs2.rename(tmppath, path.join(this.dirname, fileName), cb);
            });
          }.bind(this, x));
        }
        asyncSeries(tasks, () => {
          fs2.rename(path.join(this.dirname, `${basename}${ext}`), path.join(this.dirname, `${basename}1${ext}${isZipped}`), callback);
        });
      }
      _createLogDirIfNotExist(dirPath) {
        if (!fs2.existsSync(dirPath)) {
          fs2.mkdirSync(dirPath, { recursive: true });
        }
      }
    };
  }
});

// ../../node_modules/winston/lib/winston/transports/http.js
var require_http2 = __commonJS({
  "../../node_modules/winston/lib/winston/transports/http.js"(exports2, module2) {
    "use strict";
    var http = require("http");
    var https = require("https");
    var { Stream } = require_readable();
    var TransportStream = require_winston_transport();
    module2.exports = class Http extends TransportStream {
      constructor(options2 = {}) {
        super(options2);
        this.options = options2;
        this.name = options2.name || "http";
        this.ssl = !!options2.ssl;
        this.host = options2.host || "localhost";
        this.port = options2.port;
        this.auth = options2.auth;
        this.path = options2.path || "";
        this.agent = options2.agent;
        this.headers = options2.headers || {};
        this.headers["content-type"] = "application/json";
        if (!this.port) {
          this.port = this.ssl ? 443 : 80;
        }
      }
      log(info, callback) {
        this._request(info, (err, res) => {
          if (res && res.statusCode !== 200) {
            err = new Error(`Invalid HTTP Status Code: ${res.statusCode}`);
          }
          if (err) {
            this.emit("warn", err);
          } else {
            this.emit("logged", info);
          }
        });
        if (callback) {
          setImmediate(callback);
        }
      }
      query(options2, callback) {
        if (typeof options2 === "function") {
          callback = options2;
          options2 = {};
        }
        options2 = {
          method: "query",
          params: this.normalizeQuery(options2)
        };
        if (options2.params.path) {
          options2.path = options2.params.path;
          delete options2.params.path;
        }
        if (options2.params.auth) {
          options2.auth = options2.params.auth;
          delete options2.params.auth;
        }
        this._request(options2, (err, res, body) => {
          if (res && res.statusCode !== 200) {
            err = new Error(`Invalid HTTP Status Code: ${res.statusCode}`);
          }
          if (err) {
            return callback(err);
          }
          if (typeof body === "string") {
            try {
              body = JSON.parse(body);
            } catch (e) {
              return callback(e);
            }
          }
          callback(null, body);
        });
      }
      stream(options2 = {}) {
        const stream = new Stream();
        options2 = {
          method: "stream",
          params: options2
        };
        if (options2.params.path) {
          options2.path = options2.params.path;
          delete options2.params.path;
        }
        if (options2.params.auth) {
          options2.auth = options2.params.auth;
          delete options2.params.auth;
        }
        let buff = "";
        const req = this._request(options2);
        stream.destroy = () => req.destroy();
        req.on("data", (data2) => {
          data2 = (buff + data2).split(/\n+/);
          const l = data2.length - 1;
          let i = 0;
          for (; i < l; i++) {
            try {
              stream.emit("log", JSON.parse(data2[i]));
            } catch (e) {
              stream.emit("error", e);
            }
          }
          buff = data2[l];
        });
        req.on("error", (err) => stream.emit("error", err));
        return stream;
      }
      _request(options2, callback) {
        options2 = options2 || {};
        const auth = options2.auth || this.auth;
        const path = options2.path || this.path || "";
        delete options2.auth;
        delete options2.path;
        const headers = Object.assign({}, this.headers);
        if (auth && auth.bearer) {
          headers.Authorization = `Bearer ${auth.bearer}`;
        }
        const req = (this.ssl ? https : http).request({
          ...this.options,
          method: "POST",
          host: this.host,
          port: this.port,
          path: `/${path.replace(/^\//, "")}`,
          headers,
          auth: auth && auth.username && auth.password ? `${auth.username}:${auth.password}` : "",
          agent: this.agent
        });
        req.on("error", callback);
        req.on("response", (res) => res.on("end", () => callback(null, res)).resume());
        req.end(Buffer.from(JSON.stringify(options2), "utf8"));
      }
    };
  }
});

// ../../node_modules/is-stream/index.js
var require_is_stream = __commonJS({
  "../../node_modules/is-stream/index.js"(exports2, module2) {
    "use strict";
    var isStream = (stream) => stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
    isStream.writable = (stream) => isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
    isStream.readable = (stream) => isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
    isStream.duplex = (stream) => isStream.writable(stream) && isStream.readable(stream);
    isStream.transform = (stream) => isStream.duplex(stream) && typeof stream._transform === "function" && typeof stream._transformState === "object";
    module2.exports = isStream;
  }
});

// ../../node_modules/winston/lib/winston/transports/stream.js
var require_stream3 = __commonJS({
  "../../node_modules/winston/lib/winston/transports/stream.js"(exports2, module2) {
    "use strict";
    var isStream = require_is_stream();
    var { MESSAGE } = require_triple_beam();
    var os = require("os");
    var TransportStream = require_winston_transport();
    module2.exports = class Stream extends TransportStream {
      constructor(options2 = {}) {
        super(options2);
        if (!options2.stream || !isStream(options2.stream)) {
          throw new Error("options.stream is required.");
        }
        this._stream = options2.stream;
        this._stream.setMaxListeners(Infinity);
        this.isObjectMode = options2.stream._writableState.objectMode;
        this.eol = options2.eol || os.EOL;
      }
      log(info, callback) {
        setImmediate(() => this.emit("logged", info));
        if (this.isObjectMode) {
          this._stream.write(info);
          if (callback) {
            callback();
          }
          return;
        }
        this._stream.write(`${info[MESSAGE]}${this.eol}`);
        if (callback) {
          callback();
        }
        return;
      }
    };
  }
});

// ../../node_modules/winston/lib/winston/transports/index.js
var require_transports2 = __commonJS({
  "../../node_modules/winston/lib/winston/transports/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "Console", {
      configurable: true,
      enumerable: true,
      get() {
        return require_console();
      }
    });
    Object.defineProperty(exports2, "File", {
      configurable: true,
      enumerable: true,
      get() {
        return require_file4();
      }
    });
    Object.defineProperty(exports2, "Http", {
      configurable: true,
      enumerable: true,
      get() {
        return require_http2();
      }
    });
    Object.defineProperty(exports2, "Stream", {
      configurable: true,
      enumerable: true,
      get() {
        return require_stream3();
      }
    });
  }
});

// ../../node_modules/winston/lib/winston/config/index.js
var require_config3 = __commonJS({
  "../../node_modules/winston/lib/winston/config/index.js"(exports2) {
    "use strict";
    var logform = require_logform();
    var { configs } = require_triple_beam();
    exports2.cli = logform.levels(configs.cli);
    exports2.npm = logform.levels(configs.npm);
    exports2.syslog = logform.levels(configs.syslog);
    exports2.addColors = logform.levels;
  }
});

// ../../node_modules/winston/node_modules/async/eachOf.js
var require_eachOf = __commonJS({
  "../../node_modules/winston/node_modules/async/eachOf.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _isArrayLike = require_isArrayLike2();
    var _isArrayLike2 = _interopRequireDefault2(_isArrayLike);
    var _breakLoop = require_breakLoop();
    var _breakLoop2 = _interopRequireDefault2(_breakLoop);
    var _eachOfLimit = require_eachOfLimit2();
    var _eachOfLimit2 = _interopRequireDefault2(_eachOfLimit);
    var _once = require_once();
    var _once2 = _interopRequireDefault2(_once);
    var _onlyOnce = require_onlyOnce();
    var _onlyOnce2 = _interopRequireDefault2(_onlyOnce);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault2(_wrapAsync);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault2(_awaitify);
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachOfArrayLike(coll, iteratee, callback) {
      callback = (0, _once2.default)(callback);
      var index = 0, completed = 0, { length } = coll, canceled = false;
      if (length === 0) {
        callback(null);
      }
      function iteratorCallback(err, value) {
        if (err === false) {
          canceled = true;
        }
        if (canceled === true)
          return;
        if (err) {
          callback(err);
        } else if (++completed === length || value === _breakLoop2.default) {
          callback(null);
        }
      }
      for (; index < length; index++) {
        iteratee(coll[index], index, (0, _onlyOnce2.default)(iteratorCallback));
      }
    }
    function eachOfGeneric(coll, iteratee, callback) {
      return (0, _eachOfLimit2.default)(coll, Infinity, iteratee, callback);
    }
    function eachOf(coll, iteratee, callback) {
      var eachOfImplementation = (0, _isArrayLike2.default)(coll) ? eachOfArrayLike : eachOfGeneric;
      return eachOfImplementation(coll, (0, _wrapAsync2.default)(iteratee), callback);
    }
    exports2.default = (0, _awaitify2.default)(eachOf, 3);
    module2.exports = exports2["default"];
  }
});

// ../../node_modules/winston/node_modules/async/internal/withoutIndex.js
var require_withoutIndex = __commonJS({
  "../../node_modules/winston/node_modules/async/internal/withoutIndex.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = _withoutIndex;
    function _withoutIndex(iteratee) {
      return (value, index, callback) => iteratee(value, callback);
    }
    module2.exports = exports2["default"];
  }
});

// ../../node_modules/winston/node_modules/async/forEach.js
var require_forEach = __commonJS({
  "../../node_modules/winston/node_modules/async/forEach.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _eachOf = require_eachOf();
    var _eachOf2 = _interopRequireDefault2(_eachOf);
    var _withoutIndex = require_withoutIndex();
    var _withoutIndex2 = _interopRequireDefault2(_withoutIndex);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault2(_wrapAsync);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault2(_awaitify);
    function _interopRequireDefault2(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachLimit(coll, iteratee, callback) {
      return (0, _eachOf2.default)(coll, (0, _withoutIndex2.default)((0, _wrapAsync2.default)(iteratee)), callback);
    }
    exports2.default = (0, _awaitify2.default)(eachLimit, 3);
    module2.exports = exports2["default"];
  }
});

// ../../node_modules/fn.name/index.js
var require_fn = __commonJS({
  "../../node_modules/fn.name/index.js"(exports2, module2) {
    "use strict";
    var toString = Object.prototype.toString;
    module2.exports = function name(fn) {
      if ("string" === typeof fn.displayName && fn.constructor.name) {
        return fn.displayName;
      } else if ("string" === typeof fn.name && fn.name) {
        return fn.name;
      }
      if ("object" === typeof fn && fn.constructor && "string" === typeof fn.constructor.name)
        return fn.constructor.name;
      var named = fn.toString(), type = toString.call(fn).slice(8, -1);
      if ("Function" === type) {
        named = named.substring(named.indexOf("(") + 1, named.indexOf(")"));
      } else {
        named = type;
      }
      return named || "anonymous";
    };
  }
});

// ../../node_modules/one-time/index.js
var require_one_time = __commonJS({
  "../../node_modules/one-time/index.js"(exports2, module2) {
    "use strict";
    var name = require_fn();
    module2.exports = function one(fn) {
      var called = 0, value;
      function onetime() {
        if (called)
          return value;
        called = 1;
        value = fn.apply(this, arguments);
        fn = null;
        return value;
      }
      onetime.displayName = name(fn);
      return onetime;
    };
  }
});

// ../../node_modules/stack-trace/lib/stack-trace.js
var require_stack_trace = __commonJS({
  "../../node_modules/stack-trace/lib/stack-trace.js"(exports2) {
    exports2.get = function(belowFn) {
      var oldLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = Infinity;
      var dummyObject = {};
      var v8Handler = Error.prepareStackTrace;
      Error.prepareStackTrace = function(dummyObject2, v8StackTrace2) {
        return v8StackTrace2;
      };
      Error.captureStackTrace(dummyObject, belowFn || exports2.get);
      var v8StackTrace = dummyObject.stack;
      Error.prepareStackTrace = v8Handler;
      Error.stackTraceLimit = oldLimit;
      return v8StackTrace;
    };
    exports2.parse = function(err) {
      if (!err.stack) {
        return [];
      }
      var self2 = this;
      var lines = err.stack.split("\n").slice(1);
      return lines.map(function(line) {
        if (line.match(/^\s*[-]{4,}$/)) {
          return self2._createParsedCallSite({
            fileName: line,
            lineNumber: null,
            functionName: null,
            typeName: null,
            methodName: null,
            columnNumber: null,
            "native": null
          });
        }
        var lineMatch = line.match(/at (?:(.+)\s+\()?(?:(.+?):(\d+)(?::(\d+))?|([^)]+))\)?/);
        if (!lineMatch) {
          return;
        }
        var object = null;
        var method = null;
        var functionName = null;
        var typeName = null;
        var methodName = null;
        var isNative = lineMatch[5] === "native";
        if (lineMatch[1]) {
          functionName = lineMatch[1];
          var methodStart = functionName.lastIndexOf(".");
          if (functionName[methodStart - 1] == ".")
            methodStart--;
          if (methodStart > 0) {
            object = functionName.substr(0, methodStart);
            method = functionName.substr(methodStart + 1);
            var objectEnd = object.indexOf(".Module");
            if (objectEnd > 0) {
              functionName = functionName.substr(objectEnd + 1);
              object = object.substr(0, objectEnd);
            }
          }
          typeName = null;
        }
        if (method) {
          typeName = object;
          methodName = method;
        }
        if (method === "<anonymous>") {
          methodName = null;
          functionName = null;
        }
        var properties = {
          fileName: lineMatch[2] || null,
          lineNumber: parseInt(lineMatch[3], 10) || null,
          functionName,
          typeName,
          methodName,
          columnNumber: parseInt(lineMatch[4], 10) || null,
          "native": isNative
        };
        return self2._createParsedCallSite(properties);
      }).filter(function(callSite) {
        return !!callSite;
      });
    };
    function CallSite(properties) {
      for (var property in properties) {
        this[property] = properties[property];
      }
    }
    var strProperties = [
      "this",
      "typeName",
      "functionName",
      "methodName",
      "fileName",
      "lineNumber",
      "columnNumber",
      "function",
      "evalOrigin"
    ];
    var boolProperties = [
      "topLevel",
      "eval",
      "native",
      "constructor"
    ];
    strProperties.forEach(function(property) {
      CallSite.prototype[property] = null;
      CallSite.prototype["get" + property[0].toUpperCase() + property.substr(1)] = function() {
        return this[property];
      };
    });
    boolProperties.forEach(function(property) {
      CallSite.prototype[property] = false;
      CallSite.prototype["is" + property[0].toUpperCase() + property.substr(1)] = function() {
        return this[property];
      };
    });
    exports2._createParsedCallSite = function(properties) {
      return new CallSite(properties);
    };
  }
});

// ../../node_modules/winston/lib/winston/exception-stream.js
var require_exception_stream = __commonJS({
  "../../node_modules/winston/lib/winston/exception-stream.js"(exports2, module2) {
    "use strict";
    var { Writable } = require_readable();
    module2.exports = class ExceptionStream extends Writable {
      constructor(transport) {
        super({ objectMode: true });
        if (!transport) {
          throw new Error("ExceptionStream requires a TransportStream instance.");
        }
        this.handleExceptions = true;
        this.transport = transport;
      }
      _write(info, enc, callback) {
        if (info.exception) {
          return this.transport.log(info, callback);
        }
        callback();
        return true;
      }
    };
  }
});

// ../../node_modules/winston/lib/winston/exception-handler.js
var require_exception_handler = __commonJS({
  "../../node_modules/winston/lib/winston/exception-handler.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var asyncForEach = require_forEach();
    var debug = require_node4()("winston:exception");
    var once = require_one_time();
    var stackTrace = require_stack_trace();
    var ExceptionStream = require_exception_stream();
    module2.exports = class ExceptionHandler {
      constructor(logger) {
        if (!logger) {
          throw new Error("Logger is required to handle exceptions");
        }
        this.logger = logger;
        this.handlers = /* @__PURE__ */ new Map();
      }
      handle(...args) {
        args.forEach((arg) => {
          if (Array.isArray(arg)) {
            return arg.forEach((handler) => this._addHandler(handler));
          }
          this._addHandler(arg);
        });
        if (!this.catcher) {
          this.catcher = this._uncaughtException.bind(this);
          process.on("uncaughtException", this.catcher);
        }
      }
      unhandle() {
        if (this.catcher) {
          process.removeListener("uncaughtException", this.catcher);
          this.catcher = false;
          Array.from(this.handlers.values()).forEach((wrapper) => this.logger.unpipe(wrapper));
        }
      }
      getAllInfo(err) {
        let { message } = err;
        if (!message && typeof err === "string") {
          message = err;
        }
        return {
          error: err,
          level: "error",
          message: [
            `uncaughtException: ${message || "(no error message)"}`,
            err.stack || "  No stack trace"
          ].join("\n"),
          stack: err.stack,
          exception: true,
          date: new Date().toString(),
          process: this.getProcessInfo(),
          os: this.getOsInfo(),
          trace: this.getTrace(err)
        };
      }
      getProcessInfo() {
        return {
          pid: process.pid,
          uid: process.getuid ? process.getuid() : null,
          gid: process.getgid ? process.getgid() : null,
          cwd: process.cwd(),
          execPath: process.execPath,
          version: process.version,
          argv: process.argv,
          memoryUsage: process.memoryUsage()
        };
      }
      getOsInfo() {
        return {
          loadavg: os.loadavg(),
          uptime: os.uptime()
        };
      }
      getTrace(err) {
        const trace = err ? stackTrace.parse(err) : stackTrace.get();
        return trace.map((site) => {
          return {
            column: site.getColumnNumber(),
            file: site.getFileName(),
            function: site.getFunctionName(),
            line: site.getLineNumber(),
            method: site.getMethodName(),
            native: site.isNative()
          };
        });
      }
      _addHandler(handler) {
        if (!this.handlers.has(handler)) {
          handler.handleExceptions = true;
          const wrapper = new ExceptionStream(handler);
          this.handlers.set(handler, wrapper);
          this.logger.pipe(wrapper);
        }
      }
      _uncaughtException(err) {
        const info = this.getAllInfo(err);
        const handlers = this._getExceptionHandlers();
        let doExit = typeof this.logger.exitOnError === "function" ? this.logger.exitOnError(err) : this.logger.exitOnError;
        let timeout;
        if (!handlers.length && doExit) {
          console.warn("winston: exitOnError cannot be true with no exception handlers.");
          console.warn("winston: not exiting process.");
          doExit = false;
        }
        function gracefulExit() {
          debug("doExit", doExit);
          debug("process._exiting", process._exiting);
          if (doExit && !process._exiting) {
            if (timeout) {
              clearTimeout(timeout);
            }
            process.exit(1);
          }
        }
        if (!handlers || handlers.length === 0) {
          return process.nextTick(gracefulExit);
        }
        asyncForEach(handlers, (handler, next) => {
          const done = once(next);
          const transport = handler.transport || handler;
          function onDone(event) {
            return () => {
              debug(event);
              done();
            };
          }
          transport._ending = true;
          transport.once("finish", onDone("finished"));
          transport.once("error", onDone("error"));
        }, () => doExit && gracefulExit());
        this.logger.log(info);
        if (doExit) {
          timeout = setTimeout(gracefulExit, 3e3);
        }
      }
      _getExceptionHandlers() {
        return this.logger.transports.filter((wrap) => {
          const transport = wrap.transport || wrap;
          return transport.handleExceptions;
        });
      }
    };
  }
});

// ../../node_modules/winston/lib/winston/rejection-handler.js
var require_rejection_handler = __commonJS({
  "../../node_modules/winston/lib/winston/rejection-handler.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var asyncForEach = require_forEach();
    var debug = require_node4()("winston:rejection");
    var once = require_one_time();
    var stackTrace = require_stack_trace();
    var ExceptionStream = require_exception_stream();
    module2.exports = class RejectionHandler {
      constructor(logger) {
        if (!logger) {
          throw new Error("Logger is required to handle rejections");
        }
        this.logger = logger;
        this.handlers = /* @__PURE__ */ new Map();
      }
      handle(...args) {
        args.forEach((arg) => {
          if (Array.isArray(arg)) {
            return arg.forEach((handler) => this._addHandler(handler));
          }
          this._addHandler(arg);
        });
        if (!this.catcher) {
          this.catcher = this._unhandledRejection.bind(this);
          process.on("unhandledRejection", this.catcher);
        }
      }
      unhandle() {
        if (this.catcher) {
          process.removeListener("unhandledRejection", this.catcher);
          this.catcher = false;
          Array.from(this.handlers.values()).forEach((wrapper) => this.logger.unpipe(wrapper));
        }
      }
      getAllInfo(err) {
        let { message } = err;
        if (!message && typeof err === "string") {
          message = err;
        }
        return {
          error: err,
          level: "error",
          message: [
            `unhandledRejection: ${message || "(no error message)"}`,
            err.stack || "  No stack trace"
          ].join("\n"),
          stack: err.stack,
          exception: true,
          date: new Date().toString(),
          process: this.getProcessInfo(),
          os: this.getOsInfo(),
          trace: this.getTrace(err)
        };
      }
      getProcessInfo() {
        return {
          pid: process.pid,
          uid: process.getuid ? process.getuid() : null,
          gid: process.getgid ? process.getgid() : null,
          cwd: process.cwd(),
          execPath: process.execPath,
          version: process.version,
          argv: process.argv,
          memoryUsage: process.memoryUsage()
        };
      }
      getOsInfo() {
        return {
          loadavg: os.loadavg(),
          uptime: os.uptime()
        };
      }
      getTrace(err) {
        const trace = err ? stackTrace.parse(err) : stackTrace.get();
        return trace.map((site) => {
          return {
            column: site.getColumnNumber(),
            file: site.getFileName(),
            function: site.getFunctionName(),
            line: site.getLineNumber(),
            method: site.getMethodName(),
            native: site.isNative()
          };
        });
      }
      _addHandler(handler) {
        if (!this.handlers.has(handler)) {
          handler.handleRejections = true;
          const wrapper = new ExceptionStream(handler);
          this.handlers.set(handler, wrapper);
          this.logger.pipe(wrapper);
        }
      }
      _unhandledRejection(err) {
        const info = this.getAllInfo(err);
        const handlers = this._getRejectionHandlers();
        let doExit = typeof this.logger.exitOnError === "function" ? this.logger.exitOnError(err) : this.logger.exitOnError;
        let timeout;
        if (!handlers.length && doExit) {
          console.warn("winston: exitOnError cannot be true with no rejection handlers.");
          console.warn("winston: not exiting process.");
          doExit = false;
        }
        function gracefulExit() {
          debug("doExit", doExit);
          debug("process._exiting", process._exiting);
          if (doExit && !process._exiting) {
            if (timeout) {
              clearTimeout(timeout);
            }
            process.exit(1);
          }
        }
        if (!handlers || handlers.length === 0) {
          return process.nextTick(gracefulExit);
        }
        asyncForEach(handlers, (handler, next) => {
          const done = once(next);
          const transport = handler.transport || handler;
          function onDone(event) {
            return () => {
              debug(event);
              done();
            };
          }
          transport._ending = true;
          transport.once("finish", onDone("finished"));
          transport.once("error", onDone("error"));
        }, () => doExit && gracefulExit());
        this.logger.log(info);
        if (doExit) {
          timeout = setTimeout(gracefulExit, 3e3);
        }
      }
      _getRejectionHandlers() {
        return this.logger.transports.filter((wrap) => {
          const transport = wrap.transport || wrap;
          return transport.handleRejections;
        });
      }
    };
  }
});

// ../../node_modules/winston/lib/winston/profiler.js
var require_profiler = __commonJS({
  "../../node_modules/winston/lib/winston/profiler.js"(exports2, module2) {
    "use strict";
    module2.exports = class Profiler {
      constructor(logger) {
        if (!logger) {
          throw new Error("Logger is required for profiling.");
        }
        this.logger = logger;
        this.start = Date.now();
      }
      done(...args) {
        if (typeof args[args.length - 1] === "function") {
          console.warn("Callback function no longer supported as of winston@3.0.0");
          args.pop();
        }
        const info = typeof args[args.length - 1] === "object" ? args.pop() : {};
        info.level = info.level || "info";
        info.durationMs = Date.now() - this.start;
        return this.logger.write(info);
      }
    };
  }
});

// ../../node_modules/winston/lib/winston/logger.js
var require_logger = __commonJS({
  "../../node_modules/winston/lib/winston/logger.js"(exports2, module2) {
    "use strict";
    var { Stream, Transform } = require_readable();
    var asyncForEach = require_forEach();
    var { LEVEL, SPLAT } = require_triple_beam();
    var isStream = require_is_stream();
    var ExceptionHandler = require_exception_handler();
    var RejectionHandler = require_rejection_handler();
    var LegacyTransportStream = require_legacy();
    var Profiler = require_profiler();
    var { warn: warn3 } = require_common6();
    var config = require_config3();
    var formatRegExp = /%[scdjifoO%]/g;
    var Logger3 = class extends Transform {
      constructor(options2) {
        super({ objectMode: true });
        this.configure(options2);
      }
      child(defaultRequestMetadata) {
        const logger = this;
        return Object.create(logger, {
          write: {
            value: function(info) {
              const infoClone = Object.assign({}, defaultRequestMetadata, info);
              if (info instanceof Error) {
                infoClone.stack = info.stack;
                infoClone.message = info.message;
              }
              logger.write(infoClone);
            }
          }
        });
      }
      configure({
        silent,
        format: format2,
        defaultMeta,
        levels,
        level = "info",
        exitOnError = true,
        transports,
        colors,
        emitErrs,
        formatters,
        padLevels,
        rewriters,
        stripColors,
        exceptionHandlers,
        rejectionHandlers
      } = {}) {
        if (this.transports.length) {
          this.clear();
        }
        this.silent = silent;
        this.format = format2 || this.format || require_json()();
        this.defaultMeta = defaultMeta || null;
        this.levels = levels || this.levels || config.npm.levels;
        this.level = level;
        this.exceptions = new ExceptionHandler(this);
        this.rejections = new RejectionHandler(this);
        this.profilers = {};
        this.exitOnError = exitOnError;
        if (transports) {
          transports = Array.isArray(transports) ? transports : [transports];
          transports.forEach((transport) => this.add(transport));
        }
        if (colors || emitErrs || formatters || padLevels || rewriters || stripColors) {
          throw new Error([
            "{ colors, emitErrs, formatters, padLevels, rewriters, stripColors } were removed in winston@3.0.0.",
            "Use a custom winston.format(function) instead.",
            "See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md"
          ].join("\n"));
        }
        if (exceptionHandlers) {
          this.exceptions.handle(exceptionHandlers);
        }
        if (rejectionHandlers) {
          this.rejections.handle(rejectionHandlers);
        }
      }
      isLevelEnabled(level) {
        const givenLevelValue = getLevelValue(this.levels, level);
        if (givenLevelValue === null) {
          return false;
        }
        const configuredLevelValue = getLevelValue(this.levels, this.level);
        if (configuredLevelValue === null) {
          return false;
        }
        if (!this.transports || this.transports.length === 0) {
          return configuredLevelValue >= givenLevelValue;
        }
        const index = this.transports.findIndex((transport) => {
          let transportLevelValue = getLevelValue(this.levels, transport.level);
          if (transportLevelValue === null) {
            transportLevelValue = configuredLevelValue;
          }
          return transportLevelValue >= givenLevelValue;
        });
        return index !== -1;
      }
      log(level, msg, ...splat) {
        if (arguments.length === 1) {
          level[LEVEL] = level.level;
          this._addDefaultMeta(level);
          this.write(level);
          return this;
        }
        if (arguments.length === 2) {
          if (msg && typeof msg === "object") {
            msg[LEVEL] = msg.level = level;
            this._addDefaultMeta(msg);
            this.write(msg);
            return this;
          }
          this.write({ [LEVEL]: level, level, message: msg });
          return this;
        }
        const [meta] = splat;
        if (typeof meta === "object" && meta !== null) {
          const tokens = msg && msg.match && msg.match(formatRegExp);
          if (!tokens) {
            const info = Object.assign({}, this.defaultMeta, meta, {
              [LEVEL]: level,
              [SPLAT]: splat,
              level,
              message: msg
            });
            if (meta.message)
              info.message = `${info.message} ${meta.message}`;
            if (meta.stack)
              info.stack = meta.stack;
            this.write(info);
            return this;
          }
        }
        this.write(Object.assign({}, this.defaultMeta, {
          [LEVEL]: level,
          [SPLAT]: splat,
          level,
          message: msg
        }));
        return this;
      }
      _transform(info, enc, callback) {
        if (this.silent) {
          return callback();
        }
        if (!info[LEVEL]) {
          info[LEVEL] = info.level;
        }
        if (!this.levels[info[LEVEL]] && this.levels[info[LEVEL]] !== 0) {
          console.error("[winston] Unknown logger level: %s", info[LEVEL]);
        }
        if (!this._readableState.pipes) {
          console.error("[winston] Attempt to write logs with no transports %j", info);
        }
        try {
          this.push(this.format.transform(info, this.format.options));
        } catch (ex) {
          throw ex;
        } finally {
          callback();
        }
      }
      _final(callback) {
        const transports = this.transports.slice();
        asyncForEach(transports, (transport, next) => {
          if (!transport || transport.finished)
            return setImmediate(next);
          transport.once("finish", next);
          transport.end();
        }, callback);
      }
      add(transport) {
        const target = !isStream(transport) || transport.log.length > 2 ? new LegacyTransportStream({ transport }) : transport;
        if (!target._writableState || !target._writableState.objectMode) {
          throw new Error("Transports must WritableStreams in objectMode. Set { objectMode: true }.");
        }
        this._onEvent("error", target);
        this._onEvent("warn", target);
        this.pipe(target);
        if (transport.handleExceptions) {
          this.exceptions.handle();
        }
        if (transport.handleRejections) {
          this.rejections.handle();
        }
        return this;
      }
      remove(transport) {
        if (!transport)
          return this;
        let target = transport;
        if (!isStream(transport) || transport.log.length > 2) {
          target = this.transports.filter((match) => match.transport === transport)[0];
        }
        if (target) {
          this.unpipe(target);
        }
        return this;
      }
      clear() {
        this.unpipe();
        return this;
      }
      close() {
        this.clear();
        this.emit("close");
        return this;
      }
      setLevels() {
        warn3.deprecated("setLevels");
      }
      query(options2, callback) {
        if (typeof options2 === "function") {
          callback = options2;
          options2 = {};
        }
        options2 = options2 || {};
        const results = {};
        const queryObject = Object.assign({}, options2.query || {});
        function queryTransport(transport, next) {
          if (options2.query && typeof transport.formatQuery === "function") {
            options2.query = transport.formatQuery(queryObject);
          }
          transport.query(options2, (err, res) => {
            if (err) {
              return next(err);
            }
            if (typeof transport.formatResults === "function") {
              res = transport.formatResults(res, options2.format);
            }
            next(null, res);
          });
        }
        function addResults(transport, next) {
          queryTransport(transport, (err, result2) => {
            if (next) {
              result2 = err || result2;
              if (result2) {
                results[transport.name] = result2;
              }
              next();
            }
            next = null;
          });
        }
        asyncForEach(this.transports.filter((transport) => !!transport.query), addResults, () => callback(null, results));
      }
      stream(options2 = {}) {
        const out = new Stream();
        const streams = [];
        out._streams = streams;
        out.destroy = () => {
          let i = streams.length;
          while (i--) {
            streams[i].destroy();
          }
        };
        this.transports.filter((transport) => !!transport.stream).forEach((transport) => {
          const str = transport.stream(options2);
          if (!str) {
            return;
          }
          streams.push(str);
          str.on("log", (log4) => {
            log4.transport = log4.transport || [];
            log4.transport.push(transport.name);
            out.emit("log", log4);
          });
          str.on("error", (err) => {
            err.transport = err.transport || [];
            err.transport.push(transport.name);
            out.emit("error", err);
          });
        });
        return out;
      }
      startTimer() {
        return new Profiler(this);
      }
      profile(id, ...args) {
        const time = Date.now();
        if (this.profilers[id]) {
          const timeEnd = this.profilers[id];
          delete this.profilers[id];
          if (typeof args[args.length - 2] === "function") {
            console.warn("Callback function no longer supported as of winston@3.0.0");
            args.pop();
          }
          const info = typeof args[args.length - 1] === "object" ? args.pop() : {};
          info.level = info.level || "info";
          info.durationMs = time - timeEnd;
          info.message = info.message || id;
          return this.write(info);
        }
        this.profilers[id] = time;
        return this;
      }
      handleExceptions(...args) {
        console.warn("Deprecated: .handleExceptions() will be removed in winston@4. Use .exceptions.handle()");
        this.exceptions.handle(...args);
      }
      unhandleExceptions(...args) {
        console.warn("Deprecated: .unhandleExceptions() will be removed in winston@4. Use .exceptions.unhandle()");
        this.exceptions.unhandle(...args);
      }
      cli() {
        throw new Error([
          "Logger.cli() was removed in winston@3.0.0",
          "Use a custom winston.formats.cli() instead.",
          "See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md"
        ].join("\n"));
      }
      _onEvent(event, transport) {
        function transportEvent(err) {
          if (event === "error" && !this.transports.includes(transport)) {
            this.add(transport);
          }
          this.emit(event, err, transport);
        }
        if (!transport["__winston" + event]) {
          transport["__winston" + event] = transportEvent.bind(this);
          transport.on(event, transport["__winston" + event]);
        }
      }
      _addDefaultMeta(msg) {
        if (this.defaultMeta) {
          Object.assign(msg, this.defaultMeta);
        }
      }
    };
    function getLevelValue(levels, level) {
      const value = levels[level];
      if (!value && value !== 0) {
        return null;
      }
      return value;
    }
    Object.defineProperty(Logger3.prototype, "transports", {
      configurable: false,
      enumerable: true,
      get() {
        const { pipes } = this._readableState;
        return !Array.isArray(pipes) ? [pipes].filter(Boolean) : pipes;
      }
    });
    module2.exports = Logger3;
  }
});

// ../../node_modules/winston/lib/winston/create-logger.js
var require_create_logger = __commonJS({
  "../../node_modules/winston/lib/winston/create-logger.js"(exports2, module2) {
    "use strict";
    var { LEVEL } = require_triple_beam();
    var config = require_config3();
    var Logger3 = require_logger();
    var debug = require_node4()("winston:create-logger");
    function isLevelEnabledFunctionName(level) {
      return "is" + level.charAt(0).toUpperCase() + level.slice(1) + "Enabled";
    }
    module2.exports = function(opts = {}) {
      opts.levels = opts.levels || config.npm.levels;
      class DerivedLogger extends Logger3 {
        constructor(options2) {
          super(options2);
        }
      }
      const logger = new DerivedLogger(opts);
      Object.keys(opts.levels).forEach(function(level) {
        debug('Define prototype method for "%s"', level);
        if (level === "log") {
          console.warn('Level "log" not defined: conflicts with the method "log". Use a different level name.');
          return;
        }
        DerivedLogger.prototype[level] = function(...args) {
          const self2 = this || logger;
          if (args.length === 1) {
            const [msg] = args;
            const info = msg && msg.message && msg || { message: msg };
            info.level = info[LEVEL] = level;
            self2._addDefaultMeta(info);
            self2.write(info);
            return this || logger;
          }
          if (args.length === 0) {
            self2.log(level, "");
            return self2;
          }
          return self2.log(level, ...args);
        };
        DerivedLogger.prototype[isLevelEnabledFunctionName(level)] = function() {
          return (this || logger).isLevelEnabled(level);
        };
      });
      return logger;
    };
  }
});

// ../../node_modules/winston/lib/winston/container.js
var require_container = __commonJS({
  "../../node_modules/winston/lib/winston/container.js"(exports2, module2) {
    "use strict";
    var createLogger = require_create_logger();
    module2.exports = class Container {
      constructor(options2 = {}) {
        this.loggers = /* @__PURE__ */ new Map();
        this.options = options2;
      }
      add(id, options2) {
        if (!this.loggers.has(id)) {
          options2 = Object.assign({}, options2 || this.options);
          const existing = options2.transports || this.options.transports;
          options2.transports = existing ? existing.slice() : [];
          const logger = createLogger(options2);
          logger.on("close", () => this._delete(id));
          this.loggers.set(id, logger);
        }
        return this.loggers.get(id);
      }
      get(id, options2) {
        return this.add(id, options2);
      }
      has(id) {
        return !!this.loggers.has(id);
      }
      close(id) {
        if (id) {
          return this._removeLogger(id);
        }
        this.loggers.forEach((val, key) => this._removeLogger(key));
      }
      _removeLogger(id) {
        if (!this.loggers.has(id)) {
          return;
        }
        const logger = this.loggers.get(id);
        logger.close();
        this._delete(id);
      }
      _delete(id) {
        this.loggers.delete(id);
      }
    };
  }
});

// ../../node_modules/winston/lib/winston.js
var require_winston = __commonJS({
  "../../node_modules/winston/lib/winston.js"(exports2) {
    "use strict";
    var logform = require_logform();
    var { warn: warn3 } = require_common6();
    var winston = exports2;
    winston.version = require_package6().version;
    winston.transports = require_transports2();
    winston.config = require_config3();
    winston.addColors = logform.levels;
    winston.format = logform.format;
    winston.createLogger = require_create_logger();
    winston.ExceptionHandler = require_exception_handler();
    winston.RejectionHandler = require_rejection_handler();
    winston.Container = require_container();
    winston.Transport = require_winston_transport();
    winston.loggers = new winston.Container();
    var defaultLogger = winston.createLogger();
    Object.keys(winston.config.npm.levels).concat([
      "log",
      "query",
      "stream",
      "add",
      "remove",
      "clear",
      "profile",
      "startTimer",
      "handleExceptions",
      "unhandleExceptions",
      "handleRejections",
      "unhandleRejections",
      "configure",
      "child"
    ]).forEach((method) => winston[method] = (...args) => defaultLogger[method](...args));
    Object.defineProperty(winston, "level", {
      get() {
        return defaultLogger.level;
      },
      set(val) {
        defaultLogger.level = val;
      }
    });
    Object.defineProperty(winston, "exceptions", {
      get() {
        return defaultLogger.exceptions;
      }
    });
    ["exitOnError"].forEach((prop) => {
      Object.defineProperty(winston, prop, {
        get() {
          return defaultLogger[prop];
        },
        set(val) {
          defaultLogger[prop] = val;
        }
      });
    });
    Object.defineProperty(winston, "default", {
      get() {
        return {
          exceptionHandlers: defaultLogger.exceptionHandlers,
          rejectionHandlers: defaultLogger.rejectionHandlers,
          transports: defaultLogger.transports
        };
      }
    });
    warn3.deprecated(winston, "setLevels");
    warn3.forFunctions(winston, "useFormat", ["cli"]);
    warn3.forProperties(winston, "useFormat", ["padLevels", "stripColors"]);
    warn3.forFunctions(winston, "deprecated", [
      "addRewriter",
      "addFilter",
      "clone",
      "extend"
    ]);
    warn3.forProperties(winston, "deprecated", ["emitErrs", "levelLength"]);
    warn3.moved(winston, "createLogger", "Logger");
  }
});

// ../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream4 = __commonJS({
  "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    module2.exports = require("stream");
  }
});

// ../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy3 = __commonJS({
  "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err);
      else
        stream.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// ../../node_modules/winston-transport/node_modules/readable-stream/errors.js
var require_errors4 = __commonJS({
  "../../node_modules/winston-transport/node_modules/readable-stream/errors.js"(exports2, module2) {
    "use strict";
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      class NodeError extends Base {
        constructor(arg1, arg2, arg3) {
          super(getMessage(arg1, arg2, arg3));
        }
      }
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        const len = expected.length;
        expected = expected.map((i) => String(i));
        if (len > 2) {
          return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
        } else if (len === 2) {
          return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        } else {
          return `of ${thing} ${expected[0]}`;
        }
      } else {
        return `of ${thing} ${String(expected)}`;
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      let determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      let msg;
      if (endsWith(name, " argument")) {
        msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
      } else {
        const type = includes(name, ".") ? "property" : "argument";
        msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
      }
      msg += `. Received type ${typeof actual}`;
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module2.exports.codes = codes;
  }
});

// ../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/state.js
var require_state2 = __commonJS({
  "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/state.js"(exports2, module2) {
    "use strict";
    var ERR_INVALID_OPT_VALUE = require_errors4().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options2, isDuplex, duplexKey) {
      return options2.highWaterMark != null ? options2.highWaterMark : isDuplex ? options2[duplexKey] : null;
    }
    function getHighWaterMark(state, options2, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options2, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module2.exports = {
      getHighWaterMark
    };
  }
});

// ../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list2 = __commonJS({
  "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports2, module2) {
    "use strict";
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread2(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty2(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty2(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck2(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties2(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass2(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties2(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties2(Constructor, staticProps);
      return Constructor;
    }
    var _require = require("buffer");
    var Buffer2 = _require.Buffer;
    var _require2 = require("util");
    var inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer2.prototype.copy.call(src, target, offset);
    }
    module2.exports = /* @__PURE__ */ function() {
      function BufferList() {
        _classCallCheck2(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass2(BufferList, [{
        key: "push",
        value: function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join2(s) {
          if (this.length === 0)
            return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next) {
            ret += s + p.data;
          }
          return ret;
        }
      }, {
        key: "concat",
        value: function concat(n) {
          if (this.length === 0)
            return Buffer2.alloc(0);
          var ret = Buffer2.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        }
      }, {
        key: "consume",
        value: function consume(n, hasStrings) {
          var ret;
          if (n < this.head.data.length) {
            ret = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
      }, {
        key: "_getString",
        value: function _getString(n) {
          var p = this.head;
          var c = 1;
          var ret = p.data;
          n -= ret.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length)
              ret += str;
            else
              ret += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n) {
          var ret = Buffer2.allocUnsafe(n);
          var p = this.head;
          var c = 1;
          p.data.copy(ret);
          n -= p.data.length;
          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret, ret.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
      }, {
        key: custom,
        value: function value(_45, options2) {
          return inspect(this, _objectSpread2({}, options2, {
            depth: 0,
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
  }
});

// ../../node_modules/safe-buffer/index.js
var require_safe_buffer3 = __commonJS({
  "../../node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// ../../node_modules/winston-transport/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder3 = __commonJS({
  "../../node_modules/winston-transport/node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer3().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// ../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream2 = __commonJS({
  "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports2, module2) {
    "use strict";
    var ERR_STREAM_PREMATURE_CLOSE = require_errors4().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop3() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop3);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable)
          onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module2.exports = eos;
  }
});

// ../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator2 = __commonJS({
  "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports2, module2) {
    "use strict";
    var _Object$setPrototypeO;
    function _defineProperty2(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var finished = require_end_of_stream2();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data2 = iter[kStream].read();
        if (data2 !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data2, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error3 = this[kError];
        if (error3 !== null) {
          return Promise.reject(error3);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data2 = this[kStream].read();
          if (data2 !== null) {
            return Promise.resolve(createIterResult(data2, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty2(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty2(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty2(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty2(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty2(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty2(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty2(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty2(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
          var data2 = iterator[kStream].read();
          if (data2) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(data2, false));
          } else {
            iterator[kLastResolve] = resolve;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module2.exports = createReadableStreamAsyncIterator;
  }
});

// ../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/from.js
var require_from2 = __commonJS({
  "../../node_modules/winston-transport/node_modules/readable-stream/lib/internal/streams/from.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error3) {
        reject(error3);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve, reject) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread2(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty2(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty2(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var ERR_INVALID_ARG_TYPE = require_errors4().codes.ERR_INVALID_ARG_TYPE;
    function from(Readable, iterable, opts) {
      var iterator;
      if (iterable && typeof iterable.next === "function") {
        iterator = iterable;
      } else if (iterable && iterable[Symbol.asyncIterator])
        iterator = iterable[Symbol.asyncIterator]();
      else if (iterable && iterable[Symbol.iterator])
        iterator = iterable[Symbol.iterator]();
      else
        throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
      var readable = new Readable(_objectSpread2({
        objectMode: true
      }, opts));
      var reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      function next() {
        return _next2.apply(this, arguments);
      }
      function _next2() {
        _next2 = _asyncToGenerator(function* () {
          try {
            var _ref = yield iterator.next(), value = _ref.value, done = _ref.done;
            if (done) {
              readable.push(null);
            } else if (readable.push(yield value)) {
              next();
            } else {
              reading = false;
            }
          } catch (err) {
            readable.destroy(err);
          }
        });
        return _next2.apply(this, arguments);
      }
      return readable;
    }
    module2.exports = from;
  }
});

// ../../node_modules/winston-transport/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable3 = __commonJS({
  "../../node_modules/winston-transport/node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    module2.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream4();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require("util");
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = require_buffer_list2();
    var destroyImpl = require_destroy3();
    var _require = require_state2();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors4().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    require_inherits()(Readable, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options2, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex3();
      options2 = options2 || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options2.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options2.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options2, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options2.emitClose !== false;
      this.autoDestroy = !!options2.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options2.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options2.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder3().StringDecoder;
        this.decoder = new StringDecoder(options2.encoding);
        this.encoding = options2.encoding;
      }
    }
    function Readable(options2) {
      Duplex = Duplex || require_stream_duplex3();
      if (!(this instanceof Readable))
        return new Readable(options2);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options2, this, isDuplex);
      this.readable = true;
      if (options2) {
        if (typeof options2.read === "function")
          this._read = options2.read;
        if (typeof options2.destroy === "function")
          this._destroy = options2.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      enumerable: false,
      get: function get3() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder3().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) {
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        }
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      var res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
        ;
      }
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator2();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      enumerable: false,
      get: function get3() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      enumerable: false,
      get: function get3() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      enumerable: false,
      get: function get3() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      enumerable: false,
      get: function get3() {
        return this._readableState.length;
      }
    });
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from === void 0) {
          from = require_from2();
        }
        return from(Readable, iterable, opts);
      };
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// ../../node_modules/winston-transport/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex3 = __commonJS({
  "../../node_modules/winston-transport/node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) {
        keys2.push(key);
      }
      return keys2;
    };
    module2.exports = Duplex;
    var Readable = require_stream_readable3();
    var Writable = require_stream_writable3();
    require_inherits()(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options2) {
      if (!(this instanceof Duplex))
        return new Duplex(options2);
      Readable.call(this, options2);
      Writable.call(this, options2);
      this.allowHalfOpen = true;
      if (options2) {
        if (options2.readable === false)
          this.readable = false;
        if (options2.writable === false)
          this.writable = false;
        if (options2.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function get3() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      enumerable: false,
      get: function get3() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      enumerable: false,
      get: function get3() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended)
        return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      enumerable: false,
      get: function get3() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// ../../node_modules/winston-transport/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable3 = __commonJS({
  "../../node_modules/winston-transport/node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_node3()
    };
    var Stream = require_stream4();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy3();
    var _require = require_state2();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors4().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits()(Writable, Stream);
    function nop() {
    }
    function WritableState(options2, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex3();
      options2 = options2 || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options2.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options2.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options2, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options2.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options2.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options2.emitClose !== false;
      this.autoDestroy = !!options2.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_45) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable(options2) {
      Duplex = Duplex || require_stream_duplex3();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this))
        return new Writable(options2);
      this._writableState = new WritableState(options2, this, isDuplex);
      this.writable = true;
      if (options2) {
        if (typeof options2.write === "function")
          this._write = options2.write;
        if (typeof options2.writev === "function")
          this._writev = options2.writev;
        if (typeof options2.destroy === "function")
          this._destroy = options2.destroy;
        if (typeof options2.final === "function")
          this._final = options2.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      enumerable: false,
      get: function get3() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function get3() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      enumerable: false,
      get: function get3() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      enumerable: false,
      get: function get3() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// ../../node_modules/winston-transport/legacy.js
var require_legacy2 = __commonJS({
  "../../node_modules/winston-transport/legacy.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var { LEVEL } = require_triple_beam();
    var TransportStream = require_winston_transport2();
    var LegacyTransportStream = module2.exports = function LegacyTransportStream2(options2 = {}) {
      TransportStream.call(this, options2);
      if (!options2.transport || typeof options2.transport.log !== "function") {
        throw new Error("Invalid transport, must be an object with a log method.");
      }
      this.transport = options2.transport;
      this.level = this.level || options2.transport.level;
      this.handleExceptions = this.handleExceptions || options2.transport.handleExceptions;
      this._deprecated();
      function transportError(err) {
        this.emit("error", err, this.transport);
      }
      if (!this.transport.__winstonError) {
        this.transport.__winstonError = transportError.bind(this);
        this.transport.on("error", this.transport.__winstonError);
      }
    };
    util.inherits(LegacyTransportStream, TransportStream);
    LegacyTransportStream.prototype._write = function _write(info, enc, callback) {
      if (this.silent || info.exception === true && !this.handleExceptions) {
        return callback(null);
      }
      if (!this.level || this.levels[this.level] >= this.levels[info[LEVEL]]) {
        this.transport.log(info[LEVEL], info.message, info, this._nop);
      }
      callback(null);
    };
    LegacyTransportStream.prototype._writev = function _writev(chunks, callback) {
      for (let i = 0; i < chunks.length; i++) {
        if (this._accept(chunks[i])) {
          this.transport.log(chunks[i].chunk[LEVEL], chunks[i].chunk.message, chunks[i].chunk, this._nop);
          chunks[i].callback();
        }
      }
      return callback(null);
    };
    LegacyTransportStream.prototype._deprecated = function _deprecated() {
      console.error([
        `${this.transport.name} is a legacy winston transport. Consider upgrading: `,
        "- Upgrade docs: https://github.com/winstonjs/winston/blob/master/UPGRADE-3.0.md"
      ].join("\n"));
    };
    LegacyTransportStream.prototype.close = function close() {
      if (this.transport.close) {
        this.transport.close();
      }
      if (this.transport.__winstonError) {
        this.transport.removeListener("error", this.transport.__winstonError);
        this.transport.__winstonError = null;
      }
    };
  }
});

// ../../node_modules/winston-transport/index.js
var require_winston_transport2 = __commonJS({
  "../../node_modules/winston-transport/index.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var Writable = require_stream_writable3();
    var { LEVEL } = require_triple_beam();
    var TransportStream = module2.exports = function TransportStream2(options2 = {}) {
      Writable.call(this, { objectMode: true, highWaterMark: options2.highWaterMark });
      this.format = options2.format;
      this.level = options2.level;
      this.handleExceptions = options2.handleExceptions;
      this.handleRejections = options2.handleRejections;
      this.silent = options2.silent;
      if (options2.log)
        this.log = options2.log;
      if (options2.logv)
        this.logv = options2.logv;
      if (options2.close)
        this.close = options2.close;
      this.once("pipe", (logger) => {
        this.levels = logger.levels;
        this.parent = logger;
      });
      this.once("unpipe", (src) => {
        if (src === this.parent) {
          this.parent = null;
          if (this.close) {
            this.close();
          }
        }
      });
    };
    util.inherits(TransportStream, Writable);
    TransportStream.prototype._write = function _write(info, enc, callback) {
      if (this.silent || info.exception === true && !this.handleExceptions) {
        return callback(null);
      }
      const level = this.level || this.parent && this.parent.level;
      if (!level || this.levels[level] >= this.levels[info[LEVEL]]) {
        if (info && !this.format) {
          return this.log(info, callback);
        }
        let errState;
        let transformed;
        try {
          transformed = this.format.transform(Object.assign({}, info), this.format.options);
        } catch (err) {
          errState = err;
        }
        if (errState || !transformed) {
          callback();
          if (errState)
            throw errState;
          return;
        }
        return this.log(transformed, callback);
      }
      return callback(null);
    };
    TransportStream.prototype._writev = function _writev(chunks, callback) {
      if (this.logv) {
        const infos = chunks.filter(this._accept, this);
        if (!infos.length) {
          return callback(null);
        }
        return this.logv(infos, callback);
      }
      for (let i = 0; i < chunks.length; i++) {
        if (!this._accept(chunks[i]))
          continue;
        if (chunks[i].chunk && !this.format) {
          this.log(chunks[i].chunk, chunks[i].callback);
          continue;
        }
        let errState;
        let transformed;
        try {
          transformed = this.format.transform(Object.assign({}, chunks[i].chunk), this.format.options);
        } catch (err) {
          errState = err;
        }
        if (errState || !transformed) {
          chunks[i].callback();
          if (errState) {
            callback(null);
            throw errState;
          }
        } else {
          this.log(transformed, chunks[i].callback);
        }
      }
      return callback(null);
    };
    TransportStream.prototype._accept = function _accept(write) {
      const info = write.chunk;
      if (this.silent) {
        return false;
      }
      const level = this.level || this.parent && this.parent.level;
      if (info.exception === true || !level || this.levels[level] >= this.levels[info[LEVEL]]) {
        if (this.handleExceptions || info.exception !== true) {
          return true;
        }
      }
      return false;
    };
    TransportStream.prototype._nop = function _nop() {
      return void 0;
    };
    module2.exports.LegacyTransportStream = require_legacy2();
  }
});

// ../../node_modules/@sap-ux/store/node_modules/@sap-ux/logger/dist/winston-logger/null-transport.js
var require_null_transport = __commonJS({
  "../../node_modules/@sap-ux/store/node_modules/@sap-ux/logger/dist/winston-logger/null-transport.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NullTransport = void 0;
    var winston_transport_1 = __importDefault(require_winston_transport2());
    var NullTransport = class extends winston_transport_1.default {
      log(_data, callback) {
        callback();
      }
    };
    exports2.NullTransport = NullTransport;
  }
});

// ../../node_modules/@sap-ux/store/node_modules/@sap-ux/logger/dist/winston-logger/vscode-output-channel-transport.js
var require_vscode_output_channel_transport = __commonJS({
  "../../node_modules/@sap-ux/store/node_modules/@sap-ux/logger/dist/winston-logger/vscode-output-channel-transport.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VSCodeTransport = void 0;
    var winston_transport_1 = __importDefault(require_winston_transport2());
    var VSCodeTransport = class extends winston_transport_1.default {
      constructor(options2) {
        super(options2);
        this.channel = getVSCodeInstance().window.createOutputChannel(options2.channelName);
      }
      log(data2, callback) {
        setImmediate(() => {
          this.channel.appendLine(`${data2.timestamp} [${data2.level.toUpperCase()}] - ${data2.message}`);
        });
        callback();
      }
    };
    exports2.VSCodeTransport = VSCodeTransport;
    function getVSCodeInstance() {
      return require("vscode");
    }
  }
});

// ../../node_modules/@sap-ux/store/node_modules/chalk/source/util.js
var require_util4 = __commonJS({
  "../../node_modules/@sap-ux/store/node_modules/chalk/source/util.js"(exports2, module2) {
    "use strict";
    var stringReplaceAll = (string, substring, replacer) => {
      let index = string.indexOf(substring);
      if (index === -1) {
        return string;
      }
      const substringLength = substring.length;
      let endIndex = 0;
      let returnValue = "";
      do {
        returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
        endIndex = index + substringLength;
        index = string.indexOf(substring, endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    var stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
      let endIndex = 0;
      let returnValue = "";
      do {
        const gotCR = string[index - 1] === "\r";
        returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
        endIndex = index + 1;
        index = string.indexOf("\n", endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    module2.exports = {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    };
  }
});

// ../../node_modules/@sap-ux/store/node_modules/chalk/source/templates.js
var require_templates2 = __commonJS({
  "../../node_modules/@sap-ux/store/node_modules/chalk/source/templates.js"(exports2, module2) {
    "use strict";
    var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = /* @__PURE__ */ new Map([
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", "\x1B"],
      ["a", "\x07"]
    ]);
    function unescape2(c) {
      const u = c[0] === "u";
      const bracket = c[1] === "{";
      if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
        return String.fromCharCode(parseInt(c.slice(1), 16));
      }
      if (u && bracket) {
        return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
      }
      return ESCAPES.get(c) || c;
    }
    function parseArguments(name, arguments_) {
      const results = [];
      const chunks = arguments_.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        const number = Number(chunk);
        if (!Number.isNaN(number)) {
          results.push(number);
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape4, character) => escape4 ? unescape2(escape4) : character));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
        }
      }
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style)) !== null) {
        const name = matches[1];
        if (matches[2]) {
          const args = parseArguments(name, matches[2]);
          results.push([name].concat(args));
        } else {
          results.push([name]);
        }
      }
      return results;
    }
    function buildStyle(chalk, styles) {
      const enabled = {};
      for (const layer of styles) {
        for (const style of layer.styles) {
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }
      let current = chalk;
      for (const [styleName, styles2] of Object.entries(enabled)) {
        if (!Array.isArray(styles2)) {
          continue;
        }
        if (!(styleName in current)) {
          throw new Error(`Unknown Chalk style: ${styleName}`);
        }
        current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
      }
      return current;
    }
    module2.exports = (chalk, temporary) => {
      const styles = [];
      const chunks = [];
      let chunk = [];
      temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
        if (escapeCharacter) {
          chunk.push(unescape2(escapeCharacter));
        } else if (style) {
          const string = chunk.join("");
          chunk = [];
          chunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));
          styles.push({ inverse, styles: parseStyle(style) });
        } else if (close) {
          if (styles.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk, styles)(chunk.join("")));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(character);
        }
      });
      chunks.push(chunk.join(""));
      if (styles.length > 0) {
        const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMessage);
      }
      return chunks.join("");
    };
  }
});

// ../../node_modules/@sap-ux/store/node_modules/chalk/source/index.js
var require_source2 = __commonJS({
  "../../node_modules/@sap-ux/store/node_modules/chalk/source/index.js"(exports2, module2) {
    "use strict";
    var ansiStyles = require_ansi_styles();
    var { stdout: stdoutColor, stderr: stderrColor } = require_supports_color();
    var {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    } = require_util4();
    var { isArray } = Array;
    var levelMapping = [
      "ansi",
      "ansi",
      "ansi256",
      "ansi16m"
    ];
    var styles = /* @__PURE__ */ Object.create(null);
    var applyOptions = (object, options2 = {}) => {
      if (options2.level && !(Number.isInteger(options2.level) && options2.level >= 0 && options2.level <= 3)) {
        throw new Error("The `level` option should be an integer from 0 to 3");
      }
      const colorLevel = stdoutColor ? stdoutColor.level : 0;
      object.level = options2.level === void 0 ? colorLevel : options2.level;
    };
    var ChalkClass = class {
      constructor(options2) {
        return chalkFactory(options2);
      }
    };
    var chalkFactory = (options2) => {
      const chalk2 = {};
      applyOptions(chalk2, options2);
      chalk2.template = (...arguments_) => chalkTag(chalk2.template, ...arguments_);
      Object.setPrototypeOf(chalk2, Chalk.prototype);
      Object.setPrototypeOf(chalk2.template, chalk2);
      chalk2.template.constructor = () => {
        throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
      };
      chalk2.template.Instance = ChalkClass;
      return chalk2.template;
    };
    function Chalk(options2) {
      return chalkFactory(options2);
    }
    for (const [styleName, style] of Object.entries(ansiStyles)) {
      styles[styleName] = {
        get() {
          const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
          Object.defineProperty(this, styleName, { value: builder });
          return builder;
        }
      };
    }
    styles.visible = {
      get() {
        const builder = createBuilder(this, this._styler, true);
        Object.defineProperty(this, "visible", { value: builder });
        return builder;
      }
    };
    var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
    for (const model of usedModels) {
      styles[model] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    for (const model of usedModels) {
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    var proto = Object.defineProperties(() => {
    }, {
      ...styles,
      level: {
        enumerable: true,
        get() {
          return this._generator.level;
        },
        set(level) {
          this._generator.level = level;
        }
      }
    });
    var createStyler = (open, close, parent) => {
      let openAll;
      let closeAll;
      if (parent === void 0) {
        openAll = open;
        closeAll = close;
      } else {
        openAll = parent.openAll + open;
        closeAll = close + parent.closeAll;
      }
      return {
        open,
        close,
        openAll,
        closeAll,
        parent
      };
    };
    var createBuilder = (self2, _styler, _isEmpty) => {
      const builder = (...arguments_) => {
        if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
          return applyStyle(builder, chalkTag(builder, ...arguments_));
        }
        return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
      };
      Object.setPrototypeOf(builder, proto);
      builder._generator = self2;
      builder._styler = _styler;
      builder._isEmpty = _isEmpty;
      return builder;
    };
    var applyStyle = (self2, string) => {
      if (self2.level <= 0 || !string) {
        return self2._isEmpty ? "" : string;
      }
      let styler = self2._styler;
      if (styler === void 0) {
        return string;
      }
      const { openAll, closeAll } = styler;
      if (string.indexOf("\x1B") !== -1) {
        while (styler !== void 0) {
          string = stringReplaceAll(string, styler.close, styler.open);
          styler = styler.parent;
        }
      }
      const lfIndex = string.indexOf("\n");
      if (lfIndex !== -1) {
        string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
      }
      return openAll + string + closeAll;
    };
    var template;
    var chalkTag = (chalk2, ...strings) => {
      const [firstString] = strings;
      if (!isArray(firstString) || !isArray(firstString.raw)) {
        return strings.join(" ");
      }
      const arguments_ = strings.slice(1);
      const parts = [firstString.raw[0]];
      for (let i = 1; i < firstString.length; i++) {
        parts.push(String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"), String(firstString.raw[i]));
      }
      if (template === void 0) {
        template = require_templates2();
      }
      return template(chalk2, parts.join(""));
    };
    Object.defineProperties(Chalk.prototype, styles);
    var chalk = Chalk();
    chalk.supportsColor = stdoutColor;
    chalk.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });
    chalk.stderr.supportsColor = stderrColor;
    module2.exports = chalk;
  }
});

// ../../node_modules/@sap-ux/store/node_modules/@sap-ux/logger/dist/winston-logger/adapter.js
var require_adapter = __commonJS({
  "../../node_modules/@sap-ux/store/node_modules/@sap-ux/logger/dist/winston-logger/adapter.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    var __rest = exports2 && exports2.__rest || function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toWinstonTransport = exports2.toWinstonLogLevel = void 0;
    var types_1 = require_types7();
    var winston_1 = __importStar(require_winston());
    var transports_1 = require_transports();
    var null_transport_1 = require_null_transport();
    var vscode_output_channel_transport_1 = require_vscode_output_channel_transport();
    var util_1 = require("util");
    var chalk_1 = __importDefault(require_source2());
    function toWinstonLogLevel(logLevel) {
      return logLevel === void 0 ? void 0 : types_1.LogLevel[logLevel].toLowerCase();
    }
    exports2.toWinstonLogLevel = toWinstonLogLevel;
    var toWinstonTransportOptions = (transportOptions) => {
      const { logLevel } = transportOptions, opts = __rest(transportOptions, ["logLevel"]);
      return Object.assign({}, opts, { level: toWinstonLogLevel(logLevel) });
    };
    var levelColor = {
      info: "green",
      warn: "yellow",
      error: "red",
      verbose: "blue",
      silly: "magenta",
      debug: "cyan"
    };
    var hasColorSupport = () => process.stdout.isTTY;
    var colorFn = (color) => {
      try {
        return color ? chalk_1.default.keyword(color) : void 0;
      } catch (_a2) {
        return void 0;
      }
    };
    var ui5ToolingFormat = (moduleName) => winston_1.format.combine(winston_1.format.colorize(), winston_1.format.label({ label: moduleName }), winston_1.format.printf(({ level, message, label }) => {
      let msg = typeof message === "string" ? message : util_1.inspect(message);
      msg = msg.split(/\r?\n/).join(`
${level} ${chalk_1.default.magenta(label)} `);
      return `${level} ${chalk_1.default.magenta(label)} ${msg}`;
    }));
    var decorateLevel = (level) => {
      const padded = level.padEnd(7);
      if (hasColorSupport()) {
        const decorator = colorFn(levelColor[level]);
        if (decorator) {
          return decorator(padded);
        }
      }
      return padded;
    };
    var decorateLabel = (label, labelColor) => {
      let l = label !== null && label !== void 0 ? label : "";
      if (hasColorSupport() && label && typeof labelColor === "string") {
        const decorator = colorFn(labelColor);
        if (decorator) {
          l = decorator(label);
        }
      }
      return l;
    };
    var consoleFormat = winston_1.format.combine(winston_1.format.timestamp({ format: "YYYY-MM-DD HH:mm:ss" }), winston_1.format.printf((_a2) => {
      var { timestamp, level, message, label, labelColor } = _a2, meta = __rest(_a2, ["timestamp", "level", "message", "label", "labelColor"]);
      const msg = typeof message === "string" ? message : util_1.inspect(message);
      const lvl = decorateLevel(level);
      return `${timestamp} ${lvl} ${decorateLabel(label, labelColor)}: ${msg} ${Object.keys(meta).length ? util_1.inspect(meta) : ""}`;
    }));
    function toWinstonTransport(transport) {
      if (transport instanceof transports_1.NullTransport) {
        return new null_transport_1.NullTransport();
      } else if (transport instanceof transports_1.ConsoleTransport) {
        return new winston_1.default.transports.Console(Object.assign(Object.assign({}, toWinstonTransportOptions(transport.options)), { format: consoleFormat }));
      } else if (transport instanceof transports_1.FileTransport) {
        return new winston_1.default.transports.File(toWinstonTransportOptions(transport.options));
      } else if (transport instanceof transports_1.VSCodeTransport) {
        return new vscode_output_channel_transport_1.VSCodeTransport(toWinstonTransportOptions(transport.options));
      } else if (transport instanceof transports_1.UI5ToolingTransport) {
        return new winston_1.default.transports.Console(Object.assign(Object.assign({}, toWinstonTransportOptions(transport.options)), { format: ui5ToolingFormat(transport.options.moduleName) }));
      } else {
        throw new Error("Unrecognized transport type");
      }
    }
    exports2.toWinstonTransport = toWinstonTransport;
  }
});

// ../../node_modules/@sap-ux/store/node_modules/@sap-ux/logger/dist/winston-logger/utils.js
var require_utils11 = __commonJS({
  "../../node_modules/@sap-ux/store/node_modules/@sap-ux/logger/dist/winston-logger/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.nextColor = void 0;
    function* color() {
      const colors = ["magenta", "cyan", "blue", "yellow", "green", "red"];
      let current = 0;
      while (true) {
        if (current === colors.length) {
          current = 0;
        }
        yield colors[current++];
      }
    }
    var colorGenerator = color();
    exports2.nextColor = () => colorGenerator.next().value;
  }
});

// ../../node_modules/@sap-ux/store/node_modules/@sap-ux/logger/dist/winston-logger/logger.js
var require_logger2 = __commonJS({
  "../../node_modules/@sap-ux/store/node_modules/@sap-ux/logger/dist/winston-logger/logger.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WinstonLogger = void 0;
    var transports_1 = require_transports();
    var types_1 = require_types7();
    var winston_1 = __importStar(require_winston());
    var adapter_1 = require_adapter();
    var utils_1 = require_utils11();
    var util_1 = require("util");
    var defaultLoggerOptions = {
      transports: [new transports_1.ConsoleTransport()]
    };
    var BaseWinstonLogger = class {
      initialize({ logger, transportMap, metadataOverride, winstonLevel, logPrefix }) {
        this._logger = logger;
        this.transportMap = transportMap;
        this.winstonLevel = winstonLevel;
        this.logPrefix = logPrefix;
        this.metadataOverride = metadataOverride;
      }
      info(message) {
        this.log({ level: types_1.LogLevel.Info, message });
      }
      warn(message) {
        this.log({ level: types_1.LogLevel.Warn, message });
      }
      error(message) {
        this.log({ level: types_1.LogLevel.Error, message });
      }
      debug(message) {
        this.log({ level: types_1.LogLevel.Debug, message });
      }
      log(data2) {
        var _a2;
        if (!this.transportMap.size) {
          return;
        }
        if (typeof data2 === "string") {
          this.winstonLog({ level: this.winstonLevel, message: data2, metadata: this.metadataOverride });
        } else {
          const level = (_a2 = adapter_1.toWinstonLogLevel(data2.level)) !== null && _a2 !== void 0 ? _a2 : this._logger.level;
          this.winstonLog({ level, message: data2.message, metadata: this.metadataOverride });
        }
      }
      winstonLog({ level, message, metadata }) {
        const msg = typeof message === "string" ? message : util_1.inspect(message);
        this._logger.log(level, msg, metadata);
      }
      addToMap(transportMap, transport) {
        const winstonTransport = adapter_1.toWinstonTransport(transport);
        if (!transportMap.has(transport)) {
          transportMap.set(transport, winstonTransport);
          return winstonTransport;
        }
        return void 0;
      }
      add(transport) {
        const winstonTransport = this.addToMap(this.transportMap, transport);
        if (winstonTransport) {
          this._logger.add(winstonTransport);
        }
        return this;
      }
      remove(transport) {
        const winstonTransport = this.transportMap.get(transport);
        if (winstonTransport) {
          this._logger.remove(winstonTransport);
          this.transportMap.delete(transport);
          return this;
        } else {
          throw new Error("Cannot remove non-existent transport");
        }
      }
      transports() {
        return Array.from(this.transportMap.keys());
      }
      child({ logPrefix }) {
        const childLogPrefix = `${this.logPrefix}.${logPrefix}`;
        const metadataOverride = { label: childLogPrefix, labelColor: utils_1.nextColor() };
        const childWinstonLogger = this._logger.child(metadataOverride);
        const childLogger = new BaseWinstonLogger();
        childLogger.initialize({
          logger: childWinstonLogger,
          transportMap: this.transportMap,
          winstonLevel: this.winstonLevel,
          logPrefix: childLogPrefix,
          metadataOverride
        });
        return childLogger;
      }
    };
    var WinstonLogger = class extends BaseWinstonLogger {
      constructor({ logLevel = types_1.LogLevel.Info, transports = [], logPrefix = "main" } = defaultLoggerOptions) {
        super();
        const transportMap = /* @__PURE__ */ new Map();
        transports.forEach((t) => this.addToMap(transportMap, t));
        const level = adapter_1.toWinstonLogLevel(logLevel);
        const logger = winston_1.default.createLogger({
          level,
          transports: Array.from(transportMap.values()),
          format: winston_1.format.combine(winston_1.format.timestamp(), winston_1.format.json()),
          defaultMeta: { label: logPrefix, labelColor: utils_1.nextColor() }
        });
        const winstonLevel = level !== null && level !== void 0 ? level : logger.level;
        this.initialize({ logger, transportMap, winstonLevel, logPrefix });
      }
    };
    exports2.WinstonLogger = WinstonLogger;
  }
});

// ../../node_modules/@sap-ux/store/node_modules/@sap-ux/logger/dist/winston-logger/index.js
var require_winston_logger = __commonJS({
  "../../node_modules/@sap-ux/store/node_modules/@sap-ux/logger/dist/winston-logger/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WinstonLogger = void 0;
    var logger_1 = require_logger2();
    Object.defineProperty(exports2, "WinstonLogger", { enumerable: true, get: function() {
      return logger_1.WinstonLogger;
    } });
  }
});

// ../../node_modules/@sap-ux/store/node_modules/@sap-ux/logger/dist/index.js
var require_dist8 = __commonJS({
  "../../node_modules/@sap-ux/store/node_modules/@sap-ux/logger/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ToolsLogger = void 0;
    __exportStar(require_types7(), exports2);
    __exportStar(require_transports(), exports2);
    var winston_logger_1 = require_winston_logger();
    Object.defineProperty(exports2, "ToolsLogger", { enumerable: true, get: function() {
      return winston_logger_1.WinstonLogger;
    } });
  }
});

// ../../node_modules/@sap-ux/store/dist/defaults.js
var require_defaults2 = __commonJS({
  "../../node_modules/@sap-ux/store/dist/defaults.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getDefaultLogger = void 0;
    var logger_1 = require_dist8();
    exports2.getDefaultLogger = () => new logger_1.ToolsLogger({ transports: [new logger_1.ConsoleTransport()] });
  }
});

// ../../node_modules/@sap-ux/store/dist/services/index.js
var require_services2 = __commonJS({
  "../../node_modules/@sap-ux/store/dist/services/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApiHubSettingsService = exports2.SystemService = void 0;
    var backend_system_1 = require_backend_system6();
    Object.defineProperty(exports2, "SystemService", { enumerable: true, get: function() {
      return backend_system_1.SystemService;
    } });
    var api_hub_1 = require_api_hub4();
    Object.defineProperty(exports2, "ApiHubSettingsService", { enumerable: true, get: function() {
      return api_hub_1.ApiHubSettingsService;
    } });
  }
});

// ../../node_modules/@sap-ux/store/dist/data-access/index.js
var require_data_access2 = __commonJS({
  "../../node_modules/@sap-ux/store/dist/data-access/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getFilesystemWatcherFor = void 0;
    var filesystem_1 = require_filesystem2();
    Object.defineProperty(exports2, "getFilesystemWatcherFor", { enumerable: true, get: function() {
      return filesystem_1.getFilesystemWatcherFor;
    } });
  }
});

// ../../node_modules/@sap-ux/store/dist/index.js
var require_dist9 = __commonJS({
  "../../node_modules/@sap-ux/store/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Entity = exports2.getFilesystemWatcherFor = exports2.getService = void 0;
    var constants_1 = require_constants5();
    Object.defineProperty(exports2, "Entity", { enumerable: true, get: function() {
      return constants_1.Entity;
    } });
    var i18n_1 = require_i18n4();
    var backend_system_1 = require_backend_system6();
    var telemetry_setting_1 = require_telemetry_setting3();
    var api_hub_1 = require_api_hub4();
    var defaults_1 = require_defaults2();
    var services = {
      system: backend_system_1.getInstance,
      telemetrySetting: telemetry_setting_1.getInstance,
      "api-hub": api_hub_1.getInstance
    };
    function getService({ logger = defaults_1.getDefaultLogger(), entityName, options: options2 = {} }) {
      return __awaiter(this, void 0, void 0, function* () {
        yield i18n_1.initI18n();
        const factory = services[entityName];
        if (factory) {
          return factory(logger, options2);
        } else {
          throw new Error(i18n_1.text("error.unsupportedEntity", { entityName }));
        }
      });
    }
    exports2.getService = getService;
    __exportStar(require_services2(), exports2);
    __exportStar(require_backend_system4(), exports2);
    __exportStar(require_telemetry_setting(), exports2);
    __exportStar(require_api_hub2(), exports2);
    var data_access_1 = require_data_access2();
    Object.defineProperty(exports2, "getFilesystemWatcherFor", { enumerable: true, get: function() {
      return data_access_1.getFilesystemWatcherFor;
    } });
  }
});

// ../lib/telemetry/dist/src/toolsSuiteTelemetry/toolsSuiteTelemetrySettings.js
var require_toolsSuiteTelemetrySettings = __commonJS({
  "../lib/telemetry/dist/src/toolsSuiteTelemetry/toolsSuiteTelemetrySettings.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.initTelemetrySettings = exports2.getTelemetrySetting = exports2.setEnableTelemetry = void 0;
    var reporting_1 = require_reporting();
    var cloudDebugger_1 = require_cloudDebugger();
    var system_1 = require_system2();
    var store_1 = require_dist9();
    var ux_common_utils_1 = require_dist();
    var os_1 = __importDefault(require("os"));
    var path_1 = __importDefault(require("path"));
    var fs_1 = __importDefault(require("fs"));
    var toolsSuiteTelemetryDataProcessor_1 = require_toolsSuiteTelemetryDataProcessor();
    var isExtensionModule = (packageJson) => {
      return packageJson["contributes"] || packageJson["activationEvents"] || packageJson.name.match(/sap-ux-.*-extension/g);
    };
    var settingPaths = {
      win32: "\\AppData\\Roaming\\Code\\User\\settings.json",
      darwin: "/Library/Application Support/Code/User/settings.json",
      linux: "/.config/Code/User/settings.json",
      theia: "/.theia/settings.json"
    };
    var deprecatedExtensionPropKeys = [
      "sap.ux.annotation.lsp.enableTelemetry",
      "sap.ux.applicationModeler.enableTelemetry",
      "sap.ux.help.enableTelemetry",
      "sap.ux.serviceModeler.enableTelemetry"
    ];
    var definePath = (paths) => {
      const platform = process.platform;
      let settingsPath = paths[platform];
      if (ux_common_utils_1.isAppStudio()) {
        settingsPath = paths.theia;
      }
      if (!settingsPath) {
        console.error("no path for current OS is provided - ", platform);
        return null;
      }
      const homedir = os_1.default.homedir();
      return path_1.default.join(homedir, settingsPath);
    };
    var setEnableTelemetry = async (enableTelemetry) => {
      const storeService = await store_1.getService({
        entityName: "telemetrySetting"
      });
      const setting = new store_1.TelemetrySetting({ enableTelemetry });
      await storeService.write(setting);
      system_1.TelemetrySystem.telemetryEnabled = enableTelemetry;
      const commonProperties = await toolsSuiteTelemetryDataProcessor_1.getCommonProperties();
      reporting_1.reportEnableTelemetryOnOff(enableTelemetry, commonProperties);
    };
    exports2.setEnableTelemetry = setEnableTelemetry;
    var getTelemetrySetting = async () => {
      let setting;
      try {
        const storeService = await store_1.getService({
          entityName: "telemetrySetting"
        });
        setting = await storeService.read(new store_1.TelemetrySettingKey());
      } catch {
      }
      return setting;
    };
    exports2.getTelemetrySetting = getTelemetrySetting;
    var readEnableTelemetryFromSetting = async () => {
      const storeService = await store_1.getService({
        entityName: "telemetrySetting"
      });
      let setting;
      try {
        setting = await storeService.read(new store_1.TelemetrySettingKey());
      } catch {
      }
      if (!setting) {
        const deprecatedSettingPath = definePath(settingPaths);
        if (!deprecatedSettingPath) {
          exports2.setEnableTelemetry(true);
        } else {
          let content;
          try {
            content = await fs_1.default.promises.readFile(deprecatedSettingPath, "utf-8");
            const deprecatedSetting = JSON.parse(content);
            const propValues = deprecatedExtensionPropKeys.map((propKey) => {
              var _a2;
              return (_a2 = deprecatedSetting[propKey]) != null ? _a2 : true;
            });
            const deprecatedEnableTelemetrySetting = propValues.reduce((prevValue, currentValue) => prevValue && currentValue);
            exports2.setEnableTelemetry(deprecatedEnableTelemetrySetting);
          } catch {
            exports2.setEnableTelemetry(true);
          }
        }
      } else {
        system_1.TelemetrySystem.telemetryEnabled = setting.enableTelemetry;
      }
      if (system_1.TelemetrySystem.WORKSTREAM === "extension") {
        store_1.getFilesystemWatcherFor(store_1.Entity.TelemetrySetting, async () => {
          const watchedSetting = await storeService.read(new store_1.TelemetrySettingKey());
          system_1.TelemetrySystem.telemetryEnabled = watchedSetting.enableTelemetry;
        });
      }
    };
    var initToolsSuiteTelemetrySettings = async () => {
      cloudDebugger_1.debug("start initTelemetrySettings");
      if (!system_1.TelemetrySystem.WORKSTREAM) {
        throw new Error("Workstream is undefined");
      }
      cloudDebugger_1.debug(`workstream: ${system_1.TelemetrySystem.WORKSTREAM}`);
      system_1.TelemetrySystem.telemetryEnabled = true;
      await readEnableTelemetryFromSetting();
    };
    var initWithInputManifest = async (options2) => {
      system_1.TelemetrySystem.WORKSTREAM = isExtensionModule(options2.modulePackageJson) ? "extension" : "core";
      system_1.TelemetrySystem.manifest = options2.modulePackageJson;
      await initToolsSuiteTelemetrySettings();
    };
    var initTelemetrySettings2 = async (options2) => {
      try {
        if (options2 && options2.modulePackageJson) {
          await initWithInputManifest(options2);
        } else {
          await initToolsSuiteTelemetrySettings();
        }
      } catch (err) {
        reporting_1.reportRuntimeError(err);
      }
    };
    exports2.initTelemetrySettings = initTelemetrySettings2;
  }
});

// ../lib/telemetry/dist/src/toolsSuiteTelemetry/index.js
var require_toolsSuiteTelemetry = __commonJS({
  "../lib/telemetry/dist/src/toolsSuiteTelemetry/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.processToolsSuiteTelemetry = void 0;
    __exportStar(require_toolsSuiteTelemetryClient(), exports2);
    var toolsSuiteTelemetryDataProcessor_1 = require_toolsSuiteTelemetryDataProcessor();
    Object.defineProperty(exports2, "processToolsSuiteTelemetry", { enumerable: true, get: function() {
      return toolsSuiteTelemetryDataProcessor_1.processToolsSuiteTelemetry;
    } });
    __exportStar(require_toolsSuiteTelemetrySettings(), exports2);
    __exportStar(require_types5(), exports2);
  }
});

// ../lib/telemetry/dist/src/client/index.js
var require_client3 = __commonJS({
  "../lib/telemetry/dist/src/client/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ClientFactory = void 0;
    var system_1 = require_system2();
    var telemetryPackageJSON = __importStar(require_package4());
    var toolsSuiteTelemetry_1 = require_toolsSuiteTelemetry();
    var ClientFactory2 = class {
      static getTelemetryClient() {
        return ClientFactory2.getTelemetryClientByClass(toolsSuiteTelemetry_1.ToolsSuiteTelemetryClient);
      }
      static getTelemetryClientByClass(clientConstructor) {
        let client = ClientFactory2.clientMap.get(clientConstructor.name);
        if (client) {
          return client;
        }
        if (system_1.TelemetrySystem.manifest) {
          client = new clientConstructor(telemetryPackageJSON.azureInstrumentationKey, system_1.TelemetrySystem.manifest.name, system_1.TelemetrySystem.manifest.version);
        } else {
          client = new clientConstructor(telemetryPackageJSON.azureInstrumentationKey, telemetryPackageJSON.name, telemetryPackageJSON.version);
        }
        ClientFactory2.clientMap.set(clientConstructor.name, client);
        return client;
      }
    };
    exports2.ClientFactory = ClientFactory2;
    ClientFactory2.clientMap = /* @__PURE__ */ new Map();
  }
});

// ../lib/telemetry/dist/src/client/model/ClientType.js
var require_ClientType = __commonJS({
  "../lib/telemetry/dist/src/client/model/ClientType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ClientType = void 0;
    var ClientType;
    (function(ClientType2) {
      ClientType2[ClientType2["AzureApplicationInsights"] = 0] = "AzureApplicationInsights";
    })(ClientType = exports2.ClientType || (exports2.ClientType = {}));
  }
});

// ../lib/telemetry/dist/src/performance/types.js
var require_types8 = __commonJS({
  "../lib/telemetry/dist/src/performance/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PerformanceMeasurement = exports2.EntryType = void 0;
    var EntryType;
    (function(EntryType2) {
      EntryType2["START_MARK"] = "START_MARK";
      EntryType2["END_MARK"] = "END_MARK";
      EntryType2["MEASUREMENT"] = "MEASUREMENT";
    })(EntryType || (EntryType = {}));
    exports2.EntryType = EntryType;
    var PerformanceMeasurement = class {
    };
    exports2.PerformanceMeasurement = PerformanceMeasurement;
  }
});

// ../lib/telemetry/dist/src/performance/entries.js
var require_entries = __commonJS({
  "../lib/telemetry/dist/src/performance/entries.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Measurement = exports2.Mark = void 0;
    var types_1 = require_types8();
    var Mark = class {
      constructor(name, type, startTime) {
        this.startTime = startTime;
        this.name = name;
        this.startTime = startTime;
        this.type = type;
      }
      getStartTime() {
        return this.startTime;
      }
    };
    exports2.Mark = Mark;
    var Measurement = class extends Mark {
      constructor(name, startTime, duration) {
        super(name, types_1.EntryType.MEASUREMENT, startTime);
        this.startTime = startTime;
        this.duration = duration;
        this.duration = duration;
      }
      getDurationTime() {
        return this.duration;
      }
    };
    exports2.Measurement = Measurement;
  }
});

// ../../node_modules/performance-now/lib/performance-now.js
var require_performance_now = __commonJS({
  "../../node_modules/performance-now/lib/performance-now.js"(exports2, module2) {
    (function() {
      var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;
      if (typeof performance !== "undefined" && performance !== null && performance.now) {
        module2.exports = function() {
          return performance.now();
        };
      } else if (typeof process !== "undefined" && process !== null && process.hrtime) {
        module2.exports = function() {
          return (getNanoSeconds() - nodeLoadTime) / 1e6;
        };
        hrtime = process.hrtime;
        getNanoSeconds = function() {
          var hr;
          hr = hrtime();
          return hr[0] * 1e9 + hr[1];
        };
        moduleLoadTime = getNanoSeconds();
        upTime = process.uptime() * 1e9;
        nodeLoadTime = moduleLoadTime - upTime;
      } else if (Date.now) {
        module2.exports = function() {
          return Date.now() - loadTime;
        };
        loadTime = Date.now();
      } else {
        module2.exports = function() {
          return new Date().getTime() - loadTime;
        };
        loadTime = new Date().getTime();
      }
    }).call(exports2);
  }
});

// ../lib/telemetry/dist/src/performance/api.js
var require_api = __commonJS({
  "../lib/telemetry/dist/src/performance/api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PerformanceMeasurementAPI = void 0;
    var entries_1 = require_entries();
    var types_1 = require_types8();
    var performanceNow = require_performance_now();
    var PerformanceMeasurementAPI = class extends types_1.PerformanceMeasurement {
      static initialize() {
        PerformanceMeasurementAPI.initTiming = PerformanceMeasurementAPI.now();
      }
      static mark(name, type, timing) {
        const entry = new entries_1.Mark(name, type, timing);
        PerformanceMeasurementAPI.entries.push(entry);
      }
      static startMark(name) {
        const timing = PerformanceMeasurementAPI.now();
        const extendedName = name + timing;
        PerformanceMeasurementAPI.mark(extendedName, types_1.EntryType.START_MARK, timing);
        return extendedName;
      }
      static endMark(name) {
        const timing = PerformanceMeasurementAPI.now();
        PerformanceMeasurementAPI.mark(name, types_1.EntryType.END_MARK, timing);
      }
      static measure(markName) {
        const startMark = PerformanceMeasurementAPI.getEntriesByNameType(markName, types_1.EntryType.START_MARK).slice(-1)[0];
        const endMark = PerformanceMeasurementAPI.getEntriesByNameType(markName, types_1.EntryType.END_MARK).slice(-1)[0];
        if (!startMark && !endMark) {
          throw new Error(`Failed to execute 'measure': mark '${markName}' doesn't exist.`);
        } else if (!startMark || !endMark) {
          const errMarkType = startMark ? types_1.EntryType.END_MARK : types_1.EntryType.START_MARK;
          throw new Error(`Failed to execute 'measure': mark '${markName}'of type '${errMarkType}' doesn't exist.`);
        }
        const startTime = startMark.getStartTime();
        const endTime = endMark.getStartTime();
        const duration = endTime - startTime;
        const measurement = new entries_1.Measurement(`${markName}`, PerformanceMeasurementAPI.now(), duration);
        PerformanceMeasurementAPI.entries.push(measurement);
      }
      static getEntries() {
        return PerformanceMeasurementAPI.entries;
      }
      static getEntriesByName(name) {
        return PerformanceMeasurementAPI.entries.filter((entry) => entry.name === name);
      }
      static getEntriesByNameType(name, type) {
        return PerformanceMeasurementAPI.entries.filter((entry) => entry.name === name && entry.type === type);
      }
      static getEntriesByType(type) {
        return PerformanceMeasurementAPI.entries.filter((entry) => entry.type === type);
      }
      static getMeasurementDuration(name) {
        const entry = PerformanceMeasurementAPI.getEntriesByNameType(name, types_1.EntryType.MEASUREMENT).slice(-1)[0];
        return entry.getDurationTime();
      }
      static clearEntries() {
        PerformanceMeasurementAPI.entries = [];
      }
    };
    exports2.PerformanceMeasurementAPI = PerformanceMeasurementAPI;
    PerformanceMeasurementAPI.now = performanceNow;
    PerformanceMeasurementAPI.entries = [];
    PerformanceMeasurementAPI.initialize();
  }
});

// ../lib/telemetry/dist/src/util/paramProcessing.js
var require_paramProcessing = __commonJS({
  "../lib/telemetry/dist/src/util/paramProcessing.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getParamsData = exports2.paramsProcessing = exports2.getValue = exports2.wrongPathErr = exports2.ParamRecordConfig = exports2.ParamRecordConfigField = void 0;
    var ParamRecordConfigField = class {
      constructor(path) {
        this.path = path;
      }
    };
    exports2.ParamRecordConfigField = ParamRecordConfigField;
    var ParamRecordConfig = class {
      constructor(key = void 0, value = void 0, paramIndex = void 0) {
        this.key = key;
        this.value = value;
        this.paramIndex = paramIndex;
      }
    };
    exports2.ParamRecordConfig = ParamRecordConfig;
    var wrongPathErr = (field, index) => new Error(`Wrong path for '${field}' field is specified in instructions with index - ${index}`);
    exports2.wrongPathErr = wrongPathErr;
    var getValue = (obj, path, field, paramIndex) => {
      const pathArr = path.split("/");
      let node = obj, i = 0;
      while (i < pathArr.length) {
        node = node[pathArr[i]];
        if (node === void 0) {
          throw exports2.wrongPathErr(field, paramIndex);
        }
        i++;
      }
      return node;
    };
    exports2.getValue = getValue;
    var paramsProcessing = (params, instructions) => {
      const processedDimensions = {};
      const processedMeasurements = {};
      let param = null;
      if (instructions.paramIndex !== void 0) {
        param = params[instructions.paramIndex];
      }
      const key = instructions.key ? instructions.key : "data";
      let val = "";
      if (typeof instructions.value === "string") {
        val = instructions.value;
      } else if (instructions.value !== void 0 && instructions.paramIndex !== void 0) {
        val = exports2.getValue(param, instructions.value.path, "val", instructions.paramIndex);
      } else {
        val = param;
      }
      if (!isNaN(val)) {
        processedMeasurements[key] = val;
      } else {
        processedDimensions[key] = val;
      }
      return [processedDimensions, processedMeasurements];
    };
    exports2.paramsProcessing = paramsProcessing;
    var getParamsData = (params, instructions) => {
      let processedDimensions, processedMeasurements;
      let customDimensions = {};
      let customMeasurements = {};
      if (Array.isArray(instructions)) {
        for (const instruction of instructions) {
          [processedDimensions, processedMeasurements] = exports2.paramsProcessing(params, instruction);
          customDimensions = {
            ...customDimensions,
            ...processedDimensions
          };
          customMeasurements = {
            ...customMeasurements,
            ...processedMeasurements
          };
        }
      } else {
        [customDimensions, customMeasurements] = exports2.paramsProcessing(params, instructions);
      }
      return [customDimensions, customMeasurements];
    };
    exports2.getParamsData = getParamsData;
  }
});

// ../lib/telemetry/dist/src/interceptor/index.js
var require_interceptor = __commonJS({
  "../lib/telemetry/dist/src/interceptor/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.captureParamAsync = exports2.captureParam = exports2.durationAsync = exports2.duration = exports2.notifyAsync = exports2.notify = void 0;
    var client_1 = require_client3();
    var api_1 = require_api();
    var paramProcessing_1 = require_paramProcessing();
    var notify = (target, originalFn, evtName, sampleRate) => {
      return (...args) => {
        const result2 = originalFn.apply(target, args);
        const appinsightClient = client_1.ClientFactory.getTelemetryClient();
        appinsightClient.report(evtName, {}, {}, sampleRate);
        return result2;
      };
    };
    exports2.notify = notify;
    var notifyAsync = (target, originalFn, evtName, sampleRate) => {
      return async (...args) => {
        const result2 = await originalFn.apply(target, args);
        const appinsightClient = client_1.ClientFactory.getTelemetryClient();
        appinsightClient.report(evtName, {}, {}, sampleRate);
        return result2;
      };
    };
    exports2.notifyAsync = notifyAsync;
    var duration = (target, originalFn, evtName, sampleRate) => {
      return (...args) => {
        const markName = api_1.PerformanceMeasurementAPI.startMark("mark");
        const result2 = originalFn.apply(target, args);
        api_1.PerformanceMeasurementAPI.endMark(markName);
        api_1.PerformanceMeasurementAPI.measure(markName);
        const duration2 = api_1.PerformanceMeasurementAPI.getMeasurementDuration(markName);
        const appinsightClient = client_1.ClientFactory.getTelemetryClient();
        appinsightClient.report(evtName, {}, { ms: duration2 }, sampleRate);
        return result2;
      };
    };
    exports2.duration = duration;
    var durationAsync = (target, originalFn, evtName, sampleRate) => {
      return async (...args) => {
        const markName = api_1.PerformanceMeasurementAPI.startMark("mark");
        const result2 = await originalFn.apply(target, args);
        api_1.PerformanceMeasurementAPI.endMark(markName);
        api_1.PerformanceMeasurementAPI.measure(markName);
        const duration2 = api_1.PerformanceMeasurementAPI.getMeasurementDuration(markName);
        const appinsightClient = client_1.ClientFactory.getTelemetryClient();
        appinsightClient.report(evtName, {}, { ms: duration2 }, sampleRate);
        return result2;
      };
    };
    exports2.durationAsync = durationAsync;
    var captureParam = (target, originalFn, evtName, sampleRate, instructions) => {
      return (...args) => {
        const result2 = originalFn.apply(target, args);
        const [customDimensions, customMeasurements] = paramProcessing_1.getParamsData(args, instructions);
        const appinsightClient = client_1.ClientFactory.getTelemetryClient();
        appinsightClient.report(evtName, customDimensions, customMeasurements, sampleRate);
        return result2;
      };
    };
    exports2.captureParam = captureParam;
    var captureParamAsync = (target, originalFn, evtName, sampleRate, instructions) => {
      return async (...args) => {
        const result2 = await originalFn.apply(target, args);
        const [customDimensions, customMeasurements] = paramProcessing_1.getParamsData(args, instructions);
        const appinsightClient = client_1.ClientFactory.getTelemetryClient();
        appinsightClient.report(evtName, customDimensions, customMeasurements, sampleRate);
        return result2;
      };
    };
    exports2.captureParamAsync = captureParamAsync;
  }
});

// ../lib/telemetry/dist/src/interceptor/config.js
var require_config4 = __commonJS({
  "../lib/telemetry/dist/src/interceptor/config.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result2 = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result2, mod, k);
      }
      __setModuleDefault(result2, mod);
      return result2;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.asyncInterceptorTypesMapping = exports2.interceptorTypesMapping = exports2.interceptorTypes = void 0;
    var interceptors = __importStar(require_interceptor());
    var interceptorTypes;
    (function(interceptorTypes2) {
      interceptorTypes2["NOTIFICATION"] = "notify";
      interceptorTypes2["DURATION"] = "duration";
      interceptorTypes2["CAPTURE_PARAM"] = "captureParam";
    })(interceptorTypes = exports2.interceptorTypes || (exports2.interceptorTypes = {}));
    var interceptorTypesMapping = /* @__PURE__ */ new Map();
    exports2.interceptorTypesMapping = interceptorTypesMapping;
    interceptorTypesMapping.set(interceptorTypes.NOTIFICATION, interceptors.notify);
    interceptorTypesMapping.set(interceptorTypes.DURATION, interceptors.duration);
    interceptorTypesMapping.set(interceptorTypes.CAPTURE_PARAM, interceptors.captureParam);
    var asyncInterceptorTypesMapping = /* @__PURE__ */ new Map();
    exports2.asyncInterceptorTypesMapping = asyncInterceptorTypesMapping;
    asyncInterceptorTypesMapping.set(interceptorTypes.NOTIFICATION, interceptors.notifyAsync);
    asyncInterceptorTypesMapping.set(interceptorTypes.DURATION, interceptors.durationAsync);
    asyncInterceptorTypesMapping.set(interceptorTypes.CAPTURE_PARAM, interceptors.captureParamAsync);
  }
});

// ../lib/telemetry/dist/src/decorator/index.js
var require_decorator = __commonJS({
  "../lib/telemetry/dist/src/decorator/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.logTelemetryAsync = exports2.logTelemetry = void 0;
    var config_1 = require_config4();
    var decorCommon = (isAsync, target, descriptor, evtName, interceptorType, sampleRate, paramsCapturingInstructions) => {
      const originalMethod = descriptor.value;
      const interceptorTypesMap = isAsync ? config_1.asyncInterceptorTypesMapping : config_1.interceptorTypesMapping;
      const interceptor = interceptorTypesMap.get(interceptorType);
      descriptor.value = interceptor(target, originalMethod, evtName, sampleRate, paramsCapturingInstructions);
    };
    var logTelemetry = (evtName, interceptorType, sampleRate, paramsCapturingInstructions) => {
      return (target, functionName, descriptor) => {
        decorCommon(false, target, descriptor, evtName, interceptorType, sampleRate, paramsCapturingInstructions);
      };
    };
    exports2.logTelemetry = logTelemetry;
    var logTelemetryAsync = (evtName, interceptorType, sampleRate, paramsCapturingInstructions) => {
      return (target, functionName, descriptor) => {
        decorCommon(true, target, descriptor, evtName, interceptorType, sampleRate, paramsCapturingInstructions);
      };
    };
    exports2.logTelemetryAsync = logTelemetryAsync;
  }
});

// ../lib/telemetry/dist/src/index.js
var require_src7 = __commonJS({
  "../lib/telemetry/dist/src/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TelemetrySettings = exports2.getTelemetrySetting = exports2.setEnableTelemetry = exports2.ToolsSuiteTelemetryClient = exports2.initTelemetrySettings = exports2.logTelemetryAsync = exports2.logTelemetry = exports2.ParamRecordConfigField = exports2.ParamRecordConfig = exports2.PerformanceMeasurementAPI = exports2.interceptorTypes = exports2.SampleRate = exports2.EventName = exports2.EventHeader = exports2.TelemetrySystem = exports2.ApplicationInsightClient = exports2.ClientType = exports2.Client = exports2.ClientFactory = void 0;
    var index_1 = require_client3();
    Object.defineProperty(exports2, "ClientFactory", { enumerable: true, get: function() {
      return index_1.ClientFactory;
    } });
    var client_1 = require_client();
    Object.defineProperty(exports2, "Client", { enumerable: true, get: function() {
      return client_1.Client;
    } });
    var ClientType_1 = require_ClientType();
    Object.defineProperty(exports2, "ClientType", { enumerable: true, get: function() {
      return ClientType_1.ClientType;
    } });
    var appInsightClient_1 = require_appInsightClient();
    Object.defineProperty(exports2, "ApplicationInsightClient", { enumerable: true, get: function() {
      return appInsightClient_1.ApplicationInsightClient;
    } });
    var system_1 = require_system2();
    Object.defineProperty(exports2, "TelemetrySystem", { enumerable: true, get: function() {
      return system_1.TelemetrySystem;
    } });
    var EventHeader_1 = require_EventHeader();
    Object.defineProperty(exports2, "EventHeader", { enumerable: true, get: function() {
      return EventHeader_1.EventHeader;
    } });
    var EventName_1 = require_EventName();
    Object.defineProperty(exports2, "EventName", { enumerable: true, get: function() {
      return EventName_1.EventName;
    } });
    var SampleRate_1 = require_SampleRate();
    Object.defineProperty(exports2, "SampleRate", { enumerable: true, get: function() {
      return SampleRate_1.SampleRate;
    } });
    var config_1 = require_config4();
    Object.defineProperty(exports2, "interceptorTypes", { enumerable: true, get: function() {
      return config_1.interceptorTypes;
    } });
    var api_1 = require_api();
    Object.defineProperty(exports2, "PerformanceMeasurementAPI", { enumerable: true, get: function() {
      return api_1.PerformanceMeasurementAPI;
    } });
    var paramProcessing_1 = require_paramProcessing();
    Object.defineProperty(exports2, "ParamRecordConfig", { enumerable: true, get: function() {
      return paramProcessing_1.ParamRecordConfig;
    } });
    Object.defineProperty(exports2, "ParamRecordConfigField", { enumerable: true, get: function() {
      return paramProcessing_1.ParamRecordConfigField;
    } });
    var decorator_1 = require_decorator();
    Object.defineProperty(exports2, "logTelemetry", { enumerable: true, get: function() {
      return decorator_1.logTelemetry;
    } });
    Object.defineProperty(exports2, "logTelemetryAsync", { enumerable: true, get: function() {
      return decorator_1.logTelemetryAsync;
    } });
    var toolsSuiteTelemetry_1 = require_toolsSuiteTelemetry();
    Object.defineProperty(exports2, "initTelemetrySettings", { enumerable: true, get: function() {
      return toolsSuiteTelemetry_1.initTelemetrySettings;
    } });
    Object.defineProperty(exports2, "ToolsSuiteTelemetryClient", { enumerable: true, get: function() {
      return toolsSuiteTelemetry_1.ToolsSuiteTelemetryClient;
    } });
    Object.defineProperty(exports2, "setEnableTelemetry", { enumerable: true, get: function() {
      return toolsSuiteTelemetry_1.setEnableTelemetry;
    } });
    Object.defineProperty(exports2, "getTelemetrySetting", { enumerable: true, get: function() {
      return toolsSuiteTelemetry_1.getTelemetrySetting;
    } });
    exports2.TelemetrySettings = {};
  }
});

// ../../node_modules/@ui5/logger/node_modules/are-we-there-yet/tracker-base.js
var require_tracker_base = __commonJS({
  "../../node_modules/@ui5/logger/node_modules/are-we-there-yet/tracker-base.js"(exports2, module2) {
    "use strict";
    var EventEmitter3 = require("events").EventEmitter;
    var util = require("util");
    var trackerId = 0;
    var TrackerBase = module2.exports = function(name) {
      EventEmitter3.call(this);
      this.id = ++trackerId;
      this.name = name;
    };
    util.inherits(TrackerBase, EventEmitter3);
  }
});

// ../../node_modules/@ui5/logger/node_modules/are-we-there-yet/tracker.js
var require_tracker = __commonJS({
  "../../node_modules/@ui5/logger/node_modules/are-we-there-yet/tracker.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var TrackerBase = require_tracker_base();
    var Tracker = module2.exports = function(name, todo) {
      TrackerBase.call(this, name);
      this.workDone = 0;
      this.workTodo = todo || 0;
    };
    util.inherits(Tracker, TrackerBase);
    Tracker.prototype.completed = function() {
      return this.workTodo === 0 ? 0 : this.workDone / this.workTodo;
    };
    Tracker.prototype.addWork = function(work) {
      this.workTodo += work;
      this.emit("change", this.name, this.completed(), this);
    };
    Tracker.prototype.completeWork = function(work) {
      this.workDone += work;
      if (this.workDone > this.workTodo)
        this.workDone = this.workTodo;
      this.emit("change", this.name, this.completed(), this);
    };
    Tracker.prototype.finish = function() {
      this.workTodo = this.workDone = 1;
      this.emit("change", this.name, 1, this);
    };
  }
});

// ../../node_modules/readable-stream/node_modules/isarray/index.js
var require_isarray2 = __commonJS({
  "../../node_modules/readable-stream/node_modules/isarray/index.js"(exports2, module2) {
    var toString = {}.toString;
    module2.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream5 = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    module2.exports = require("stream");
  }
});

// ../../node_modules/readable-stream/node_modules/safe-buffer/index.js
var require_safe_buffer4 = __commonJS({
  "../../node_modules/readable-stream/node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList2 = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/BufferList.js"(exports2, module2) {
    "use strict";
    function _classCallCheck2(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = require_safe_buffer4().Buffer;
    var util = require("util");
    function copyBuffer(src, target, offset) {
      src.copy(target, offset);
    }
    module2.exports = function() {
      function BufferList() {
        _classCallCheck2(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList.prototype.push = function push(v) {
        var entry = { data: v, next: null };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList.prototype.unshift = function unshift(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList.prototype.shift = function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList.prototype.join = function join2(s) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      };
      BufferList.prototype.concat = function concat(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        if (this.length === 1)
          return this.head.data;
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };
      return BufferList;
    }();
    if (util && util.inspect && util.inspect.custom) {
      module2.exports.prototype[util.inspect.custom] = function() {
        var obj = util.inspect({ length: this.length });
        return this.constructor.name + " " + obj;
      };
    }
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy4 = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
          pna.nextTick(emitErrorNT, this, err);
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          pna.nextTick(emitErrorNT, _this, err2);
          if (_this._writableState) {
            _this._writableState.errorEmitted = true;
          }
        } else if (cb) {
          cb(err2);
        }
      });
      return this;
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy
    };
  }
});

// ../../node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable4 = __commonJS({
  "../../node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
    var Duplex;
    Writable.WritableState = WritableState;
    var util = Object.create(require_util2());
    util.inherits = require_inherits();
    var internalUtil = {
      deprecate: require_node3()
    };
    var Stream = require_stream5();
    var Buffer2 = require_safe_buffer4().Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy4();
    util.inherits(Writable, Stream);
    function nop() {
    }
    function WritableState(options2, stream) {
      Duplex = Duplex || require_stream_duplex4();
      options2 = options2 || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options2.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options2.writableObjectMode;
      var hwm = options2.highWaterMark;
      var writableHwm = options2.writableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (writableHwm || writableHwm === 0))
        this.highWaterMark = writableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options2.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options2.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_45) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function(object) {
        return object instanceof this;
      };
    }
    function Writable(options2) {
      Duplex = Duplex || require_stream_duplex4();
      if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
        return new Writable(options2);
      }
      this._writableState = new WritableState(options2, this);
      this.writable = true;
      if (options2) {
        if (typeof options2.write === "function")
          this._write = options2.write;
        if (typeof options2.writev === "function")
          this._writev = options2.writev;
        if (typeof options2.destroy === "function")
          this._destroy = options2.destroy;
        if (typeof options2.final === "function")
          this._final = options2.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    function writeAfterEnd(stream, cb) {
      var er = new Error("write after end");
      stream.emit("error", er);
      pna.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      var er = false;
      if (chunk === null) {
        er = new TypeError("May not write null values to stream");
      } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      if (er) {
        stream.emit("error", er);
        pna.nextTick(cb, er);
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ended)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        pna.nextTick(cb, er);
        pna.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state);
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          asyncWrite(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("_write() is not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          stream.emit("error", err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function") {
          state.pendingcb++;
          state.finalCalled = true;
          pna.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          pna.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      if (state.corkedRequestsFree) {
        state.corkedRequestsFree.next = corkReq;
      } else {
        state.corkedRequestsFree = corkReq;
      }
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      get: function() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      this.end();
      cb(err);
    };
  }
});

// ../../node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex4 = __commonJS({
  "../../node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) {
        keys2.push(key);
      }
      return keys2;
    };
    module2.exports = Duplex;
    var util = Object.create(require_util2());
    util.inherits = require_inherits();
    var Readable = require_stream_readable4();
    var Writable = require_stream_writable4();
    util.inherits(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options2) {
      if (!(this instanceof Duplex))
        return new Duplex(options2);
      Readable.call(this, options2);
      Writable.call(this, options2);
      if (options2 && options2.readable === false)
        this.readable = false;
      if (options2 && options2.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options2 && options2.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once("end", onend);
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return;
      pna.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
    Duplex.prototype._destroy = function(err, cb) {
      this.push(null);
      this.end();
      pna.nextTick(cb, err);
    };
  }
});

// ../../node_modules/readable-stream/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder4 = __commonJS({
  "../../node_modules/readable-stream/node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer4().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// ../../node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable4 = __commonJS({
  "../../node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Readable;
    var isArray = require_isarray2();
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream5();
    var Buffer2 = require_safe_buffer4().Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var util = Object.create(require_util2());
    util.inherits = require_inherits();
    var debugUtil = require("util");
    var debug = void 0;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function() {
      };
    }
    var BufferList = require_BufferList2();
    var destroyImpl = require_destroy4();
    var StringDecoder;
    util.inherits(Readable, Stream);
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options2, stream) {
      Duplex = Duplex || require_stream_duplex4();
      options2 = options2 || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options2.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options2.readableObjectMode;
      var hwm = options2.highWaterMark;
      var readableHwm = options2.readableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (readableHwm || readableHwm === 0))
        this.highWaterMark = readableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.destroyed = false;
      this.defaultEncoding = options2.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options2.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder4().StringDecoder;
        this.decoder = new StringDecoder(options2.encoding);
        this.encoding = options2.encoding;
      }
    }
    function Readable(options2) {
      Duplex = Duplex || require_stream_duplex4();
      if (!(this instanceof Readable))
        return new Readable(options2);
      this._readableState = new ReadableState(options2, this);
      this.readable = true;
      if (options2) {
        if (typeof options2.read === "function")
          this._read = options2.read;
        if (typeof options2.destroy === "function")
          this._destroy = options2.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      this.push(null);
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          stream.emit("error", er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              stream.emit("error", new Error("stream.unshift() after end event"));
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            stream.emit("error", new Error("stream.push() after EOF"));
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
        }
      }
      return needMoreData(state);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit("data", chunk);
        stream.read(0);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      return er;
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder4().StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 8388608;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      emitReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        if (state.sync)
          pna.nextTick(emitReadable_, stream);
        else
          emitReadable_(stream);
      }
    }
    function emitReadable_(stream) {
      debug("emit readable");
      stream.emit("readable");
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        pna.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      this.emit("error", new Error("_read() is not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        pna.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      var increasedAwaitDrain = false;
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (false === ret && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", src._readableState.awaitDrain);
            src._readableState.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          dest.emit("error", er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = { hasUnpiped: false };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) {
          dests[i].emit("unpipe", this, unpipeInfo);
        }
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            pna.nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        pna.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      if (!state.reading) {
        debug("resume read 0");
        stream.read(0);
      }
      state.resumeScheduled = false;
      state.awaitDrain = 0;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
      }
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      enumerable: false,
      get: function() {
        return this._readableState.highWaterMark;
      }
    });
    Readable._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.head.data;
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = fromListPartial(n, state.buffer, state.decoder);
      }
      return ret;
    }
    function fromListPartial(n, list, hasStrings) {
      var ret;
      if (n < list.head.data.length) {
        ret = list.head.data.slice(0, n);
        list.head.data = list.head.data.slice(n);
      } else if (n === list.head.data.length) {
        ret = list.shift();
      } else {
        ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
      }
      return ret;
    }
    function copyFromBufferString(n, list) {
      var p = list.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length)
          ret += str;
        else
          ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function copyFromBuffer(n, list) {
      var ret = Buffer2.allocUnsafe(n);
      var p = list.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0)
        throw new Error('"endReadable()" called on non-empty stream');
      if (!state.endEmitted) {
        state.ended = true;
        pna.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
      }
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// ../../node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform2 = __commonJS({
  "../../node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform;
    var Duplex = require_stream_duplex4();
    var util = Object.create(require_util2());
    util.inherits = require_inherits();
    util.inherits(Transform, Duplex);
    function afterTransform(er, data2) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb) {
        return this.emit("error", new Error("write callback called multiple times"));
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data2 != null)
        this.push(data2);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options2) {
      if (!(this instanceof Transform))
        return new Transform(options2);
      Duplex.call(this, options2);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options2) {
        if (typeof options2.transform === "function")
          this._transform = options2.transform;
        if (typeof options2.flush === "function")
          this._flush = options2.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function") {
        this._flush(function(er, data2) {
          done(_this, er, data2);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("_transform() is not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      var _this2 = this;
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
        _this2.emit("close");
      });
    };
    function done(stream, er, data2) {
      if (er)
        return stream.emit("error", er);
      if (data2 != null)
        stream.push(data2);
      if (stream._writableState.length)
        throw new Error("Calling transform done when ws.length != 0");
      if (stream._transformState.transforming)
        throw new Error("Calling transform done when still transforming");
      return stream.push(null);
    }
  }
});

// ../../node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough2 = __commonJS({
  "../../node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform2();
    var util = Object.create(require_util2());
    util.inherits = require_inherits();
    util.inherits(PassThrough, Transform);
    function PassThrough(options2) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options2);
      Transform.call(this, options2);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// ../../node_modules/readable-stream/readable.js
var require_readable2 = __commonJS({
  "../../node_modules/readable-stream/readable.js"(exports2, module2) {
    var Stream = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream;
      exports2 = module2.exports = Stream.Readable;
      exports2.Readable = Stream.Readable;
      exports2.Writable = Stream.Writable;
      exports2.Duplex = Stream.Duplex;
      exports2.Transform = Stream.Transform;
      exports2.PassThrough = Stream.PassThrough;
      exports2.Stream = Stream;
    } else {
      exports2 = module2.exports = require_stream_readable4();
      exports2.Stream = Stream || exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable4();
      exports2.Duplex = require_stream_duplex4();
      exports2.Transform = require_stream_transform2();
      exports2.PassThrough = require_stream_passthrough2();
    }
  }
});

// ../../node_modules/delegates/index.js
var require_delegates = __commonJS({
  "../../node_modules/delegates/index.js"(exports2, module2) {
    module2.exports = Delegator;
    function Delegator(proto, target) {
      if (!(this instanceof Delegator))
        return new Delegator(proto, target);
      this.proto = proto;
      this.target = target;
      this.methods = [];
      this.getters = [];
      this.setters = [];
      this.fluents = [];
    }
    Delegator.prototype.method = function(name) {
      var proto = this.proto;
      var target = this.target;
      this.methods.push(name);
      proto[name] = function() {
        return this[target][name].apply(this[target], arguments);
      };
      return this;
    };
    Delegator.prototype.access = function(name) {
      return this.getter(name).setter(name);
    };
    Delegator.prototype.getter = function(name) {
      var proto = this.proto;
      var target = this.target;
      this.getters.push(name);
      proto.__defineGetter__(name, function() {
        return this[target][name];
      });
      return this;
    };
    Delegator.prototype.setter = function(name) {
      var proto = this.proto;
      var target = this.target;
      this.setters.push(name);
      proto.__defineSetter__(name, function(val) {
        return this[target][name] = val;
      });
      return this;
    };
    Delegator.prototype.fluent = function(name) {
      var proto = this.proto;
      var target = this.target;
      this.fluents.push(name);
      proto[name] = function(val) {
        if ("undefined" != typeof val) {
          this[target][name] = val;
          return this;
        } else {
          return this[target][name];
        }
      };
      return this;
    };
  }
});

// ../../node_modules/@ui5/logger/node_modules/are-we-there-yet/tracker-stream.js
var require_tracker_stream = __commonJS({
  "../../node_modules/@ui5/logger/node_modules/are-we-there-yet/tracker-stream.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var stream = require_readable2();
    var delegate = require_delegates();
    var Tracker = require_tracker();
    var TrackerStream = module2.exports = function(name, size, options2) {
      stream.Transform.call(this, options2);
      this.tracker = new Tracker(name, size);
      this.name = name;
      this.id = this.tracker.id;
      this.tracker.on("change", delegateChange(this));
    };
    util.inherits(TrackerStream, stream.Transform);
    function delegateChange(trackerStream) {
      return function(name, completion, tracker) {
        trackerStream.emit("change", name, completion, trackerStream);
      };
    }
    TrackerStream.prototype._transform = function(data2, encoding, cb) {
      this.tracker.completeWork(data2.length ? data2.length : 1);
      this.push(data2);
      cb();
    };
    TrackerStream.prototype._flush = function(cb) {
      this.tracker.finish();
      cb();
    };
    delegate(TrackerStream.prototype, "tracker").method("completed").method("addWork").method("finish");
  }
});

// ../../node_modules/@ui5/logger/node_modules/are-we-there-yet/tracker-group.js
var require_tracker_group = __commonJS({
  "../../node_modules/@ui5/logger/node_modules/are-we-there-yet/tracker-group.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var TrackerBase = require_tracker_base();
    var Tracker = require_tracker();
    var TrackerStream = require_tracker_stream();
    var TrackerGroup = module2.exports = function(name) {
      TrackerBase.call(this, name);
      this.parentGroup = null;
      this.trackers = [];
      this.completion = {};
      this.weight = {};
      this.totalWeight = 0;
      this.finished = false;
      this.bubbleChange = bubbleChange(this);
    };
    util.inherits(TrackerGroup, TrackerBase);
    function bubbleChange(trackerGroup) {
      return function(name, completed, tracker) {
        trackerGroup.completion[tracker.id] = completed;
        if (trackerGroup.finished)
          return;
        trackerGroup.emit("change", name || trackerGroup.name, trackerGroup.completed(), trackerGroup);
      };
    }
    TrackerGroup.prototype.nameInTree = function() {
      var names = [];
      var from = this;
      while (from) {
        names.unshift(from.name);
        from = from.parentGroup;
      }
      return names.join("/");
    };
    TrackerGroup.prototype.addUnit = function(unit, weight) {
      if (unit.addUnit) {
        var toTest = this;
        while (toTest) {
          if (unit === toTest) {
            throw new Error("Attempted to add tracker group " + unit.name + " to tree that already includes it " + this.nameInTree(this));
          }
          toTest = toTest.parentGroup;
        }
        unit.parentGroup = this;
      }
      this.weight[unit.id] = weight || 1;
      this.totalWeight += this.weight[unit.id];
      this.trackers.push(unit);
      this.completion[unit.id] = unit.completed();
      unit.on("change", this.bubbleChange);
      if (!this.finished)
        this.emit("change", unit.name, this.completion[unit.id], unit);
      return unit;
    };
    TrackerGroup.prototype.completed = function() {
      if (this.trackers.length === 0)
        return 0;
      var valPerWeight = 1 / this.totalWeight;
      var completed = 0;
      for (var ii = 0; ii < this.trackers.length; ii++) {
        var trackerId = this.trackers[ii].id;
        completed += valPerWeight * this.weight[trackerId] * this.completion[trackerId];
      }
      return completed;
    };
    TrackerGroup.prototype.newGroup = function(name, weight) {
      return this.addUnit(new TrackerGroup(name), weight);
    };
    TrackerGroup.prototype.newItem = function(name, todo, weight) {
      return this.addUnit(new Tracker(name, todo), weight);
    };
    TrackerGroup.prototype.newStream = function(name, todo, weight) {
      return this.addUnit(new TrackerStream(name, todo), weight);
    };
    TrackerGroup.prototype.finish = function() {
      this.finished = true;
      if (!this.trackers.length)
        this.addUnit(new Tracker(), 1, true);
      for (var ii = 0; ii < this.trackers.length; ii++) {
        var tracker = this.trackers[ii];
        tracker.finish();
        tracker.removeListener("change", this.bubbleChange);
      }
      this.emit("change", this.name, 1, this);
    };
    var buffer = "                                  ";
    TrackerGroup.prototype.debug = function(depth) {
      depth = depth || 0;
      var indent = depth ? buffer.substr(0, depth) : "";
      var output3 = indent + (this.name || "top") + ": " + this.completed() + "\n";
      this.trackers.forEach(function(tracker) {
        if (tracker instanceof TrackerGroup) {
          output3 += tracker.debug(depth + 1);
        } else {
          output3 += indent + " " + tracker.name + ": " + tracker.completed() + "\n";
        }
      });
      return output3;
    };
  }
});

// ../../node_modules/@ui5/logger/node_modules/are-we-there-yet/index.js
var require_are_we_there_yet = __commonJS({
  "../../node_modules/@ui5/logger/node_modules/are-we-there-yet/index.js"(exports2) {
    "use strict";
    exports2.TrackerGroup = require_tracker_group();
    exports2.Tracker = require_tracker();
    exports2.TrackerStream = require_tracker_stream();
  }
});

// ../../node_modules/console-control-strings/index.js
var require_console_control_strings = __commonJS({
  "../../node_modules/console-control-strings/index.js"(exports2) {
    "use strict";
    var prefix = "\x1B[";
    exports2.up = function up(num) {
      return prefix + (num || "") + "A";
    };
    exports2.down = function down(num) {
      return prefix + (num || "") + "B";
    };
    exports2.forward = function forward(num) {
      return prefix + (num || "") + "C";
    };
    exports2.back = function back(num) {
      return prefix + (num || "") + "D";
    };
    exports2.nextLine = function nextLine(num) {
      return prefix + (num || "") + "E";
    };
    exports2.previousLine = function previousLine(num) {
      return prefix + (num || "") + "F";
    };
    exports2.horizontalAbsolute = function horizontalAbsolute(num) {
      if (num == null)
        throw new Error("horizontalAboslute requires a column to position to");
      return prefix + num + "G";
    };
    exports2.eraseData = function eraseData() {
      return prefix + "J";
    };
    exports2.eraseLine = function eraseLine() {
      return prefix + "K";
    };
    exports2.goto = function(x, y) {
      return prefix + y + ";" + x + "H";
    };
    exports2.gotoSOL = function() {
      return "\r";
    };
    exports2.beep = function() {
      return "\x07";
    };
    exports2.hideCursor = function hideCursor() {
      return prefix + "?25l";
    };
    exports2.showCursor = function showCursor() {
      return prefix + "?25h";
    };
    var colors = {
      reset: 0,
      bold: 1,
      italic: 3,
      underline: 4,
      inverse: 7,
      stopBold: 22,
      stopItalic: 23,
      stopUnderline: 24,
      stopInverse: 27,
      white: 37,
      black: 30,
      blue: 34,
      cyan: 36,
      green: 32,
      magenta: 35,
      red: 31,
      yellow: 33,
      bgWhite: 47,
      bgBlack: 40,
      bgBlue: 44,
      bgCyan: 46,
      bgGreen: 42,
      bgMagenta: 45,
      bgRed: 41,
      bgYellow: 43,
      grey: 90,
      brightBlack: 90,
      brightRed: 91,
      brightGreen: 92,
      brightYellow: 93,
      brightBlue: 94,
      brightMagenta: 95,
      brightCyan: 96,
      brightWhite: 97,
      bgGrey: 100,
      bgBrightBlack: 100,
      bgBrightRed: 101,
      bgBrightGreen: 102,
      bgBrightYellow: 103,
      bgBrightBlue: 104,
      bgBrightMagenta: 105,
      bgBrightCyan: 106,
      bgBrightWhite: 107
    };
    exports2.color = function color(colorWith) {
      if (arguments.length !== 1 || !Array.isArray(colorWith)) {
        colorWith = Array.prototype.slice.call(arguments);
      }
      return prefix + colorWith.map(colorNameToCode).join(";") + "m";
    };
    function colorNameToCode(color) {
      if (colors[color] != null)
        return colors[color];
      throw new Error("Unknown color or style name: " + color);
    }
  }
});

// ../../node_modules/ansi-regex/index.js
var require_ansi_regex = __commonJS({
  "../../node_modules/ansi-regex/index.js"(exports2, module2) {
    "use strict";
    module2.exports = ({ onlyFirst = false } = {}) => {
      const pattern = [
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
      ].join("|");
      return new RegExp(pattern, onlyFirst ? void 0 : "g");
    };
  }
});

// ../../node_modules/@ui5/logger/node_modules/wide-align/node_modules/strip-ansi/index.js
var require_strip_ansi = __commonJS({
  "../../node_modules/@ui5/logger/node_modules/wide-align/node_modules/strip-ansi/index.js"(exports2, module2) {
    "use strict";
    var ansiRegex = require_ansi_regex();
    module2.exports = (input) => typeof input === "string" ? input.replace(ansiRegex(), "") : input;
  }
});

// ../../node_modules/@ui5/logger/node_modules/wide-align/node_modules/is-fullwidth-code-point/index.js
var require_is_fullwidth_code_point = __commonJS({
  "../../node_modules/@ui5/logger/node_modules/wide-align/node_modules/is-fullwidth-code-point/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (x) => {
      if (Number.isNaN(x)) {
        return false;
      }
      if (x >= 4352 && (x <= 4447 || x === 9001 || x === 9002 || 11904 <= x && x <= 12871 && x !== 12351 || 12880 <= x && x <= 19903 || 19968 <= x && x <= 42182 || 43360 <= x && x <= 43388 || 44032 <= x && x <= 55203 || 63744 <= x && x <= 64255 || 65040 <= x && x <= 65049 || 65072 <= x && x <= 65131 || 65281 <= x && x <= 65376 || 65504 <= x && x <= 65510 || 110592 <= x && x <= 110593 || 127488 <= x && x <= 127569 || 131072 <= x && x <= 262141)) {
        return true;
      }
      return false;
    };
  }
});

// ../../node_modules/@ui5/logger/node_modules/wide-align/node_modules/string-width/index.js
var require_string_width = __commonJS({
  "../../node_modules/@ui5/logger/node_modules/wide-align/node_modules/string-width/index.js"(exports2, module2) {
    "use strict";
    var stripAnsi = require_strip_ansi();
    var isFullwidthCodePoint = require_is_fullwidth_code_point();
    module2.exports = (str) => {
      if (typeof str !== "string" || str.length === 0) {
        return 0;
      }
      str = stripAnsi(str);
      let width = 0;
      for (let i = 0; i < str.length; i++) {
        const code = str.codePointAt(i);
        if (code <= 31 || code >= 127 && code <= 159) {
          continue;
        }
        if (code >= 768 && code <= 879) {
          continue;
        }
        if (code > 65535) {
          i++;
        }
        width += isFullwidthCodePoint(code) ? 2 : 1;
      }
      return width;
    };
  }
});

// ../../node_modules/@ui5/logger/node_modules/wide-align/align.js
var require_align2 = __commonJS({
  "../../node_modules/@ui5/logger/node_modules/wide-align/align.js"(exports2) {
    "use strict";
    var stringWidth = require_string_width();
    exports2.center = alignCenter;
    exports2.left = alignLeft;
    exports2.right = alignRight;
    function createPadding(width) {
      var result2 = "";
      var string = " ";
      var n = width;
      do {
        if (n % 2) {
          result2 += string;
        }
        n = Math.floor(n / 2);
        string += string;
      } while (n);
      return result2;
    }
    function alignLeft(str, width) {
      var trimmed = str.trimRight();
      if (trimmed.length === 0 && str.length >= width)
        return str;
      var padding = "";
      var strWidth = stringWidth(trimmed);
      if (strWidth < width) {
        padding = createPadding(width - strWidth);
      }
      return trimmed + padding;
    }
    function alignRight(str, width) {
      var trimmed = str.trimLeft();
      if (trimmed.length === 0 && str.length >= width)
        return str;
      var padding = "";
      var strWidth = stringWidth(trimmed);
      if (strWidth < width) {
        padding = createPadding(width - strWidth);
      }
      return padding + trimmed;
    }
    function alignCenter(str, width) {
      var trimmed = str.trim();
      if (trimmed.length === 0 && str.length >= width)
        return str;
      var padLeft = "";
      var padRight = "";
      var strWidth = stringWidth(trimmed);
      if (strWidth < width) {
        var padLeftBy = parseInt((width - strWidth) / 2, 10);
        padLeft = createPadding(padLeftBy);
        padRight = createPadding(width - (strWidth + padLeftBy));
      }
      return padLeft + trimmed + padRight;
    }
  }
});

// ../../node_modules/aproba/index.js
var require_aproba = __commonJS({
  "../../node_modules/aproba/index.js"(exports2, module2) {
    "use strict";
    function isArguments(thingy) {
      return thingy != null && typeof thingy === "object" && thingy.hasOwnProperty("callee");
    }
    var types = {
      "*": { label: "any", check: function() {
        return true;
      } },
      A: { label: "array", check: function(thingy) {
        return Array.isArray(thingy) || isArguments(thingy);
      } },
      S: { label: "string", check: function(thingy) {
        return typeof thingy === "string";
      } },
      N: { label: "number", check: function(thingy) {
        return typeof thingy === "number";
      } },
      F: { label: "function", check: function(thingy) {
        return typeof thingy === "function";
      } },
      O: { label: "object", check: function(thingy) {
        return typeof thingy === "object" && thingy != null && !types.A.check(thingy) && !types.E.check(thingy);
      } },
      B: { label: "boolean", check: function(thingy) {
        return typeof thingy === "boolean";
      } },
      E: { label: "error", check: function(thingy) {
        return thingy instanceof Error;
      } },
      Z: { label: "null", check: function(thingy) {
        return thingy == null;
      } }
    };
    function addSchema(schema, arity) {
      var group = arity[schema.length] = arity[schema.length] || [];
      if (group.indexOf(schema) === -1)
        group.push(schema);
    }
    var validate = module2.exports = function(rawSchemas, args) {
      if (arguments.length !== 2)
        throw wrongNumberOfArgs(["SA"], arguments.length);
      if (!rawSchemas)
        throw missingRequiredArg(0, "rawSchemas");
      if (!args)
        throw missingRequiredArg(1, "args");
      if (!types.S.check(rawSchemas))
        throw invalidType(0, ["string"], rawSchemas);
      if (!types.A.check(args))
        throw invalidType(1, ["array"], args);
      var schemas = rawSchemas.split("|");
      var arity = {};
      schemas.forEach(function(schema) {
        for (var ii2 = 0; ii2 < schema.length; ++ii2) {
          var type = schema[ii2];
          if (!types[type])
            throw unknownType(ii2, type);
        }
        if (/E.*E/.test(schema))
          throw moreThanOneError(schema);
        addSchema(schema, arity);
        if (/E/.test(schema)) {
          addSchema(schema.replace(/E.*$/, "E"), arity);
          addSchema(schema.replace(/E/, "Z"), arity);
          if (schema.length === 1)
            addSchema("", arity);
        }
      });
      var matching = arity[args.length];
      if (!matching) {
        throw wrongNumberOfArgs(Object.keys(arity), args.length);
      }
      for (var ii = 0; ii < args.length; ++ii) {
        var newMatching = matching.filter(function(schema) {
          var type = schema[ii];
          var typeCheck = types[type].check;
          return typeCheck(args[ii]);
        });
        if (!newMatching.length) {
          var labels = matching.map(function(schema) {
            return types[schema[ii]].label;
          }).filter(function(schema) {
            return schema != null;
          });
          throw invalidType(ii, labels, args[ii]);
        }
        matching = newMatching;
      }
    };
    function missingRequiredArg(num) {
      return newException("EMISSINGARG", "Missing required argument #" + (num + 1));
    }
    function unknownType(num, type) {
      return newException("EUNKNOWNTYPE", "Unknown type " + type + " in argument #" + (num + 1));
    }
    function invalidType(num, expectedTypes, value) {
      var valueType;
      Object.keys(types).forEach(function(typeCode) {
        if (types[typeCode].check(value))
          valueType = types[typeCode].label;
      });
      return newException("EINVALIDTYPE", "Argument #" + (num + 1) + ": Expected " + englishList(expectedTypes) + " but got " + valueType);
    }
    function englishList(list) {
      return list.join(", ").replace(/, ([^,]+)$/, " or $1");
    }
    function wrongNumberOfArgs(expected, got) {
      var english = englishList(expected);
      var args = expected.every(function(ex) {
        return ex.length === 1;
      }) ? "argument" : "arguments";
      return newException("EWRONGARGCOUNT", "Expected " + english + " " + args + " but got " + got);
    }
    function moreThanOneError(schema) {
      return newException("ETOOMANYERRORTYPES", 'Only one error type per argument signature is allowed, more than one found in "' + schema + '"');
    }
    function newException(code, msg) {
      var e = new Error(msg);
      e.code = code;
      if (Error.captureStackTrace)
        Error.captureStackTrace(e, validate);
      return e;
    }
  }
});

// ../../node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "../../node_modules/object-assign/index.js"(exports2, module2) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module2.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
          if (hasOwnProperty.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from, symbols[i])) {
              to[symbols[i]] = from[symbols[i]];
            }
          }
        }
      }
      return to;
    };
  }
});

// ../../node_modules/@ui5/logger/node_modules/strip-ansi/index.js
var require_strip_ansi2 = __commonJS({
  "../../node_modules/@ui5/logger/node_modules/strip-ansi/index.js"(exports2, module2) {
    "use strict";
    var ansiRegex = require_ansi_regex()();
    module2.exports = function(str) {
      return typeof str === "string" ? str.replace(ansiRegex, "") : str;
    };
  }
});

// ../../node_modules/code-point-at/index.js
var require_code_point_at = __commonJS({
  "../../node_modules/code-point-at/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(str, pos) {
      if (str === null || str === void 0) {
        throw TypeError();
      }
      str = String(str);
      var size = str.length;
      var i = pos ? Number(pos) : 0;
      if (Number.isNaN(i)) {
        i = 0;
      }
      if (i < 0 || i >= size) {
        return void 0;
      }
      var first = str.charCodeAt(i);
      if (first >= 55296 && first <= 56319 && size > i + 1) {
        var second = str.charCodeAt(i + 1);
        if (second >= 56320 && second <= 57343) {
          return (first - 55296) * 1024 + second - 56320 + 65536;
        }
      }
      return first;
    };
  }
});

// ../../node_modules/number-is-nan/index.js
var require_number_is_nan = __commonJS({
  "../../node_modules/number-is-nan/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Number.isNaN || function(x) {
      return x !== x;
    };
  }
});

// ../../node_modules/@ui5/logger/node_modules/is-fullwidth-code-point/index.js
var require_is_fullwidth_code_point2 = __commonJS({
  "../../node_modules/@ui5/logger/node_modules/is-fullwidth-code-point/index.js"(exports2, module2) {
    "use strict";
    var numberIsNan = require_number_is_nan();
    module2.exports = function(x) {
      if (numberIsNan(x)) {
        return false;
      }
      if (x >= 4352 && (x <= 4447 || 9001 === x || 9002 === x || 11904 <= x && x <= 12871 && x !== 12351 || 12880 <= x && x <= 19903 || 19968 <= x && x <= 42182 || 43360 <= x && x <= 43388 || 44032 <= x && x <= 55203 || 63744 <= x && x <= 64255 || 65040 <= x && x <= 65049 || 65072 <= x && x <= 65131 || 65281 <= x && x <= 65376 || 65504 <= x && x <= 65510 || 110592 <= x && x <= 110593 || 127488 <= x && x <= 127569 || 131072 <= x && x <= 262141)) {
        return true;
      }
      return false;
    };
  }
});

// ../../node_modules/@ui5/logger/node_modules/string-width/index.js
var require_string_width2 = __commonJS({
  "../../node_modules/@ui5/logger/node_modules/string-width/index.js"(exports2, module2) {
    "use strict";
    var stripAnsi = require_strip_ansi2();
    var codePointAt = require_code_point_at();
    var isFullwidthCodePoint = require_is_fullwidth_code_point2();
    module2.exports = function(str) {
      if (typeof str !== "string" || str.length === 0) {
        return 0;
      }
      var width = 0;
      str = stripAnsi(str);
      for (var i = 0; i < str.length; i++) {
        var code = codePointAt(str, i);
        if (code <= 31 || code >= 127 && code <= 159) {
          continue;
        }
        if (code >= 65536) {
          i++;
        }
        if (isFullwidthCodePoint(code)) {
          width += 2;
        } else {
          width++;
        }
      }
      return width;
    };
  }
});

// ../../node_modules/@ui5/logger/node_modules/gauge/wide-truncate.js
var require_wide_truncate = __commonJS({
  "../../node_modules/@ui5/logger/node_modules/gauge/wide-truncate.js"(exports2, module2) {
    "use strict";
    var stringWidth = require_string_width2();
    var stripAnsi = require_strip_ansi2();
    module2.exports = wideTruncate;
    function wideTruncate(str, target) {
      if (stringWidth(str) === 0)
        return str;
      if (target <= 0)
        return "";
      if (stringWidth(str) <= target)
        return str;
      var noAnsi = stripAnsi(str);
      var ansiSize = str.length + noAnsi.length;
      var truncated = str.slice(0, target + ansiSize);
      while (stringWidth(truncated) > target) {
        truncated = truncated.slice(0, -1);
      }
      return truncated;
    }
  }
});

// ../../node_modules/@ui5/logger/node_modules/gauge/error.js
var require_error3 = __commonJS({
  "../../node_modules/@ui5/logger/node_modules/gauge/error.js"(exports2) {
    "use strict";
    var util = require("util");
    var User = exports2.User = function User2(msg) {
      var err = new Error(msg);
      Error.captureStackTrace(err, User2);
      err.code = "EGAUGE";
      return err;
    };
    exports2.MissingTemplateValue = function MissingTemplateValue(item, values) {
      var err = new User(util.format('Missing template value "%s"', item.type));
      Error.captureStackTrace(err, MissingTemplateValue);
      err.template = item;
      err.values = values;
      return err;
    };
    exports2.Internal = function Internal(msg) {
      var err = new Error(msg);
      Error.captureStackTrace(err, Internal);
      err.code = "EGAUGEINTERNAL";
      return err;
    };
  }
});

// ../../node_modules/@ui5/logger/node_modules/gauge/template-item.js
var require_template_item = __commonJS({
  "../../node_modules/@ui5/logger/node_modules/gauge/template-item.js"(exports2, module2) {
    "use strict";
    var stringWidth = require_string_width2();
    module2.exports = TemplateItem;
    function isPercent(num) {
      if (typeof num !== "string")
        return false;
      return num.slice(-1) === "%";
    }
    function percent(num) {
      return Number(num.slice(0, -1)) / 100;
    }
    function TemplateItem(values, outputLength) {
      this.overallOutputLength = outputLength;
      this.finished = false;
      this.type = null;
      this.value = null;
      this.length = null;
      this.maxLength = null;
      this.minLength = null;
      this.kerning = null;
      this.align = "left";
      this.padLeft = 0;
      this.padRight = 0;
      this.index = null;
      this.first = null;
      this.last = null;
      if (typeof values === "string") {
        this.value = values;
      } else {
        for (var prop in values)
          this[prop] = values[prop];
      }
      if (isPercent(this.length)) {
        this.length = Math.round(this.overallOutputLength * percent(this.length));
      }
      if (isPercent(this.minLength)) {
        this.minLength = Math.round(this.overallOutputLength * percent(this.minLength));
      }
      if (isPercent(this.maxLength)) {
        this.maxLength = Math.round(this.overallOutputLength * percent(this.maxLength));
      }
      return this;
    }
    TemplateItem.prototype = {};
    TemplateItem.prototype.getBaseLength = function() {
      var length = this.length;
      if (length == null && typeof this.value === "string" && this.maxLength == null && this.minLength == null) {
        length = stringWidth(this.value);
      }
      return length;
    };
    TemplateItem.prototype.getLength = function() {
      var length = this.getBaseLength();
      if (length == null)
        return null;
      return length + this.padLeft + this.padRight;
    };
    TemplateItem.prototype.getMaxLength = function() {
      if (this.maxLength == null)
        return null;
      return this.maxLength + this.padLeft + this.padRight;
    };
    TemplateItem.prototype.getMinLength = function() {
      if (this.minLength == null)
        return null;
      return this.minLength + this.padLeft + this.padRight;
    };
  }
});

// ../../node_modules/@ui5/logger/node_modules/gauge/render-template.js
var require_render_template = __commonJS({
  "../../node_modules/@ui5/logger/node_modules/gauge/render-template.js"(exports2, module2) {
    "use strict";
    var align = require_align2();
    var validate = require_aproba();
    var objectAssign = require_object_assign();
    var wideTruncate = require_wide_truncate();
    var error3 = require_error3();
    var TemplateItem = require_template_item();
    function renderValueWithValues(values) {
      return function(item) {
        return renderValue(item, values);
      };
    }
    var renderTemplate = module2.exports = function(width, template, values) {
      var items = prepareItems(width, template, values);
      var rendered = items.map(renderValueWithValues(values)).join("");
      return align.left(wideTruncate(rendered, width), width);
    };
    function preType(item) {
      var cappedTypeName = item.type[0].toUpperCase() + item.type.slice(1);
      return "pre" + cappedTypeName;
    }
    function postType(item) {
      var cappedTypeName = item.type[0].toUpperCase() + item.type.slice(1);
      return "post" + cappedTypeName;
    }
    function hasPreOrPost(item, values) {
      if (!item.type)
        return;
      return values[preType(item)] || values[postType(item)];
    }
    function generatePreAndPost(baseItem, parentValues) {
      var item = objectAssign({}, baseItem);
      var values = Object.create(parentValues);
      var template = [];
      var pre = preType(item);
      var post = postType(item);
      if (values[pre]) {
        template.push({ value: values[pre] });
        values[pre] = null;
      }
      item.minLength = null;
      item.length = null;
      item.maxLength = null;
      template.push(item);
      values[item.type] = values[item.type];
      if (values[post]) {
        template.push({ value: values[post] });
        values[post] = null;
      }
      return function($1, $2, length) {
        return renderTemplate(length, template, values);
      };
    }
    function prepareItems(width, template, values) {
      function cloneAndObjectify(item, index, arr) {
        var cloned = new TemplateItem(item, width);
        var type = cloned.type;
        if (cloned.value == null) {
          if (!(type in values)) {
            if (cloned.default == null) {
              throw new error3.MissingTemplateValue(cloned, values);
            } else {
              cloned.value = cloned.default;
            }
          } else {
            cloned.value = values[type];
          }
        }
        if (cloned.value == null || cloned.value === "")
          return null;
        cloned.index = index;
        cloned.first = index === 0;
        cloned.last = index === arr.length - 1;
        if (hasPreOrPost(cloned, values))
          cloned.value = generatePreAndPost(cloned, values);
        return cloned;
      }
      var output3 = template.map(cloneAndObjectify).filter(function(item) {
        return item != null;
      });
      var outputLength = 0;
      var remainingSpace = width;
      var variableCount = output3.length;
      function consumeSpace(length) {
        if (length > remainingSpace)
          length = remainingSpace;
        outputLength += length;
        remainingSpace -= length;
      }
      function finishSizing(item, length) {
        if (item.finished)
          throw new error3.Internal("Tried to finish template item that was already finished");
        if (length === Infinity)
          throw new error3.Internal("Length of template item cannot be infinity");
        if (length != null)
          item.length = length;
        item.minLength = null;
        item.maxLength = null;
        --variableCount;
        item.finished = true;
        if (item.length == null)
          item.length = item.getBaseLength();
        if (item.length == null)
          throw new error3.Internal("Finished template items must have a length");
        consumeSpace(item.getLength());
      }
      output3.forEach(function(item) {
        if (!item.kerning)
          return;
        var prevPadRight = item.first ? 0 : output3[item.index - 1].padRight;
        if (!item.first && prevPadRight < item.kerning)
          item.padLeft = item.kerning - prevPadRight;
        if (!item.last)
          item.padRight = item.kerning;
      });
      output3.forEach(function(item) {
        if (item.getBaseLength() == null)
          return;
        finishSizing(item);
      });
      var resized = 0;
      var resizing;
      var hunkSize;
      do {
        resizing = false;
        hunkSize = Math.round(remainingSpace / variableCount);
        output3.forEach(function(item) {
          if (item.finished)
            return;
          if (!item.maxLength)
            return;
          if (item.getMaxLength() < hunkSize) {
            finishSizing(item, item.maxLength);
            resizing = true;
          }
        });
      } while (resizing && resized++ < output3.length);
      if (resizing)
        throw new error3.Internal("Resize loop iterated too many times while determining maxLength");
      resized = 0;
      do {
        resizing = false;
        hunkSize = Math.round(remainingSpace / variableCount);
        output3.forEach(function(item) {
          if (item.finished)
            return;
          if (!item.minLength)
            return;
          if (item.getMinLength() >= hunkSize) {
            finishSizing(item, item.minLength);
            resizing = true;
          }
        });
      } while (resizing && resized++ < output3.length);
      if (resizing)
        throw new error3.Internal("Resize loop iterated too many times while determining minLength");
      hunkSize = Math.round(remainingSpace / variableCount);
      output3.forEach(function(item) {
        if (item.finished)
          return;
        finishSizing(item, hunkSize);
      });
      return output3;
    }
    function renderFunction(item, values, length) {
      validate("OON", arguments);
      if (item.type) {
        return item.value(values, values[item.type + "Theme"] || {}, length);
      } else {
        return item.value(values, {}, length);
      }
    }
    function renderValue(item, values) {
      var length = item.getBaseLength();
      var value = typeof item.value === "function" ? renderFunction(item, values, length) : item.value;
      if (value == null || value === "")
        return "";
      var alignWith = align[item.align] || align.left;
      var leftPadding = item.padLeft ? align.left("", item.padLeft) : "";
      var rightPadding = item.padRight ? align.right("", item.padRight) : "";
      var truncated = wideTruncate(String(value), length);
      var aligned = alignWith(truncated, length);
      return leftPadding + aligned + rightPadding;
    }
  }
});

// ../../node_modules/@ui5/logger/node_modules/gauge/plumbing.js
var require_plumbing = __commonJS({
  "../../node_modules/@ui5/logger/node_modules/gauge/plumbing.js"(exports2, module2) {
    "use strict";
    var consoleControl = require_console_control_strings();
    var renderTemplate = require_render_template();
    var validate = require_aproba();
    var Plumbing = module2.exports = function(theme, template, width) {
      if (!width)
        width = 80;
      validate("OAN", [theme, template, width]);
      this.showing = false;
      this.theme = theme;
      this.width = width;
      this.template = template;
    };
    Plumbing.prototype = {};
    Plumbing.prototype.setTheme = function(theme) {
      validate("O", [theme]);
      this.theme = theme;
    };
    Plumbing.prototype.setTemplate = function(template) {
      validate("A", [template]);
      this.template = template;
    };
    Plumbing.prototype.setWidth = function(width) {
      validate("N", [width]);
      this.width = width;
    };
    Plumbing.prototype.hide = function() {
      return consoleControl.gotoSOL() + consoleControl.eraseLine();
    };
    Plumbing.prototype.hideCursor = consoleControl.hideCursor;
    Plumbing.prototype.showCursor = consoleControl.showCursor;
    Plumbing.prototype.show = function(status) {
      var values = Object.create(this.theme);
      for (var key in status) {
        values[key] = status[key];
      }
      return renderTemplate(this.width, this.template, values).trim() + consoleControl.color("reset") + consoleControl.eraseLine() + consoleControl.gotoSOL();
    };
  }
});

// ../../node_modules/has-unicode/index.js
var require_has_unicode = __commonJS({
  "../../node_modules/has-unicode/index.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var hasUnicode = module2.exports = function() {
      if (os.type() == "Windows_NT") {
        return false;
      }
      var isUTF8 = /UTF-?8$/i;
      var ctype = process.env.LC_ALL || process.env.LC_CTYPE || process.env.LANG;
      return isUTF8.test(ctype);
    };
  }
});

// ../../node_modules/@ui5/logger/node_modules/gauge/has-color.js
var require_has_color = __commonJS({
  "../../node_modules/@ui5/logger/node_modules/gauge/has-color.js"(exports2, module2) {
    "use strict";
    module2.exports = isWin32() || isColorTerm();
    function isWin32() {
      return process.platform === "win32";
    }
    function isColorTerm() {
      var termHasColor = /^screen|^xterm|^vt100|color|ansi|cygwin|linux/i;
      return !!process.env.COLORTERM || termHasColor.test(process.env.TERM);
    }
  }
});

// ../../node_modules/signal-exit/signals.js
var require_signals = __commonJS({
  "../../node_modules/signal-exit/signals.js"(exports2, module2) {
    module2.exports = [
      "SIGABRT",
      "SIGALRM",
      "SIGHUP",
      "SIGINT",
      "SIGTERM"
    ];
    if (process.platform !== "win32") {
      module2.exports.push("SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT");
    }
    if (process.platform === "linux") {
      module2.exports.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT", "SIGUNUSED");
    }
  }
});

// ../../node_modules/signal-exit/index.js
var require_signal_exit = __commonJS({
  "../../node_modules/signal-exit/index.js"(exports2, module2) {
    var assert = require("assert");
    var signals = require_signals();
    var isWin = /^win/i.test(process.platform);
    var EE = require("events");
    if (typeof EE !== "function") {
      EE = EE.EventEmitter;
    }
    var emitter;
    if (process.__signal_exit_emitter__) {
      emitter = process.__signal_exit_emitter__;
    } else {
      emitter = process.__signal_exit_emitter__ = new EE();
      emitter.count = 0;
      emitter.emitted = {};
    }
    if (!emitter.infinite) {
      emitter.setMaxListeners(Infinity);
      emitter.infinite = true;
    }
    module2.exports = function(cb, opts) {
      assert.equal(typeof cb, "function", "a callback must be provided for exit handler");
      if (loaded === false) {
        load();
      }
      var ev = "exit";
      if (opts && opts.alwaysLast) {
        ev = "afterexit";
      }
      var remove3 = function() {
        emitter.removeListener(ev, cb);
        if (emitter.listeners("exit").length === 0 && emitter.listeners("afterexit").length === 0) {
          unload();
        }
      };
      emitter.on(ev, cb);
      return remove3;
    };
    module2.exports.unload = unload;
    function unload() {
      if (!loaded) {
        return;
      }
      loaded = false;
      signals.forEach(function(sig) {
        try {
          process.removeListener(sig, sigListeners[sig]);
        } catch (er) {
        }
      });
      process.emit = originalProcessEmit;
      process.reallyExit = originalProcessReallyExit;
      emitter.count -= 1;
    }
    function emit(event, code, signal) {
      if (emitter.emitted[event]) {
        return;
      }
      emitter.emitted[event] = true;
      emitter.emit(event, code, signal);
    }
    var sigListeners = {};
    signals.forEach(function(sig) {
      sigListeners[sig] = function listener() {
        var listeners = process.listeners(sig);
        if (listeners.length === emitter.count) {
          unload();
          emit("exit", null, sig);
          emit("afterexit", null, sig);
          if (isWin && sig === "SIGHUP") {
            sig = "SIGINT";
          }
          process.kill(process.pid, sig);
        }
      };
    });
    module2.exports.signals = function() {
      return signals;
    };
    module2.exports.load = load;
    var loaded = false;
    function load() {
      if (loaded) {
        return;
      }
      loaded = true;
      emitter.count += 1;
      signals = signals.filter(function(sig) {
        try {
          process.on(sig, sigListeners[sig]);
          return true;
        } catch (er) {
          return false;
        }
      });
      process.emit = processEmit;
      process.reallyExit = processReallyExit;
    }
    var originalProcessReallyExit = process.reallyExit;
    function processReallyExit(code) {
      process.exitCode = code || 0;
      emit("exit", process.exitCode, null);
      emit("afterexit", process.exitCode, null);
      originalProcessReallyExit.call(process, process.exitCode);
    }
    var originalProcessEmit = process.emit;
    function processEmit(ev, arg) {
      if (ev === "exit") {
        if (arg !== void 0) {
          process.exitCode = arg;
        }
        var ret = originalProcessEmit.apply(this, arguments);
        emit("exit", process.exitCode, null);
        emit("afterexit", process.exitCode, null);
        return ret;
      } else {
        return originalProcessEmit.apply(this, arguments);
      }
    }
  }
});

// ../../node_modules/@ui5/logger/node_modules/gauge/spin.js
var require_spin = __commonJS({
  "../../node_modules/@ui5/logger/node_modules/gauge/spin.js"(exports2, module2) {
    "use strict";
    module2.exports = function spin(spinstr, spun) {
      return spinstr[spun % spinstr.length];
    };
  }
});

// ../../node_modules/@ui5/logger/node_modules/gauge/progress-bar.js
var require_progress_bar = __commonJS({
  "../../node_modules/@ui5/logger/node_modules/gauge/progress-bar.js"(exports2, module2) {
    "use strict";
    var validate = require_aproba();
    var renderTemplate = require_render_template();
    var wideTruncate = require_wide_truncate();
    var stringWidth = require_string_width2();
    module2.exports = function(theme, width, completed) {
      validate("ONN", [theme, width, completed]);
      if (completed < 0)
        completed = 0;
      if (completed > 1)
        completed = 1;
      if (width <= 0)
        return "";
      var sofar = Math.round(width * completed);
      var rest = width - sofar;
      var template = [
        { type: "complete", value: repeat(theme.complete, sofar), length: sofar },
        { type: "remaining", value: repeat(theme.remaining, rest), length: rest }
      ];
      return renderTemplate(width, template, theme);
    };
    function repeat(string, width) {
      var result2 = "";
      var n = width;
      do {
        if (n % 2) {
          result2 += string;
        }
        n = Math.floor(n / 2);
        string += string;
      } while (n && stringWidth(result2) < width);
      return wideTruncate(result2, width);
    }
  }
});

// ../../node_modules/@ui5/logger/node_modules/gauge/base-theme.js
var require_base_theme = __commonJS({
  "../../node_modules/@ui5/logger/node_modules/gauge/base-theme.js"(exports2, module2) {
    "use strict";
    var spin = require_spin();
    var progressBar = require_progress_bar();
    module2.exports = {
      activityIndicator: function(values, theme, width) {
        if (values.spun == null)
          return;
        return spin(theme, values.spun);
      },
      progressbar: function(values, theme, width) {
        if (values.completed == null)
          return;
        return progressBar(theme, width, values.completed);
      }
    };
  }
});

// ../../node_modules/@ui5/logger/node_modules/gauge/theme-set.js
var require_theme_set = __commonJS({
  "../../node_modules/@ui5/logger/node_modules/gauge/theme-set.js"(exports2, module2) {
    "use strict";
    var objectAssign = require_object_assign();
    module2.exports = function() {
      return ThemeSetProto.newThemeSet();
    };
    var ThemeSetProto = {};
    ThemeSetProto.baseTheme = require_base_theme();
    ThemeSetProto.newTheme = function(parent, theme) {
      if (!theme) {
        theme = parent;
        parent = this.baseTheme;
      }
      return objectAssign({}, parent, theme);
    };
    ThemeSetProto.getThemeNames = function() {
      return Object.keys(this.themes);
    };
    ThemeSetProto.addTheme = function(name, parent, theme) {
      this.themes[name] = this.newTheme(parent, theme);
    };
    ThemeSetProto.addToAllThemes = function(theme) {
      var themes = this.themes;
      Object.keys(themes).forEach(function(name) {
        objectAssign(themes[name], theme);
      });
      objectAssign(this.baseTheme, theme);
    };
    ThemeSetProto.getTheme = function(name) {
      if (!this.themes[name])
        throw this.newMissingThemeError(name);
      return this.themes[name];
    };
    ThemeSetProto.setDefault = function(opts, name) {
      if (name == null) {
        name = opts;
        opts = {};
      }
      var platform = opts.platform == null ? "fallback" : opts.platform;
      var hasUnicode = !!opts.hasUnicode;
      var hasColor = !!opts.hasColor;
      if (!this.defaults[platform])
        this.defaults[platform] = { true: {}, false: {} };
      this.defaults[platform][hasUnicode][hasColor] = name;
    };
    ThemeSetProto.getDefault = function(opts) {
      if (!opts)
        opts = {};
      var platformName = opts.platform || process.platform;
      var platform = this.defaults[platformName] || this.defaults.fallback;
      var hasUnicode = !!opts.hasUnicode;
      var hasColor = !!opts.hasColor;
      if (!platform)
        throw this.newMissingDefaultThemeError(platformName, hasUnicode, hasColor);
      if (!platform[hasUnicode][hasColor]) {
        if (hasUnicode && hasColor && platform[!hasUnicode][hasColor]) {
          hasUnicode = false;
        } else if (hasUnicode && hasColor && platform[hasUnicode][!hasColor]) {
          hasColor = false;
        } else if (hasUnicode && hasColor && platform[!hasUnicode][!hasColor]) {
          hasUnicode = false;
          hasColor = false;
        } else if (hasUnicode && !hasColor && platform[!hasUnicode][hasColor]) {
          hasUnicode = false;
        } else if (!hasUnicode && hasColor && platform[hasUnicode][!hasColor]) {
          hasColor = false;
        } else if (platform === this.defaults.fallback) {
          throw this.newMissingDefaultThemeError(platformName, hasUnicode, hasColor);
        }
      }
      if (platform[hasUnicode][hasColor]) {
        return this.getTheme(platform[hasUnicode][hasColor]);
      } else {
        return this.getDefault(objectAssign({}, opts, { platform: "fallback" }));
      }
    };
    ThemeSetProto.newMissingThemeError = function newMissingThemeError(name) {
      var err = new Error('Could not find a gauge theme named "' + name + '"');
      Error.captureStackTrace.call(err, newMissingThemeError);
      err.theme = name;
      err.code = "EMISSINGTHEME";
      return err;
    };
    ThemeSetProto.newMissingDefaultThemeError = function newMissingDefaultThemeError(platformName, hasUnicode, hasColor) {
      var err = new Error("Could not find a gauge theme for your platform/unicode/color use combo:\n    platform = " + platformName + "\n    hasUnicode = " + hasUnicode + "\n    hasColor = " + hasColor);
      Error.captureStackTrace.call(err, newMissingDefaultThemeError);
      err.platform = platformName;
      err.hasUnicode = hasUnicode;
      err.hasColor = hasColor;
      err.code = "EMISSINGTHEME";
      return err;
    };
    ThemeSetProto.newThemeSet = function() {
      var themeset = function(opts) {
        return themeset.getDefault(opts);
      };
      return objectAssign(themeset, ThemeSetProto, {
        themes: objectAssign({}, this.themes),
        baseTheme: objectAssign({}, this.baseTheme),
        defaults: JSON.parse(JSON.stringify(this.defaults || {}))
      });
    };
  }
});

// ../../node_modules/@ui5/logger/node_modules/gauge/themes.js
var require_themes = __commonJS({
  "../../node_modules/@ui5/logger/node_modules/gauge/themes.js"(exports2, module2) {
    "use strict";
    var consoleControl = require_console_control_strings();
    var ThemeSet = require_theme_set();
    var themes = module2.exports = new ThemeSet();
    themes.addTheme("ASCII", {
      preProgressbar: "[",
      postProgressbar: "]",
      progressbarTheme: {
        complete: "#",
        remaining: "."
      },
      activityIndicatorTheme: "-\\|/",
      preSubsection: ">"
    });
    themes.addTheme("colorASCII", themes.getTheme("ASCII"), {
      progressbarTheme: {
        preComplete: consoleControl.color("inverse"),
        complete: " ",
        postComplete: consoleControl.color("stopInverse"),
        preRemaining: consoleControl.color("brightBlack"),
        remaining: ".",
        postRemaining: consoleControl.color("reset")
      }
    });
    themes.addTheme("brailleSpinner", {
      preProgressbar: "\u2E28",
      postProgressbar: "\u2E29",
      progressbarTheme: {
        complete: "\u2591",
        remaining: "\u2802"
      },
      activityIndicatorTheme: "\u280B\u2819\u2839\u2838\u283C\u2834\u2826\u2827\u2807\u280F",
      preSubsection: ">"
    });
    themes.addTheme("colorBrailleSpinner", themes.getTheme("brailleSpinner"), {
      progressbarTheme: {
        preComplete: consoleControl.color("inverse"),
        complete: " ",
        postComplete: consoleControl.color("stopInverse"),
        preRemaining: consoleControl.color("brightBlack"),
        remaining: "\u2591",
        postRemaining: consoleControl.color("reset")
      }
    });
    themes.setDefault({}, "ASCII");
    themes.setDefault({ hasColor: true }, "colorASCII");
    themes.setDefault({ platform: "darwin", hasUnicode: true }, "brailleSpinner");
    themes.setDefault({ platform: "darwin", hasUnicode: true, hasColor: true }, "colorBrailleSpinner");
  }
});

// ../../node_modules/@ui5/logger/node_modules/gauge/set-interval.js
var require_set_interval = __commonJS({
  "../../node_modules/@ui5/logger/node_modules/gauge/set-interval.js"(exports2, module2) {
    "use strict";
    module2.exports = setInterval;
  }
});

// ../../node_modules/@ui5/logger/node_modules/gauge/process.js
var require_process = __commonJS({
  "../../node_modules/@ui5/logger/node_modules/gauge/process.js"(exports2, module2) {
    "use strict";
    module2.exports = process;
  }
});

// ../../node_modules/@ui5/logger/node_modules/gauge/set-immediate.js
var require_set_immediate = __commonJS({
  "../../node_modules/@ui5/logger/node_modules/gauge/set-immediate.js"(exports2, module2) {
    "use strict";
    var process2 = require_process();
    try {
      module2.exports = setImmediate;
    } catch (ex) {
      module2.exports = process2.nextTick;
    }
  }
});

// ../../node_modules/@ui5/logger/node_modules/gauge/index.js
var require_gauge = __commonJS({
  "../../node_modules/@ui5/logger/node_modules/gauge/index.js"(exports2, module2) {
    "use strict";
    var Plumbing = require_plumbing();
    var hasUnicode = require_has_unicode();
    var hasColor = require_has_color();
    var onExit = require_signal_exit();
    var defaultThemes = require_themes();
    var setInterval2 = require_set_interval();
    var process2 = require_process();
    var setImmediate2 = require_set_immediate();
    module2.exports = Gauge;
    function callWith(obj, method) {
      return function() {
        return method.call(obj);
      };
    }
    function Gauge(arg1, arg2) {
      var options2, writeTo;
      if (arg1 && arg1.write) {
        writeTo = arg1;
        options2 = arg2 || {};
      } else if (arg2 && arg2.write) {
        writeTo = arg2;
        options2 = arg1 || {};
      } else {
        writeTo = process2.stderr;
        options2 = arg1 || arg2 || {};
      }
      this._status = {
        spun: 0,
        section: "",
        subsection: ""
      };
      this._paused = false;
      this._disabled = true;
      this._showing = false;
      this._onScreen = false;
      this._needsRedraw = false;
      this._hideCursor = options2.hideCursor == null ? true : options2.hideCursor;
      this._fixedFramerate = options2.fixedFramerate == null ? !/^v0\.8\./.test(process2.version) : options2.fixedFramerate;
      this._lastUpdateAt = null;
      this._updateInterval = options2.updateInterval == null ? 50 : options2.updateInterval;
      this._themes = options2.themes || defaultThemes;
      this._theme = options2.theme;
      var theme = this._computeTheme(options2.theme);
      var template = options2.template || [
        { type: "progressbar", length: 20 },
        { type: "activityIndicator", kerning: 1, length: 1 },
        { type: "section", kerning: 1, default: "" },
        { type: "subsection", kerning: 1, default: "" }
      ];
      this.setWriteTo(writeTo, options2.tty);
      var PlumbingClass = options2.Plumbing || Plumbing;
      this._gauge = new PlumbingClass(theme, template, this.getWidth());
      this._$$doRedraw = callWith(this, this._doRedraw);
      this._$$handleSizeChange = callWith(this, this._handleSizeChange);
      this._cleanupOnExit = options2.cleanupOnExit == null || options2.cleanupOnExit;
      this._removeOnExit = null;
      if (options2.enabled || options2.enabled == null && this._tty && this._tty.isTTY) {
        this.enable();
      } else {
        this.disable();
      }
    }
    Gauge.prototype = {};
    Gauge.prototype.isEnabled = function() {
      return !this._disabled;
    };
    Gauge.prototype.setTemplate = function(template) {
      this._gauge.setTemplate(template);
      if (this._showing)
        this._requestRedraw();
    };
    Gauge.prototype._computeTheme = function(theme) {
      if (!theme)
        theme = {};
      if (typeof theme === "string") {
        theme = this._themes.getTheme(theme);
      } else if (theme && (Object.keys(theme).length === 0 || theme.hasUnicode != null || theme.hasColor != null)) {
        var useUnicode = theme.hasUnicode == null ? hasUnicode() : theme.hasUnicode;
        var useColor = theme.hasColor == null ? hasColor : theme.hasColor;
        theme = this._themes.getDefault({ hasUnicode: useUnicode, hasColor: useColor, platform: theme.platform });
      }
      return theme;
    };
    Gauge.prototype.setThemeset = function(themes) {
      this._themes = themes;
      this.setTheme(this._theme);
    };
    Gauge.prototype.setTheme = function(theme) {
      this._gauge.setTheme(this._computeTheme(theme));
      if (this._showing)
        this._requestRedraw();
      this._theme = theme;
    };
    Gauge.prototype._requestRedraw = function() {
      this._needsRedraw = true;
      if (!this._fixedFramerate)
        this._doRedraw();
    };
    Gauge.prototype.getWidth = function() {
      return (this._tty && this._tty.columns || 80) - 1;
    };
    Gauge.prototype.setWriteTo = function(writeTo, tty) {
      var enabled = !this._disabled;
      if (enabled)
        this.disable();
      this._writeTo = writeTo;
      this._tty = tty || writeTo === process2.stderr && process2.stdout.isTTY && process2.stdout || writeTo.isTTY && writeTo || this._tty;
      if (this._gauge)
        this._gauge.setWidth(this.getWidth());
      if (enabled)
        this.enable();
    };
    Gauge.prototype.enable = function() {
      if (!this._disabled)
        return;
      this._disabled = false;
      if (this._tty)
        this._enableEvents();
      if (this._showing)
        this.show();
    };
    Gauge.prototype.disable = function() {
      if (this._disabled)
        return;
      if (this._showing) {
        this._lastUpdateAt = null;
        this._showing = false;
        this._doRedraw();
        this._showing = true;
      }
      this._disabled = true;
      if (this._tty)
        this._disableEvents();
    };
    Gauge.prototype._enableEvents = function() {
      if (this._cleanupOnExit) {
        this._removeOnExit = onExit(callWith(this, this.disable));
      }
      this._tty.on("resize", this._$$handleSizeChange);
      if (this._fixedFramerate) {
        this.redrawTracker = setInterval2(this._$$doRedraw, this._updateInterval);
        if (this.redrawTracker.unref)
          this.redrawTracker.unref();
      }
    };
    Gauge.prototype._disableEvents = function() {
      this._tty.removeListener("resize", this._$$handleSizeChange);
      if (this._fixedFramerate)
        clearInterval(this.redrawTracker);
      if (this._removeOnExit)
        this._removeOnExit();
    };
    Gauge.prototype.hide = function(cb) {
      if (this._disabled)
        return cb && process2.nextTick(cb);
      if (!this._showing)
        return cb && process2.nextTick(cb);
      this._showing = false;
      this._doRedraw();
      cb && setImmediate2(cb);
    };
    Gauge.prototype.show = function(section, completed) {
      this._showing = true;
      if (typeof section === "string") {
        this._status.section = section;
      } else if (typeof section === "object") {
        var sectionKeys = Object.keys(section);
        for (var ii = 0; ii < sectionKeys.length; ++ii) {
          var key = sectionKeys[ii];
          this._status[key] = section[key];
        }
      }
      if (completed != null)
        this._status.completed = completed;
      if (this._disabled)
        return;
      this._requestRedraw();
    };
    Gauge.prototype.pulse = function(subsection) {
      this._status.subsection = subsection || "";
      this._status.spun++;
      if (this._disabled)
        return;
      if (!this._showing)
        return;
      this._requestRedraw();
    };
    Gauge.prototype._handleSizeChange = function() {
      this._gauge.setWidth(this._tty.columns - 1);
      this._requestRedraw();
    };
    Gauge.prototype._doRedraw = function() {
      if (this._disabled || this._paused)
        return;
      if (!this._fixedFramerate) {
        var now = Date.now();
        if (this._lastUpdateAt && now - this._lastUpdateAt < this._updateInterval)
          return;
        this._lastUpdateAt = now;
      }
      if (!this._showing && this._onScreen) {
        this._onScreen = false;
        var result2 = this._gauge.hide();
        if (this._hideCursor) {
          result2 += this._gauge.showCursor();
        }
        return this._writeTo.write(result2);
      }
      if (!this._showing && !this._onScreen)
        return;
      if (this._showing && !this._onScreen) {
        this._onScreen = true;
        this._needsRedraw = true;
        if (this._hideCursor) {
          this._writeTo.write(this._gauge.hideCursor());
        }
      }
      if (!this._needsRedraw)
        return;
      if (!this._writeTo.write(this._gauge.show(this._status))) {
        this._paused = true;
        this._writeTo.on("drain", callWith(this, function() {
          this._paused = false;
          this._doRedraw();
        }));
      }
    };
  }
});

// ../../node_modules/set-blocking/index.js
var require_set_blocking = __commonJS({
  "../../node_modules/set-blocking/index.js"(exports2, module2) {
    module2.exports = function(blocking) {
      [process.stdout, process.stderr].forEach(function(stream) {
        if (stream._handle && stream.isTTY && typeof stream._handle.setBlocking === "function") {
          stream._handle.setBlocking(blocking);
        }
      });
    };
  }
});

// ../../node_modules/@ui5/logger/node_modules/npmlog/log.js
var require_log2 = __commonJS({
  "../../node_modules/@ui5/logger/node_modules/npmlog/log.js"(exports2, module2) {
    "use strict";
    var Progress = require_are_we_there_yet();
    var Gauge = require_gauge();
    var EE = require("events").EventEmitter;
    var log4 = exports2 = module2.exports = new EE();
    var util = require("util");
    var setBlocking = require_set_blocking();
    var consoleControl = require_console_control_strings();
    setBlocking(true);
    var stream = process.stderr;
    Object.defineProperty(log4, "stream", {
      set: function(newStream) {
        stream = newStream;
        if (this.gauge)
          this.gauge.setWriteTo(stream, stream);
      },
      get: function() {
        return stream;
      }
    });
    var colorEnabled;
    log4.useColor = function() {
      return colorEnabled != null ? colorEnabled : stream.isTTY;
    };
    log4.enableColor = function() {
      colorEnabled = true;
      this.gauge.setTheme({ hasColor: colorEnabled, hasUnicode: unicodeEnabled });
    };
    log4.disableColor = function() {
      colorEnabled = false;
      this.gauge.setTheme({ hasColor: colorEnabled, hasUnicode: unicodeEnabled });
    };
    log4.level = "info";
    log4.gauge = new Gauge(stream, {
      enabled: false,
      theme: { hasColor: log4.useColor() },
      template: [
        { type: "progressbar", length: 20 },
        { type: "activityIndicator", kerning: 1, length: 1 },
        { type: "section", default: "" },
        ":",
        { type: "logline", kerning: 1, default: "" }
      ]
    });
    log4.tracker = new Progress.TrackerGroup();
    log4.progressEnabled = log4.gauge.isEnabled();
    var unicodeEnabled;
    log4.enableUnicode = function() {
      unicodeEnabled = true;
      this.gauge.setTheme({ hasColor: this.useColor(), hasUnicode: unicodeEnabled });
    };
    log4.disableUnicode = function() {
      unicodeEnabled = false;
      this.gauge.setTheme({ hasColor: this.useColor(), hasUnicode: unicodeEnabled });
    };
    log4.setGaugeThemeset = function(themes) {
      this.gauge.setThemeset(themes);
    };
    log4.setGaugeTemplate = function(template) {
      this.gauge.setTemplate(template);
    };
    log4.enableProgress = function() {
      if (this.progressEnabled)
        return;
      this.progressEnabled = true;
      this.tracker.on("change", this.showProgress);
      if (this._pause)
        return;
      this.gauge.enable();
    };
    log4.disableProgress = function() {
      if (!this.progressEnabled)
        return;
      this.progressEnabled = false;
      this.tracker.removeListener("change", this.showProgress);
      this.gauge.disable();
    };
    var trackerConstructors = ["newGroup", "newItem", "newStream"];
    var mixinLog = function(tracker) {
      Object.keys(log4).forEach(function(P) {
        if (P[0] === "_")
          return;
        if (trackerConstructors.filter(function(C) {
          return C === P;
        }).length)
          return;
        if (tracker[P])
          return;
        if (typeof log4[P] !== "function")
          return;
        var func = log4[P];
        tracker[P] = function() {
          return func.apply(log4, arguments);
        };
      });
      if (tracker instanceof Progress.TrackerGroup) {
        trackerConstructors.forEach(function(C) {
          var func = tracker[C];
          tracker[C] = function() {
            return mixinLog(func.apply(tracker, arguments));
          };
        });
      }
      return tracker;
    };
    trackerConstructors.forEach(function(C) {
      log4[C] = function() {
        return mixinLog(this.tracker[C].apply(this.tracker, arguments));
      };
    });
    log4.clearProgress = function(cb) {
      if (!this.progressEnabled)
        return cb && process.nextTick(cb);
      this.gauge.hide(cb);
    };
    log4.showProgress = function(name, completed) {
      if (!this.progressEnabled)
        return;
      var values = {};
      if (name)
        values.section = name;
      var last = log4.record[log4.record.length - 1];
      if (last) {
        values.subsection = last.prefix;
        var disp = log4.disp[last.level] || last.level;
        var logline = this._format(disp, log4.style[last.level]);
        if (last.prefix)
          logline += " " + this._format(last.prefix, this.prefixStyle);
        logline += " " + last.message.split(/\r?\n/)[0];
        values.logline = logline;
      }
      values.completed = completed || this.tracker.completed();
      this.gauge.show(values);
    }.bind(log4);
    log4.pause = function() {
      this._paused = true;
      if (this.progressEnabled)
        this.gauge.disable();
    };
    log4.resume = function() {
      if (!this._paused)
        return;
      this._paused = false;
      var b = this._buffer;
      this._buffer = [];
      b.forEach(function(m) {
        this.emitLog(m);
      }, this);
      if (this.progressEnabled)
        this.gauge.enable();
    };
    log4._buffer = [];
    var id = 0;
    log4.record = [];
    log4.maxRecordSize = 1e4;
    log4.log = function(lvl, prefix, message) {
      var l = this.levels[lvl];
      if (l === void 0) {
        return this.emit("error", new Error(util.format("Undefined log level: %j", lvl)));
      }
      var a = new Array(arguments.length - 2);
      var stack = null;
      for (var i = 2; i < arguments.length; i++) {
        var arg = a[i - 2] = arguments[i];
        if (typeof arg === "object" && arg && arg instanceof Error && arg.stack) {
          Object.defineProperty(arg, "stack", {
            value: stack = arg.stack + "",
            enumerable: true,
            writable: true
          });
        }
      }
      if (stack)
        a.unshift(stack + "\n");
      message = util.format.apply(util, a);
      var m = {
        id: id++,
        level: lvl,
        prefix: String(prefix || ""),
        message,
        messageRaw: a
      };
      this.emit("log", m);
      this.emit("log." + lvl, m);
      if (m.prefix)
        this.emit(m.prefix, m);
      this.record.push(m);
      var mrs = this.maxRecordSize;
      var n = this.record.length - mrs;
      if (n > mrs / 10) {
        var newSize = Math.floor(mrs * 0.9);
        this.record = this.record.slice(-1 * newSize);
      }
      this.emitLog(m);
    }.bind(log4);
    log4.emitLog = function(m) {
      if (this._paused) {
        this._buffer.push(m);
        return;
      }
      if (this.progressEnabled)
        this.gauge.pulse(m.prefix);
      var l = this.levels[m.level];
      if (l === void 0)
        return;
      if (l < this.levels[this.level])
        return;
      if (l > 0 && !isFinite(l))
        return;
      var disp = log4.disp[m.level] != null ? log4.disp[m.level] : m.level;
      this.clearProgress();
      m.message.split(/\r?\n/).forEach(function(line) {
        if (this.heading) {
          this.write(this.heading, this.headingStyle);
          this.write(" ");
        }
        this.write(disp, log4.style[m.level]);
        var p = m.prefix || "";
        if (p)
          this.write(" ");
        this.write(p, this.prefixStyle);
        this.write(" " + line + "\n");
      }, this);
      this.showProgress();
    };
    log4._format = function(msg, style) {
      if (!stream)
        return;
      var output3 = "";
      if (this.useColor()) {
        style = style || {};
        var settings = [];
        if (style.fg)
          settings.push(style.fg);
        if (style.bg)
          settings.push("bg" + style.bg[0].toUpperCase() + style.bg.slice(1));
        if (style.bold)
          settings.push("bold");
        if (style.underline)
          settings.push("underline");
        if (style.inverse)
          settings.push("inverse");
        if (settings.length)
          output3 += consoleControl.color(settings);
        if (style.beep)
          output3 += consoleControl.beep();
      }
      output3 += msg;
      if (this.useColor()) {
        output3 += consoleControl.color("reset");
      }
      return output3;
    };
    log4.write = function(msg, style) {
      if (!stream)
        return;
      stream.write(this._format(msg, style));
    };
    log4.addLevel = function(lvl, n, style, disp) {
      if (disp == null)
        disp = lvl;
      this.levels[lvl] = n;
      this.style[lvl] = style;
      if (!this[lvl]) {
        this[lvl] = function() {
          var a = new Array(arguments.length + 1);
          a[0] = lvl;
          for (var i = 0; i < arguments.length; i++) {
            a[i + 1] = arguments[i];
          }
          return this.log.apply(this, a);
        }.bind(this);
      }
      this.disp[lvl] = disp;
    };
    log4.prefixStyle = { fg: "magenta" };
    log4.headingStyle = { fg: "white", bg: "black" };
    log4.style = {};
    log4.levels = {};
    log4.disp = {};
    log4.addLevel("silly", -Infinity, { inverse: true }, "sill");
    log4.addLevel("verbose", 1e3, { fg: "blue", bg: "black" }, "verb");
    log4.addLevel("info", 2e3, { fg: "green" });
    log4.addLevel("timing", 2500, { fg: "green", bg: "black" });
    log4.addLevel("http", 3e3, { fg: "green", bg: "black" });
    log4.addLevel("notice", 3500, { fg: "blue", bg: "black" });
    log4.addLevel("warn", 4e3, { fg: "black", bg: "yellow" }, "WARN");
    log4.addLevel("error", 5e3, { fg: "red", bg: "black" }, "ERR!");
    log4.addLevel("silent", Infinity);
    log4.on("error", function() {
    });
  }
});

// ../../node_modules/@ui5/logger/lib/logger.js
var require_logger3 = __commonJS({
  "../../node_modules/@ui5/logger/lib/logger.js"(exports2, module2) {
    var npmlog = require_log2();
    var levels = ["silly", "verbose", "info", "warn", "error", "silent"];
    if (process.env.UI5_LOG_LVL) {
      const logLvl = process.env.UI5_LOG_LVL;
      if (!levels.includes(logLvl)) {
        throw new Error(`UI5 Logger: Environment variable UI5_LOG_LVL is set to an unknown log level "${logLvl}". Valid levels are ${levels.join(", ")}`);
      }
      npmlog.level = logLvl;
    } else {
      npmlog.level = "info";
    }
    npmlog.enableUnicode();
    npmlog.on("error", (err) => {
      console.log(err);
    });
    function isLevelEnabled(levelName) {
      const currIdx = levels.indexOf(npmlog.level);
      const reqIdx = levels.indexOf(levelName);
      if (currIdx === -1) {
        throw new Error(`Failed to find current log level "${npmlog.level}" in list of expected log levels`);
      }
      if (reqIdx === -1) {
        throw new Error(`Unknown log level "${levelName}"`);
      }
      if (reqIdx >= currIdx) {
        return true;
      } else {
        return false;
      }
    }
    var Logger3 = class {
      constructor(moduleName) {
        this._moduleName = moduleName;
        this._logger = npmlog;
      }
      isLevelEnabled(levelName) {
        return logger.isLevelEnabled(levelName);
      }
      silly(...messages) {
        return this._logger.silly(this._moduleName, ...messages);
      }
      verbose(...messages) {
        return this._logger.verbose(this._moduleName, ...messages);
      }
      info(...messages) {
        return this._logger.info(this._moduleName, ...messages);
      }
      warn(...messages) {
        return this._logger.warn(this._moduleName, ...messages);
      }
      error(...messages) {
        return this._logger.error(this._moduleName, ...messages);
      }
      _getLogger() {
        return this._logger;
      }
    };
    var GroupLogger = class extends Logger3 {
      constructor(moduleName, weight = 0, parentLogger) {
        super(moduleName);
        if (parentLogger) {
          this._logger = parentLogger._getLogger().newGroup("", weight);
        } else {
          this._logger = npmlog.newGroup("", weight);
        }
      }
      createSubLogger(name, weight) {
        return new GroupLogger(this._moduleName + " " + name, weight, this);
      }
      createTaskLogger(name, todo, weight) {
        return new TaskLogger(this._moduleName + " " + name, todo, weight, this);
      }
    };
    var TaskLogger = class extends Logger3 {
      constructor(moduleName, todo, weight, parentLogger) {
        super(moduleName);
        this._todo = todo || 0;
        this._completed = 0;
        if (parentLogger) {
          this._logger = parentLogger._getLogger().newItem("", todo, weight);
        } else {
          this._logger = npmlog.newItem(this._moduleName, todo, weight);
        }
      }
      addWork(todo) {
        this._logger.addWork(todo);
        this._todo += todo;
      }
      startWork(...messages) {
        this.info(`(${this._completed + 1}/${this._todo})`, ...messages);
      }
      completeWork(completed) {
        this._completed += completed;
        this._logger.completeWork(completed);
      }
      finish() {
        return this._logger.finish();
      }
    };
    var logger = {
      getLogger: function(moduleName) {
        return new Logger3(moduleName);
      },
      getGroupLogger: function(moduleName) {
        return new GroupLogger(moduleName);
      },
      setLevel(level) {
        if (!levels.includes(level)) {
          throw new Error(`Unknown log level "${level}"`);
        }
        return npmlog.level = level;
      },
      isLevelEnabled,
      setShowProgress(showProgress) {
        if (showProgress) {
          npmlog.enableProgress();
        } else {
          npmlog.disableProgress();
        }
      }
    };
    if (process.env.NODE_ENV === "test") {
      logger.__test__ = {
        Logger: Logger3,
        GroupLogger,
        TaskLogger
      };
    }
    module2.exports = logger;
  }
});

// ../../node_modules/@ui5/logger/index.js
var require_logger4 = __commonJS({
  "../../node_modules/@ui5/logger/index.js"(exports2, module2) {
    module2.exports = require_logger3();
  }
});

// src/tasks/cf-deploy/index.ts
var import_path = require("path");
var import_fs = require("fs");
var import_child_process = require("child_process");
var import_ux_telemetry = __toESM(require_src7());
var import_ux_odata_client = __toESM(require_dist5());
var import_logger = __toESM(require_logger4());
init_i18next();
var import_yaml = __toESM(require_dist2());
var log3 = (0, import_logger.getLogger)("cf spaces");
async function _spawnAsync(cmd, args, options2) {
  return new Promise((resolve, reject) => {
    const process2 = (0, import_child_process.spawn)(cmd, args, options2);
    process2.on("exit", (exitCode) => {
      var _a2;
      if (exitCode === 0) {
        resolve(exitCode);
      } else {
        if ((_a2 = process2 == null ? void 0 : process2.stderr) == null ? void 0 : _a2.on) {
          process2.stderr.on("data", (data2) => {
            const errorMsg = data2 && data2.toString ? data2.toString("utf8").trim() : `Error when run cf spaces. Exit code ${exitCode}`;
            log3.info(errorMsg);
          });
        }
        reject(exitCode);
      }
    });
  });
}
async function _reportDeployTelemetry(exitCode, markName) {
  import_ux_telemetry.PerformanceMeasurementAPI.endMark(markName);
  import_ux_telemetry.PerformanceMeasurementAPI.measure(markName);
  const executionTime = import_ux_telemetry.PerformanceMeasurementAPI.getMeasurementDuration(markName);
  let scp, authType;
  try {
    if ((0, import_fs.existsSync)("xs-app.json")) {
      let destination;
      const xsAppConfig = JSON.parse((0, import_fs.readFileSync)("xs-app.json", "utf-8"));
      const xsAppRoutes = xsAppConfig["routes"].filter((route) => route.destination && route.destination !== "ui5");
      if (xsAppRoutes.length === 1) {
        destination = xsAppRoutes[0].destination;
      }
      if (destination) {
        const sapSystems = await (0, import_ux_odata_client.listSAPSystems)();
        const targetSystems = Object.values(sapSystems).filter((sapSystem) => sapSystem.name === destination);
        if (targetSystems && targetSystems.length === 1) {
          scp = targetSystems[0].isScp() ? "true" : "false";
          authType = targetSystems[0].config.destinationAuthType;
        }
      }
    }
  } catch (error3) {
  }
  const eventName = exitCode === 0 ? import_ux_telemetry.EventName.DEPLOY : import_ux_telemetry.EventName.DEPLOY_FAIL;
  import_ux_telemetry.ClientFactory.getTelemetryClient().report(eventName, {
    target: "cf",
    exitCode: `${exitCode}`,
    scp,
    authType
  }, { DeployTime: executionTime }, import_ux_telemetry.SampleRate.NoSampling);
}
async function _getMtaAppName() {
  let mtaId;
  try {
    const mtaYamlPath = (0, import_path.join)(process.cwd(), "mta.yaml");
    if ((0, import_fs.existsSync)(mtaYamlPath)) {
      const mtaYaml = import_yaml.default.parseDocument(await import_fs.promises.readFile(mtaYamlPath, { encoding: "utf8" })).toJSON();
      if (mtaYaml) {
        mtaId = mtaYaml == null ? void 0 : mtaYaml.ID;
      }
    }
  } catch (err) {
  }
  return mtaId;
}
async function _showHelpGuide() {
  try {
    const mtaId = await _getMtaAppName();
    if (mtaId && (0, import_fs.existsSync)("xs-app.json")) {
      log3.info(i18next_default.t("DEPLOYMENT_MSG"));
      log3.info(`	${i18next_default.t("DEPLOYMENT_MANAGED_CF_URL", { mtaId })}`);
    } else {
      log3.info(i18next_default.t("DEPLOYMENT_STANDALONE_CF_URL"));
    }
  } catch (err) {
  }
  log3.info(`${i18next_default.t("DEPLOYMENT_HELP")}`);
}
module.exports = async function task(args = []) {
  await (0, import_ux_telemetry.initTelemetrySettings)();
  const markName = import_ux_telemetry.PerformanceMeasurementAPI.startMark("LOADING_TIME");
  let cfAuthenticated = true;
  try {
    await _spawnAsync("cf", ["spaces"]);
  } catch (error3) {
    cfAuthenticated = false;
  }
  if (cfAuthenticated) {
    const defaultMtaDir = "mta_archives";
    let archiveName = "archive.mtar";
    try {
      const mtaArchives = (0, import_fs.readdirSync)(defaultMtaDir);
      if (mtaArchives.length === 1 && mtaArchives[0].includes(".mtar")) {
        archiveName = mtaArchives[0];
      }
    } catch (err) {
    }
    let exitCode;
    let error3;
    try {
      exitCode = await _spawnAsync("cf", ["deploy", `${defaultMtaDir}/${archiveName}`, ...args], {
        stdio: "inherit"
      });
    } catch (err) {
      error3 = err;
      exitCode = 1;
    }
    if (exitCode === 0) {
      await _showHelpGuide();
    }
    try {
      await _reportDeployTelemetry(exitCode, markName);
    } catch (err) {
    }
    if (error3) {
      throw error3;
    }
  }
};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/*!
 * repeat-string <https://github.com/jonschlinkert/repeat-string>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/*! js-yaml 4.0.0 https://github.com/nodeca/js-yaml @license MIT */
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
